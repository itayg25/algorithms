{"prompt": "def subsets_unique(nums):\n\n    def backtrack(res, nums, stack, pos):\n        if pos == len(nums):\n            res.add(tuple(stack))\n        else:\n            stack.append(nums[pos])\n            backtrack(res, nums, stack, pos + 1)\n            stack.pop()\n            backtrack(res, nums, stack, pos + 1)\n    res = set()\n    backtrack(res, nums, [], 0)\n    return list(res)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function uses backtracking to generate all unique subsets of a given list of numbers. It takes the list of numbers as its argument and returns a list of all the unique subsets."}
{"prompt": "def enqueue(self, value):\n    if self._rear == len(self._array):\n        self._expand()\n    self._array[self._rear] = value\n    self._rear += 1\n    self._size += 1\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nEnqueue a value to the rear of the queue. If the rear equals the length of the array, expand the array. Increment the size and rear of the queue.\n\"\"\""}
{"prompt": "def _repair_tree(self, node: Node, child_index: int) -> bool:\n    child = node.children[child_index]\n    if self.min_numbers_of_keys < len(child.keys) <= self.max_number_of_keys:\n        return False\n    if child_index > 0 and len(node.children[child_index - 1].keys) > self.min_numbers_of_keys:\n        self._rotate_right(node, child_index)\n        return True\n    if child_index < len(node.children) - 1 and len(node.children[child_index + 1].keys) > self.min_numbers_of_keys:\n        self._rotate_left(node, child_index)\n        return True\n    if child_index > 0:\n        self._merge(node, child_index - 1, child_index)\n    else:\n        self._merge(node, child_index, child_index + 1)\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\n_repair_tree(node, child_index) -> bool:\n    \"\"\"Repair a node of a tree if it requires splitting or merging.\n\n    Args:\n        node (Node): The node to be repaired.\n        child_index (int): The index of the child of the node to be repaired.\n\n    Returns:\n        bool: Whether the node was successfully repaired or not.\n    \"\"\""}
{"prompt": "def match_symbol(words, symbols):\n    import re\n    combined = []\n    for s in symbols:\n        for c in words:\n            r = re.search(s, c)\n            if r:\n                combined.append(re.sub(s, '[{}]'.format(s), c))\n    return combined\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes in two parameters: a list of words and a list of symbols. It uses a regular expression search to find any of the symbols in each word, and if found, it replaces it with the same symbol but surrounded by square brackets. It returns a list of words with any of the matching symbols replaced."}
{"prompt": "def min_height(root):\n    if root is None:\n        return 0\n    height = 0\n    level = [root]\n    while level:\n        height += 1\n        new_level = []\n        for node in level:\n            if node.left is None and node.right is None:\n                return height\n            if node.left is not None:\n                new_level.append(node.left)\n            if node.right is not None:\n                new_level.append(node.right)\n        level = new_level\n    return height\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCalculate the minimum height of a given binary tree.\n\nArgs:\n    root (Node): The root of the binary tree\n\nReturns:\n    int: The minimum height of the binary tree\n\"\"\""}
{"prompt": "def kruskal(vertex_count, edges, forest):\n    edges.sort(key=lambda edge: edge.weight)\n    mst = []\n    for edge in edges:\n        set_u = forest.find_set(edge.u)\n        set_v = forest.find_set(edge.v)\n        if set_u != set_v:\n            forest.merge_set(set_u, set_v)\n            mst.append(edge)\n            if len(mst) == vertex_count - 1:\n                break\n    return sum([edge.weight for edge in mst])\n##############\nEND_FUNC\n##############\n", "completion": "\n\nImplements the Kruskal algorithm which finds the minimum spanning tree of a graph with a given set of edges and vertex count. Returns the sum of the weights of the edges in the minimum spanning tree."}
{"prompt": "def is_power_of_two(n):\n    return n > 0 and (not n & n - 1)\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nReturns a boolean value indicating whether or not the given number is a power of two."}
{"prompt": "def postorder(self, root):\n    if root:\n        self.postorder(root.left)\n        self.postorder(root.right)\n        print(str(root.data), end=' ')\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nTraverse a binary tree in post-order.\n\nThis function traverses the binary tree using post-order traversal and prints the node data for each node it visits. It takes the root node as an argument."}
{"prompt": "def is_palindrome_stack(s):\n    stack = []\n    s = remove_punctuation(s)\n    for i in range(len(s) // 2, len(s)):\n        stack.append(s[i])\n    for i in range(0, len(s) // 2):\n        if s[i] != stack.pop():\n            return False\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nis_palindrome_stack(s) checks if the string s is a palindrome. It removes punctuation from the string and then builds a stack by pushing the second half of the string onto the stack. It then checks if the first half of the string is equal to the popped elements of the stack, and returns True if the stack is empty at the end of the loop, indicating that the string was a palindrome.\n\"\"\""}
{"prompt": "def all_pairs_shortest_path(adjacency_matrix):\n    new_array = copy.deepcopy(adjacency_matrix)\n    size = len(new_array)\n    for k in range(size):\n        for i in range(size):\n            for j in range(size):\n                if new_array[i][j] > new_array[i][k] + new_array[k][j]:\n                    new_array[i][j] = new_array[i][k] + new_array[k][j]\n    return new_array\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCalculates the shortest path between all pairs of vertices in a given adjacency matrix, using the Floyd-Warshall algorithm.\n\nParameters:\nadjacency_matrix (list of lists): Adjacency matrix representing a graph.\n\nReturns:\nlist of lists: Updated adjacency matrix with shortest paths between all pairs of vertices.\n\"\"\""}
{"prompt": "def check_pangram(input_string):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    for ch in alphabet:\n        if ch not in input_string.lower():\n            return False\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\ncheck_pangram(input_string)\n\nReturns True if the given string is a pangram, i.e. it contains all the letters of the alphabet at least once, False otherwise. The comparison is case insensitive.\n\"\"\""}
{"prompt": "def sum_closure_default(a, b):\n    return a + b\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes two numbers, a and b, and returns the sum of the two numbers."}
{"prompt": "def _count_frequency(array, element):\n    return array.count(element)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n_count_frequency() takes in two arguments - an array and an element - and returns the number of times the element appears in the array."}
{"prompt": "def __init__(self, size):\n    self.parent = [None] * size\n    self.size = [1] * size\n    for i in range(size):\n        self.parent[i] = i\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__(self, size):\n    \"\"\"\n    Initialize a new union find structure with 'size' elements.\n    \n    Args:\n        size (int): The number of elements in the structure.\n    \"\"\""}
{"prompt": "def possible_values(self):\n    a = '123456789'\n    (d, val) = ({}, {})\n    for i in range(self.row):\n        for j in range(self.col):\n            ele = self.board[i][j]\n            if ele != '.':\n                d['r', i] = d.get(('r', i), []) + [ele]\n                d['c', j] = d.get(('c', j), []) + [ele]\n                d[i // 3, j // 3] = d.get((i // 3, j // 3), []) + [ele]\n            else:\n                val[i, j] = []\n    for (i, j) in val.keys():\n        inval = d.get(('r', i), []) + d.get(('c', j), []) + d.get((i / 3, j / 3), [])\n        val[i, j] = [n for n in a if n not in inval]\n    return val\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function takes in a board and returns all possible values for each cell. It checks all the rows, columns and 3x3 subgrids for any given cell and returns a dictionary with the cell coordinates as key and a list of possible values as value."}
{"prompt": "def next_state(chain, current_state):\n    next_state_map = chain.get(current_state)\n    return __choose_state(next_state_map)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function returns the next state given a Markov chain and the current state. It looks up the next state map based on the current state, and then chooses the next state using the __choose_state helper function."}
{"prompt": "def flatten_iter(iterable):\n    for element in iterable:\n        if not isinstance(element, str) and isinstance(element, Iterable):\n            yield from flatten_iter(element)\n        else:\n            yield element\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Flatten an iterable of iterables into a single iterable.\n\nArgs:\n    iterable (Iterable): An iterable object to be flattened.\n\nReturns:\n    Iterable: A flattened iterable.\n\"\"\""}
{"prompt": "def longest_palindromic_subsequence(s):\n    k = len(s)\n    olist = [0] * k\n    nList = [0] * k\n    logestSubStr = ''\n    logestLen = 0\n    for j in range(0, k):\n        for i in range(0, j + 1):\n            if j - i <= 1:\n                if s[i] == s[j]:\n                    nList[i] = 1\n                    len_t = j - i + 1\n                    if logestLen < len_t:\n                        logestSubStr = s[i:j + 1]\n                        logestLen = len_t\n            elif s[i] == s[j] and olist[i + 1]:\n                nList[i] = 1\n                len_t = j - i + 1\n                if logestLen < len_t:\n                    logestSubStr = s[i:j + 1]\n                    logestLen = len_t\n        olist = nList\n        nList = [0] * k\n    return logestLen\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function finds the longest palindromic subsequence in a given string. It returns the length of the longest palindromic subsequence."}
{"prompt": "def permute_unique(nums):\n    perms = [[]]\n    for n in nums:\n        new_perms = []\n        for l in perms:\n            for i in range(len(l) + 1):\n                new_perms.append(l[:i] + [n] + l[i:])\n                if i < len(l) and l[i] == n:\n                    break\n        perms = new_perms\n    return perms\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nGenerate all unique permutations of a given list of numbers.\n\nArgs:\n    nums (list): List of numbers to generate permutations of\n\nReturns:\n    list: List of all unique permutations of the given numbers.\n\"\"\""}
{"prompt": "def partition(head, x):\n    left = None\n    right = None\n    prev = None\n    current = head\n    while current:\n        if int(current.val) >= x:\n            if not right:\n                right = current\n        elif not left:\n            left = current\n        else:\n            prev.next = current.next\n            left.next = current\n            left = current\n            left.next = right\n        if prev and prev.next is None:\n            break\n        prev = current\n        current = current.next\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\npartition(head, x) partitions a linked list around a value x. \nThe left side of the list contains all nodes with values less than x, \nwhile the right side contains all nodes with values greater than or equal to x.\n\"\"\""}
{"prompt": "def add_pair(res, s, left, right):\n    if left == 0 and right == 0:\n        res.append(s)\n        return\n    if right > 0:\n        add_pair(res, s + ')', left, right - 1)\n    if left > 0:\n        add_pair(res, s + '(', left - 1, right + 1)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function adds a pair of parentheses to a provided string 's', given the number of left and right parentheses that can be added. It appends the resulting string to the list 'res'. If both left and right parentheses have been added, the function will return the resulting list."}
{"prompt": "def __init__(self):\n    self.keys = []\n    self.children = []\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nInitialize a new instance of the class. \nSet the keys and children attributes to empty lists."}
{"prompt": "def __init__(self, name):\n    self.name = name\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__(self, name)\n\nThis is a constructor that initializes the instance of the class with the given name. It sets the instance variable 'name' to the given name."}
{"prompt": "def get_bit(num, i):\n    return num & 1 << i != 0\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCheck if a bit at index 'i' is set to 1 in the binary representation of 'num'. \nReturns True if set, False otherwise."}
{"prompt": "def single_number(nums):\n    i = 0\n    for num in nums:\n        i ^= num\n    return i\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes in a list of numbers and returns the single number that appears once in the list. It uses bitwise XOR to iterate through the list and return the number that appears only once."}
{"prompt": "@abstractmethod\ndef remove_min(self):\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Removes and returns the item with the minimum value from the collection.\"\"\""}
{"prompt": "def cut_rod(price):\n    n = len(price)\n    val = [0] * (n + 1)\n    for i in range(1, n + 1):\n        max_val = INT_MIN\n        for j in range(i):\n            max_val = max(max_val, price[j] + val[i - j - 1])\n        val[i] = max_val\n    return val[n]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes in a list of prices and returns the maximum possible revenue from selling pieces of a rod of the given length. It uses a bottom-up dynamic programming approach to calculate the maximum revenue for each piece length and returns the maximum revenue for the entire rod."}
{"prompt": "def set_bit(num, i):\n    return num | 1 << i\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nSet the bit at index i in num to 1.\n\nParameters:\nnum (int): The number to modify.\ni (int): The index of the bit to set.\n\nReturns:\nint: num with the bit at index i set to 1."}
{"prompt": "def test_convert_to_list(self):\n    result = convert_to_str(convert_to_list(112))\n    self.assertEqual('211', result)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Test the conversion of a number to a list and back to a string.\n\nThis function takes in a number and tests that it is correctly converted to a list and back to a string. It checks that the result is equal to the original number as a string.\n\"\"\""}
{"prompt": "def count(coins, value):\n    dp_array = [1] + [0] * value\n    for coin in coins:\n        for i in range(coin, value + 1):\n            dp_array[i] += dp_array[i - coin]\n    return dp_array[value]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function counts the number of ways to make a given value with coins of given denominations. It uses dynamic programming to achieve this efficiently. \n\nParameters: \ncoins (list): a list of denominations of coins \nvalue (int): the desired value that needs to be made \n\nReturns: \nint: the number of ways to make the given value with coins of given denominations \n\"\"\""}
{"prompt": "def __init__(self, file):\n    self.file = file\n    self.buffer = []\n    self.is_last_byte = False\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nThis function is a constructor for a class. It takes a file as an argument and sets the file attribute to the file argument, initializes an empty buffer, and sets the is_last_byte attribute to False."}
{"prompt": "def __init__(self):\n    self.root = TrieNode('')\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__(self) initializes a new Trie object with a root TrieNode. The root node has an empty string as its value."}
{"prompt": "def __init__(self, x):\n    self.val = x\n    self.next = None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__() is a constructor for a Node object.\nIt takes in an argument x, which is the value for the Node.\nIt sets the value of the node to x, and sets the next pointer to None."}
{"prompt": "def magic_number(n):\n    total_sum = 0\n    while n > 0 or total_sum > 9:\n        if n == 0:\n            n = total_sum\n            total_sum = 0\n        total_sum += n % 10\n        n //= 10\n    return total_sum == 1\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes an integer n as input and returns a boolean that indicates whether the sum of the digits of n equals to 1 or not."}
{"prompt": "def find(self, key) -> bool:\n    current_node = self.root\n    while True:\n        i = len(current_node.keys) - 1\n        while i >= 0 and current_node.keys[i] > key:\n            i -= 1\n        if i >= 0 and current_node.keys[i] == key:\n            return True\n        if current_node.is_leaf:\n            return False\n        current_node = current_node.children[i + 1]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nFind a key in a B-tree and return a boolean indicating whether it was found. \n\"\"\""}
{"prompt": "def intersection(h1, h2):\n    count = 0\n    flag = None\n    h1_orig = h1\n    h2_orig = h2\n    while h1 or h2:\n        count += 1\n        if not flag and (h1.next is None or h2.next is None):\n            flag = (count, h1.next, h2.next)\n        if h1:\n            h1 = h1.next\n        if h2:\n            h2 = h2.next\n    long_len = count\n    short_len = flag[0]\n    if flag[1] is None:\n        shorter = h1_orig\n        longer = h2_orig\n    elif flag[2] is None:\n        shorter = h2_orig\n        longer = h1_orig\n    while longer and shorter:\n        while long_len > short_len:\n            longer = longer.next\n            long_len -= 1\n        if longer == shorter:\n            return longer\n        else:\n            longer = longer.next\n            shorter = shorter.next\n    return None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturns the point at which two linked lists intersect, or None if they do not intersect. \nh1 and h2 are the head nodes of the two linked lists. \n\"\"\""}
{"prompt": "def bracket(words, symbols):\n    root = TreeNode()\n    for s in symbols:\n        t = root\n        for char in s:\n            if char not in t.c:\n                t.c[char] = TreeNode()\n            t = t.c[char]\n        t.sym = s\n    result = dict()\n    for word in words:\n        i = 0\n        symlist = list()\n        while i < len(word):\n            (j, t) = (i, root)\n            while j < len(word) and word[j] in t.c:\n                t = t.c[word[j]]\n                if t.sym is not None:\n                    symlist.append((j + 1 - len(t.sym), j + 1, t.sym))\n                j += 1\n            i += 1\n        if len(symlist) > 0:\n            sym = reduce(lambda x, y: x if x[1] - x[0] >= y[1] - y[0] else y, symlist)\n            result[word] = '{}[{}]{}'.format(word[:sym[0]], sym[2], word[sym[1]:])\n    return tuple((word if word not in result else result[word] for word in words))\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function takes in a list of words and a list of symbols, and constructs a tree structure using the symbols. Then, it iterates through the words, trying to match the symbols in the words. If a symbol is found, the word is modified and added to the result dict. Finally, a tuple is returned that contains the modified words, or the original word if no matches were found."}
{"prompt": "def dfs(nums, target, index, path, res):\n    if target < 0:\n        return\n    if target == 0:\n        res.append(path)\n        return\n    for i in range(index, len(nums)):\n        dfs(nums, target - nums[i], i, path + [nums[i]], res)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function performs a depth-first search on a list of numbers to find all possible combinations that add up to the target. It takes in the list of numbers, the target number, the index of the current number in the list, the path of numbers added together so far, and a list of all valid combinations. It then checks if the target number is less than zero, and if so, returns. If the target number is zero, it adds the path to the list of valid combinations and returns. Otherwise, it calls the function on the remaining numbers in the list."}
{"prompt": "def missing_ranges(arr, lo, hi):\n    res = []\n    start = lo\n    for n in arr:\n        if n == start:\n            start += 1\n        elif n > start:\n            res.append((start, n - 1))\n            start = n + 1\n    if start <= hi:\n        res.append((start, hi))\n    return res\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nmissing_ranges(arr, lo, hi)\n\nGiven a sorted array of values and an upper and lower bound, return a list of tuples representing all ranges of missing values in the array.\n\nParameters:\narr (list): A sorted array of values\nlo (int): Lower bound\nhi (int): Upper bound\n\nReturns:\nlist: A list of tuples representing all ranges of missing values in the array.\n\"\"\""}
{"prompt": "def euler_totient(n):\n    result = n\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            while n % i == 0:\n                n //= i\n            result -= result // i\n    if n > 1:\n        result -= result // n\n    return result\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\neuler_totient(n)\n\nCalculates the Euler totient function of integer 'n'.\nThe Euler totient function is a function that returns the number of numbers less than n that are relatively prime to n.\n\"\"\""}
{"prompt": "def is_strobogrammatic2(num: str):\n    return num == num[::-1].replace('6', '#').replace('9', '6').replace('#', '9')\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturns True if the given number is a strobogrammatic number, False otherwise. A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).\n\"\"\""}
{"prompt": "@abstractmethod\ndef __iter__(self):\n    pass\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function is an abstract method for creating an iterator. It does not contain any implementation details."}
{"prompt": "def climb_stairs(steps):\n    arr = [1, 1]\n    for _ in range(1, steps):\n        arr.append(arr[-1] + arr[-2])\n    return arr[-1]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nclimb_stairs(steps)\n\nFunction to calculate the number of distinct ways to climb a staircase with a given number of steps.\n\nParameters:\n    steps (int): The number of steps in the staircase.\n\nReturns:\n    int: The number of distinct ways to climb the staircase.\n\"\"\""}
{"prompt": "def in_order_traverse(self):\n    result = []\n    if not self.node:\n        return result\n    result.extend(self.node.left.in_order_traverse())\n    result.append(self.node.key)\n    result.extend(self.node.right.in_order_traverse())\n    return result\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nTraverse a binary tree in order and return a list of visited values.\n\nArguments:\n    self (object): The binary tree object.\n\nReturns:\n    list: A list of values visited in order."}
{"prompt": "def test_add_two_numbers(self):\n    number1 = Node(2)\n    number1.next = Node(4)\n    number1.next.next = Node(3)\n    number2 = Node(5)\n    number2.next = Node(6)\n    number2.next.next = Node(4)\n    result = convert_to_str(add_two_numbers(number1, number2))\n    self.assertEqual('708', result)\n    number3 = Node(1)\n    number3.next = Node(1)\n    number3.next.next = Node(9)\n    number4 = Node(1)\n    number4.next = Node(0)\n    number4.next.next = Node(1)\n    result = convert_to_str(add_two_numbers(number3, number4))\n    self.assertEqual('2101', result)\n    number5 = Node(1)\n    number6 = Node(0)\n    result = convert_to_str(add_two_numbers(number5, number6))\n    self.assertEqual('1', result)\n    number7 = Node(9)\n    number7.next = Node(1)\n    number7.next.next = Node(1)\n    number8 = Node(1)\n    number8.next = Node(0)\n    number8.next.next = Node(1)\n    result = convert_to_str(add_two_numbers(number7, number8))\n    self.assertEqual('022', result)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function tests the add_two_numbers function by asserting various test cases that use Node objects to represent numbers. It converts the result from the add_two_numbers function to a string before checking the result against an expected value.\n\"\"\""}
{"prompt": "def __init__(self, val=None):\n    self.val = val\n    self.next = None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__(self, val=None)\n\nConstructor for a linked list node.\n\nParameters:\n    val (optional): The value stored in this node. Defaults to None.\n\nAttributes:\n    val (optional): The value stored in this node.\n    next (Node): The next node in the linked list. Defaults to None.\n\"\"\""}
{"prompt": "def first_occurrence(array, query):\n    (low, high) = (0, len(array) - 1)\n    while low <= high:\n        mid = (low + high) // 2\n        if low == high:\n            break\n        if array[mid] < query:\n            low = mid + 1\n        else:\n            high = mid\n    if array[low] == query:\n        return low\n##############\nEND_FUNC\n##############\n", "completion": "\n\n'''\nReturns the index of the first occurrence of the given query in the given array.\nReturns None if query is not present in the array.\n'''"}
{"prompt": "def __repr__(self):\n    return 'Interval ({}, {})'.format(self.start, self.end)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturn a string representation of the Interval object."}
{"prompt": "def postorder(root):\n    res_temp = []\n    res = []\n    if not root:\n        return res\n    stack = []\n    stack.append(root)\n    while stack:\n        root = stack.pop()\n        res_temp.append(root.val)\n        if root.left:\n            stack.append(root.left)\n        if root.right:\n            stack.append(root.right)\n    while res_temp:\n        res.append(res_temp.pop())\n    return res\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nTraverse a tree in postorder and return a list of node values in the order.\n\nParameters:\nroot (TreeNode): Root of the tree to traverse\n\nReturns:\nlist: List of node values in postorder traversal\n\"\"\""}
{"prompt": "def __init__(self, val=None):\n    self.val = val\n    self.next = None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis is the constructor for a linked list node. \nIt takes in an optional argument 'val', which assigns a value to the node. \nThe node also has an attribute 'next' which is set to None by default."}
{"prompt": "def base_to_int(str_to_convert, base):\n    digit = {}\n    for (ind, char) in enumerate(string.digits + string.ascii_uppercase):\n        digit[char] = ind\n    multiplier = 1\n    res = 0\n    for char in str_to_convert[::-1]:\n        res += digit[char] * multiplier\n        multiplier *= base\n    return res\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nConvert a string of a given base to an int.\n\nParameters:\nstr_to_convert (str): The string to convert.\nbase (int): The base of the string.\n\nReturns:\nint: The int representation of the string in the given base.\n\"\"\""}
{"prompt": "def exchange_sort(arr):\n    arr_len = len(arr)\n    for i in range(arr_len - 1):\n        for j in range(i + 1, arr_len):\n            if arr[i] > arr[j]:\n                (arr[i], arr[j]) = (arr[j], arr[i])\n    return arr\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes an array as input and sorts it using an exchange sort algorithm. It will iterate over the array and compare each element with the elements after it, swapping them if the preceding element is larger. It then returns the sorted array."}
{"prompt": "def edit_distance(word_a, word_b):\n    (length_a, length_b) = (len(word_a) + 1, len(word_b) + 1)\n    edit = [[0 for _ in range(length_b)] for _ in range(length_a)]\n    for i in range(1, length_a):\n        edit[i][0] = i\n    for j in range(1, length_b):\n        edit[0][j] = j\n    for i in range(1, length_a):\n        for j in range(1, length_b):\n            cost = 0 if word_a[i - 1] == word_b[j - 1] else 1\n            edit[i][j] = min(edit[i - 1][j] + 1, edit[i][j - 1] + 1, edit[i - 1][j - 1] + cost)\n    return edit[-1][-1]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function computes the edit distance between two words. The edit distance is defined as the minimum number of single-character edits (insertions, deletions, or substitutions) that are required to turn word_a into word_b. It uses a dynamic programming approach to calculate the edit distance in an efficient manner. "}
{"prompt": "def partition(arr, first, last):\n    wall = first\n    for pos in range(first, last):\n        if arr[pos] < arr[last]:\n            (arr[pos], arr[wall]) = (arr[wall], arr[pos])\n            wall += 1\n    (arr[wall], arr[last]) = (arr[last], arr[wall])\n    return wall\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\npartition() partitions the given array around a given element such that all elements less than the given element come before it and all elements greater than the given element come after it.\n\nParameters: \narr (list): The list to be partitioned.\nfirst (int): The index of the first element in the list.\nlast (int): The index of the last element in the list.\n\nReturns:\nwall (int): The index of the partitioned element.\n\"\"\""}
{"prompt": "def longest_non_repeat_v1(string):\n    if string is None:\n        return 0\n    dict = {}\n    max_length = 0\n    j = 0\n    for i in range(len(string)):\n        if string[i] in dict:\n            j = max(dict[string[i]], j)\n        dict[string[i]] = i + 1\n        max_length = max(max_length, i - j + 1)\n    return max_length\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function returns the length of the longest substring of a given string that does not contain any repeated characters. It does this by iterating through the given string, keeping track of the longest substring length and the last occurrence of each character in a dictionary. If a character is repeated, the starting index of the substring is updated to that of the last occurrence of the character.\n\"\"\""}
{"prompt": "def rotate_right(head, k):\n    if not head or not head.next:\n        return head\n    current = head\n    length = 1\n    while current.next:\n        current = current.next\n        length += 1\n    current.next = head\n    k = k % length\n    for i in range(length - k):\n        current = current.next\n    head = current.next\n    current.next = None\n    return head\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nRotate a linked list right by k nodes.\n\nReturns the new head node of the list. If the list has length 0 or 1, it will return the head node without any modifications.\n\"\"\""}
{"prompt": "def print_optimal_solution(optimal_solution, i, j):\n    if i == j:\n        print('A' + str(i), end=' ')\n    else:\n        print('(', end=' ')\n        print_optimal_solution(optimal_solution, i, optimal_solution[i][j])\n        print_optimal_solution(optimal_solution, optimal_solution[i][j] + 1, j)\n        print(')', end=' ')\n##############\nEND_FUNC\n##############\n", "completion": "\n\nPrints the optimal solution for the matrix chain multiplication problem given a 2D array of optimal subproblems and the starting and ending indices of the subproblem."}
{"prompt": "def __repr__(self):\n    return '<ch: {0}: {1}>'.format(self.sign, self.frequency)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturns a string representation of a 'ch' object, containing the sign and frequency."}
{"prompt": "def find_factorial(n):\n    fact = 1\n    while n != 0:\n        fact *= n\n        n -= 1\n    return fact\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function calculates the factorial of a given number 'n'. \nIt does this by initializing a variable 'fact' to 1 and then multiplies 'fact' by 'n' and decrements 'n' by 1 until 'n' is equal to 0. The final value of 'fact' is then returned."}
{"prompt": "def clone_graph1(node):\n    if not node:\n        return None\n    node_copy = node.shallow_copy()\n    dic = {node: node_copy}\n    queue = collections.deque([node])\n    while queue:\n        node = queue.popleft()\n        for neighbor in node.neighbors:\n            if neighbor not in dic:\n                neighbor_copy = neighbor.shallow_copy()\n                dic[neighbor] = neighbor_copy\n                dic[node].add_neighbor(neighbor_copy)\n                queue.append(neighbor)\n            else:\n                dic[node].add_neighbor(dic[neighbor])\n    return node_copy\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nclone_graph1(node) takes in a node object and returns a shallow copy of the graph. The shallow copy includes all the node and neighbor connections."}
{"prompt": "def height(root):\n    if root is None:\n        return 0\n    else:\n        return 1 + max(height(root.left), height(root.right))\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nThis function takes in a root node and returns the height of the given root node. The height of a tree is defined as the number of edges on the longest path from the root node to a leaf. If the root node is None, the height is 0."}
{"prompt": "def fix_insert(self, node):\n    if node.parent is None:\n        node.color = 0\n        self.root = node\n        return\n    while node.parent and node.parent.color == 1:\n        if node.parent is node.parent.parent.left:\n            uncle_node = node.parent.parent.right\n            if uncle_node and uncle_node.color == 1:\n                node.parent.color = 0\n                node.parent.parent.right.color = 0\n                node.parent.parent.color = 1\n                node = node.parent.parent\n                continue\n            elif node is node.parent.right:\n                node = node.parent\n                self.left_rotate(node)\n            node.parent.color = 0\n            node.parent.parent.color = 1\n            self.right_rotate(node.parent.parent)\n        else:\n            uncle_node = node.parent.parent.left\n            if uncle_node and uncle_node.color == 1:\n                node.parent.color = 0\n                node.parent.parent.left.color = 0\n                node.parent.parent.color = 1\n                node = node.parent.parent\n                continue\n            elif node is node.parent.left:\n                node = node.parent\n                self.right_rotate(node)\n            node.parent.color = 0\n            node.parent.parent.color = 1\n            self.left_rotate(node.parent.parent)\n    self.root.color = 0\n##############\nEND_FUNC\n##############\n", "completion": "\n\nfix_insert(self, node) - Inserts a node into the Red-Black Tree and re-balances accordingly. If the node is the root, sets the root's color to black. Otherwise, checks if the node's parent is colored black, then checks if the uncle node is colored black. If so, recolors parent and uncle, then recursively checks the parent. If either the parent or uncle is red, performs a rotation to balance the tree."}
{"prompt": "def palindromic_substrings_iter(s):\n    if not s:\n        yield []\n        return\n    for i in range(len(s), 0, -1):\n        sub = s[:i]\n        if sub == sub[::-1]:\n            for rest in palindromic_substrings_iter(s[i:]):\n                yield ([sub] + rest)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturn all substrings of s that are palindromes, using an iterative approach.\n\nArgs:\n    s (str): The string to search for palindromic substrings\n\nYields:\n    list[str]: A list of all palindromic substrings of s\n\"\"\""}
{"prompt": "def find_path(graph, start, end, path=[]):\n    path = path + [start]\n    if start == end:\n        return path\n    if not start in graph:\n        return None\n    for node in graph[start]:\n        if node not in path:\n            newpath = find_path(graph, node, end, path)\n            return newpath\n    return None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Finds a path from start to end in a graph.\n\nParameters: \ngraph (dict): A dictionary representing a graph\nstart (any): The starting node\nend (any): The destination node\npath (list): The current path, which is updated as the function is called recursively\n\nReturns: \npath (list): A list representing the path from start to end\nNone: If no path is found\n\"\"\""}
{"prompt": "def next_sort(arr):\n    for i in range(1, len(arr)):\n        j = i - 1\n        key = arr[i]\n        while arr[j] > key and j >= 0:\n            arr[j + 1] = arr[j]\n            j = j - 1\n        arr[j + 1] = key\n    return arr\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes an array as an argument and uses an insertion sort algorithm to sort the array in increasing order. It returns the sorted array."}
{"prompt": "def swap(i, j):\n    (arr[i], arr[j]) = (arr[j], arr[i])\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"Swap the elements at positions i and j in the given array 'arr'.\""}
{"prompt": "def copy_random_pointer_v1(head):\n    dic = dict()\n    m = n = head\n    while m:\n        dic[m] = RandomListNode(m.label)\n        m = m.next\n    while n:\n        dic[n].next = dic.get(n.next)\n        dic[n].random = dic.get(n.random)\n        n = n.next\n    return dic.get(head)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes a head node of a linked list and creates a copy of the linked list, with each node containing a 'random' pointer. It returns the head node of the copied linked list."}
{"prompt": "def right_rotate(self, node):\n    left_node = node.left\n    if left_node is None:\n        return\n    else:\n        node.left = left_node.right\n        if left_node.right is not None:\n            left_node.right.parent = node\n        left_node.parent = node.parent\n        if node.parent is None:\n            self.root = left_node\n        elif node is node.parent.left:\n            node.parent.left = left_node\n        else:\n            node.parent.right = left_node\n        left_node.right = node\n        node.parent = left_node\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nright_rotate(self, node) -> None\n\nRotate the element at the given node to the right in the tree.\n\"\"\""}
{"prompt": "def _rotate_left(self, parent_node: Node, child_index: int):\n    new_child_key = parent_node.keys[child_index]\n    new_parent_key = parent_node.children[child_index + 1].keys.pop(0)\n    parent_node.children[child_index].keys.append(new_child_key)\n    parent_node.keys[child_index] = new_parent_key\n    if not parent_node.children[child_index + 1].is_leaf:\n        ownerless_child = parent_node.children[child_index + 1].children.pop(0)\n        parent_node.children[child_index].children.append(ownerless_child)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nRotate the child at the given index of the given parent node to the left. This is done by taking the new child key from the parent and assigning it to the child, taking the first key from the right child and making it the new parent key, and if the right child is not a leaf, moving its first child to the left child.\n\nArgs:\n    parent_node (Node): The parent node of the child to be rotated.\n    child_index (int): The index of the child to be rotated.\n\"\"\""}
{"prompt": "def root(self, element):\n    while element != self.parents[element]:\n        self.parents[element] = self.parents[self.parents[element]]\n        element = self.parents[element]\n    return element\n##############\nEND_FUNC\n##############\n", "completion": "\n\nFinds the root of a given element in the Union-Find data structure."}
{"prompt": "def _check_every_number_in_bitsum(bitsum, sum_signs):\n    for val in bitsum:\n        if val != 0 and val != sum_signs:\n            return False\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n_check_every_number_in_bitsum() checks if every number in a given bitsum is either 0 or equal to the given sum_signs. It returns False if any number in the bitsum is neither 0 nor equal to the given sum_signs, and True otherwise."}
{"prompt": "def insert_one_bit(num, bit, i):\n    mask = num >> i\n    mask = mask << 1 | bit\n    mask = mask << i\n    right = (1 << i) - 1 & num\n    return right | mask\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nInsert one bit into the given number at a specified index.\n\nParameters:\nnum (int): The number to insert into\nbit (int): The bit to insert\ni (int): The index to insert the bit into\n\nReturns:\nint: The new number after the bit is inserted\n\"\"\""}
{"prompt": "def __init__(self, size):\n    self.queue = deque(maxlen=size)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__(self, size) initializes a queue object with a maximum size of 'size'. The queue is implemented using a deque."}
{"prompt": "def is_empty(self):\n    return self._top == -1\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nReturn True if the stack is empty, False otherwise."}
{"prompt": "def __iter__(self):\n    probe = self._top\n    while True:\n        if probe == -1:\n            return\n        yield self._array[probe]\n        probe -= 1\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"This function iterates through the elements of a stack and yields them one-by-one in reverse order (from the top of the stack down).\"\"\""}
{"prompt": "def top_left_invert(matrix):\n    new = []\n    for row in matrix:\n        for (i, elem) in enumerate(row):\n            try:\n                new[i].append(elem)\n            except IndexError:\n                new.insert(i, [])\n                new[i].append(elem)\n    return new\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReverses the order of a 2D matrix, with the top left element becoming the bottom right element.\n\nArgs:\n    matrix (list): A 2D matrix of elements\n\nReturns:\n    list: The reversed matrix with the top left element becoming the bottom right element.\n\"\"\""}
{"prompt": "def update(pos, left, right, target, vertex):\n    if left == right:\n        tree[pos] = vertex\n        return\n    mid = left + right >> 1\n    if target <= mid:\n        update(pos << 1, left, mid, target, vertex)\n    else:\n        update(pos << 1 | 1, mid + 1, right, target, vertex)\n    tree[pos] = max_seq(tree[pos << 1], tree[pos << 1 | 1])\n##############\nEND_FUNC\n##############\n", "completion": "\n\nUpdate the segment tree with the given vertex at the target position. \n\nThe segment tree is a binary tree that stores the maximum value of all the elements in the given range. The given target is the index of the element to be updated with the given vertex. The left and right parameters indicate the range in which the search should be performed."}
{"prompt": "def dfs(maze, i, j, depth, cnt):\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    row = len(maze)\n    col = len(maze[0])\n    if i == row - 1 and j == col - 1:\n        if cnt == -1:\n            cnt = depth\n        elif cnt > depth:\n            cnt = depth\n        return cnt\n    maze[i][j] = 0\n    for k in range(len(directions)):\n        nx_i = i + directions[k][0]\n        nx_j = j + directions[k][1]\n        if nx_i >= 0 and nx_i < row and (nx_j >= 0) and (nx_j < col):\n            if maze[nx_i][nx_j] == 1:\n                cnt = dfs(maze, nx_i, nx_j, depth + 1, cnt)\n    maze[i][j] = 1\n    return cnt\n##############\nEND_FUNC\n##############\n", "completion": "\n\ndfs(maze, i, j, depth, cnt)\n\"\"\"\nGiven a maze and two coordinates (i, j), this function uses depth-first search to traverse the maze and find the shortest path from the start point (i, j) to the end point (row-1, col-1). The function takes four parameters: maze (list of list of integers representing the maze), i (row coordinate of the start point), j (column coordinate of the start point), depth (depth of the current node), and cnt (count of the shortest path). The function returns the length of the shortest path from the start point to the end point."}
{"prompt": "def update_heights(self, recursive=True):\n    if self.node:\n        if recursive:\n            if self.node.left:\n                self.node.left.update_heights()\n            if self.node.right:\n                self.node.right.update_heights()\n        self.height = 1 + max(self.node.left.height, self.node.right.height)\n    else:\n        self.height = -1\n##############\nEND_FUNC\n##############\n", "completion": "\n\nupdate_heights(self, recursive=True) updates the heights of a binary tree node and its descendents, if recursive is True. The height of a node is equal to the maximum height of its children plus 1. If the node is None, its height is set to -1."}
{"prompt": "def gen_prime(k, seed=None):\n\n    def is_prime(num):\n        if num == 2:\n            return True\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    random.seed(seed)\n    while True:\n        key = random.randrange(int(2 ** (k - 1)), int(2 ** k))\n        if is_prime(key):\n            return key\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\ngen_prime(k, seed=None)\n\nGenerate a prime number of length k.\nInputs:\n    k (int): Length of prime number to generate.\n    seed (int, optional): Seed to use for random number generator.\nReturns:\n    int: Prime number of length k.\n\"\"\""}
{"prompt": "def string_reverse(s):\n    return s[::-1]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes a string as an argument and returns it reversed."}
{"prompt": "def __str__(self):\n    result = ' '.join(map(str, self))\n    return 'Top-> ' + result\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturns a string representation of a list, with each item separated by a space and the list elements in order from top to bottom."}
{"prompt": "def insertion_sort(arr, simulation=False):\n    iteration = 0\n    if simulation:\n        print('iteration', iteration, ':', *arr)\n    for i in range(len(arr)):\n        cursor = arr[i]\n        pos = i\n        while pos > 0 and arr[pos - 1] > cursor:\n            arr[pos] = arr[pos - 1]\n            pos = pos - 1\n        arr[pos] = cursor\n        if simulation:\n            iteration = iteration + 1\n            print('iteration', iteration, ':', *arr)\n    return arr\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function performs an insertion sort on an array of numbers, with an optional simulation flag that prints out the intermediate steps of the sorting process."}
{"prompt": "def diffie_hellman_key_exchange(a, p, option=None):\n    if option is not None:\n        option = 1\n    if prime_check(p) is False:\n        print(f'{p} is not a prime number')\n        return False\n    try:\n        p_root_list = find_primitive_root(p)\n        p_root_list.index(a)\n    except ValueError:\n        print(f'{a} is not a primitive root of {p}')\n        return False\n    a_pr_k = alice_private_key(p)\n    a_pu_k = alice_public_key(a_pr_k, a, p)\n    b_pr_k = bob_private_key(p)\n    b_pu_k = bob_public_key(b_pr_k, a, p)\n    if option == 1:\n        print(f\"Alice's private key: {a_pr_k}\")\n        print(f\"Alice's public key: {a_pu_k}\")\n        print(f\"Bob's private key: {b_pr_k}\")\n        print(f\"Bob's public key: {b_pu_k}\")\n    a_sh_k = alice_shared_key(b_pu_k, a_pr_k, p)\n    b_sh_k = bob_shared_key(a_pu_k, b_pr_k, p)\n    print(f'Shared key calculated by Alice = {a_sh_k}')\n    print(f'Shared key calculated by Bob = {b_sh_k}')\n    return a_sh_k == b_sh_k\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function implements the Diffie-Hellman key exchange protocol. It takes three arguments: a (a primitive root of p), p (a prime number) and an optional argument option (defaults to None). It checks if p is a prime number and a is a primitive root of p. It then generates private keys for Alice and Bob, followed by their respective public keys. If option is set to 1, it prints out the private and public keys. It then calculates the shared key for Alice and Bob and returns a boolean indicating whether the two shared keys are equal. \n\"\"\""}
{"prompt": "def test():\n    a = Node('3')\n    b = Node('5')\n    c = Node('8')\n    d = Node('5')\n    e = Node('10')\n    f = Node('2')\n    g = Node('1')\n    a.next = b\n    b.next = c\n    c.next = d\n    d.next = e\n    e.next = f\n    f.next = g\n    print_linked_list(a)\n    partition(a, 5)\n    print_linked_list(a)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function creates a linked list of Node objects, prints out the list, then partitions the list based on a given parameter. \n\"\"\""}
{"prompt": "def make_sentence(str_piece, dictionaries):\n    global count\n    if len(str_piece) == 0:\n        return True\n    for i in range(0, len(str_piece)):\n        (prefix, suffix) = (str_piece[0:i], str_piece[i:])\n        if prefix in dictionaries:\n            if suffix in dictionaries or make_sentence(suffix, dictionaries):\n                count += 1\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nmake_sentence takes two parameters: a string (str_piece) and a dictionary of valid words (dictionaries). It then checks if the string can be split into words which are all in the dictionary. If so, it returns True, and increases a global count. Otherwise it returns False."}
{"prompt": "def is_same_tree(tree_p, tree_q):\n    if tree_p is None and tree_q is None:\n        return True\n    if tree_p is not None and tree_q is not None and (tree_p.val == tree_q.val):\n        return is_same_tree(tree_p.left, tree_q.left) and is_same_tree(tree_p.right, tree_q.right)\n    return False\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCheck if two binary trees are the same.\n\nParameters:\ntree_p (TreeNode): The root node of the first tree.\ntree_q (TreeNode): The root node of the second tree.\n\nReturns:\nbool: True if the two trees are the same, False otherwise.\n\"\"\""}
{"prompt": "def merge_set(self, node1, node2):\n    node1 = self.find_set(node1)\n    node2 = self.find_set(node2)\n    if self.size[node1] < self.size[node2]:\n        self.parent[node1] = node2\n        self.size[node2] += self.size[node1]\n    else:\n        self.parent[node2] = node1\n        self.size[node1] += self.size[node2]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nMerge two sets together by connecting the root of one set to the root of the other set. The size of the larger set will be incremented by the size of the smaller set. \n\"\"\""}
{"prompt": "def is_valid_coordinates_regular_expression(coordinates):\n    return bool(re.match('-?(\\\\d|[1-8]\\\\d|90)\\\\.?\\\\d*, -?(\\\\d|[1-9]\\\\d|1[0-7]\\\\d|180)\\\\.?\\\\d*$', coordinates))\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturns a boolean indicating if the given coordinates are valid according to a regular expression that matches valid lat/lng coordinates. \n\"\"\""}
{"prompt": "def zigzag_level(root):\n    res = []\n    if not root:\n        return res\n    level = [root]\n    flag = 1\n    while level:\n        current = []\n        new_level = []\n        for node in level:\n            current.append(node.val)\n            if node.left:\n                new_level.append(node.left)\n            if node.right:\n                new_level.append(node.right)\n        level = new_level\n        res.append(current[::flag])\n        flag *= -1\n    return res\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nThis function takes in the root node of a binary tree and traverses through it in a zigzag level order. It returns a list of lists, representing the values of each level of the tree in a zigzag pattern."}
{"prompt": "def find_words(board, words):\n\n    def backtrack(board, i, j, trie, pre, used, result):\n        if '#' in trie:\n            result.add(pre)\n        if i < 0 or i >= len(board) or j < 0 or (j >= len(board[0])):\n            return\n        if not used[i][j] and board[i][j] in trie:\n            used[i][j] = True\n            backtrack(board, i + 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n            backtrack(board, i, j + 1, trie[board[i][j]], pre + board[i][j], used, result)\n            backtrack(board, i - 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n            backtrack(board, i, j - 1, trie[board[i][j]], pre + board[i][j], used, result)\n            used[i][j] = False\n    trie = {}\n    for word in words:\n        curr_trie = trie\n        for char in word:\n            if char not in curr_trie:\n                curr_trie[char] = {}\n            curr_trie = curr_trie[char]\n        curr_trie['#'] = '#'\n    result = set()\n    used = [[False] * len(board[0]) for _ in range(len(board))]\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            backtrack(board, i, j, trie, '', used, result)\n    return list(result)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function finds all words in a given board of characters that are present in a given list of words. It uses backtracking and builds a trie data structure to traverse the board and create the list of words found."}
{"prompt": "def match_symbol_1(words, symbols):\n    res = []\n    symbols = sorted(symbols, key=lambda _: len(_), reverse=True)\n    for word in words:\n        for symbol in symbols:\n            word_replaced = ''\n            if word.find(symbol) != -1:\n                word_replaced = word.replace(symbol, '[' + symbol + ']')\n                res.append(word_replaced)\n                break\n        if word_replaced == '':\n            res.append(word)\n    return res\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\n\nmatch_symbol_1(words, symbols) takes two parameters, words and symbols, both as lists of strings. It returns a list of strings with the symbols in symbols replaced with the format '[symbol]' in the words list. The symbols list is sorted in reverse order of length before the comparison is made."}
{"prompt": "def reverse_graph(self):\n    reverse_graph = Graph(self.vertex_count)\n    for (source, adjacent) in self.graph.items():\n        for target in adjacent:\n            reverse_graph.add_edge(target, source)\n    return reverse_graph\n##############\nEND_FUNC\n##############\n", "completion": "\n\nCreate a graph with the edges reversed from the given graph.\nReturns a new Graph object with the edges reversed from the given graph."}
{"prompt": "def find_k_factor(length, k_factor):\n    mat = [[[0 for i in range(4)] for j in range((length - 1) // 3 + 2)] for k in range(length + 1)]\n    if 3 * k_factor + 1 > length:\n        return 0\n    mat[1][0][0] = 1\n    mat[1][0][1] = 0\n    mat[1][0][2] = 0\n    mat[1][0][3] = 25\n    for i in range(2, length + 1):\n        for j in range((length - 1) // 3 + 2):\n            if j == 0:\n                mat[i][j][0] = mat[i - 1][j][0] + mat[i - 1][j][1] + mat[i - 1][j][3]\n                mat[i][j][1] = mat[i - 1][j][0]\n                mat[i][j][2] = mat[i - 1][j][1]\n                mat[i][j][3] = mat[i - 1][j][0] * 24 + mat[i - 1][j][1] * 24 + mat[i - 1][j][2] * 25 + mat[i - 1][j][3] * 25\n            elif 3 * j + 1 < i:\n                mat[i][j][0] = mat[i - 1][j][0] + mat[i - 1][j][1] + mat[i - 1][j][3] + mat[i - 1][j - 1][2]\n                mat[i][j][1] = mat[i - 1][j][0]\n                mat[i][j][2] = mat[i - 1][j][1]\n                mat[i][j][3] = mat[i - 1][j][0] * 24 + mat[i - 1][j][1] * 24 + mat[i - 1][j][2] * 25 + mat[i - 1][j][3] * 25\n            elif 3 * j + 1 == i:\n                mat[i][j][0] = 1\n                mat[i][j][1] = 0\n                mat[i][j][2] = 0\n                mat[i][j][3] = 0\n            else:\n                mat[i][j][0] = 0\n                mat[i][j][1] = 0\n                mat[i][j][2] = 0\n                mat[i][j][3] = 0\n    return sum(mat[length][k_factor])\n##############\nEND_FUNC\n##############\n", "completion": "\n\nfind_k_factor(length, k_factor)\n\n\"\"\"\nReturns the sum of all possible sequences of length 'length' with 'k_factor' number of sequences of length 3.\nThe sequences must contain only the characters 'A', 'C', 'G', and 'T'.\n\"\"\""}
{"prompt": "def valid_solution_set(board):\n    valid = set(range(1, 10))\n    for row in board:\n        if set(row) != valid:\n            return False\n    for col in [[row[i] for row in board] for i in range(9)]:\n        if set(col) != valid:\n            return False\n    for x in range(3):\n        for y in range(3):\n            if set(sum([row[x * 3:(x + 1) * 3] for row in board[y * 3:(y + 1) * 3]], [])) != valid:\n                return False\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"This function checks if a given board (9x9 2-dimensional array) is a valid solution set. It returns True if all rows, columns, and 3x3 boxes contain all digits from 1-9, and False otherwise.\"\"\""}
{"prompt": "def text_justification(words, max_width):\n    ret = []\n    row_len = 0\n    row_words = []\n    index = 0\n    is_first_word = True\n    while index < len(words):\n        while row_len <= max_width and index < len(words):\n            if len(words[index]) > max_width:\n                raise ValueError('there exists word whose length is larger than max_width')\n            tmp = row_len\n            row_words.append(words[index])\n            tmp += len(words[index])\n            if not is_first_word:\n                tmp += 1\n            if tmp > max_width:\n                row_words.pop()\n                break\n            row_len = tmp\n            index += 1\n            is_first_word = False\n        row = ''\n        if index == len(words):\n            for word in row_words:\n                row += word + ' '\n            row = row[:-1]\n            row += ' ' * (max_width - len(row))\n        elif len(row_words) != 1:\n            space_num = max_width - row_len\n            space_num_of_each_interval = space_num // (len(row_words) - 1)\n            space_num_rest = space_num - space_num_of_each_interval * (len(row_words) - 1)\n            for j in range(len(row_words)):\n                row += row_words[j]\n                if j != len(row_words) - 1:\n                    row += ' ' * (1 + space_num_of_each_interval)\n                if space_num_rest > 0:\n                    row += ' '\n                    space_num_rest -= 1\n        else:\n            row += row_words[0]\n            row += ' ' * (max_width - len(row))\n        ret.append(row)\n        row_len = 0\n        row_words = []\n        is_first_word = True\n    return ret\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function formats a list of words into a paragraph with left-justified text and a specified maximum width. It takes two parameters: words (a list of strings) and max_width (an integer representing the maximum width of the paragraph). It returns a list of strings representing the left-justified paragraph."}
{"prompt": "def test_search(self):\n    self.assertTrue(self.tree.search(24))\n    self.assertFalse(self.tree.search(50))\n##############\nEND_FUNC\n##############\n", "completion": "\n\nCheck if the given value is present in the Binary Tree or not."}
{"prompt": "def peek(self):\n    return self.items[len(self.items) - 1]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function returns the last item in a list."}
{"prompt": "def __getitem__(self, index):\n    if index < 0:\n        return self.end + index\n    return self.start + index\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nRetrieve an item from the sequence using a given index. If the index is negative, the item is retrieved from the end of the sequence. Otherwise, it is retrieved from the beginning."}
