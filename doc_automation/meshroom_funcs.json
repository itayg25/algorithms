[
  "def run(*args):\n    m = __import__('__main__')\n    importer = zipimport.zipimporter(os.path.dirname(os.__file__))\n    if len(args) == 0:\n        (name, ext) = os.path.splitext(os.path.basename(os.path.normcase(FILE_NAME)))\n        moduleName = '%s__main__' % name\n    else:\n        moduleName = args[0]\n    code = importer.get_code(moduleName)\n    exec(code, m.__dict__)",
  "def __init__(self, script, initScript=None, base=None, targetName=None, icons=None, shortcutName=None, shortcutDir=None, copyright=None, trademarks=None):\n    if not targetName:\n        targetName = os.path.splitext(os.path.basename(script))[0]\n    targetName += PlatformExecutable.exeExtensions[platform.system()]\n    icon = icons.get(platform.system(), None) if icons else None\n    if platform.system() in (self.Linux, self.Darwin):\n        initScript = os.path.join(currentDir, 'setupInitScriptUnix.py')\n    super(PlatformExecutable, self).__init__(script, initScript, base, targetName, icon, shortcutName, shortcutDir, copyright, trademarks)",
  "def test_coreModel_add_remove():\n    m = CoreDictModel(keyAttrName='name')\n    node = DummyNode('DummyNode_1')\n    m.add(node)\n    assert len(m) == 1\n    assert m.get('DummyNode_1') == node\n    m.pop('DummyNode_1')\n    assert len(m) == 0",
  "def test_listModel_add_remove():\n    m = QObjectListModel(keyAttrName='name')\n    node = DummyNode('DummyNode_1')\n    m.add(node)\n    assert len(m) == 1\n    assert m.get('DummyNode_1') == node\n    m.remove(node)\n    assert len(m) == 0",
  "def test_listModel_typed_add():\n    m = QTypedObjectListModel(T=DummyNode)\n    assert m.roleForName('name') != -1\n    node = DummyNode('DummyNode_1')\n    m.add(node)\n    assert m.data(m.index(0), m.roleForName('name')) == 'DummyNode_1'\n    obj = QObject()\n    with pytest.raises(TypeError):\n        m.add(obj)",
  "def __init__(self, name='', parent=None):\n    super(DummyNode, self).__init__(parent)\n    self._name = name",
  "def getName(self):\n    return self._name",
  "def test_unknown_node_type():\n    registerNodeType(SampleNodeV1)\n    g = Graph('')\n    n = g.addNewNode('SampleNodeV1', input='/dev/null', paramA='foo')\n    graphFile = os.path.join(tempfile.mkdtemp(), 'test_unknown_node_type.mg')\n    g.save(graphFile)\n    internalFolder = n.internalFolder\n    nodeName = n.name\n    unregisterNodeType(SampleNodeV1)\n    g = loadGraph(graphFile)\n    os.remove(graphFile)\n    assert len(g.nodes) == 1\n    n = g.node(nodeName)\n    assert isinstance(n, CompatibilityNode)\n    assert n.issue == CompatibilityIssue.UnknownNodeType\n    assert len(n.attributes) == 3\n    assert n.input.isInput\n    assert n.output.isOutput\n    assert n.internalFolder == internalFolder\n    assert not n.canUpgrade\n    with pytest.raises(NodeUpgradeError):\n        g.upgradeNode(nodeName)",
  "def test_description_conflict():\n    originalNodeTypes = copy.copy(meshroom.core.nodesDesc)\n    nodeTypes = [SampleNodeV1, SampleNodeV2, SampleNodeV3, SampleNodeV4, SampleNodeV5]\n    nodes = []\n    g = Graph('')\n    for nt in nodeTypes[:-1]:\n        registerNodeType(nt)\n        n = g.addNewNode(nt.__name__)\n        if nt == SampleNodeV4:\n            n.paramA.value = [{'a': 0, 'b': [1.0, 2.0]}]\n        nodes.append(n)\n    graphFile = os.path.join(tempfile.mkdtemp(), 'test_description_conflict.mg')\n    g.save(graphFile)\n    g = loadGraph(graphFile)\n    assert all((isinstance(n, Node) for n in g.nodes))\n    for (i, nt) in enumerate(nodeTypes[:-1]):\n        meshroom.core.nodesDesc[nt.__name__] = nodeTypes[i + 1]\n    g = loadGraph(graphFile)\n    os.remove(graphFile)\n    assert len(g.nodes) == len(nodes)\n    for srcNode in nodes:\n        nodeName = srcNode.name\n        compatNode = g.node(srcNode.name)\n        assert isinstance(compatNode, CompatibilityNode)\n        assert srcNode.internalFolder == compatNode.internalFolder\n        if isinstance(srcNode.nodeDesc, SampleNodeV1):\n            assert len(compatNode.attributes) == 3\n            assert hasattr(compatNode, 'input')\n            assert not hasattr(compatNode, 'in')\n            upgradedNode = g.upgradeNode(nodeName)[0]\n            assert isinstance(upgradedNode, Node) and isinstance(upgradedNode.nodeDesc, SampleNodeV2)\n            assert not hasattr(upgradedNode, 'input')\n            assert hasattr(upgradedNode, 'in')\n            assert upgradedNode.internalFolder != srcNode.internalFolder\n        elif isinstance(srcNode.nodeDesc, SampleNodeV2):\n            assert len(compatNode.attributes) == 3\n            assert hasattr(compatNode, 'paramA')\n            upgradedNode = g.upgradeNode(nodeName)[0]\n            assert isinstance(upgradedNode, Node) and isinstance(upgradedNode.nodeDesc, SampleNodeV3)\n            assert not hasattr(upgradedNode, 'paramA')\n            assert upgradedNode.internalFolder == srcNode.internalFolder\n        elif isinstance(srcNode.nodeDesc, SampleNodeV3):\n            assert len(compatNode.attributes) == 2\n            assert not hasattr(compatNode, 'paramA')\n            upgradedNode = g.upgradeNode(nodeName)[0]\n            assert isinstance(upgradedNode, Node) and isinstance(upgradedNode.nodeDesc, SampleNodeV4)\n            assert hasattr(upgradedNode, 'paramA')\n            assert isinstance(upgradedNode.paramA.attributeDesc, desc.ListAttribute)\n            assert upgradedNode.internalFolder != srcNode.internalFolder\n        elif isinstance(srcNode.nodeDesc, SampleNodeV4):\n            assert len(compatNode.attributes) == 3\n            assert hasattr(compatNode, 'paramA')\n            groupAttribute = compatNode.paramA.attributeDesc.elementDesc\n            assert isinstance(groupAttribute, desc.GroupAttribute)\n            for elt in groupAttribute.groupDesc:\n                assert isinstance(elt, next((a for a in SampleGroupV1 if a.name == elt.name)).__class__)\n            upgradedNode = g.upgradeNode(nodeName)[0]\n            assert isinstance(upgradedNode, Node) and isinstance(upgradedNode.nodeDesc, SampleNodeV5)\n            assert hasattr(upgradedNode, 'paramA')\n            assert upgradedNode.paramA.isDefault\n            assert upgradedNode.internalFolder != srcNode.internalFolder\n        else:\n            raise ValueError('Unexpected node type: ' + srcNode.nodeType)\n    meshroom.core.nodesDesc = originalNodeTypes",
  "def test_upgradeAllNodes():\n    registerNodeType(SampleNodeV1)\n    registerNodeType(SampleNodeV2)\n    g = Graph('')\n    n1 = g.addNewNode('SampleNodeV1')\n    n2 = g.addNewNode('SampleNodeV2')\n    n1Name = n1.name\n    n2Name = n2.name\n    graphFile = os.path.join(tempfile.mkdtemp(), 'test_description_conflict.mg')\n    g.save(graphFile)\n    unregisterNodeType(SampleNodeV2)\n    meshroom.core.nodesDesc[SampleNodeV1.__name__] = SampleNodeV2\n    g = loadGraph(graphFile)\n    os.remove(graphFile)\n    assert len(g.compatibilityNodes) == 2\n    assert g.node(n1Name).canUpgrade\n    assert not g.node(n2Name).canUpgrade\n    g.upgradeAllNodes()\n    assert len(g.compatibilityNodes) == 1\n    assert n2Name in g.compatibilityNodes.keys()\n    unregisterNodeType(SampleNodeV1)",
  "def test_conformUpgrade():\n    registerNodeType(SampleNodeV5)\n    registerNodeType(SampleNodeV6)\n    g = Graph('')\n    n1 = g.addNewNode('SampleNodeV5')\n    n1.paramA.value = [{'a': 0, 'b': [{'a': 0, 'b': [1.0, 2.0]}, {'a': 1, 'b': [1.0, 2.0]}]}]\n    n1Name = n1.name\n    graphFile = os.path.join(tempfile.mkdtemp(), 'test_conform_upgrade.mg')\n    g.save(graphFile)\n    meshroom.core.nodesDesc[SampleNodeV5.__name__] = SampleNodeV6\n    g = loadGraph(graphFile)\n    os.remove(graphFile)\n    assert len(g.compatibilityNodes) == 1\n    assert g.node(n1Name).canUpgrade\n    g.upgradeAllNodes()\n    assert len(g.compatibilityNodes) == 0\n    upgradedNode = g.node(n1Name)\n    assert isinstance(upgradedNode, Node) and isinstance(upgradedNode.nodeDesc, SampleNodeV6)\n    assert len(upgradedNode.paramA.value) == 1\n    unregisterNodeType(SampleNodeV5)\n    unregisterNodeType(SampleNodeV6)",
  "def test_output_invalidation():\n    graph = Graph('')\n    n1 = graph.addNewNode('SampleNode', input='/tmp')\n    n2 = graph.addNewNode('SampleNode')\n    n3 = graph.addNewNode('SampleNode')\n    graph.addEdges((n1.output, n2.input), (n1.output, n3.input))\n    n2inputUid = n2.input.uid()\n    n3inputUid = n3.input.uid()\n    assert n3inputUid == n2inputUid\n    n1.paramA.value = 'a'\n    assert n2.input.uid() == n2inputUid\n    n1.input.value = '/a/path'\n    assert n2.input.uid() != n2inputUid\n    assert n2.input.uid() == n3.input.uid()",
  "def test_inputLinkInvalidation():\n    graph = Graph('')\n    n1 = graph.addNewNode('SampleNode')\n    n2 = graph.addNewNode('SampleNode')\n    graph.addEdges((n1.input, n2.input))\n    assert n1.input.uid() == n2.input.uid()\n    assert n1.output.value == n2.output.value",
  "def test_depth():\n    graph = Graph('Tests tasks depth')\n    tA = graph.addNewNode('Ls', input='/tmp')\n    tB = graph.addNewNode('AppendText', inputText='echo B')\n    tC = graph.addNewNode('AppendText', inputText='echo C')\n    graph.addEdges((tA.output, tB.input), (tB.output, tC.input))\n    assert tA.depth == 0\n    assert tB.depth == 1\n    assert tC.depth == 2",
  "def test_depth_diamond_graph():\n    graph = Graph('Tests tasks depth')\n    tA = graph.addNewNode('Ls', input='/tmp')\n    tB = graph.addNewNode('AppendText', inputText='echo B')\n    tC = graph.addNewNode('AppendText', inputText='echo C')\n    tD = graph.addNewNode('AppendFiles')\n    graph.addEdges((tA.output, tB.input), (tA.output, tC.input), (tB.output, tD.input), (tC.output, tD.input2))\n    assert tA.depth == 0\n    assert tB.depth == 1\n    assert tC.depth == 1\n    assert tD.depth == 2\n    (nodes, edges) = graph.dfsOnFinish()\n    assert len(nodes) == 4\n    assert nodes[0] == tA\n    assert nodes[-1] == tD\n    assert len(edges) == 4\n    (nodes, edges) = graph.dfsOnFinish(startNodes=[tD])\n    assert len(nodes) == 4\n    assert nodes[0] == tA\n    assert nodes[-1] == tD\n    assert len(edges) == 4\n    (nodes, edges) = graph.dfsOnFinish(startNodes=[tB])\n    assert len(nodes) == 2\n    assert nodes[0] == tA\n    assert nodes[-1] == tB\n    assert len(edges) == 1",
  "def test_depth_diamond_graph2():\n    graph = Graph('Tests tasks depth')\n    tA = graph.addNewNode('Ls', input='/tmp')\n    tB = graph.addNewNode('AppendText', inputText='echo B')\n    tC = graph.addNewNode('AppendText', inputText='echo C')\n    tD = graph.addNewNode('AppendText', inputText='echo D')\n    tE = graph.addNewNode('AppendFiles')\n    graph.addEdges((tA.output, tB.input), (tB.output, tC.input), (tB.output, tD.input), (tA.output, tE.input), (tB.output, tE.input2), (tC.output, tE.input3), (tD.output, tE.input4))\n    assert tA.depth == 0\n    assert tB.depth == 1\n    assert tC.depth == 2\n    assert tD.depth == 2\n    assert tE.depth == 3\n    (nodes, edges) = graph.dfsOnFinish()\n    assert len(nodes) == 5\n    assert nodes[0] == tA\n    assert nodes[-1] == tE\n    assert len(edges) == 7\n    (nodes, edges) = graph.dfsOnFinish(startNodes=[tE])\n    assert len(nodes) == 5\n    assert nodes[0] == tA\n    assert nodes[-1] == tE\n    assert len(edges) == 7\n    (nodes, edges) = graph.dfsOnFinish(startNodes=[tD])\n    assert len(nodes) == 3\n    assert nodes[0] == tA\n    assert nodes[1] == tB\n    assert nodes[2] == tD\n    assert len(edges) == 2\n    (nodes, edges) = graph.dfsOnFinish(startNodes=[tB])\n    assert len(nodes) == 2\n    assert nodes[0] == tA\n    assert nodes[-1] == tB\n    assert len(edges) == 1",
  "def test_transitive_reduction():\n    graph = Graph('Tests tasks depth')\n    tA = graph.addNewNode('Ls', input='/tmp')\n    tB = graph.addNewNode('AppendText', inputText='echo B')\n    tC = graph.addNewNode('AppendText', inputText='echo C')\n    tD = graph.addNewNode('AppendText', inputText='echo D')\n    tE = graph.addNewNode('AppendFiles')\n    graph.addEdges((tA.output, tE.input), (tA.output, tB.input), (tB.output, tC.input), (tB.output, tD.input), (tB.output, tE.input4), (tC.output, tE.input3), (tD.output, tE.input2))\n    edgesScore = graph.dfsMaxEdgeLength()\n    flowEdges = graph.flowEdges()\n    flowEdgesRes = [(tB, tA), (tD, tB), (tC, tB), (tE, tD), (tE, tC)]\n    assert set(flowEdgesRes) == set(flowEdges)\n    assert len(graph._nodesMinMaxDepths) == len(graph.nodes)\n    for (node, (minDepth, maxDepth)) in graph._nodesMinMaxDepths.items():\n        assert node.depth == maxDepth",
  "def test_graph_reverse_dfsOnDiscover():\n    graph = Graph('Test dfsOnDiscover(reverse=True)')\n    A = graph.addNewNode('Ls', input='/tmp')\n    B = graph.addNewNode('AppendText', inputText=A.output)\n    C = graph.addNewNode('AppendText', inputText=B.output)\n    D = graph.addNewNode('AppendText', inputText=B.output)\n    E = graph.addNewNode('Ls', input=C.output)\n    F = graph.addNewNode('AppendText', input=A.output, inputText=E.output)\n    nodes = graph.dfsOnDiscover(startNodes=[A], reverse=True)[0]\n    assert set(nodes) == {A, B, D, C, E, F}\n    nodes = graph.dfsOnDiscover(startNodes=[B], reverse=True)[0]\n    assert set(nodes) == {B, D, C, E, F}\n    nodes = graph.dfsOnDiscover(startNodes=[B], filterTypes=['AppendText'], reverse=True)[0]\n    assert set(nodes) == {B, D, C, F}\n    nodes = graph.dfsOnDiscover(startNodes=[C], reverse=True)[0]\n    assert nodes == [C, E, F]\n    nodes = graph.dfsOnDiscover(reverse=True)[0]\n    assert set(nodes) == {A, B, C, D, E, F}",
  "def test_graph_dfsOnDiscover():\n    graph = Graph('Test dfsOnDiscover(reverse=False)')\n    G = graph.addNewNode('Ls', input='/tmp')\n    A = graph.addNewNode('Ls', input='/tmp')\n    B = graph.addNewNode('AppendText', inputText=A.output)\n    C = graph.addNewNode('AppendText', inputText=B.output)\n    D = graph.addNewNode('AppendText', input=G.output, inputText=B.output)\n    E = graph.addNewNode('Ls', input=C.output)\n    F = graph.addNewNode('AppendText', input=A.output, inputText=E.output)\n    nodes = graph.dfsOnDiscover(startNodes=[A], reverse=False)[0]\n    assert set(nodes) == {A}\n    nodes = graph.dfsOnDiscover(startNodes=[D], reverse=False)[0]\n    assert set(nodes) == {A, B, D, G}\n    nodes = graph.dfsOnDiscover(startNodes=[E], reverse=False)[0]\n    assert set(nodes) == {A, B, C, E}\n    nodes = graph.dfsOnDiscover(startNodes=[F], reverse=False)[0]\n    assert set(nodes) == {A, B, C, E, F}\n    nodes = graph.dfsOnDiscover(startNodes=[C], filterTypes=['AppendText'], reverse=False)[0]\n    assert set(nodes) == {B, C}\n    nodes = graph.dfsOnDiscover(startNodes=[D], longestPathFirst=True, reverse=False)[0]\n    assert nodes == [D, B, A, G]\n    nodes = graph.dfsOnDiscover(reverse=False)[0]\n    assert set(nodes) == {A, B, C, D, E, F, G}",
  "def test_graph_nodes_sorting():\n    graph = Graph('')\n    ls0 = graph.addNewNode('Ls')\n    ls1 = graph.addNewNode('Ls')\n    ls2 = graph.addNewNode('Ls')\n    assert graph.nodesOfType('Ls', sortedByIndex=True) == [ls0, ls1, ls2]\n    graph = Graph('')\n    ls2 = graph.addNewNode('Ls', name='Ls_2')\n    ls0 = graph.addNewNode('Ls', name='Ls_0')\n    ls1 = graph.addNewNode('Ls', name='Ls_1')\n    assert graph.nodesOfType('Ls', sortedByIndex=True) == [ls0, ls1, ls2]",
  "def test_duplicate_nodes():\n    g = Graph('')\n    n0 = g.addNewNode('Ls', input='/tmp')\n    n1 = g.addNewNode('Ls', input=n0.output)\n    n2 = g.addNewNode('Ls', input=n1.output)\n    n3 = g.addNewNode('AppendFiles', input=n1.output, input2=n2.output)\n    (nodes_to_duplicate, _) = g.dfsOnDiscover(startNodes=[n1], reverse=True, dependenciesOnly=True)\n    nMap = g.duplicateNodes(srcNodes=nodes_to_duplicate)\n    for (s, duplicated) in nMap.items():\n        for d in duplicated:\n            assert s.nodeType == d.nodeType\n    assert len(nMap) == 3 and all([len(nMap[i]) == 1 for i in nMap.keys()])\n    assert nMap[n1][0].input.getLinkParam() == n0.output\n    assert nMap[n2][0].input.getLinkParam() == nMap[n1][0].output\n    assert nMap[n3][0].input.getLinkParam() == nMap[n1][0].output\n    assert nMap[n3][0].input2.getLinkParam() == nMap[n2][0].output",
  "def test_multiviewPipeline():\n    graph1InputImages = ['/non/existing/fileA']\n    graph1 = loadGraph(meshroom.core.pipelineTemplates['photogrammetry'])\n    graph1CameraInit = graph1.node('CameraInit_1')\n    graph1CameraInit.viewpoints.extend([{'path': image} for image in graph1InputImages])\n    graph2InputImages = []\n    graph2 = loadGraph(meshroom.core.pipelineTemplates['photogrammetry'])\n    graph2CameraInit = graph2.node('CameraInit_1')\n    graph2CameraInit.viewpoints.extend([{'path': image} for image in graph2InputImages])\n    graph2b = loadGraph(meshroom.core.pipelineTemplates['photogrammetry'])\n    graph2bCameraInit = graph2b.node('CameraInit_1')\n    graph2bCameraInit.viewpoints.extend([{'path': image} for image in graph2InputImages])\n    graph3InputImages = ['/non/existing/file1', '/non/existing/file2']\n    graph3 = loadGraph(meshroom.core.pipelineTemplates['photogrammetry'])\n    graph3CameraInit = graph3.node('CameraInit_1')\n    graph3CameraInit.viewpoints.extend([{'path': image} for image in graph3InputImages])\n    graph4InputViewpoints = [{'path': '/non/existing/file1', 'intrinsicId': 50}, {'path': '/non/existing/file2', 'intrinsicId': 55}]\n    graph4 = loadGraph(meshroom.core.pipelineTemplates['photogrammetry'])\n    graph4CameraInit = graph4.node('CameraInit_1')\n    graph4CameraInit.viewpoints.extend(graph4InputViewpoints)\n    graph4b = loadGraph(meshroom.core.pipelineTemplates['photogrammetry'])\n    graph4bCameraInit = graph4b.node('CameraInit_1')\n    graph4bCameraInit.viewpoints.extend(graph4InputViewpoints)\n    assert graph1.findNode('CameraInit').viewpoints.at(0).path.value == '/non/existing/fileA'\n    assert len(graph2.findNode('CameraInit').viewpoints) == 0\n    assert graph3.findNode('CameraInit').viewpoints.at(0).path.value == '/non/existing/file1'\n    assert graph4.findNode('CameraInit').viewpoints.at(0).path.value == '/non/existing/file1'\n    assert len(graph1.findNode('CameraInit').viewpoints) == 1\n    assert len(graph2.findNode('CameraInit').viewpoints) == 0\n    assert len(graph3.findNode('CameraInit').viewpoints) == 2\n    assert len(graph4.findNode('CameraInit').viewpoints) == 2\n    viewpoints = graph3.findNode('CameraInit').viewpoints\n    assert viewpoints.at(0).path.value == '/non/existing/file1'\n    assert viewpoints.at(0).path.value == '/non/existing/file1'\n    assert viewpoints.at(0).intrinsicId.value == -1\n    assert viewpoints.at(1).path.value == '/non/existing/file2'\n    assert viewpoints.at(1).intrinsicId.value == -1\n    assert not viewpoints.at(0).path.isDefault\n    assert viewpoints.at(0).intrinsicId.isDefault\n    assert viewpoints.getPrimitiveValue(exportDefault=False) == [{'path': '/non/existing/file1'}, {'path': '/non/existing/file2'}]\n    for graph in (graph4, graph4b):\n        viewpoints = graph.findNode('CameraInit').viewpoints\n        assert viewpoints.at(0).path.value == '/non/existing/file1'\n        assert viewpoints.at(0).intrinsicId.value == 50\n        assert viewpoints.at(1).path.value == '/non/existing/file2'\n        assert viewpoints.at(1).intrinsicId.value == 55\n    for otherGraph in (graph2, graph3, graph4):\n        for node in graph1.nodes:\n            otherNode = otherGraph.node(node.name)\n            for (key, attr) in node.attributes.items():\n                if attr.isOutput:\n                    otherAttr = otherNode.attribute(key)\n                    assert attr.uid() != otherAttr.uid()\n    (nodes, edges) = graph2.dfsOnFinish()\n    for node in nodes:\n        otherNode = graph2b.node(node.name)\n        for (key, attr) in node.attributes.items():\n            otherAttr = otherNode.attribute(key)\n            if attr.isOutput:\n                assert attr.uid() == otherAttr.uid()\n            else:\n                for uidIndex in attr.desc.uid:\n                    assert attr.uid(uidIndex) == otherAttr.uid(uidIndex)\n    (nodes, edges) = graph4.dfsOnFinish()\n    for node in nodes:\n        otherNode = graph4b.node(node.name)\n        for (key, attr) in node.attributes.items():\n            otherAttr = otherNode.attribute(key)\n            if attr.isOutput:\n                assert attr.uid() == otherAttr.uid()\n            else:\n                for uidIndex in attr.desc.uid:\n                    assert attr.uid(uidIndex) == otherAttr.uid(uidIndex)\n    for graph in [graph1, graph2, graph3, graph4]:\n        filename = tempfile.mktemp()\n        graph.save(filename)\n        loadedGraph = loadGraph(filename)\n        os.remove(filename)\n        assert sorted([n.name for n in loadedGraph.nodes]) == sorted([n.name for n in graph.nodes])\n        assert all((isinstance(n, Node) for n in loadedGraph.nodes))\n        assert sorted([n._uids.get(0) for n in loadedGraph.nodes]) == sorted([n._uids.get(0) for n in graph.nodes])",
  "def test_templateVersions():\n    assert len(pipelineTemplates) >= 1\n    for (_, path) in pipelineTemplates.items():\n        with open(path) as jsonFile:\n            fileData = json.load(jsonFile)\n        graphData = fileData.get(Graph.IO.Keys.Graph, fileData)\n        assert isinstance(graphData, dict)\n        header = fileData.get(Graph.IO.Keys.Header, {})\n        assert header.get('template', False)\n        nodesVersions = header.get(Graph.IO.Keys.NodesVersions, {})\n        for (_, nodeData) in graphData.items():\n            nodeType = nodeData['nodeType']\n            assert nodeType in meshroom.core.nodesDesc\n            nodeDesc = meshroom.core.nodesDesc[nodeType]\n            currentNodeVersion = meshroom.core.nodeVersion(nodeDesc)\n            inputs = nodeData.get('inputs', {})\n            version = nodesVersions.get(nodeType, None)\n            compatibilityIssue = None\n            if version and currentNodeVersion and (Version(version).major != Version(currentNodeVersion).major):\n                compatibilityIssue = CompatibilityIssue.VersionConflict\n            else:\n                for (attrName, value) in inputs.items():\n                    if not CompatibilityNode.attributeDescFromName(nodeDesc.inputs, attrName, value):\n                        compatibilityIssue = CompatibilityIssue.DescriptionConflict\n                        break\n            assert compatibilityIssue is None",
  "def setup(app):\n    app.add_directive('fetch_md', FetchMd)\n    return {'version': '0.1', 'parallel_read_safe': True, 'parallel_write_safe': True}",
  "def relink(self, node, base_dir):\n    key = get_link_key(node)\n    if key is None:\n        return\n    link = node.attributes[key]\n    if link.startswith('http') or link.startswith('mailto'):\n        return\n    if link.startswith('/'):\n        link = link[1:]\n    node.attributes[key] = base_dir + '/' + link",
  "def visit_image(self, node):\n    self.relink(node, os.getenv('PROJECT_DIR'))",
  "def run(self):\n    path = os.path.abspath(os.getenv('PROJECT_DIR') + '/' + self.arguments[0])\n    result = []\n    try:\n        with open(path) as file:\n            text = file.read()\n            doc = md_to_docutils(text)\n            relinker = Relinker(doc)\n            doc.walk(relinker)\n            result.append(doc[0])\n    except FileNotFoundError:\n        pass\n    return result",
  "def setup(app):\n    app.add_directive('meshroom_doc', MeshroomDoc)\n    return {'version': '0.1', 'parallel_read_safe': True, 'parallel_write_safe': True}",
  "def parse_args(self):\n    module_name = self.arguments[self.arguments.index(':module:') + 1]\n    class_name = self.arguments[self.arguments.index(':class:') + 1]\n    return (module_name, class_name)",
  "def run(self):\n    result = []\n    (module_name, class_name) = self.parse_args()\n    module = importlib.import_module(module_name)\n    node_class = getattr(module, class_name)\n    if issubclass(node_class, desc.Node):\n        node = node_class()\n        doc = md_to_docutils('**Category**: {}'.format(node.category))\n        result.extend(doc.children)\n        doc = md_to_docutils(node.documentation)\n        result.extend(doc.children)\n        text_inputs = '**Inputs**: \\n'\n        for attr in node.inputs:\n            text_inputs += '- {} ({})\\n'.format(attr._name, attr.__class__.__name__)\n        doc = md_to_docutils(text_inputs)\n        result.extend(doc.children)\n        text_outputs = '**Outputs**: \\n'\n        for attr in node.outputs:\n            text_outputs += '- {} ({})\\n'.format(attr._name, attr.__class__.__name__)\n        doc = md_to_docutils(text_outputs)\n        result.extend(doc.children)\n    return result",
  "def md_to_docutils(text):\n    parser = Parser()\n    doc = make_document(parser_cls=Parser)\n    parser.parse(text, doc)\n    return doc",
  "def get_link_key(node):\n    link_keys = ['uri', 'refuri', 'refname']\n    for key in link_keys:\n        if key in node.attributes.keys():\n            return key\n    return None",
  "def hasExtension(filepath, extensions):\n    return os.path.splitext(filepath)[1].lower() in extensions",
  "def findFilesByTypeInFolder(folder, recursive=False):\n    inputFolders = []\n    if isinstance(folder, (list, tuple)):\n        inputFolders = folder\n    else:\n        inputFolders.append(folder)\n    output = FilesByType()\n    for currentFolder in inputFolders:\n        if os.path.isfile(currentFolder):\n            output.addFile(currentFolder)\n            continue\n        elif os.path.isdir(currentFolder):\n            if recursive:\n                for (root, directories, files) in os.walk(currentFolder):\n                    for filename in files:\n                        output.addFile(os.path.join(root, filename))\n            else:\n                output.addFiles([os.path.join(currentFolder, filename) for filename in os.listdir(currentFolder)])\n        else:\n            import glob\n            paths = glob.glob(currentFolder)\n            filesByType = findFilesByTypeInFolder(paths, recursive=recursive)\n            output.extend(filesByType)\n    return output",
  "def mvsPipeline(graph, sfm=None):\n    if sfm and (not sfm.nodeType == 'StructureFromMotion'):\n        raise ValueError('Invalid node type. Expected StructureFromMotion, got {}.'.format(sfm.nodeType))\n    prepareDenseScene = graph.addNewNode('PrepareDenseScene', input=sfm.output if sfm else '')\n    depthMap = graph.addNewNode('DepthMap', input=prepareDenseScene.input, imagesFolder=prepareDenseScene.output)\n    depthMapFilter = graph.addNewNode('DepthMapFilter', input=depthMap.input, depthMapsFolder=depthMap.output)\n    meshing = graph.addNewNode('Meshing', input=depthMapFilter.input, depthMapsFolder=depthMapFilter.output)\n    meshFiltering = graph.addNewNode('MeshFiltering', inputMesh=meshing.outputMesh)\n    texturing = graph.addNewNode('Texturing', input=meshing.output, imagesFolder=depthMap.imagesFolder, inputMesh=meshFiltering.outputMesh)\n    return [prepareDenseScene, depthMap, depthMapFilter, meshing, meshFiltering, texturing]",
  "def sfmAugmentation(graph, sourceSfm, withMVS=False):\n    cameraInit = graph.addNewNode('CameraInit')\n    featureExtraction = graph.addNewNode('FeatureExtraction', input=cameraInit.output)\n    imageMatchingMulti = graph.addNewNode('ImageMatchingMultiSfM', input=featureExtraction.input, featuresFolders=[featureExtraction.output])\n    featureMatching = graph.addNewNode('FeatureMatching', input=imageMatchingMulti.outputCombinedSfM, featuresFolders=imageMatchingMulti.featuresFolders, imagePairsList=imageMatchingMulti.output, describerTypes=featureExtraction.describerTypes)\n    structureFromMotion = graph.addNewNode('StructureFromMotion', input=featureMatching.input, featuresFolders=featureMatching.featuresFolders, matchesFolders=[featureMatching.output], describerTypes=featureMatching.describerTypes)\n    graph.addEdge(sourceSfm.output, imageMatchingMulti.inputB)\n    sfmNodes = [cameraInit, featureExtraction, imageMatchingMulti, featureMatching, structureFromMotion]\n    mvsNodes = []\n    if withMVS:\n        mvsNodes = mvsPipeline(graph, structureFromMotion)\n    return (sfmNodes, mvsNodes)",
  "def __init__(self):\n    self.images = []\n    self.videos = []\n    self.panoramaInfo = []\n    self.other = []",
  "def __bool__(self):\n    return self.images or self.videos or self.panoramaInfo",
  "def extend(self, other):\n    self.images.extend(other.images)\n    self.videos.extend(other.videos)\n    self.panoramaInfo.extend(other.panoramaInfo)\n    self.other.extend(other.other)",
  "def addFile(self, file):\n    if hasExtension(file, imageExtensions):\n        self.images.append(file)\n    elif hasExtension(file, videoExtensions):\n        self.videos.append(file)\n    elif hasExtension(file, panoramaInfoExtensions):\n        self.panoramaInfo.append(file)\n    else:\n        self.other.append(file)",
  "def addFiles(self, files):\n    for file in files:\n        self.addFile(file)",
  "def setupEnvironment(backend=Backend.STANDALONE):\n    init(backend)\n\n    def addToEnvPath(var, val, index=-1):\n        if not val:\n            return\n        paths = os.environ.get(var, '').split(os.pathsep)\n        if not isinstance(val, (list, tuple)):\n            val = [val]\n        if index == -1:\n            paths.extend(val)\n        elif index == 0:\n            paths = val + paths\n        else:\n            raise ValueError('addToEnvPath: index must be -1 or 0.')\n        os.environ[var] = os.pathsep.join(paths)\n    rootDir = os.path.dirname(sys.executable) if isFrozen else os.environ.get('MESHROOM_INSTALL_DIR', None)\n    if rootDir:\n        os.environ['MESHROOM_INSTALL_DIR'] = rootDir\n        aliceVisionDir = os.path.join(rootDir, 'aliceVision')\n        aliceVisionBinDir = os.path.join(aliceVisionDir, 'bin')\n        aliceVisionShareDir = os.path.join(aliceVisionDir, 'share', 'aliceVision')\n        qtPluginsDir = os.path.join(rootDir, 'qtPlugins')\n        sensorDBPath = os.path.join(aliceVisionShareDir, 'cameraSensors.db')\n        voctreePath = os.path.join(aliceVisionShareDir, 'vlfeat_K80L3.SIFT.tree')\n        env = {'PATH': aliceVisionBinDir, 'QT_PLUGIN_PATH': [qtPluginsDir], 'QML2_IMPORT_PATH': [os.path.join(qtPluginsDir, 'qml')]}\n        for (key, value) in env.items():\n            logging.info('Add to {}: {}'.format(key, value))\n            addToEnvPath(key, value, 0)\n        variables = {'ALICEVISION_SENSOR_DB': sensorDBPath, 'ALICEVISION_VOCTREE': voctreePath}\n        for (key, value) in variables.items():\n            if key not in os.environ and os.path.exists(value):\n                logging.info('Set {}: {}'.format(key, value))\n                os.environ[key] = value\n    else:\n        addToEnvPath('PATH', os.environ.get('ALICEVISION_BIN_PATH', ''))",
  "def addToEnvPath(var, val, index=-1):\n    if not val:\n        return\n    paths = os.environ.get(var, '').split(os.pathsep)\n    if not isinstance(val, (list, tuple)):\n        val = [val]\n    if index == -1:\n        paths.extend(val)\n    elif index == 0:\n        paths = val + paths\n    else:\n        raise ValueError('addToEnvPath: index must be -1 or 0.')\n    os.environ[var] = os.pathsep.join(paths)",
  "def parseSfMJsonFile(sfmJsonFile):\n    if not os.path.exists(sfmJsonFile):\n        return ({}, {}, {})\n    with open(sfmJsonFile) as jsonFile:\n        report = json.load(jsonFile)\n    views = dict()\n    poses = dict()\n    intrinsics = dict()\n    for view in report['views']:\n        views[view['viewId']] = view\n    for pose in report['poses']:\n        poses[pose['poseId']] = pose['pose']\n    for intrinsic in report['intrinsics']:\n        intrinsics[intrinsic['intrinsicId']] = intrinsic\n    return (views, poses, intrinsics)",
  "def __init__(self, title, text, detailedText='', parent=None):\n    super(Message, self).__init__(parent)\n    self._title = title\n    self._text = text\n    self._detailedText = detailedText",
  "def __init__(self, reconstruction):\n    super(LiveSfmManager, self).__init__(reconstruction)\n    self.reconstruction = reconstruction\n    self._folder = ''\n    self.timerId = -1\n    self.minImagesPerStep = 4\n    self.watchTimerInterval = 1000\n    self.allImages = []\n    self.cameraInit = None\n    self.sfm = None\n    self._running = False",
  "def reset(self):\n    self.stop(False)\n    self.sfm = None\n    self.cameraInit = None",
  "def setRunning(self, value):\n    if self._running == value:\n        return\n    if self._running:\n        self.killTimer(self.timerId)\n    else:\n        self.timerId = self.startTimer(self.watchTimerInterval)\n    self._running = value\n    self.runningChanged.emit()",
  "@Slot(str, int)\ndef start(self, folder, minImagesPerStep):\n    if not os.path.isdir(folder):\n        raise RuntimeError('Invalid folder provided: {}'.format(folder))\n    self._folder = folder\n    self.folderChanged.emit()\n    self.cameraInit = self.sfm = None\n    self.allImages = self.reconstruction.allImagePaths()\n    self.minImagesPerStep = minImagesPerStep\n    self.setRunning(True)\n    self.update()",
  "@Slot()\ndef stop(self, requestCompute=True):\n    self.setRunning(False)\n    if requestCompute:\n        self.computeStep()",
  "def timerEvent(self, evt):\n    self.update()",
  "def update(self):\n    imagesInFolder = multiview.findFilesByTypeInFolder(self._folder).images\n    newImages = set(imagesInFolder).difference(self.allImages)\n    for imagePath in newImages:\n        if not self.cameraInit:\n            self.reconstruction.beginModification('SfM Augmentation')\n            (self.cameraInit, self.sfm) = self.reconstruction.addSfmAugmentation()\n        self.addImageToStep(imagePath)\n    if len(self.imagesInStep()) >= self.minImagesPerStep and (not self.reconstruction.computing):\n        self.computeStep()",
  "def addImageToStep(self, path):\n    self.reconstruction.appendAttribute(self.cameraInit.viewpoints, {'path': path})\n    self.allImages.append(path)",
  "def imagePathsInCameraInit(self, node):\n    assert node.nodeType == 'CameraInit'\n    return [vp.path.value for vp in node.viewpoints.value]",
  "def imagesInStep(self):\n    return self.imagePathsInCameraInit(self.cameraInit) if self.cameraInit else []",
  "@Slot()\ndef computeStep(self):\n    if not self.cameraInit:\n        return\n    self.reconstruction.buildIntrinsics(self.cameraInit, [])\n    self.cameraInit = None\n    sfm = self.sfm\n    self.sfm = None\n    self.reconstruction.endModification()\n    self.reconstruction.execute(sfm)",
  "def __init__(self, viewpointAttribute, reconstruction):\n    super(ViewpointWrapper, self).__init__(parent=reconstruction)\n    self._viewpoint = viewpointAttribute\n    self._reconstruction = reconstruction\n    self._initialIntrinsics = None\n    self._T = None\n    self._R = None\n    self._solvedIntrinsics = {}\n    self._reconstructed = False\n    self._undistortedImagePath = ''\n    self._activeNode_PrepareDenseScene = self._reconstruction.activeNodes.get('PrepareDenseScene')\n    self._updateInitialParams()\n    self._updateSfMParams()\n    self._updateDenseSceneParams()\n    self._reconstruction.cameraInitChanged.connect(self._updateInitialParams)\n    self._reconstruction.sfmReportChanged.connect(self._updateSfMParams)\n    self._activeNode_PrepareDenseScene.nodeChanged.connect(self._updateDenseSceneParams)",
  "def _updateInitialParams(self):\n    if not self._reconstruction.cameraInit:\n        self._initialIntrinsics = None\n        self._metadata = {}\n    else:\n        self._initialIntrinsics = self._reconstruction.getIntrinsic(self._viewpoint)\n        try:\n            self._metadata = json.loads(self._viewpoint.metadata.value) if self._viewpoint.metadata.value else None\n        except Exception as e:\n            logging.warning(\"Failed to parse Viewpoint metadata: '{}', '{}'\".format(str(e), str(self._viewpoint.metadata.value)))\n            self._metadata = {}\n        if not self._metadata:\n            self._metadata = {}\n    self.initialParamsChanged.emit()",
  "def _updateSfMParams(self):\n    if not self._reconstruction.sfm:\n        self._T = None\n        self._R = None\n        self._solvedIntrinsics = {}\n        self._reconstructed = False\n    else:\n        self._solvedIntrinsics = self._reconstruction.getSolvedIntrinsics(self._viewpoint)\n        (self._R, self._T) = self._reconstruction.getPoseRT(self._viewpoint)\n        self._reconstructed = self._R is not None\n    self.sfmParamsChanged.emit()",
  "def _updateDenseSceneParams(self):\n    if not self._activeNode_PrepareDenseScene.node:\n        self._undistortedImagePath = ''\n    else:\n        filename = '{}.{}'.format(self._viewpoint.viewId.value, self._activeNode_PrepareDenseScene.node.outputFileType.value)\n        self._undistortedImagePath = os.path.join(self._activeNode_PrepareDenseScene.node.output.value, filename)\n    self.denseSceneParamsChanged.emit()",
  "@Property(type='QVariant', notify=initialParamsChanged)\ndef initialIntrinsics(self):\n    return self._initialIntrinsics",
  "@Property(type='QVariant', notify=initialParamsChanged)\ndef metadata(self):\n    return self._metadata",
  "@Property(type=QSizeF, notify=initialParamsChanged)\ndef imageSize(self):\n    if not self._initialIntrinsics:\n        return QSizeF(0, 0)\n    return QSizeF(self._initialIntrinsics.width.value, self._initialIntrinsics.height.value)",
  "@Property(type=int, notify=initialParamsChanged)\ndef orientation(self):\n    return int(self.metadata.get('Orientation', 1))",
  "@Property(type=QSizeF, notify=initialParamsChanged)\ndef orientedImageSize(self):\n    if self.orientation in (6, 8):\n        return QSizeF(self.imageSize.height(), self.imageSize.width())\n    else:\n        return self.imageSize",
  "@Property(type=bool, notify=sfmParamsChanged)\ndef isReconstructed(self):\n    return self._reconstructed",
  "@Property(type='QVariant', notify=sfmParamsChanged)\ndef solvedIntrinsics(self):\n    return self._solvedIntrinsics",
  "@Property(type=QVector3D, notify=sfmParamsChanged)\ndef translation(self):\n    if self._T is None:\n        return None\n    return QVector3D(*self._T)",
  "@Property(type=QQuaternion, notify=sfmParamsChanged)\ndef rotation(self):\n    if self._R is None:\n        return None\n    rot = QMatrix3x3([self._R[0], -self._R[1], -self._R[2], self._R[3], -self._R[4], -self._R[5], self._R[6], -self._R[7], -self._R[8]])\n    return QQuaternion.fromRotationMatrix(rot)",
  "@Property(type=QMatrix4x4, notify=sfmParamsChanged)\ndef pose(self):\n    if self._R is None or self._T is None:\n        return None\n    return QMatrix4x4(self._R[0], -self._R[1], -self._R[2], self._T[0], self._R[3], -self._R[4], -self._R[5], self._T[1], self._R[6], -self._R[7], -self._R[8], self._T[2], 0, 0, 0, 1)",
  "@Property(type=QVector3D, notify=sfmParamsChanged)\ndef upVector(self):\n    if self.orientation == 6:\n        return QVector3D(-1.0, 0.0, 0.0)\n    elif self.orientation == 8:\n        return QVector3D(1.0, 0.0, 0.0)\n    else:\n        return QVector3D(0.0, 1.0, 0.0)",
  "@Property(type=QVector2D, notify=sfmParamsChanged)\ndef uvCenterOffset(self):\n    if not self.solvedIntrinsics:\n        return None\n    pp = self.solvedIntrinsics['principalPoint']\n    offset = QVector2D(float(pp[0]) / self.imageSize.width(), float(pp[1]) / self.imageSize.height())\n    if self.orientation == 6:\n        offset = QVector2D(-offset.y(), offset.x())\n    elif self.orientation == 8:\n        offset = QVector2D(offset.y(), -offset.x())\n    return offset",
  "@Property(type=float, notify=sfmParamsChanged)\ndef fieldOfView(self):\n    if not self.solvedIntrinsics:\n        return None\n    focalLength = self.solvedIntrinsics['focalLength']\n    sensorHeight = self.solvedIntrinsics['sensorHeight']\n    return 2.0 * math.atan(float(sensorHeight) / (2.0 * float(focalLength))) * 180.0 / math.pi",
  "@Property(type=QUrl, notify=denseSceneParamsChanged)\ndef undistortedImageSource(self):\n    return QUrl.fromLocalFile(self._undistortedImagePath)",
  "def __init__(self, nodeType, parent=None):\n    super(ActiveNode, self).__init__(parent)\n    self.nodeType = nodeType\n    self._node = None",
  "def __init__(self, undoStack, taskManager, defaultPipeline='', parent=None):\n    super(Reconstruction, self).__init__(undoStack, taskManager, parent)\n    self._activeNodes = meshroom.common.DictModel(keyAttrName='nodeType')\n    self.initActiveNodes()\n    self._cameraInit = None\n    self._cameraInits = QObjectListModel(parent=self)\n    self._buildingIntrinsics = False\n    self.intrinsicsBuilt.connect(self.onIntrinsicsAvailable)\n    self.cameraInitChanged.connect(self.onCameraInitChanged)\n    self._tempCameraInit = None\n    self.importImagesFailed.connect(self.onImportImagesFailed)\n    self._sfm = None\n    self._views = None\n    self._poses = None\n    self._solvedIntrinsics = None\n    self._selectedViewId = None\n    self._selectedViewpoint = None\n    self._liveSfmManager = LiveSfmManager(self)\n    self.graphChanged.connect(self.onGraphChanged)\n    self.setDefaultPipeline(defaultPipeline)",
  "def clear(self):\n    self.clearActiveNodes()\n    super(Reconstruction, self).clear()",
  "def setDefaultPipeline(self, defaultPipeline):\n    self._defaultPipeline = defaultPipeline",
  "def setSubmitLabel(self, submitLabel):\n    self.submitLabel = submitLabel",
  "def initActiveNodes(self):\n    for (category, _) in self.activeNodeCategories.items():\n        self._activeNodes.add(ActiveNode(category, self))\n    for (nodeType, _) in meshroom.core.nodesDesc.items():\n        self._activeNodes.add(ActiveNode(nodeType, self))",
  "def clearActiveNodes(self):\n    for key in self._activeNodes.keys():\n        self._activeNodes.get(key).node = None",
  "def onCameraInitChanged(self):\n    nodes = self._graph.dfsOnDiscover(startNodes=[self._cameraInit], reverse=True)[0]\n    self.setActiveNodes(nodes)",
  "@Slot()\n@Slot(str)\ndef new(self, pipeline=None):\n    p = pipeline if pipeline != None else self._defaultPipeline\n    ' Create a new pipeline. '\n    loweredPipelineTemplates = dict(((k.lower(), v) for (k, v) in meshroom.core.pipelineTemplates.items()))\n    if p.lower() in loweredPipelineTemplates:\n        self.load(loweredPipelineTemplates[p.lower()], setupProjectFile=False)\n    else:\n        self.load(p, setupProjectFile=False)",
  "@Slot(str, result=bool)\ndef load(self, filepath, setupProjectFile=True):\n    try:\n        status = super(Reconstruction, self).loadGraph(filepath, setupProjectFile)\n        if Version(self._graph.fileReleaseVersion).major == '0':\n            self.warning.emit(Message('Automatic project upgrade', 'This project was created with an older version of Meshroom and has been automatically upgraded.\\nData might have been lost in the process.', 'Open it with the corresponding version of Meshroom to recover your data.'))\n        return status\n    except FileNotFoundError as e:\n        self.error.emit(Message('No Such File', \"Error While Loading '{}': No Such File.\".format(os.path.basename(filepath)), ''))\n        logging.error(\"Error while loading '{}': No Such File.\".format(os.path.basename(filepath)))\n        return False\n    except Exception as e:\n        import traceback\n        trace = traceback.format_exc()\n        self.error.emit(Message('Error While Loading Project File', \"An unexpected error has occurred while loading file: '{}'\".format(os.path.basename(filepath)), trace))\n        logging.error(trace)\n        return False",
  "@Slot(QUrl, result=bool)\ndef loadUrl(self, url):\n    if isinstance(url, QUrl):\n        localFile = url.toLocalFile()\n        if not localFile:\n            localFile = url.toString()\n    else:\n        localFile = url\n    return self.load(localFile)",
  "def onGraphChanged(self):\n    self._liveSfmManager.reset()\n    self.selectedViewId = '-1'\n    self.sfm = None\n    self.tempCameraInit = None\n    self.updateCameraInits()\n    if not self._graph:\n        return\n    self.setSfm(self.lastSfmNode())\n    self._graph.nodes.countChanged.connect(self.updateCameraInits)",
  "@staticmethod\ndef runAsync(func, args=(), kwargs=None):\n    thread = Thread(target=func, args=args, kwargs=kwargs)\n    thread.start()\n    return thread",
  "@Slot(QObject)\ndef getViewpoints(self):\n    if self.tempCameraInit:\n        return self.tempCameraInit.viewpoints.value\n    elif self._cameraInit:\n        return self._cameraInit.viewpoints.value\n    else:\n        return QObjectListModel(parent=self)",
  "def updateCameraInits(self):\n    cameraInits = self._graph.nodesOfType('CameraInit', sortedByIndex=True)\n    if set(self._cameraInits.objectList()) == set(cameraInits):\n        return\n    self._cameraInits.setObjectList(cameraInits)\n    self.cameraInit = cameraInits[0] if cameraInits else None",
  "def getCameraInitIndex(self):\n    if not self._cameraInit:\n        return -1\n    if not self._cameraInit.graph:\n        return -1\n    return self._cameraInits.indexOf(self._cameraInit)",
  "def setCameraInitIndex(self, idx):\n    camInit = self._cameraInits[idx] if self._cameraInits else None\n    self.cameraInit = camInit",
  "@Slot()\ndef clearTempCameraInit(self):\n    self.tempCameraInit = None",
  "@Slot(QObject, str)\ndef setupTempCameraInit(self, node, attrName):\n    if not node or not attrName:\n        self.tempCameraInit = None\n        return\n    sfmFile = node.attribute(attrName).value\n    if not sfmFile or not os.path.isfile(sfmFile):\n        self.tempCameraInit = None\n        return\n    nodeDesc = meshroom.core.nodesDesc['CameraInit']()\n    (views, intrinsics) = nodeDesc.readSfMData(sfmFile)\n    tmpCameraInit = Node('CameraInit', viewpoints=views, intrinsics=intrinsics)\n    self.tempCameraInit = tmpCameraInit",
  "@Slot(QObject, result=QVector3D)\ndef getAutoFisheyeCircle(self, panoramaInit):\n    if not panoramaInit or not panoramaInit.isComputed:\n        return QVector3D(0.0, 0.0, 0.0)\n    if not panoramaInit.attribute('estimateFisheyeCircle').value:\n        return QVector3D(0.0, 0.0, 0.0)\n    sfmFile = panoramaInit.attribute('outSfMData').value\n    if not os.path.exists(sfmFile):\n        return QVector3D(0.0, 0.0, 0.0)\n    with open(sfmFile, 'r', encoding='utf-8', errors='ignore') as f:\n        data = json.load(f)\n    intrinsics = data.get('intrinsics', [])\n    if len(intrinsics) == 0:\n        return QVector3D(0.0, 0.0, 0.0)\n    intrinsic = intrinsics[0]\n    res = QVector3D(float(intrinsic.get('fisheyeCircleCenterX', 0.0)) - float(intrinsic.get('width', 0.0)) * 0.5, float(intrinsic.get('fisheyeCircleCenterY', 0.0)) - float(intrinsic.get('height', 0.0)) * 0.5, float(intrinsic.get('fisheyeCircleRadius', 0.0)))\n    return res",
  "def lastSfmNode(self):\n    return self.lastNodeOfType(self.activeNodeCategories['sfm'], self._cameraInit, Status.SUCCESS)",
  "def lastNodeOfType(self, nodeTypes, startNode, preferredStatus=None):\n    if not startNode:\n        return None\n    nodes = self._graph.dfsOnDiscover(startNodes=[startNode], filterTypes=nodeTypes, reverse=True)[0]\n    if not nodes:\n        return None\n    node = nodes[-1]\n    if preferredStatus:\n        node = next((n for n in reversed(nodes) if n.getGlobalStatus() == preferredStatus), node)\n    return node",
  "def addSfmAugmentation(self, withMVS=False):\n    sfm = self.lastSfmNode()\n    if not sfm:\n        return (None, None)\n    if len(self._cameraInits) == 1:\n        assert self._cameraInit == self._cameraInits[0]\n        if len(self._cameraInits[0].viewpoints) == 0:\n            return (self._cameraInit, sfm)\n    with self.groupedGraphModification('SfM Augmentation', disableUpdates=False):\n        with self.groupedGraphModification('Augmentation', disableUpdates=True):\n            (sfm, mvs) = multiview.sfmAugmentation(self, self.lastSfmNode(), withMVS=withMVS)\n        (first, last) = (sfm[0], mvs[-1] if mvs else sfm[-1])\n        bb = self.layout.boundingBox()\n        self.layout.autoLayout(first, last, bb[0], bb[3] + self._layout.gridSpacing)\n    self.sfmAugmented.emit(first, last)\n    return (sfm[0], sfm[-1])",
  "def allImagePaths(self):\n    return [vp.path.value for node in self._cameraInits for vp in node.viewpoints.value]",
  "def allViewIds(self):\n    return [vp.viewId.value for node in self._cameraInits for vp in node.viewpoints.value]",
  "@Slot(QObject, Node)\ndef handleFilesDrop(self, drop, cameraInit):\n    filesByType = self.getFilesByTypeFromDrop(drop)\n    if filesByType.images:\n        self.importImagesAsync(filesByType.images, cameraInit)\n    if filesByType.videos:\n        boundingBox = self.layout.boundingBox()\n        keyframeNode = self.addNewNode('KeyframeSelection', position=Position(boundingBox[0], boundingBox[1] + boundingBox[3]))\n        keyframeNode.mediaPaths.value = filesByType.videos\n        if len(filesByType.videos) == 1:\n            newVideoNodeMessage = \"New node '{}' added for the input video.\".format(keyframeNode.getLabel())\n        else:\n            newVideoNodeMessage = \"New node '{}' added for a rig of {} synchronized cameras.\".format(keyframeNode.getLabel(), len(filesByType.videos))\n        self.info.emit(Message('Video Input', newVideoNodeMessage, 'Warning: You need to manually compute the KeyframeSelection node \\nand then reimport the created images into Meshroom for the reconstruction.\\n\\nIf you know the Camera Make/Model, it is highly recommended to declare them in the Node.'))\n    if filesByType.panoramaInfo:\n        if len(filesByType.panoramaInfo) > 1:\n            self.error.emit(Message('Multiple XML files in input', \"Ignore the xml Panorama files:\\n\\n'{}'.\".format(',\\n'.join(filesByType.panoramaInfo)), ''))\n        else:\n            panoramaInitNodes = self.graph.nodesOfType('PanoramaInit')\n            for panoramaInfoFile in filesByType.panoramaInfo:\n                for panoramaInitNode in panoramaInitNodes:\n                    panoramaInitNode.attribute('initializeCameras').value = 'File'\n                    panoramaInitNode.attribute('config').value = panoramaInfoFile\n            if panoramaInitNodes:\n                self.info.emit(Message('Panorama XML', 'XML file declared on PanoramaInit node', \"XML file '{}' set on node '{}'\".format(','.join(filesByType.panoramaInfo), ','.join([n.getLabel() for n in panoramaInitNodes]))))\n            else:\n                self.error.emit(Message('No PanoramaInit Node', \"No PanoramaInit Node to set the Panorama file:\\n'{}'.\".format(','.join(filesByType.panoramaInfo)), ''))\n    if not filesByType.images and (not filesByType.videos) and (not filesByType.panoramaInfo):\n        if filesByType.other:\n            extensions = set([os.path.splitext(url)[1] for url in filesByType.other])\n            self.error.emit(Message('No Recognized Input File', 'No recognized input file in the {} dropped files'.format(len(filesByType.other)), 'Unknown file extensions: ' + ', '.join(extensions)))",
  "@staticmethod\ndef getFilesByTypeFromDrop(drop):\n    urls = drop.property('urls')\n    filesByType = multiview.FilesByType()\n    for url in urls:\n        localFile = url.toLocalFile()\n        if os.path.isdir(localFile):\n            filesByType.extend(multiview.findFilesByTypeInFolder(localFile))\n        else:\n            filesByType.addFile(localFile)\n    return filesByType",
  "def importImagesFromFolder(self, path, recursive=False):\n    logging.debug('importImagesFromFolder: ' + str(path))\n    filesByType = multiview.findFilesByTypeInFolder(path, recursive)\n    if filesByType.images:\n        self.buildIntrinsics(self.cameraInit, filesByType.images)",
  "@Slot('QVariant')\ndef importImagesUrls(self, imagePaths, recursive=False):\n    paths = []\n    for imagePath in imagePaths:\n        if isinstance(imagePath, QUrl):\n            p = imagePath.toLocalFile()\n            if not p:\n                p = imagePath.toString()\n        else:\n            p = imagePath\n        paths.append(p)\n    self.importImagesFromFolder(paths)",
  "def importImagesAsync(self, images, cameraInit):\n    logging.debug('Import images: ' + str(images))\n    self.runAsync(self.importImagesSync, args=(images, cameraInit))",
  "def importImagesSync(self, images, cameraInit):\n    try:\n        self.buildIntrinsics(cameraInit, images)\n    except Exception as e:\n        self.importImagesFailed.emit(str(e))",
  "@Slot()\ndef onImportImagesFailed(self, msg):\n    self.error.emit(Message('Failed to Import Images', 'You probably have a corrupted image within the images that you are trying to import.', ''))",
  "def buildIntrinsics(self, cameraInit, additionalViews, rebuild=False):\n    views = []\n    intrinsics = []\n    inputs = cameraInit.toDict()['inputs'] if cameraInit else {}\n    cameraInitCopy = Node('CameraInit', **inputs)\n    if rebuild:\n        for vp in cameraInitCopy.viewpoints.value:\n            vp.intrinsicId.resetValue()\n            vp.metadata.resetValue()\n        cameraInitCopy.intrinsics.resetValue()\n    try:\n        self.setBuildingIntrinsics(True)\n        (views, intrinsics) = cameraInitCopy.nodeDesc.buildIntrinsics(cameraInitCopy, additionalViews)\n    except Exception as e:\n        logging.error('Error while building intrinsics: {}'.format(str(e)))\n        raise\n    finally:\n        cameraInitCopy.deleteLater()\n        self.setBuildingIntrinsics(False)\n    self.intrinsicsBuilt.emit(cameraInit, views, intrinsics, rebuild)",
  "@Slot(Node)\ndef rebuildIntrinsics(self, cameraInit):\n    self.runAsync(self.buildIntrinsics, args=(cameraInit, (), True))",
  "def onIntrinsicsAvailable(self, cameraInit, views, intrinsics, rebuild=False):\n    augmentSfM = cameraInit is None\n    commandTitle = 'Add {} Images'\n    if augmentSfM:\n        allViewIds = self.allViewIds()\n        views = [view for view in views if int(view['viewId']) not in allViewIds]\n        commandTitle = 'Augment Reconstruction ({} Images)'\n    if rebuild:\n        commandTitle = \"Rebuild '{}' Intrinsics\".format(cameraInit.label)\n    if not views:\n        return\n    commandTitle = commandTitle.format(len(views))\n    with self.groupedGraphModification(commandTitle, disableUpdates=False):\n        if augmentSfM:\n            (cameraInit, self.sfm) = self.addSfmAugmentation(withMVS=True)\n        with self.groupedGraphModification('Set Views and Intrinsics'):\n            self.setAttribute(cameraInit.viewpoints, views)\n            self.setAttribute(cameraInit.intrinsics, intrinsics)\n    self.cameraInit = cameraInit",
  "def setBuildingIntrinsics(self, value):\n    if self._buildingIntrinsics == value:\n        return\n    self._buildingIntrinsics = value\n    self.buildingIntrinsicsChanged.emit()",
  "@Slot(QObject)\ndef setActiveNode(self, node):\n    for (category, nodeTypes) in self.activeNodeCategories.items():\n        if node.nodeType in nodeTypes:\n            self.activeNodes.get(category).node = node\n            if category == 'sfm':\n                self.setSfm(node)\n            if node.nodeType == 'CameraInit':\n                self.setCameraInitIndex(self._cameraInits.indexOf(node))\n    self.activeNodes.get(node.nodeType).node = node",
  "@Slot(QObject)\ndef setActiveNodes(self, nodes):\n    nodesByCategory = {}\n    for node in nodes:\n        if node is None:\n            continue\n        for (category, nodeTypes) in self.activeNodeCategories.items():\n            if node.nodeType in nodeTypes:\n                nodesByCategory[category] = node\n    for (category, node) in nodesByCategory.items():\n        self.activeNodes.get(category).node = node\n        if category == 'sfm':\n            self.setSfm(node)\n    for node in nodes:\n        if node is None:\n            continue\n        if not isinstance(node, CompatibilityNode):\n            self.activeNodes.get(node.nodeType).node = node",
  "def updateSfMResults(self):\n    if not self._sfm or 'outputViewsAndPoses' not in self._sfm.getAttributes().keys():\n        self._views = dict()\n        self._poses = dict()\n        self._solvedIntrinsics = dict()\n    else:\n        (self._views, self._poses, self._solvedIntrinsics) = parseSfMJsonFile(self._sfm.outputViewsAndPoses.value)\n    self.sfmReportChanged.emit()",
  "def getSfm(self):\n    return self._sfm",
  "def _unsetSfm(self):\n    self._setSfm(None)",
  "def _setSfm(self, node):\n    self._sfm = node\n    self.updateSfMResults()\n    if self._sfm:\n        self._sfm.destroyed.connect(self._unsetSfm)\n        self._sfm.chunks[0].statusChanged.connect(self.updateSfMResults)\n    self.sfmChanged.emit()",
  "def setSfm(self, node):\n    if self._sfm:\n        self._sfm.chunks[0].statusChanged.disconnect(self.updateSfMResults)\n        self._sfm.destroyed.disconnect(self._unsetSfm)\n    self._setSfm(node)",
  "@Slot(QObject, result=bool)\ndef isInViews(self, viewpoint):\n    if not viewpoint:\n        return False\n    return str(viewpoint.viewId.value) in self._views",
  "@Slot(QObject, result=bool)\ndef isReconstructed(self, viewpoint):\n    if not viewpoint:\n        return False\n    view = self._views.get(str(viewpoint.poseId.value), None)\n    return view.get('poseId', -1) in self._poses if view else False",
  "@Slot(QObject, result=bool)\ndef hasValidIntrinsic(self, viewpoint):\n    allIntrinsicIds = [i.intrinsicId.value for i in self._cameraInit.intrinsics.value]\n    return viewpoint.intrinsicId.value in allIntrinsicIds",
  "@Slot(QObject, result=QObject)\ndef getIntrinsic(self, viewpoint):\n    if not viewpoint:\n        return None\n    return next((i for i in self._cameraInit.intrinsics.value if i.intrinsicId.value == viewpoint.intrinsicId.value), None)",
  "@Slot(QObject, result=bool)\ndef hasMetadata(self, viewpoint):\n    return len(viewpoint.metadata.value) > 2",
  "def setSelectedViewId(self, viewId):\n    if viewId == self._selectedViewId:\n        return\n    self._selectedViewId = viewId\n    vp = None\n    if self.viewpoints:\n        vp = next((v for v in self.viewpoints if str(v.viewId.value) == self._selectedViewId), None)\n    self._setSelectedViewpoint(vp)\n    self.selectedViewIdChanged.emit()",
  "def _setSelectedViewpoint(self, viewpointAttribute):\n    if self._selectedViewpoint:\n        self._selectedViewpoint.deleteLater()\n    self._selectedViewpoint = ViewpointWrapper(viewpointAttribute, self) if viewpointAttribute else None",
  "def reconstructedCamerasCount(self):\n    viewpoints = self.getViewpoints()\n    if not isinstance(viewpoints, Iterable):\n        return 0\n    return len([v for v in viewpoints if self.isReconstructed(v)])",
  "@Slot(QObject, result='QVariant')\ndef getSolvedIntrinsics(self, viewpoint):\n    if not viewpoint:\n        return None\n    return self._solvedIntrinsics.get(str(viewpoint.intrinsicId.value), None)",
  "def getPoseRT(self, viewpoint):\n    if not viewpoint:\n        return (None, None)\n    view = self._views.get(str(viewpoint.viewId.value), None)\n    if not view:\n        return (None, None)\n    pose = self._poses.get(view.get('poseId', -1), None)\n    if not pose:\n        return (None, None)\n    pose = pose['transform']\n    R = [float(i) for i in pose['rotation']]\n    T = [float(i) for i in pose['center']]\n    return (R, T)",
  "def __init__(self, parent=None):\n    super(FilesModTimePollerThread, self).__init__(parent)\n    self._thread = None\n    self._mutex = Lock()\n    self._threadPool = ThreadPool(4)\n    self._stopFlag = Event()\n    self._refreshInterval = 5\n    self._files = []",
  "def start(self, files=None):\n    if self._thread:\n        return\n    self._stopFlag.clear()\n    self._files = files or []\n    self._thread = Thread(target=self.run)\n    self._thread.start()",
  "def setFiles(self, files):\n    with self._mutex:\n        self._files = files",
  "def stop(self):\n    if not self._thread:\n        return\n    self._stopFlag.set()\n    self._thread.join()\n    self._thread = None",
  "@staticmethod\ndef getFileLastModTime(f):\n    try:\n        return os.path.getmtime(f)\n    except OSError:\n        return -1",
  "def run(self):\n    while not self._stopFlag.wait(self._refreshInterval):\n        with self._mutex:\n            files = list(self._files)\n        times = self._threadPool.map(FilesModTimePollerThread.getFileLastModTime, files)\n        with self._mutex:\n            if files == self._files:\n                self.timesAvailable.emit(times)",
  "def __init__(self, chunks=(), parent=None):\n    super(ChunksMonitor, self).__init__(parent)\n    self.chunks = []\n    self._filesTimePoller = FilesModTimePollerThread(parent=self)\n    self._filesTimePoller.timesAvailable.connect(self.compareFilesTimes)\n    self._filesTimePoller.start()\n    self.setChunks(chunks)",
  "def setChunks(self, chunks):\n    self.chunks = chunks\n    self._filesTimePoller.setFiles(self.statusFiles)",
  "def stop(self):\n    self._filesTimePoller.stop()",
  "@property\ndef statusFiles(self):\n    return [c.statusFile for c in self.chunks]",
  "def compareFilesTimes(self, times):\n    newRecords = dict(zip(self.chunks, times))\n    for (chunk, fileModTime) in newRecords.items():\n        if fileModTime != chunk.statusFileLastModTime:\n            chunk.updateStatusFromCache()",
  "def __init__(self, graph):\n    super(GraphLayout, self).__init__(graph)\n    self.graph = graph\n    self._depthMode = GraphLayout.DepthMode.MaxDepth\n    self._nodeWidth = 160\n    self._nodeHeight = 120\n    self._gridSpacing = 40",
  "@Slot(Node, Node, int, int)\ndef autoLayout(self, fromNode=None, toNode=None, startX=0, startY=0):\n    fromIndex = self.graph.nodes.indexOf(fromNode) if fromNode else 0\n    toIndex = self.graph.nodes.indexOf(toNode) if toNode else self.graph.nodes.count - 1\n\n    def getDepth(n):\n        return getattr(n, self._depthAttribute[self._depthMode])\n    maxDepth = max([getDepth(n) for n in self.graph.nodes.values()])\n    grid = [[] for _ in range(maxDepth + 1)]\n    zeroDepth = getDepth(self.graph.nodes.at(fromIndex)) if fromIndex > 0 else 0\n    for i in range(fromIndex, toIndex + 1):\n        n = self.graph.nodes.at(i)\n        grid[getDepth(n) - zeroDepth].append(n)\n    with self.graph.groupedGraphModification('Graph Auto-Layout'):\n        for (x, line) in enumerate(grid):\n            for (y, node) in enumerate(line):\n                px = startX + x * (self._nodeWidth + self._gridSpacing)\n                py = startY + y * (self._nodeHeight + self._gridSpacing)\n                self.graph.moveNode(node, Position(px, py))",
  "@Slot()\ndef reset(self):\n    self.autoLayout()",
  "def positionBoundingBox(self, nodes=None):\n    if nodes is None:\n        nodes = self.graph.nodes.values()\n    first = nodes[0]\n    bbox = [first.x, first.y, first.x, first.y]\n    for n in nodes:\n        bbox[0] = min(bbox[0], n.x)\n        bbox[1] = min(bbox[1], n.y)\n        bbox[2] = max(bbox[2], n.x)\n        bbox[3] = max(bbox[3], n.y)\n    bbox[2] -= bbox[0]\n    bbox[3] -= bbox[1]\n    return bbox",
  "def boundingBox(self, nodes=None):\n    bbox = self.positionBoundingBox(nodes)\n    bbox[2] += self._nodeWidth\n    bbox[3] += self._nodeHeight\n    return bbox",
  "def setDepthMode(self, mode):\n    if isinstance(mode, int):\n        mode = GraphLayout.DepthMode(mode)\n    if self._depthMode.value == mode.value:\n        return\n    self._depthMode = mode",
  "def __init__(self, undoStack, taskManager, parent=None):\n    super(UIGraph, self).__init__(parent)\n    self._undoStack = undoStack\n    self._taskManager = taskManager\n    self._graph = Graph('', self)\n    self._modificationCount = 0\n    self._chunksMonitor = ChunksMonitor(parent=self)\n    self._computeThread = Thread()\n    self._computingLocally = self._submitted = False\n    self._sortedDFSChunks = QObjectListModel(parent=self)\n    self._layout = GraphLayout(self)\n    self._selectedNode = None\n    self._selectedNodes = QObjectListModel(parent=self)\n    self._hoveredNode = None\n    self.submitLabel = '{projectName}'\n    self.computeStatusChanged.connect(self.updateLockedUndoStack)",
  "def setGraph(self, g):\n    if self._graph:\n        self.stopExecution()\n        if self._computingLocally:\n            self._graph.clearLocallySubmittedNodes()\n        self.clear()\n    oldGraph = self._graph\n    self._graph = g\n    if oldGraph:\n        oldGraph.deleteLater()\n    self._graph.updated.connect(self.onGraphUpdated)\n    self._graph.update()\n    self._taskManager.update(self._graph)\n    if Graph.IO.Features.NodesPositions not in self._graph.fileFeatures:\n        self._layout.reset()\n        self._undoStack.clear()\n    else:\n        bbox = self._layout.positionBoundingBox()\n        if bbox[2] == 0 and bbox[3] == 0:\n            self._layout.reset()\n            self._undoStack.clear()\n    self.graphChanged.emit()",
  "def onGraphUpdated(self):\n    self.updateChunks()",
  "def updateChunks(self):\n    dfsNodes = self._graph.dfsOnFinish(None)[0]\n    chunks = self._graph.getChunks(dfsNodes)\n    if self._sortedDFSChunks.objectList() == chunks:\n        return\n    for chunk in self._sortedDFSChunks:\n        chunk.statusChanged.disconnect(self.updateGraphComputingStatus)\n    self._sortedDFSChunks.setObjectList(chunks)\n    for chunk in self._sortedDFSChunks:\n        chunk.statusChanged.connect(self.updateGraphComputingStatus)\n    self.updateChunkMonitor(self._sortedDFSChunks)\n    self.updateGraphComputingStatus()",
  "def updateChunkMonitor(self, chunks):\n    self._chunksMonitor.setChunks(chunks)",
  "def clear(self):\n    if self._graph:\n        self.clearNodeHover()\n        self.clearNodeSelection()\n        self._taskManager.clear()\n        self._graph.clear()\n    self._sortedDFSChunks.clear()\n    self._undoStack.clear()",
  "def stopChildThreads(self):\n    self.stopExecution()\n    self._chunksMonitor.stop()",
  "@Slot(str, result=bool)\ndef loadGraph(self, filepath, setupProjectFile=True):\n    g = Graph('')\n    status = g.load(filepath, setupProjectFile)\n    if not os.path.exists(g.cacheDir):\n        os.mkdir(g.cacheDir)\n    self.setGraph(g)\n    return status",
  "@Slot(QUrl, result='QVariantList')\n@Slot(QUrl, QPoint, result='QVariantList')\ndef importProject(self, filepath, position=None):\n    if isinstance(filepath, QUrl):\n        localFile = filepath.toLocalFile()\n        if not localFile:\n            localFile = filepath.toString()\n    else:\n        localFile = filepath\n    if isinstance(position, QPoint):\n        position = Position(position.x(), position.y())\n    yOffset = self.layout.gridSpacing + self.layout.nodeHeight\n    return self.push(commands.ImportProjectCommand(self._graph, localFile, position=position, yOffset=yOffset))",
  "@Slot(QUrl)\ndef saveAs(self, url):\n    self._saveAs(url)",
  "@Slot(QUrl)\ndef saveAsTemplate(self, url):\n    self._saveAs(url, setupProjectFile=False, template=True)",
  "def _saveAs(self, url, setupProjectFile=True, template=False):\n    if isinstance(url, str):\n        localFile = url\n    else:\n        localFile = url.toLocalFile()\n    if os.path.splitext(localFile)[-1] != '.mg':\n        localFile += '.mg'\n    self._graph.save(localFile, setupProjectFile=setupProjectFile, template=template)\n    self._undoStack.setClean()\n    self.updateChunkMonitor(self._sortedDFSChunks)",
  "@Slot()\ndef save(self):\n    self._graph.save()\n    self._undoStack.setClean()",
  "@Slot()\ndef updateLockedUndoStack(self):\n    if self.isComputingLocally():\n        self._undoStack.lockAtThisIndex()\n    else:\n        self._undoStack.unlock()",
  "@Slot(Node)\ndef execute(self, node=None):\n    nodes = [node] if node else None\n    self._taskManager.compute(self._graph, nodes)\n    self.updateLockedUndoStack()",
  "@Slot()\ndef stopExecution(self):\n    if not self.isComputingLocally():\n        return\n    self._taskManager.requestBlockRestart()\n    self._graph.stopExecution()\n    self._taskManager._thread.join()",
  "@Slot(Node)\ndef stopNodeComputation(self, node):\n    if not self.isComputingLocally():\n        return\n    node.stopComputation()\n    self._taskManager._thread.join()",
  "@Slot(Node)\ndef cancelNodeComputation(self, node):\n    if node.getGlobalStatus() == Status.SUBMITTED:\n        node.clearSubmittedChunks()\n        self._taskManager.removeNode(node, displayList=True, processList=True)\n        for n in node.getOutputNodes(recursive=True, dependenciesOnly=True):\n            n.clearSubmittedChunks()\n            self._taskManager.removeNode(n, displayList=True, processList=True)",
  "@Slot(Node)\ndef submit(self, node=None):\n    self.save()\n    self._undoStack.clear()\n    node = [node] if node else None\n    self._taskManager.submit(self._graph, os.environ.get('MESHROOM_DEFAULT_SUBMITTER', ''), node, submitLabel=self.submitLabel)",
  "def updateGraphComputingStatus(self):\n    computingLocally = any([ch.status.execMode == ExecMode.LOCAL and ch.status.sessionUid == sessionUid and (ch.status.status in (Status.RUNNING, Status.SUBMITTED)) for ch in self._sortedDFSChunks])\n    submitted = any([ch.status.status == Status.SUBMITTED for ch in self._sortedDFSChunks])\n    if self._computingLocally != computingLocally or self._submitted != submitted:\n        self._computingLocally = computingLocally\n        self._submitted = submitted\n        self.computeStatusChanged.emit()",
  "def isComputing(self):\n    return self.isComputingLocally() or self.isComputingExternally()",
  "def isComputingExternally(self):\n    return self._submitted",
  "def isComputingLocally(self):\n    return self._computingLocally",
  "def push(self, command):\n    return self._undoStack.tryAndPush(command)",
  "def groupedGraphModification(self, title, disableUpdates=True):\n    return commands.GroupedGraphModification(self._graph, self._undoStack, title, disableUpdates)",
  "@Slot(str)\ndef beginModification(self, name):\n    self._modificationCount += 1\n    self._undoStack.beginMacro(name)",
  "@Slot()\ndef endModification(self):\n    assert self._modificationCount > 0\n    self._modificationCount -= 1\n    self._undoStack.endMacro()",
  "@Slot(str, QPoint, result=QObject)\ndef addNewNode(self, nodeType, position=None, **kwargs):\n    if isinstance(position, QPoint):\n        position = Position(position.x(), position.y())\n    return self.push(commands.AddNodeCommand(self._graph, nodeType, position=position, **kwargs))",
  "def filterNodes(self, nodes):\n    return [n for n in nodes if n in self._graph.nodes.values()]",
  "@Slot(Node, QPoint, QObject)\ndef moveNode(self, node, position, nodes=None):\n    if not nodes:\n        nodes = [node]\n    nodes = self.filterNodes(nodes)\n    if isinstance(position, QPoint):\n        position = Position(position.x(), position.y())\n    deltaX = position.x - node.x\n    deltaY = position.y - node.y\n    with self.groupedGraphModification('Move Selected Nodes'):\n        for n in nodes:\n            position = Position(n.x + deltaX, n.y + deltaY)\n            self.push(commands.MoveNodeCommand(self._graph, n, position))",
  "@Slot(QObject)\ndef removeNodes(self, nodes):\n    nodes = self.filterNodes(nodes)\n    if any([n.locked for n in nodes]):\n        return\n    with self.groupedGraphModification('Remove Selected Nodes'):\n        for node in nodes:\n            self.push(commands.RemoveNodeCommand(self._graph, node))",
  "@Slot(QObject)\ndef removeNodesFrom(self, nodes):\n    with self.groupedGraphModification('Remove Nodes From Selected Nodes'):\n        (nodesToRemove, _) = self._graph.dfsOnDiscover(startNodes=nodes, reverse=True, dependenciesOnly=True)\n        uniqueNodesToRemove = list(dict.fromkeys(nodesToRemove))\n        self.removeNodes(list(reversed(uniqueNodesToRemove)))",
  "@Slot(QObject, result='QVariantList')\ndef duplicateNodes(self, nodes):\n    nodes = self.filterNodes(nodes)\n    nPositions = []\n    with self.groupedGraphModification('Duplicate Selected Nodes', disableUpdates=False):\n        with self.groupedGraphModification('Node duplication', disableUpdates=True):\n            duplicates = self.push(commands.DuplicateNodesCommand(self._graph, nodes))\n        bbox = self._layout.boundingBox(duplicates)\n        for n in duplicates:\n            idx = duplicates.index(n)\n            yPos = n.y + self.layout.gridSpacing + bbox[3]\n            if idx > 0 and (n.x, yPos) in nPositions:\n                while (n.x, yPos) in nPositions:\n                    yPos = yPos + self.layout.gridSpacing + self.layout.nodeHeight\n                self.moveNode(n, Position(n.x, yPos))\n            else:\n                self.moveNode(n, Position(n.x, bbox[3] + self.layout.gridSpacing + n.y))\n            nPositions.append((n.x, n.y))\n    return duplicates",
  "@Slot(QObject, result='QVariantList')\ndef duplicateNodesFrom(self, nodes):\n    with self.groupedGraphModification('Duplicate Nodes From Selected Nodes'):\n        (nodesToDuplicate, _) = self._graph.dfsOnDiscover(startNodes=nodes, reverse=True, dependenciesOnly=True)\n        uniqueNodesToDuplicate = list(dict.fromkeys(nodesToDuplicate))\n        duplicates = self.duplicateNodes(uniqueNodesToDuplicate)\n    return duplicates",
  "@Slot(QObject)\ndef clearData(self, nodes):\n    nodes = self.filterNodes(nodes)\n    for n in nodes:\n        n.clearData()",
  "@Slot(QObject)\ndef clearDataFrom(self, nodes):\n    self.clearData(self._graph.dfsOnDiscover(startNodes=nodes, reverse=True, dependenciesOnly=True)[0])",
  "@Slot(Attribute, Attribute)\ndef addEdge(self, src, dst):\n    if isinstance(dst, ListAttribute) and (not isinstance(src, ListAttribute)):\n        with self.groupedGraphModification('Insert and Add Edge on {}'.format(dst.getFullNameToNode())):\n            self.appendAttribute(dst)\n            self._addEdge(src, dst.at(-1))\n    else:\n        self._addEdge(src, dst)",
  "def _addEdge(self, src, dst):\n    with self.groupedGraphModification(\"Connect '{}'->'{}'\".format(src.getFullNameToNode(), dst.getFullNameToNode())):\n        if dst in self._graph.edges.keys():\n            self.removeEdge(self._graph.edge(dst))\n        self.push(commands.AddEdgeCommand(self._graph, src, dst))",
  "@Slot(Edge)\ndef removeEdge(self, edge):\n    if isinstance(edge.dst.root, ListAttribute):\n        with self.groupedGraphModification('Remove Edge and Delete {}'.format(edge.dst.getFullNameToNode())):\n            self.push(commands.RemoveEdgeCommand(self._graph, edge))\n            self.removeAttribute(edge.dst)\n    else:\n        self.push(commands.RemoveEdgeCommand(self._graph, edge))",
  "@Slot(Attribute, 'QVariant')\ndef setAttribute(self, attribute, value):\n    self.push(commands.SetAttributeCommand(self._graph, attribute, value))",
  "@Slot(Attribute)\ndef resetAttribute(self, attribute):\n    self.push(commands.SetAttributeCommand(self._graph, attribute, attribute.defaultValue()))",
  "@Slot(CompatibilityNode, result=Node)\ndef upgradeNode(self, node):\n    return self.push(commands.UpgradeNodeCommand(self._graph, node))",
  "@Slot()\ndef upgradeAllNodes(self):\n    with self.groupedGraphModification('Upgrade all Nodes'):\n        nodes = [n for n in self._graph._compatibilityNodes.values() if n.canUpgrade]\n        for node in nodes:\n            self.upgradeNode(node)",
  "@Slot()\ndef forceNodesStatusUpdate(self):\n    self._graph.updateStatusFromCache(force=True)",
  "@Slot(Attribute, QJsonValue)\ndef appendAttribute(self, attribute, value=QJsonValue()):\n    if isinstance(value, QJsonValue):\n        if value.isArray():\n            pyValue = value.toArray().toVariantList()\n        else:\n            pyValue = None if value.isNull() else value.toObject()\n    else:\n        pyValue = value\n    self.push(commands.ListAttributeAppendCommand(self._graph, attribute, pyValue))",
  "@Slot(Attribute)\ndef removeAttribute(self, attribute):\n    self.push(commands.ListAttributeRemoveCommand(self._graph, attribute))",
  "@Slot(Node)\ndef appendSelection(self, node):\n    if not self._selectedNodes.contains(node):\n        self._selectedNodes.append(node)",
  "@Slot('QVariantList')\ndef selectNodes(self, nodes):\n    for node in nodes:\n        self.appendSelection(node)\n    self.selectedNodesChanged.emit()",
  "@Slot(Node)\ndef selectFollowing(self, node):\n    self.selectNodes(self._graph.dfsOnDiscover(startNodes=[node], reverse=True, dependenciesOnly=True)[0])",
  "@Slot(QObject, QObject)\ndef boxSelect(self, selection, draggable):\n    x = selection.x() - draggable.x()\n    y = selection.y() - draggable.y()\n    otherX = x + selection.width()\n    otherY = y + selection.height()\n    (x, y, otherX, otherY) = [i / draggable.scale() for i in [x, y, otherX, otherY]]\n    if x == otherX or y == otherY:\n        return\n    for n in self._graph.nodes:\n        bbox = self._layout.boundingBox([n])\n        if not (x > bbox[2] + bbox[0] or otherX < bbox[0] or y > bbox[3] + bbox[1] or (otherY < bbox[1])):\n            self.appendSelection(n)\n    self.selectedNodesChanged.emit()",
  "@Slot()\ndef clearNodeSelection(self):\n    self._selectedNode = None\n    self._selectedNodes.clear()\n    self.selectedNodeChanged.emit()\n    self.selectedNodesChanged.emit()",
  "def clearNodeHover(self):\n    self.hoveredNode = None",
  "@Slot(result=str)\ndef getSelectedNodesContent(self):\n    if self._selectedNodes:\n        d = self._graph.toDict()\n        selection = {}\n        for node in self._selectedNodes:\n            selection[node.name] = d[node.name]\n        return json.dumps(selection, indent=4)\n    return ''",
  "@Slot(str, QPoint, bool, result='QVariantList')\ndef pasteNodes(self, clipboardContent, position=None, centerPosition=False):\n    if not clipboardContent:\n        return\n    try:\n        d = json.loads(clipboardContent)\n    except ValueError as e:\n        raise ValueError(e)\n    if not isinstance(d, dict):\n        raise ValueError('The clipboard does not contain a valid node. Cannot paste it.')\n    if d.get('header', None):\n        d = d.get('graph', None)\n        if not d:\n            return\n    if isinstance(position, QPoint):\n        position = Position(position.x(), position.y())\n    if self.hoveredNode:\n        position = Position(position.x + self.layout.gridSpacing, position.y + self.layout.gridSpacing)\n    firstNodePos = None\n    minX = 0\n    maxX = 0\n    minY = 0\n    maxY = 0\n    for key in sorted(d):\n        nodeType = d[key].get('nodeType', None)\n        if not nodeType:\n            raise ValueError(\"Invalid node description: no provided node type for '{}'\".format(key))\n        pos = d[key].get('position', None)\n        if pos:\n            if not firstNodePos:\n                firstNodePos = pos\n                minX = pos[0]\n                maxX = pos[0]\n                minY = pos[1]\n                maxY = pos[1]\n            else:\n                if minX > pos[0]:\n                    minX = pos[0]\n                if maxX < pos[0]:\n                    maxX = pos[0]\n                if minY > pos[1]:\n                    minY = pos[1]\n                if maxY < pos[1]:\n                    maxY = pos[1]\n    if not firstNodePos:\n        firstNodePos = [0, 0]\n    position = Position(position.x + firstNodePos[0] - minX, position.y + firstNodePos[1] - minY)\n    if centerPosition:\n        maxX = maxX + self.layout.nodeWidth\n        maxY = maxY + self.layout.nodeHeight\n        position = Position(position.x - (maxX - minX) / 2, position.y - (maxY - minY) / 2)\n    finalPosition = None\n    prevPosition = None\n    positions = []\n    for key in sorted(d):\n        currentPosition = d[key].get('position', None)\n        if not finalPosition:\n            finalPosition = position\n        elif prevPosition and currentPosition:\n            x = finalPosition.x + (currentPosition[0] - prevPosition[0])\n            y = finalPosition.y + (currentPosition[1] - prevPosition[1])\n            finalPosition = Position(x, y)\n        else:\n            finalPosition = Position(finalPosition.x + self.layout.gridSpacing + self.layout.nodeWidth, finalPosition.y)\n        prevPosition = currentPosition\n        positions.append(finalPosition)\n    return self.push(commands.PasteNodesCommand(self.graph, d, position=positions))",
  "def getDepth(n):\n    return getattr(n, self._depthAttribute[self._depthMode])",
  "def __init__(self, qmlEngine, parent=None):\n    super(PaletteManager, self).__init__(parent)\n    self.qmlEngine = qmlEngine\n    darkPalette = QPalette()\n    window = QColor(50, 52, 55)\n    text = QColor(200, 200, 200)\n    disabledText = text.darker(170)\n    base = window.darker(150)\n    button = window.lighter(115)\n    highlight = QColor(42, 130, 218)\n    dark = window.darker(170)\n    darkPalette.setColor(QPalette.Window, window)\n    darkPalette.setColor(QPalette.WindowText, text)\n    darkPalette.setColor(QPalette.Disabled, QPalette.WindowText, disabledText)\n    darkPalette.setColor(QPalette.Base, base)\n    darkPalette.setColor(QPalette.AlternateBase, QColor(46, 47, 48))\n    darkPalette.setColor(QPalette.ToolTipBase, base)\n    darkPalette.setColor(QPalette.ToolTipText, text)\n    darkPalette.setColor(QPalette.Text, text)\n    darkPalette.setColor(QPalette.Disabled, QPalette.Text, disabledText)\n    darkPalette.setColor(QPalette.Button, button)\n    darkPalette.setColor(QPalette.ButtonText, text)\n    darkPalette.setColor(QPalette.Disabled, QPalette.ButtonText, disabledText)\n    darkPalette.setColor(QPalette.Mid, button.lighter(120))\n    darkPalette.setColor(QPalette.Highlight, highlight)\n    darkPalette.setColor(QPalette.Disabled, QPalette.Highlight, QColor(80, 80, 80))\n    darkPalette.setColor(QPalette.HighlightedText, Qt.white)\n    darkPalette.setColor(QPalette.Disabled, QPalette.HighlightedText, QColor(127, 127, 127))\n    darkPalette.setColor(QPalette.Shadow, Qt.black)\n    darkPalette.setColor(QPalette.Link, highlight.lighter(130))\n    self.darkPalette = darkPalette\n    self.defaultPalette = QApplication.instance().palette()\n    self.togglePalette()",
  "@Slot()\ndef togglePalette(self):\n    app = QApplication.instance()\n    if app.palette() == self.darkPalette:\n        app.setPalette(self.defaultPalette)\n    else:\n        app.setPalette(self.darkPalette)\n    if self.qmlEngine.rootObjects():\n        self.qmlEngine.reload()\n    self.paletteChanged.emit()",
  "def makeProperty(T, attributeName, notify=None, resetOnDestroy=False):\n\n    def setter(instance, value):\n        currentValue = getattr(instance, attributeName)\n        if currentValue == value:\n            return\n        resetCallbackName = '__reset__' + attributeName\n        if resetOnDestroy and (not hasattr(instance, resetCallbackName)):\n            setattr(instance, resetCallbackName, lambda self=instance, *args: setter(self, None))\n        resetCallback = getattr(instance, resetCallbackName, None)\n        if resetCallback and currentValue and shiboken2.isValid(currentValue):\n            currentValue.destroyed.disconnect(resetCallback)\n        setattr(instance, attributeName, value)\n        if resetCallback and value:\n            value.destroyed.connect(resetCallback)\n        getattr(instance, signalName(notify)).emit()\n\n    def getter(instance):\n        return getattr(instance, attributeName)\n\n    def signalName(signalInstance):\n        return str(signalInstance)[:-2]\n    if resetOnDestroy and (not issubclass(T, QObject)):\n        raise RuntimeError('destroyCallback can only be used with QObject-type properties.')\n    if notify:\n        return Property(T, getter, setter, notify=notify)\n    else:\n        return Property(T, getter, constant=True)",
  "def __init__(self, sourceFile='', watching=True, verbose=False, parent=None):\n    super(QmlInstantEngine, self).__init__(parent)\n    self._fileWatcher = QFileSystemWatcher()\n    self._sourceFile = ''\n    self._watchedFiles = []\n    self._verbose = verbose\n    self._watching = False\n    self._extensions = ['qml', 'js']\n    self._rootItem = None\n\n    def onObjectCreated(root, url):\n        if not root:\n            return\n        if self._rootItem:\n            root.setGeometry(self._rootItem.geometry())\n            self._rootItem.deleteLater()\n        self._rootItem = root\n    self.objectCreated.connect(onObjectCreated)\n    self.setWatching(watching)\n    if sourceFile:\n        self.load(sourceFile)",
  "def load(self, sourceFile):\n    self._sourceFile = sourceFile\n    super(QmlInstantEngine, self).load(sourceFile)",
  "def setWatching(self, watchValue):\n    if self._watching is watchValue:\n        return\n    self._watching = watchValue\n    if self._watching:\n        self.addFiles(self._watchedFiles)\n        self._fileWatcher.fileChanged.connect(self.onFileChanged)\n    else:\n        self._fileWatcher.removePaths(self._watchedFiles)\n        self._fileWatcher.fileChanged.disconnect(self.onFileChanged)",
  "@property\ndef watchedExtensions(self):\n    return self._extensions",
  "@watchedExtensions.setter\ndef watchedExtensions(self, extensions):\n    self._extensions = extensions",
  "def setVerbose(self, verboseValue):\n    self._verbose = verboseValue",
  "def addFile(self, filename):\n    if isinstance(filename, QUrl):\n        filename = filename.path()\n    if not os.path.isfile(filename):\n        raise ValueError(\"addFile: file %s doesn't exist.\" % filename)\n    if filename in self._watchedFiles:\n        return\n    self._watchedFiles.append(filename)\n    if self._watching:\n        if self._verbose:\n            print('instantcoding: addPath', filename)\n        self._fileWatcher.addPath(filename)",
  "def addFiles(self, filenames):\n    if not isinstance(filenames, list):\n        filenames = [filenames]\n    for filename in filenames:\n        self.addFile(filename)",
  "def addFilesFromDirectory(self, dirname, recursive=False):\n    if not os.path.isdir(dirname):\n        raise RuntimeError('addFilesFromDirectory : %s is not a valid directory.' % dirname)\n    if recursive:\n        for (dirpath, dirnames, filenames) in os.walk(dirname):\n            for filename in filenames:\n                if os.path.splitext(filename)[1][1:] in self._extensions:\n                    self.addFile(os.path.join(dirpath, filename))\n    else:\n        filenames = os.listdir(dirname)\n        filenames = [os.path.join(dirname, filename) for filename in filenames if os.path.splitext(filename)[1][1:] in self._extensions]\n        self.addFiles(filenames)",
  "def removeFile(self, filename):\n    if filename in self._watchedFiles:\n        self._watchedFiles.remove(filename)\n    if self._watching:\n        self._fileWatcher.removePath(filename)",
  "def getRegisteredFiles(self):\n    return self._watchedFiles",
  "@Slot(str)\ndef onFileChanged(self, filepath):\n    if filepath not in self._watchedFiles:\n        return\n    if self._verbose:\n        print('Source file changed : ', filepath)\n    self.clearComponentCache()\n    self.removeFile(filepath)\n    cptTry = 0\n    while not os.path.exists(filepath) and cptTry < 10:\n        time.sleep(0.1)\n        cptTry += 1\n    self.reload()\n    QTimer.singleShot(200, lambda : self.addFile(filepath))",
  "def reload(self):\n    print('Reloading {}'.format(self._sourceFile))\n    self.load(self._sourceFile)",
  "def setter(instance, value):\n    currentValue = getattr(instance, attributeName)\n    if currentValue == value:\n        return\n    resetCallbackName = '__reset__' + attributeName\n    if resetOnDestroy and (not hasattr(instance, resetCallbackName)):\n        setattr(instance, resetCallbackName, lambda self=instance, *args: setter(self, None))\n    resetCallback = getattr(instance, resetCallbackName, None)\n    if resetCallback and currentValue and shiboken2.isValid(currentValue):\n        currentValue.destroyed.disconnect(resetCallback)\n    setattr(instance, attributeName, value)\n    if resetCallback and value:\n        value.destroyed.connect(resetCallback)\n    getattr(instance, signalName(notify)).emit()",
  "def getter(instance):\n    return getattr(instance, attributeName)",
  "def signalName(signalInstance):\n    return str(signalInstance)[:-2]",
  "def onObjectCreated(root, url):\n    if not root:\n        return\n    if self._rootItem:\n        root.setGeometry(self._rootItem.geometry())\n        self._rootItem.deleteLater()\n    self._rootItem = root",
  "@classmethod\ndef handler(cls, messageType, context, message):\n    if not cls.outputQmlWarnings:\n        if 'QQmlApplicationEngine failed to load component' in message:\n            logging.warning('Set MESHROOM_OUTPUT_QML_WARNINGS=1 to get a detailed error message.')\n        elif any((w in message for w in cls.qmlWarningsBlacklist)):\n            return\n    MessageHandler.logFunctions[messageType](message)",
  "def __init__(self, args):\n    QtArgs = [args[0], '-style', 'fusion'] + args[1:]\n    parser = argparse.ArgumentParser(prog=args[0], description='Launch Meshroom UI.', add_help=True)\n    parser.add_argument('project', metavar='PROJECT', type=str, nargs='?', help='Meshroom project file (e.g. myProject.mg) or folder with images to reconstruct.')\n    parser.add_argument('-i', '--import', metavar='IMAGES/FOLDERS', type=str, nargs='*', help='Import images or folder with images to reconstruct.')\n    parser.add_argument('-I', '--importRecursive', metavar='FOLDERS', type=str, nargs='*', help='Import images to reconstruct from specified folder and sub-folders.')\n    parser.add_argument('-s', '--save', metavar='PROJECT.mg', type=str, default='', help='Save the created scene.')\n    parser.add_argument('-p', '--pipeline', metavar='FILE.mg/' + '/'.join(meshroom.core.pipelineTemplates), type=str, default=os.environ.get('MESHROOM_DEFAULT_PIPELINE', 'photogrammetry'), help='Override the default Meshroom pipeline with this external or template graph.')\n    parser.add_argument('--submitLabel', metavar='SUBMITLABEL', type=str, help='Label of a node in the submitter', default='{projectName} [Meshroom]')\n    parser.add_argument('--verbose', help='Verbosity level', default='warning', choices=['fatal', 'error', 'warning', 'info', 'debug', 'trace'])\n    args = parser.parse_args(args[1:])\n    logStringToPython = {'fatal': logging.FATAL, 'error': logging.ERROR, 'warning': logging.WARNING, 'info': logging.INFO, 'debug': logging.DEBUG, 'trace': logging.DEBUG}\n    logging.getLogger().setLevel(logStringToPython[args.verbose])\n    QApplication.setAttribute(Qt.AA_EnableHighDpiScaling)\n    super(MeshroomApp, self).__init__(QtArgs)\n    self.setOrganizationName('AliceVision')\n    self.setApplicationName('Meshroom')\n    self.setApplicationVersion(meshroom.__version_name__)\n    font = self.font()\n    font.setPointSize(9)\n    self.setFont(font)\n    pwd = os.path.dirname(__file__)\n    self.setWindowIcon(QIcon(os.path.join(pwd, 'img/meshroom.svg')))\n    qmlDir = os.path.join(pwd, 'qml')\n    url = os.path.join(qmlDir, 'main.qml')\n    self.engine = QmlInstantEngine()\n    self.engine.addFilesFromDirectory(qmlDir, recursive=True)\n    self.engine.setWatching(os.environ.get('MESHROOM_INSTANT_CODING', False))\n    self.engine.setOutputWarningsToStandardError(MessageHandler.outputQmlWarnings)\n    qInstallMessageHandler(MessageHandler.handler)\n    self.engine.addImportPath(qmlDir)\n    components.registerTypes()\n    self.engine.rootContext().setContextProperty('_nodeTypes', {n: {'category': nodesDesc[n].category} for n in sorted(nodesDesc.keys())})\n    self._undoStack = commands.UndoStack(self)\n    self._taskManager = TaskManager(self)\n    r = Reconstruction(undoStack=self._undoStack, taskManager=self._taskManager, defaultPipeline=args.pipeline, parent=self)\n    r.setSubmitLabel(args.submitLabel)\n    self.engine.rootContext().setContextProperty('_reconstruction', r)\n    self.engine.rootContext().setContextProperty('Filepath', FilepathHelper(parent=self))\n    self.engine.rootContext().setContextProperty('Scene3DHelper', Scene3DHelper(parent=self))\n    self.engine.rootContext().setContextProperty('Transformations3DHelper', Transformations3DHelper(parent=self))\n    self.engine.rootContext().setContextProperty('Clipboard', ClipboardHelper(parent=self))\n    self.engine.rootContext().setContextProperty('_PaletteManager', PaletteManager(self.engine, parent=self))\n    self.engine.rootContext().setContextProperty('MeshroomApp', self)\n    self.aboutToQuit.connect(r.stopChildThreads)\n    if args.project and (not os.path.isfile(args.project)):\n        raise RuntimeError(\"Meshroom Command Line Error: 'PROJECT' argument should be a Meshroom project file (.mg).\\nInvalid value: '{}'\".format(args.project))\n    if args.project:\n        r.load(args.project)\n        self.addRecentProjectFile(args.project)\n    else:\n        r.new()\n    if getattr(args, 'import', None):\n        r.importImagesFromFolder(getattr(args, 'import'), recursive=False)\n    if args.importRecursive:\n        r.importImagesFromFolder(args.importRecursive, recursive=True)\n    if args.save:\n        if os.path.isfile(args.save):\n            raise RuntimeError(\"Meshroom Command Line Error: Cannot save the new Meshroom project as the file (.mg) already exists.\\nInvalid value: '{}'\".format(args.save))\n        projectFolder = os.path.dirname(args.save)\n        if not os.path.isdir(projectFolder):\n            if not os.path.isdir(os.path.dirname(projectFolder)):\n                raise RuntimeError(\"Meshroom Command Line Error: Cannot save the new Meshroom project file (.mg) as the parent of the folder does not exists.\\nInvalid value: '{}'\".format(args.save))\n            os.mkdir(projectFolder)\n        r.saveAs(args.save)\n        self.addRecentProjectFile(args.save)\n    self.engine.load(os.path.normpath(url))",
  "def _pipelineTemplateFiles(self):\n    templates = []\n    for key in sorted(meshroom.core.pipelineTemplates.keys()):\n        name = ' '.join(re.findall('[A-Z][^A-Z]*', key[0].upper() + key[1:]))\n        variant = {'name': name, 'key': key, 'path': meshroom.core.pipelineTemplates[key]}\n        templates.append(variant)\n    return templates",
  "def _pipelineTemplateNames(self):\n    return [p['name'] for p in self.pipelineTemplateFiles]",
  "@Slot()\ndef reloadTemplateList(self):\n    for f in meshroom.core.pipelineTemplatesFolders:\n        meshroom.core.loadPipelineTemplates(f)\n    self.pipelineTemplateFilesChanged.emit()",
  "def _recentProjectFiles(self):\n    projects = []\n    settings = QSettings()\n    settings.beginGroup('RecentFiles')\n    size = settings.beginReadArray('Projects')\n    for i in range(size):\n        settings.setArrayIndex(i)\n        p = settings.value('filepath')\n        if p:\n            projects.append(p)\n    settings.endArray()\n    return projects",
  "@Slot(str)\n@Slot(QUrl)\ndef addRecentProjectFile(self, projectFile):\n    if not isinstance(projectFile, (QUrl, str)):\n        raise TypeError('Unexpected data type: {}'.format(projectFile.__class__))\n    if isinstance(projectFile, QUrl):\n        projectFileNorm = projectFile.toLocalFile()\n        if not projectFileNorm:\n            projectFileNorm = projectFile.toString()\n    else:\n        projectFileNorm = QUrl(projectFile).toLocalFile()\n        if not projectFileNorm:\n            projectFileNorm = QUrl.fromLocalFile(projectFile).toLocalFile()\n    projects = self._recentProjectFiles()\n    from collections import OrderedDict\n    uniqueProjects = OrderedDict.fromkeys(projects)\n    projects = list(uniqueProjects)\n    if projectFileNorm in uniqueProjects:\n        projects.remove(projectFileNorm)\n    projects.insert(0, projectFileNorm)\n    projects = projects[0:20]\n    settings = QSettings()\n    settings.beginGroup('RecentFiles')\n    size = settings.beginWriteArray('Projects')\n    for (i, p) in enumerate(projects):\n        settings.setArrayIndex(i)\n        settings.setValue('filepath', p)\n    settings.endArray()\n    settings.sync()\n    self.recentProjectFilesChanged.emit()",
  "@Slot(str)\n@Slot(QUrl)\ndef removeRecentProjectFile(self, projectFile):\n    if not isinstance(projectFile, (QUrl, str)):\n        raise TypeError('Unexpected data type: {}'.format(projectFile.__class__))\n    if isinstance(projectFile, QUrl):\n        projectFileNorm = projectFile.toLocalFile()\n        if not projectFileNorm:\n            projectFileNorm = projectFile.toString()\n    else:\n        projectFileNorm = QUrl(projectFile).toLocalFile()\n        if not projectFileNorm:\n            projectFileNorm = QUrl.fromLocalFile(projectFile).toLocalFile()\n    projects = self._recentProjectFiles()\n    from collections import OrderedDict\n    uniqueProjects = OrderedDict.fromkeys(projects)\n    projects = list(uniqueProjects)\n    if projectFileNorm not in uniqueProjects:\n        return\n    projects.remove(projectFileNorm)\n    settings = QSettings()\n    settings.beginGroup('RecentFiles')\n    size = settings.beginWriteArray('Projects')\n    for (i, p) in enumerate(projects):\n        settings.setArrayIndex(i)\n        settings.setValue('filepath', p)\n    settings.endArray()\n    settings.sync()\n    self.recentProjectFilesChanged.emit()",
  "@Slot(str, result=str)\ndef markdownToHtml(self, md):\n    try:\n        from markdown import markdown\n    except ImportError:\n        logging.warning(\"Can't import markdown module, returning source markdown text.\")\n        return md\n    return markdown(md)",
  "def _systemInfo(self):\n    import platform\n    import sys\n    return {'platform': '{} {}'.format(platform.system(), platform.release()), 'python': 'Python {}'.format(sys.version.split(' ')[0])}",
  "def _licensesModel(self):\n    rootDir = os.environ.get('MESHROOM_INSTALL_DIR', os.getcwd())\n    return [{'title': 'Meshroom', 'localUrl': os.path.join(rootDir, 'COPYING.md'), 'onlineUrl': 'https://raw.githubusercontent.com/alicevision/meshroom/develop/COPYING.md'}, {'title': 'AliceVision', 'localUrl': os.path.join(rootDir, 'aliceVision', 'share', 'aliceVision', 'COPYING.md'), 'onlineUrl': 'https://raw.githubusercontent.com/alicevision/AliceVision/develop/COPYING.md'}]",
  "def _default8bitViewerEnabled(self):\n    return bool(os.environ.get('MESHROOM_USE_8BIT_VIEWER', False))",
  "@contextmanager\ndef GroupedGraphModification(graph, undoStack, title, disableUpdates=True):\n    state = graph.updateEnabled\n    undoStack.beginMacro(title)\n    if disableUpdates:\n        undoStack.tryAndPush(EnableGraphUpdateCommand(graph, False))\n    try:\n        yield\n    except Exception:\n        raise\n    finally:\n        if disableUpdates:\n            undoStack.tryAndPush(EnableGraphUpdateCommand(graph, state))\n        undoStack.endMacro()",
  "def __init__(self, parent=None):\n    super(UndoCommand, self).__init__(parent)\n    self._enabled = True",
  "def setEnabled(self, enabled):\n    self._enabled = enabled",
  "def redo(self):\n    if not self._enabled:\n        return\n    try:\n        self.redoImpl()\n    except Exception:\n        logging.error(\"Error while redoing command '{}': \\n{}\".format(self.text(), traceback.format_exc()))",
  "def undo(self):\n    if not self._enabled:\n        return\n    try:\n        self.undoImpl()\n    except Exception:\n        logging.error(\"Error while undoing command '{}': \\n{}\".format(self.text(), traceback.format_exc()))",
  "def redoImpl(self):\n    pass",
  "def undoImpl(self):\n    pass",
  "def __init__(self, parent=None):\n    super(UndoStack, self).__init__(parent)\n    self.cleanChanged.connect(self._cleanChanged)\n    self.canUndoChanged.connect(self._canUndoChanged)\n    self.canRedoChanged.connect(self._canRedoChanged)\n    self.undoTextChanged.connect(self._undoTextChanged)\n    self.redoTextChanged.connect(self._redoTextChanged)\n    self.indexChanged.connect(self._indexChanged)\n    self._undoableIndex = 0\n    self._lockedRedo = False",
  "def tryAndPush(self, command):\n    try:\n        res = command.redoImpl()\n    except Exception as e:\n        logging.error(\"Error while trying command '{}': \\n{}\".format(command.text(), traceback.format_exc()))\n        res = False\n    if res is not False:\n        command.setEnabled(False)\n        self.push(command)\n        self.setLockedRedo(False)\n        command.setEnabled(True)\n    return res",
  "def setUndoableIndex(self, value):\n    if self._undoableIndex == value:\n        return\n    self._undoableIndex = value\n    self.isUndoableIndexChanged.emit()",
  "def setLockedRedo(self, value):\n    if self._lockedRedo == value:\n        return\n    self._lockedRedo = value\n    self.lockedRedoChanged.emit()",
  "def lockAtThisIndex(self):\n    self.setUndoableIndex(self.index)\n    self.setLockedRedo(True)",
  "def unlock(self):\n    self.setUndoableIndex(0)\n    self.setLockedRedo(False)",
  "def __init__(self, graph, parent=None):\n    super(GraphCommand, self).__init__(parent)\n    self.graph = graph",
  "def __init__(self, graph, nodeType, position, parent=None, **kwargs):\n    super(AddNodeCommand, self).__init__(graph, parent)\n    self.nodeType = nodeType\n    self.nodeName = None\n    self.position = position\n    self.kwargs = kwargs\n    for (key, value) in self.kwargs.items():\n        if isinstance(value, Attribute):\n            self.kwargs[key] = value.asLinkExpr()\n        elif isinstance(value, list):\n            for (idx, v) in enumerate(value):\n                if isinstance(v, Attribute):\n                    value[idx] = v.asLinkExpr()",
  "def redoImpl(self):\n    node = self.graph.addNewNode(self.nodeType, position=self.position, **self.kwargs)\n    self.nodeName = node.name\n    self.setText('Add Node {}'.format(self.nodeName))\n    return node",
  "def undoImpl(self):\n    self.graph.removeNode(self.nodeName)",
  "def __init__(self, graph, node, parent=None):\n    super(RemoveNodeCommand, self).__init__(graph, parent)\n    self.nodeDict = node.toDict()\n    self.nodeName = node.getName()\n    self.setText('Remove Node {}'.format(self.nodeName))\n    self.outEdges = {}",
  "def redoImpl(self):\n    (_, self.outEdges) = self.graph.removeNode(self.nodeName)\n    return True",
  "def undoImpl(self):\n    with GraphModification(self.graph):\n        node = nodeFactory(self.nodeDict, self.nodeName)\n        self.graph.addNode(node, self.nodeName)\n        assert node.getName() == self.nodeName\n        for (dstAttr, srcAttr) in self.outEdges.items():\n            self.graph.addEdge(self.graph.attribute(srcAttr), self.graph.attribute(dstAttr))",
  "def __init__(self, graph, srcNodes, parent=None):\n    super(DuplicateNodesCommand, self).__init__(graph, parent)\n    self.srcNodeNames = [n.name for n in srcNodes]\n    self.setText('Duplicate Nodes')",
  "def redoImpl(self):\n    srcNodes = [self.graph.node(i) for i in self.srcNodeNames]\n    duplicates = [n for nodes in list(self.graph.duplicateNodes(srcNodes).values()) for n in nodes]\n    self.duplicates = [n.name for n in duplicates]\n    return duplicates",
  "def undoImpl(self):\n    for duplicate in self.duplicates:\n        self.graph.removeNode(duplicate)",
  "def __init__(self, graph, data, position=None, parent=None):\n    super(PasteNodesCommand, self).__init__(graph, parent)\n    self.data = data\n    self.position = position\n    self.nodeNames = []",
  "def redoImpl(self):\n    data = self.graph.updateImportedProject(self.data)\n    nodes = self.graph.pasteNodes(data, self.position)\n    self.nodeNames = [node.name for node in nodes]\n    self.setText('Paste Node{} ({})'.format('s' if len(self.nodeNames) > 1 else '', ', '.join(self.nodeNames)))\n    return nodes",
  "def undoImpl(self):\n    for name in self.nodeNames:\n        self.graph.removeNode(name)",
  "def __init__(self, graph, filepath=None, position=None, yOffset=0, parent=None):\n    super(ImportProjectCommand, self).__init__(graph, parent)\n    self.filepath = filepath\n    self.importedNames = []\n    self.position = position\n    self.yOffset = yOffset",
  "def redoImpl(self):\n    status = self.graph.load(self.filepath, setupProjectFile=False, importProject=True)\n    importedNodes = self.graph.importedNodes\n    self.setText('Import Project ({} nodes)'.format(importedNodes.count))\n    lowestY = 0\n    for node in self.graph.nodes:\n        if node not in importedNodes and node.y > lowestY:\n            lowestY = node.y\n    for node in importedNodes:\n        self.importedNames.append(node.name)\n        if self.position is not None:\n            self.graph.node(node.name).position = Position(node.x + self.position.x, node.y + self.position.y)\n        else:\n            self.graph.node(node.name).position = Position(node.x, node.y + lowestY + self.yOffset)\n    return importedNodes",
  "def undoImpl(self):\n    for nodeName in self.importedNames:\n        self.graph.removeNode(nodeName)\n    self.importedNames = []",
  "def __init__(self, graph, attribute, value, parent=None):\n    super(SetAttributeCommand, self).__init__(graph, parent)\n    self.attrName = attribute.getFullNameToNode()\n    self.value = value\n    self.oldValue = attribute.getExportValue()\n    self.setText(\"Set Attribute '{}'\".format(attribute.getFullNameToNode()))",
  "def redoImpl(self):\n    if self.value == self.oldValue:\n        return False\n    self.graph.attribute(self.attrName).value = self.value\n    return True",
  "def undoImpl(self):\n    self.graph.attribute(self.attrName).value = self.oldValue",
  "def __init__(self, graph, src, dst, parent=None):\n    super(AddEdgeCommand, self).__init__(graph, parent)\n    self.srcAttr = src.getFullNameToNode()\n    self.dstAttr = dst.getFullNameToNode()\n    self.setText(\"Connect '{}'->'{}'\".format(self.srcAttr, self.dstAttr))\n    if src.baseType != dst.baseType:\n        raise ValueError(\"Attribute types are not compatible and cannot be connected: '{}'({})->'{}'({})\".format(self.srcAttr, src.baseType, self.dstAttr, dst.baseType))",
  "def redoImpl(self):\n    self.graph.addEdge(self.graph.attribute(self.srcAttr), self.graph.attribute(self.dstAttr))\n    return True",
  "def undoImpl(self):\n    self.graph.removeEdge(self.graph.attribute(self.dstAttr))",
  "def __init__(self, graph, edge, parent=None):\n    super(RemoveEdgeCommand, self).__init__(graph, parent)\n    self.srcAttr = edge.src.getFullNameToNode()\n    self.dstAttr = edge.dst.getFullNameToNode()\n    self.setText(\"Disconnect '{}'->'{}'\".format(self.srcAttr, self.dstAttr))",
  "def redoImpl(self):\n    self.graph.removeEdge(self.graph.attribute(self.dstAttr))\n    return True",
  "def undoImpl(self):\n    self.graph.addEdge(self.graph.attribute(self.srcAttr), self.graph.attribute(self.dstAttr))",
  "def __init__(self, graph, listAttribute, value, parent=None):\n    super(ListAttributeAppendCommand, self).__init__(graph, parent)\n    assert isinstance(listAttribute, ListAttribute)\n    self.attrName = listAttribute.getFullNameToNode()\n    self.index = None\n    self.count = 1\n    self.value = value if value else None\n    self.setText('Append to {}'.format(self.attrName))",
  "def redoImpl(self):\n    listAttribute = self.graph.attribute(self.attrName)\n    self.index = len(listAttribute)\n    if isinstance(self.value, list):\n        listAttribute.extend(self.value)\n        self.count = len(self.value)\n    else:\n        listAttribute.append(self.value)\n    return True",
  "def undoImpl(self):\n    listAttribute = self.graph.attribute(self.attrName)\n    listAttribute.remove(self.index, self.count)",
  "def __init__(self, graph, attribute, parent=None):\n    super(ListAttributeRemoveCommand, self).__init__(graph, parent)\n    listAttribute = attribute.root\n    assert isinstance(listAttribute, ListAttribute)\n    self.listAttrName = listAttribute.getFullNameToNode()\n    self.index = listAttribute.index(attribute)\n    self.value = attribute.getExportValue()\n    self.setText('Remove {}'.format(attribute.getFullNameToNode()))",
  "def redoImpl(self):\n    listAttribute = self.graph.attribute(self.listAttrName)\n    listAttribute.remove(self.index)\n    return True",
  "def undoImpl(self):\n    listAttribute = self.graph.attribute(self.listAttrName)\n    listAttribute.insert(self.index, self.value)",
  "def __init__(self, graph, node, position, parent=None):\n    super(MoveNodeCommand, self).__init__(graph, parent)\n    self.nodeName = node.name\n    self.oldPosition = node.position\n    self.newPosition = position\n    self.setText('Move {}'.format(self.nodeName))",
  "def redoImpl(self):\n    self.graph.node(self.nodeName).position = self.newPosition\n    return True",
  "def undoImpl(self):\n    self.graph.node(self.nodeName).position = self.oldPosition",
  "def __init__(self, graph, node, parent=None):\n    super(UpgradeNodeCommand, self).__init__(graph, parent)\n    self.nodeDict = node.toDict()\n    self.nodeName = node.getName()\n    self.outEdges = {}\n    self.setText('Upgrade Node {}'.format(self.nodeName))",
  "def redoImpl(self):\n    if not self.graph.node(self.nodeName).canUpgrade:\n        return False\n    (upgradedNode, inEdges, self.outEdges) = self.graph.upgradeNode(self.nodeName)\n    return upgradedNode",
  "def undoImpl(self):\n    self.graph.removeNode(self.nodeName)\n    with GraphModification(self.graph):\n        node = nodeFactory(self.nodeDict)\n        self.graph.addNode(node, self.nodeName)\n        for (dstAttr, srcAttr) in self.outEdges.items():\n            self.graph.addEdge(self.graph.attribute(srcAttr), self.graph.attribute(dstAttr))",
  "def __init__(self, graph, enabled, parent=None):\n    super(EnableGraphUpdateCommand, self).__init__(graph, parent)\n    self.enabled = enabled\n    self.previousState = self.graph.updateEnabled",
  "def redoImpl(self):\n    self.graph.updateEnabled = self.enabled\n    return True",
  "def undoImpl(self):\n    self.graph.updateEnabled = self.previousState",
  "def __init__(self, evt):\n    super(MouseEvent, self).__init__()\n    self._x = evt.x()\n    self._y = evt.y()\n    self._button = evt.button()\n    self._modifiers = evt.modifiers()",
  "def __init__(self, parent=None):\n    super(EdgeMouseArea, self).__init__(parent)\n    self._curveScale = 0.7\n    self._thickness = 2.0\n    self._containsMouse = False\n    self._path = None\n    self.setAcceptHoverEvents(True)\n    self.setAcceptedMouseButtons(Qt.AllButtons)",
  "def contains(self, point):\n    return self._path.contains(point)",
  "def hoverEnterEvent(self, evt):\n    self.setContainsMouse(True)\n    super(EdgeMouseArea, self).hoverEnterEvent(evt)",
  "def hoverLeaveEvent(self, evt):\n    self.setContainsMouse(False)\n    super(EdgeMouseArea, self).hoverLeaveEvent(evt)",
  "def geometryChanged(self, newGeometry, oldGeometry):\n    super(EdgeMouseArea, self).geometryChanged(newGeometry, oldGeometry)\n    self.updateShape()",
  "def mousePressEvent(self, evt):\n    if not self.acceptedMouseButtons() & evt.button():\n        evt.setAccepted(False)\n        return\n    e = MouseEvent(evt)\n    self.pressed.emit(e)\n    e.deleteLater()",
  "def mouseReleaseEvent(self, evt):\n    e = MouseEvent(evt)\n    self.released.emit(e)\n    e.deleteLater()",
  "def updateShape(self):\n    p1 = QPointF(0, 0)\n    p2 = QPointF(self.width(), self.height())\n    ctrlPt = QPointF(abs(self.width() * self.curveScale), 0)\n    path = QPainterPath(p1)\n    path.cubicTo(p1 + ctrlPt, p2 - ctrlPt, p2)\n    halfThickness = self._thickness / 2.0\n    v = QVector2D(p2 - p1).normalized()\n    offset = QPointF(halfThickness * -v.y(), halfThickness * v.x())\n    self._path = QPainterPath(path.toReversed())\n    self._path.translate(-offset)\n    path.translate(offset)\n    self._path.connectPath(path)",
  "def getThickness(self):\n    return self._thickness",
  "def setThickness(self, value):\n    if self._thickness == value:\n        return\n    self._thickness = value\n    self.thicknessChanged.emit()\n    self.updateShape()",
  "def getCurveScale(self):\n    return self._curveScale",
  "def setCurveScale(self, value):\n    if self.curveScale == value:\n        return\n    self._curveScale = value\n    self.curveScaleChanged.emit()\n    self.updateShape()",
  "def getContainsMouse(self):\n    return self._containsMouse",
  "def setContainsMouse(self, value):\n    if self._containsMouse == value:\n        return\n    self._containsMouse = value\n    self.containsMouseChanged.emit()",
  "@Slot(Qt3DCore.QEntity, str, result='QVariantList')\ndef findChildrenByProperty(self, entity, propertyName):\n    children = []\n    for child in entity.childNodes():\n        try:\n            if child.metaObject().indexOfProperty(propertyName) != -1:\n                children.append(child)\n        except RuntimeError:\n            continue\n        children += self.findChildrenByProperty(child, propertyName)\n    return children",
  "@Slot(Qt3DCore.QEntity, Qt3DCore.QComponent)\ndef addComponent(self, entity, component):\n    entity.addComponent(component)",
  "@Slot(Qt3DCore.QEntity, Qt3DCore.QComponent)\ndef removeComponent(self, entity, component):\n    entity.removeComponent(component)",
  "@Slot(Qt3DCore.QEntity, result=int)\ndef vertexCount(self, entity):\n    return sum([renderer.vertexCount() for renderer in entity.findChildren(Qt3DRender.QGeometryRenderer)])",
  "@Slot(Qt3DCore.QEntity, result=int)\ndef faceCount(self, entity):\n    count = 0\n    for geo in entity.findChildren(Qt3DRender.QGeometry):\n        count += sum([attr.count() for attr in geo.attributes() if attr.name() == 'vertexPosition'])\n    return count / 3",
  "@Slot(Qt3DCore.QEntity, result=int)\ndef vertexColorCount(self, entity):\n    count = 0\n    for geo in entity.findChildren(Qt3DRender.QGeometry):\n        count += sum([attr.count() for attr in geo.attributes() if attr.name() == 'vertexColor'])\n    return count",
  "def projectToTrackball(self, screenCoords):\n    sx = screenCoords.x()\n    sy = self._windowSize.height() - screenCoords.y()\n    p2d = QVector2D(sx / self._windowSize.width() - 0.5, sy / self._windowSize.height() - 0.5)\n    z = 0.0\n    r2 = pow(self._trackballSize, 2)\n    lengthSquared = p2d.lengthSquared()\n    if lengthSquared <= r2 * 0.5:\n        z = sqrt(r2 - lengthSquared)\n    else:\n        z = r2 * 0.5 / p2d.length()\n    return QVector3D(p2d.x(), p2d.y(), z)",
  "@staticmethod\ndef clamp(x):\n    return max(-1, min(x, 1))",
  "def createRotation(self, firstPoint, nextPoint):\n    lastPos3D = self.projectToTrackball(firstPoint).normalized()\n    currentPos3D = self.projectToTrackball(nextPoint).normalized()\n    angle = acos(self.clamp(QVector3D.dotProduct(currentPos3D, lastPos3D)))\n    direction = QVector3D.crossProduct(currentPos3D, lastPos3D)\n    return (angle, direction)",
  "@Slot(QPointF, QPointF, float)\ndef rotate(self, lastPosition, currentPosition, dt):\n    (angle, direction) = self.createRotation(lastPosition, currentPosition)\n    rotatedAxis = self._camera.transform().rotation().rotatedVector(direction)\n    angle *= self._rotationSpeed * dt\n    self._camera.rotateAboutViewCenter(QQuaternion.fromAxisAndAngle(rotatedAxis, angle * pi * 180))",
  "@Slot(QVector3D, QVector3D, result=QQuaternion)\ndef rotationBetweenAandB(self, A, B):\n    A = A / A.length()\n    B = B / B.length()\n    v = QVector3D.crossProduct(A, B)\n    s = v.length()\n    c = QVector3D.dotProduct(A, B)\n    return QQuaternion.fromAxisAndAngle(v / s, atan2(s, c) * 180 / pi)",
  "@Slot(QVector3D, result=QVector3D)\ndef fromEquirectangular(self, vector):\n    return QVector3D(cos(vector.x()) * sin(vector.y()), sin(vector.x()), cos(vector.x()) * cos(vector.y()))",
  "@Slot(QVector3D, result=QVector3D)\ndef toEquirectangular(self, vector):\n    return QVector3D(asin(vector.y()), atan2(vector.x(), vector.z()), 0)",
  "@Slot(QVector3D, QVector2D, QVector2D, result=QVector3D)\ndef updatePanorama(self, euler, ptStart, ptEnd):\n    delta = 0.001\n    qStart = QQuaternion.fromEulerAngles(euler.y(), euler.x(), euler.z())\n    vStart = self.fromEquirectangular(QVector3D(ptStart))\n    vStartdY = self.fromEquirectangular(QVector3D(ptStart.x(), ptStart.y() + delta, 0))\n    vEnd = self.fromEquirectangular(QVector3D(ptEnd))\n    qAdd = QQuaternion.rotationTo(vStart, vEnd)\n    vCurrent = qAdd.rotatedVector(vStartdY)\n    vIdeal = self.fromEquirectangular(QVector3D(ptEnd.x(), ptEnd.y() + delta, 0))\n    lambdaEnd = 1 / QVector3D.dotProduct(vEnd, vCurrent)\n    lambdaIdeal = 1 / QVector3D.dotProduct(vEnd, vIdeal)\n    vPlaneCurrent = lambdaEnd * vCurrent\n    vPlaneIdeal = lambdaIdeal * vIdeal\n    rotStart = (vPlaneCurrent - vEnd).normalized()\n    rotEnd = (vPlaneIdeal - vEnd).normalized()\n    v = QVector3D.crossProduct(rotEnd, rotStart)\n    s = QVector3D.dotProduct(v, vEnd)\n    c = QVector3D.dotProduct(rotStart, rotEnd)\n    angle = atan2(s, c) * 180 / pi\n    qImage = QQuaternion.fromAxisAndAngle(vEnd, -angle)\n    return (qImage * qAdd * qStart).toEulerAngles()",
  "@Slot(QVector3D, QVector2D, QVector2D, result=QVector3D)\ndef updatePanoramaInPlane(self, euler, ptStart, ptEnd):\n    delta = 0.001\n    qStart = QQuaternion.fromEulerAngles(euler.y(), euler.x(), euler.z())\n    vStart = self.fromEquirectangular(QVector3D(ptStart))\n    vEnd = self.fromEquirectangular(QVector3D(ptEnd))\n    vIdeal = self.fromEquirectangular(QVector3D(ptStart.x(), ptStart.y() + delta, 0))\n    lambdaEnd = 1 / QVector3D.dotProduct(vStart, vEnd)\n    lambdaIdeal = 1 / QVector3D.dotProduct(vStart, vIdeal)\n    vPlaneEnd = lambdaEnd * vEnd\n    vPlaneIdeal = lambdaIdeal * vIdeal\n    rotStart = (vPlaneEnd - vStart).normalized()\n    rotEnd = (vPlaneIdeal - vStart).normalized()\n    v = QVector3D.crossProduct(rotEnd, rotStart)\n    s = QVector3D.dotProduct(v, vStart)\n    c = QVector3D.dotProduct(rotStart, rotEnd)\n    angle = atan2(s, c) * 180 / pi\n    qAdd = QQuaternion.fromAxisAndAngle(vStart, angle)\n    return (qAdd * qStart).toEulerAngles()",
  "@Slot(QVector4D, Qt3DRender.QCamera, QSize, result=QVector2D)\ndef pointFromWorldToScreen(self, point, camera, windowSize):\n    viewMatrix = camera.transform().matrix().inverted()\n    projectedPoint = (camera.projectionMatrix() * viewMatrix[0]).map(point)\n    projectedPoint2D = QVector2D(projectedPoint.x() / projectedPoint.w(), projectedPoint.y() / projectedPoint.w())\n    screenPoint2D = QVector2D(int((projectedPoint2D.x() + 1) * windowSize.width() / 2), int((projectedPoint2D.y() - 1) * windowSize.height() / -2))\n    return screenPoint2D",
  "@Slot(Qt3DCore.QTransform, QMatrix4x4, QMatrix4x4, QMatrix4x4, QVector3D)\ndef relativeLocalTranslate(self, transformQtInstance, initialPosMat, initialRotMat, initialScaleMat, translateVec):\n    translationMat = QMatrix4x4()\n    translationMat.translate(translateVec)\n    mat = initialPosMat * initialRotMat * translationMat * initialScaleMat\n    transformQtInstance.setMatrix(mat)",
  "@Slot(Qt3DCore.QTransform, QMatrix4x4, QQuaternion, QMatrix4x4, QVector3D, int)\ndef relativeLocalRotate(self, transformQtInstance, initialPosMat, initialRotQuat, initialScaleMat, axis, degree):\n    transformQuat = QQuaternion.fromAxisAndAngle(axis, degree)\n    newRotQuat = initialRotQuat * transformQuat\n    newRotationMat = self.quaternionToRotationMatrix(newRotQuat)\n    mat = initialPosMat * newRotationMat * initialScaleMat\n    transformQtInstance.setMatrix(mat)",
  "@Slot(Qt3DCore.QTransform, QMatrix4x4, QMatrix4x4, QMatrix4x4, QVector3D)\ndef relativeLocalScale(self, transformQtInstance, initialPosMat, initialRotMat, initialScaleMat, scaleVec):\n    scaleMat = self.copyMatrix4x4(initialScaleMat)\n    scaleVecTuple = scaleVec.toTuple()\n    for i in range(3):\n        currentRow = list(scaleMat.row(i).toTuple())\n        value = currentRow[i] + scaleVecTuple[i]\n        value = value if value >= 0 else -value\n        currentRow[i] = value\n        scaleMat.setRow(i, QVector3D(currentRow[0], currentRow[1], currentRow[2]))\n    mat = initialPosMat * initialRotMat * scaleMat\n    transformQtInstance.setMatrix(mat)",
  "@Slot(QMatrix4x4, result='QVariant')\ndef modelMatrixToMatrices(self, modelMat):\n    decomposition = self.decomposeModelMatrix(modelMat)\n    posMat = QMatrix4x4()\n    posMat.translate(decomposition.get('translation'))\n    rotMat = self.quaternionToRotationMatrix(decomposition.get('quaternion'))\n    scaleMat = QMatrix4x4()\n    scaleMat.scale(decomposition.get('scale'))\n    return {'position': posMat, 'rotation': rotMat, 'scale': scaleMat, 'quaternion': decomposition.get('quaternion')}",
  "@Slot(QVector3D, QVector3D, QVector3D, result=QMatrix4x4)\ndef computeModelMatrixWithEuler(self, translation, rotation, scale):\n    posMat = QMatrix4x4()\n    posMat.translate(translation)\n    quaternion = QQuaternion.fromEulerAngles(rotation)\n    rotMat = self.quaternionToRotationMatrix(quaternion)\n    scaleMat = QMatrix4x4()\n    scaleMat.scale(scale)\n    modelMat = posMat * rotMat * scaleMat\n    return modelMat",
  "@Slot(QVector3D, result=QVector3D)\ndef convertRotationFromCV2GL(self, rotation):\n    M = QQuaternion.fromAxisAndAngle(QVector3D(1, 0, 0), 180.0)\n    quaternion = QQuaternion.fromEulerAngles(rotation)\n    U = M * quaternion * M\n    return U.toEulerAngles()",
  "@Slot(QVector3D, QMatrix4x4, Qt3DRender.QCamera, QSize, result=float)\ndef computeScaleUnitFromModelMatrix(self, axis, modelMat, camera, windowSize):\n    decomposition = self.decomposeModelMatrix(modelMat)\n    posMat = QMatrix4x4()\n    posMat.translate(decomposition.get('translation'))\n    rotMat = self.quaternionToRotationMatrix(decomposition.get('quaternion'))\n    unitScaleModelMat = posMat * rotMat * QMatrix4x4()\n    worldCenterPoint = unitScaleModelMat.map(QVector4D(0, 0, 0, 1))\n    worldAxisUnitPoint = unitScaleModelMat.map(QVector4D(axis.x(), axis.y(), axis.z(), 1))\n    screenCenter2D = self.pointFromWorldToScreen(worldCenterPoint, camera, windowSize)\n    screenAxisUnitPoint2D = self.pointFromWorldToScreen(worldAxisUnitPoint, camera, windowSize)\n    screenVector = QVector2D(screenAxisUnitPoint2D.x() - screenCenter2D.x(), -(screenAxisUnitPoint2D.y() - screenCenter2D.y()))\n    value = screenVector.length()\n    return value if value and value > 10 else 10",
  "def copyMatrix4x4(self, mat):\n    newMat = QMatrix4x4()\n    for i in range(4):\n        newMat.setRow(i, mat.row(i))\n    return newMat",
  "def decomposeModelMatrix(self, modelMat):\n    translation = modelMat.column(3).toVector3D()\n    quaternion = QQuaternion.fromDirection(modelMat.column(2).toVector3D(), modelMat.column(1).toVector3D())\n    scale = QVector3D(modelMat.column(0).length(), modelMat.column(1).length(), modelMat.column(2).length())\n    return {'translation': translation, 'quaternion': quaternion, 'scale': scale}",
  "def quaternionToRotationMatrix(self, q):\n    rotMat3x3 = q.toRotationMatrix()\n    return QMatrix4x4(rotMat3x3(0, 0), rotMat3x3(0, 1), rotMat3x3(0, 2), 0, rotMat3x3(1, 0), rotMat3x3(1, 1), rotMat3x3(1, 2), 0, rotMat3x3(2, 0), rotMat3x3(2, 1), rotMat3x3(2, 2), 0, 0, 0, 0, 1)",
  "def registerTypes():\n    from PySide2.QtQml import qmlRegisterType\n    from meshroom.ui.components.clipboard import ClipboardHelper\n    from meshroom.ui.components.edge import EdgeMouseArea\n    from meshroom.ui.components.filepath import FilepathHelper\n    from meshroom.ui.components.scene3D import Scene3DHelper, TrackballController, Transformations3DHelper\n    from meshroom.ui.components.csvData import CsvData\n    qmlRegisterType(EdgeMouseArea, 'GraphEditor', 1, 0, 'EdgeMouseArea')\n    qmlRegisterType(ClipboardHelper, 'Meshroom.Helpers', 1, 0, 'ClipboardHelper')\n    qmlRegisterType(FilepathHelper, 'Meshroom.Helpers', 1, 0, 'FilepathHelper')\n    qmlRegisterType(Scene3DHelper, 'Meshroom.Helpers', 1, 0, 'Scene3DHelper')\n    qmlRegisterType(Transformations3DHelper, 'Meshroom.Helpers', 1, 0, 'Transformations3DHelper')\n    qmlRegisterType(TrackballController, 'Meshroom.Helpers', 1, 0, 'TrackballController')\n    qmlRegisterType(CsvData, 'DataObjects', 1, 0, 'CsvData')",
  "@staticmethod\ndef asStr(path):\n    if not isinstance(path, (QUrl, str)):\n        raise TypeError('Unexpected data type: {}'.format(path.__class__))\n    if isinstance(path, QUrl):\n        path = path.toLocalFile()\n    return path",
  "@Slot(str, result=str)\n@Slot(QUrl, result=str)\ndef basename(self, path):\n    return os.path.basename(self.asStr(path))",
  "@Slot(str, result=str)\n@Slot(QUrl, result=str)\ndef dirname(self, path):\n    return os.path.dirname(self.asStr(path))",
  "@Slot(str, result=str)\n@Slot(QUrl, result=str)\ndef extension(self, path):\n    return os.path.splitext(self.asStr(path))[-1]",
  "@Slot(str, result=bool)\n@Slot(QUrl, result=bool)\ndef isFile(self, path):\n    return os.path.isfile(self.asStr(path))",
  "@Slot(str, result=bool)\n@Slot(QUrl, result=bool)\ndef exists(self, path):\n    return os.path.exists(self.asStr(path))",
  "@Slot(QUrl, result=str)\ndef urlToString(self, url):\n    return self.asStr(url)",
  "@Slot(str, result=QUrl)\ndef stringToUrl(self, path):\n    return QUrl.fromLocalFile(path)",
  "@Slot(str, result=str)\n@Slot(QUrl, result=str)\ndef normpath(self, path):\n    return os.path.normpath(self.asStr(path))",
  "@Slot(str, result=str)\n@Slot(QUrl, result=str)\ndef globFirst(self, path):\n    import glob\n    fileList = glob.glob(self.asStr(path))\n    fileList.sort()\n    if fileList:\n        return fileList[0]\n    return ''",
  "@Slot(QUrl, result=int)\ndef fileSizeMB(self, path):\n    return QFileInfo(self.asStr(path)).size() / (1024 * 1024)",
  "def __init__(self, parent=None):\n    super(ClipboardHelper, self).__init__(parent)\n    self._clipboard = QClipboard(parent=self)",
  "def __del__(self):\n    self.clear()",
  "@Slot(str)\ndef setText(self, value):\n    self._clipboard.setText(value)",
  "@Slot(result=str)\ndef getText(self):\n    return self._clipboard.text()",
  "@Slot()\ndef clear(self):\n    self._clipboard.clear()",
  "def __init__(self, parent=None):\n    super(CsvData, self).__init__(parent=parent)\n    self._filepath = ''\n    self._data = QObjectListModel(parent=self)\n    self._ready = False\n    self.filepathChanged.connect(self.updateData)",
  "@Slot(int, result=QObject)\ndef getColumn(self, index):\n    return self._data.at(index)",
  "@Slot(result=str)\ndef getFilepath(self):\n    return self._filepath",
  "@Slot(result=int)\ndef getNbColumns(self):\n    if self._ready:\n        return len(self._data)\n    else:\n        return 0",
  "@Slot(str)\ndef setFilepath(self, filepath):\n    if self._filepath == filepath:\n        return\n    self.setReady(False)\n    self._filepath = filepath\n    self.filepathChanged.emit()",
  "def setReady(self, ready):\n    if self._ready == ready:\n        return\n    self._ready = ready\n    self.readyChanged.emit()",
  "@Slot()\ndef updateData(self):\n    self.setReady(False)\n    self._data.clear()\n    newColumns = self.read()\n    if newColumns:\n        self._data.setObjectList(newColumns)\n        self.setReady(True)",
  "def read(self):\n    if not self._filepath or not self._filepath.lower().endswith('.csv') or (not os.path.isfile(self._filepath)):\n        return []\n    dataList = []\n    try:\n        csvRows = []\n        with open(self._filepath, 'r') as fp:\n            reader = csv.reader(fp)\n            for row in reader:\n                csvRows.append(row)\n        for elt in csvRows[0]:\n            dataList.append(CsvColumn(elt))\n        for elt in csvRows[1:]:\n            for (idx, value) in enumerate(elt):\n                dataList[idx].appendValue(value)\n    except Exception as e:\n        logging.error('CsvData: Failed to load file: {}\\n{}'.format(self._filepath, str(e)))\n    return dataList",
  "def __init__(self, title='', parent=None):\n    super(CsvColumn, self).__init__(parent=parent)\n    self._title = title\n    self._content = []",
  "def appendValue(self, value):\n    self._content.append(value)",
  "@Slot(result=str)\ndef getFirst(self):\n    if not self._content:\n        return ''\n    return self._content[0]",
  "@Slot(result=str)\ndef getLast(self):\n    if not self._content:\n        return ''\n    return self._content[-1]",
  "@Slot(QtCharts.QXYSeries)\ndef fillChartSerie(self, serie):\n    if not serie:\n        return\n    serie.clear()\n    for (index, value) in enumerate(self._content):\n        serie.append(float(index), float(value))",
  "def __init__(self, parent=None):\n    super(SimpleFarmSubmitter, self).__init__(name='SimpleFarm', parent=parent)\n    self.engine = os.environ.get('MESHROOM_SIMPLEFARM_ENGINE', 'tractor')\n    self.share = os.environ.get('MESHROOM_SIMPLEFARM_SHARE', 'vfx')\n    self.prod = os.environ.get('PROD', 'mvg')\n    if 'REZ_REQUEST' in os.environ:\n        packages = os.environ.get('REZ_REQUEST', '').split()\n        resolvedPackages = os.environ.get('REZ_RESOLVE', '').split()\n        resolvedVersions = {}\n        for r in resolvedPackages:\n            if r.startswith('~'):\n                continue\n            v = r.split('-')\n            if len(v) == 2:\n                resolvedVersions[v[0]] = v[1]\n        for p in packages:\n            if p.startswith('~'):\n                continue\n            v = p.split('-')\n            self.reqPackages.append('-'.join([v[0], resolvedVersions[v[0]]]))\n        logging.debug('REZ Packages: {}'.format(str(self.reqPackages)))\n    elif 'REZ_MESHROOM_VERSION' in os.environ:\n        self.reqPackages = ['meshroom-{}'.format(os.environ.get('REZ_MESHROOM_VERSION', ''))]\n    else:\n        self.reqPackages = None\n    if 'REZ_DEV_PACKAGES_ROOT' in os.environ:\n        self.environment['REZ_DEV_PACKAGES_ROOT'] = os.environ['REZ_DEV_PACKAGES_ROOT']",
  "def createTask(self, meshroomFile, node):\n    tags = self.DEFAULT_TAGS.copy()\n    nbFrames = node.size\n    arguments = {}\n    parallelArgs = ''\n    print('node: ', node.name)\n    if node.isParallelized:\n        (blockSize, fullSize, nbBlocks) = node.nodeDesc.parallelization.getSizes(node)\n        parallelArgs = ' --iteration @start'\n        arguments.update({'start': 0, 'end': nbBlocks - 1, 'step': 1})\n    tags['nbFrames'] = nbFrames\n    tags['prod'] = self.prod\n    allRequirements = list()\n    allRequirements.extend(self.config['CPU'].get(node.nodeDesc.cpu.name, []))\n    allRequirements.extend(self.config['RAM'].get(node.nodeDesc.ram.name, []))\n    allRequirements.extend(self.config['GPU'].get(node.nodeDesc.gpu.name, []))\n    task = simpleFarm.Task(name=node.nodeType, command='{exe} --node {nodeName} \"{meshroomFile}\" {parallelArgs} --extern'.format(exe='meshroom_compute' if self.reqPackages else os.path.join(binDir, 'meshroom_compute'), nodeName=node.name, meshroomFile=meshroomFile, parallelArgs=parallelArgs), tags=tags, rezPackages=self.reqPackages, requirements={'service': str(','.join(allRequirements))}, **arguments)\n    return task",
  "def submit(self, nodes, edges, filepath, submitLabel='{projectName}'):\n    projectName = os.path.splitext(os.path.basename(filepath))[0]\n    name = submitLabel.format(projectName=projectName)\n    comment = filepath\n    nbFrames = max([node.size for node in nodes])\n    mainTags = {'prod': self.prod, 'nbFrames': str(nbFrames), 'comment': comment}\n    allRequirements = list(self.config.get('BASE', []))\n    job = simpleFarm.Job(name, tags=mainTags, requirements={'service': str(','.join(allRequirements))}, environment=self.environment)\n    nodeNameToTask = {}\n    for node in nodes:\n        task = self.createTask(filepath, node)\n        job.addTask(task)\n        nodeNameToTask[node.name] = task\n    for (u, v) in edges:\n        nodeNameToTask[u.name].dependsOn(nodeNameToTask[v.name])\n    if self.engine == 'tractor-dummy':\n        job.submit(share=self.share, engine='tractor', execute=True)\n        return True\n    else:\n        res = job.submit(share=self.share, engine=self.engine)\n        return len(res) > 0",
  "def __init__(self, nodeType, msg=None):\n    msg = 'Unknown Node Type: ' + nodeType\n    super(UnknownNodeTypeError, self).__init__(msg)\n    self.nodeType = nodeType",
  "def __init__(self, nodeName, details=None):\n    msg = 'Failed to upgrade node {}'.format(nodeName)\n    if details:\n        msg += ': {}'.format(details)\n    super(NodeUpgradeError, self).__init__(msg)",
  "def attributeFactory(description, value, isOutput, node, root=None, parent=None):\n    if isinstance(description, desc.GroupAttribute):\n        cls = GroupAttribute\n    elif isinstance(description, desc.ListAttribute):\n        cls = ListAttribute\n    else:\n        cls = Attribute\n    attr = cls(node, description, isOutput, root, parent)\n    if value is not None:\n        attr.value = value\n    return attr",
  "def raiseIfLink(func):\n\n    def wrapper(attr, *args, **kwargs):\n        if attr.isLink:\n            raise RuntimeError(\"Can't modify connected Attribute\")\n        return func(attr, *args, **kwargs)\n    return wrapper",
  "def __init__(self, node, attributeDesc, isOutput, root=None, parent=None):\n    super(Attribute, self).__init__(parent)\n    self._name = attributeDesc.name\n    self._root = None if root is None else weakref.ref(root)\n    self._node = weakref.ref(node)\n    self.attributeDesc = attributeDesc\n    self._isOutput = isOutput\n    self._value = copy.copy(attributeDesc.value)\n    self._label = attributeDesc.label\n    self._enabled = True\n    self._invalidationValue = ''",
  "@property\ndef node(self):\n    return self._node()",
  "@property\ndef root(self):\n    return self._root() if self._root else None",
  "def getName(self):\n    return self._name",
  "def getFullName(self):\n    if isinstance(self.root, ListAttribute):\n        return '{}[{}]'.format(self.root.getFullName(), self.root.index(self))\n    elif isinstance(self.root, GroupAttribute):\n        return '{}.{}'.format(self.root.getFullName(), self.getName())\n    return self.getName()",
  "def getFullNameToNode(self):\n    return '{}.{}'.format(self.node.name, self.getFullName())",
  "def getFullNameToGraph(self):\n    return '{}.{}'.format(self.node.graph.name, self.getFullNameToNode())",
  "def asLinkExpr(self):\n    return '{' + self.getFullNameToNode() + '}'",
  "def getType(self):\n    return self.attributeDesc.__class__.__name__",
  "def _isReadOnly(self):\n    return not self._isOutput and self.node.isCompatibilityNode",
  "def getBaseType(self):\n    return self.getType()",
  "def getLabel(self):\n    return self._label",
  "def getFullLabel(self):\n    if isinstance(self.root, ListAttribute):\n        return self.root.getFullLabel()\n    elif isinstance(self.root, GroupAttribute):\n        return '{} {}'.format(self.root.getFullLabel(), self.getLabel())\n    return self.getLabel()",
  "def getFullLabelToNode(self):\n    return '{} {}'.format(self.node.label, self.getFullLabel())",
  "def getFullLabelToGraph(self):\n    return '{} {}'.format(self.node.graph.name, self.getFullLabelToNode())",
  "def getEnabled(self):\n    if isinstance(self.desc.enabled, types.FunctionType):\n        try:\n            return self.desc.enabled(self.node)\n        except:\n            return True\n    return self.attributeDesc.enabled",
  "def setEnabled(self, v):\n    if self._enabled == v:\n        return\n    self._enabled = v\n    self.enabledChanged.emit()",
  "def _get_value(self):\n    if self.isLink:\n        return self.getLinkParam().value\n    return self._value",
  "def _set_value(self, value):\n    if self._value == value:\n        return\n    if isinstance(value, Attribute) or Attribute.isLinkExpression(value):\n        self._value = value\n    else:\n        convertedValue = self.desc.validateValue(value)\n        self._value = convertedValue\n    if self.isInput:\n        self.requestGraphUpdate()\n    self.valueChanged.emit()",
  "def upgradeValue(self, exportedValue):\n    self._set_value(exportedValue)",
  "def resetValue(self):\n    self._value = self.attributeDesc.value",
  "def requestGraphUpdate(self):\n    if self.node.graph:\n        self.node.graph.markNodesDirty(self.node)\n        self.node.graph.update()",
  "@property\ndef isOutput(self):\n    return self._isOutput",
  "@property\ndef isInput(self):\n    return not self._isOutput",
  "def uid(self, uidIndex=-1):\n    if self.isOutput:\n        return hashValue(self._invalidationValue)\n    if self.isLink:\n        return self.getLinkParam().uid(uidIndex)\n    if isinstance(self._value, (list, tuple, set)):\n        return hashValue([hashValue(v) for v in sorted(self._value)])\n    return hashValue(self._value)",
  "@property\ndef isLink(self):\n    return self.node.graph and self.isInput and self.node.graph._edges and (self in self.node.graph._edges.keys())",
  "@staticmethod\ndef isLinkExpression(value):\n    return isinstance(value, str) and Attribute.stringIsLinkRe.match(value)",
  "def getLinkParam(self, recursive=False):\n    if not self.isLink:\n        return None\n    linkParam = self.node.graph.edge(self).src\n    if not recursive:\n        return linkParam\n    if linkParam.isLink:\n        return linkParam.getLinkParam(recursive)\n    return linkParam",
  "@property\ndef hasOutputConnections(self):\n    if not self.node.graph or not self.node.graph.edges:\n        return False\n    return next((edge for edge in self.node.graph.edges.values() if edge.src == self), None) is not None",
  "def _applyExpr(self):\n    v = self._value\n    g = self.node.graph\n    if not g:\n        return\n    if isinstance(v, Attribute):\n        g.addEdge(v, self)\n        self.resetValue()\n    elif self.isInput and Attribute.isLinkExpression(v):\n        link = v[1:-1]\n        (linkNode, linkAttr) = link.split('.')\n        try:\n            g.addEdge(g.node(linkNode).attribute(linkAttr), self)\n        except KeyError as err:\n            logging.warning('Connect Attribute from Expression failed.\\nExpression: \"{exp}\"\\nError: \"{err}\".'.format(exp=v, err=err))\n        self.resetValue()",
  "def getExportValue(self):\n    if self.isLink:\n        return self.getLinkParam().asLinkExpr()\n    if self.isOutput:\n        return self.defaultValue()\n    return self._value",
  "def getEvalValue(self):\n    if isinstance(self.value, str):\n        return Template(self.value).safe_substitute(os.environ)\n    return self.value",
  "def getValueStr(self):\n    if isinstance(self.attributeDesc, desc.ChoiceParam) and (not self.attributeDesc.exclusive):\n        assert isinstance(self.value, Sequence) and (not isinstance(self.value, str))\n        return self.attributeDesc.joinChar.join(self.getEvalValue())\n    if isinstance(self.attributeDesc, (desc.StringParam, desc.File)):\n        return '\"{}\"'.format(self.getEvalValue())\n    return str(self.getEvalValue())",
  "def defaultValue(self):\n    if isinstance(self.desc.value, types.FunctionType):\n        return self.desc.value(self)\n    return copy.copy(self.desc.value)",
  "def _isDefault(self):\n    return self.value == self.defaultValue()",
  "def getPrimitiveValue(self, exportDefault=True):\n    return self._value",
  "def updateInternals(self):\n    self.setEnabled(self.getEnabled())",
  "def wrapper(attr, *args, **kwargs):\n    if attr.isLink:\n        raise RuntimeError(\"Can't modify connected Attribute\")\n    return func(attr, *args, **kwargs)",
  "def __init__(self, node, attributeDesc, isOutput, root=None, parent=None):\n    super(ListAttribute, self).__init__(node, attributeDesc, isOutput, root, parent)\n    self._value = ListModel(parent=self)",
  "def __len__(self):\n    return len(self._value)",
  "def getBaseType(self):\n    return self.attributeDesc.elementDesc.__class__.__name__",
  "def at(self, idx):\n    return self._value.at(idx)",
  "def index(self, item):\n    return self._value.indexOf(item)",
  "def resetValue(self):\n    self._value = ListModel(parent=self)",
  "def _set_value(self, value):\n    if self.node.graph:\n        self.remove(0, len(self))\n    if isinstance(value, ListAttribute) or Attribute.isLinkExpression(value):\n        self._value = value\n    else:\n        newValue = self.desc.validateValue(value)\n        self.extend(newValue)\n    self.requestGraphUpdate()",
  "def upgradeValue(self, exportedValues):\n    if not isinstance(exportedValues, list):\n        if isinstance(exportedValues, ListAttribute) or Attribute.isLinkExpression(exportedValues):\n            self._set_value(exportedValues)\n            return\n        raise RuntimeError('ListAttribute.upgradeValue: the given value is of type ' + str(type(exportedValues)) + \" but a 'list' is expected.\")\n    attrs = []\n    for v in exportedValues:\n        a = attributeFactory(self.attributeDesc.elementDesc, None, self.isOutput, self.node, self)\n        a.upgradeValue(v)\n        attrs.append(a)\n    index = len(self._value)\n    self._value.insert(index, attrs)\n    self.valueChanged.emit()\n    self._applyExpr()\n    self.requestGraphUpdate()",
  "@raiseIfLink\ndef append(self, value):\n    self.extend([value])",
  "@raiseIfLink\ndef insert(self, index, value):\n    values = value if isinstance(value, list) else [value]\n    attrs = [attributeFactory(self.attributeDesc.elementDesc, v, self.isOutput, self.node, self) for v in values]\n    self._value.insert(index, attrs)\n    self.valueChanged.emit()\n    self._applyExpr()\n    self.requestGraphUpdate()",
  "@raiseIfLink\ndef extend(self, values):\n    self.insert(len(self._value), values)",
  "@raiseIfLink\ndef remove(self, index, count=1):\n    if self.node.graph:\n        from meshroom.core.graph import GraphModification\n        with GraphModification(self.node.graph):\n            for i in range(index, index + count):\n                attr = self._value.at(i)\n                if attr.isLink:\n                    self.node.graph.removeEdge(attr)\n    self._value.removeAt(index, count)\n    self.requestGraphUpdate()\n    self.valueChanged.emit()",
  "def uid(self, uidIndex):\n    if isinstance(self.value, ListModel):\n        uids = []\n        for value in self.value:\n            if uidIndex in value.desc.uid:\n                uids.append(value.uid(uidIndex))\n        return hashValue(uids)\n    return super(ListAttribute, self).uid(uidIndex)",
  "def _applyExpr(self):\n    if not self.node.graph:\n        return\n    if isinstance(self._value, ListAttribute) or Attribute.isLinkExpression(self._value):\n        super(ListAttribute, self)._applyExpr()\n    else:\n        for value in self._value:\n            value._applyExpr()",
  "def getExportValue(self):\n    if self.isLink:\n        return self.getLinkParam().asLinkExpr()\n    return [attr.getExportValue() for attr in self._value]",
  "def defaultValue(self):\n    return []",
  "def _isDefault(self):\n    return len(self._value) == 0",
  "def getPrimitiveValue(self, exportDefault=True):\n    if exportDefault:\n        return [attr.getPrimitiveValue(exportDefault=exportDefault) for attr in self._value]\n    else:\n        return [attr.getPrimitiveValue(exportDefault=exportDefault) for attr in self._value if not attr.isDefault]",
  "def getValueStr(self):\n    if isinstance(self.value, ListModel):\n        return self.attributeDesc.joinChar.join([v.getValueStr() for v in self.value])\n    return super(ListAttribute, self).getValueStr()",
  "def updateInternals(self):\n    super(ListAttribute, self).updateInternals()\n    for attr in self._value:\n        attr.updateInternals()",
  "def __init__(self, node, attributeDesc, isOutput, root=None, parent=None):\n    super(GroupAttribute, self).__init__(node, attributeDesc, isOutput, root, parent)\n    self._value = DictModel(keyAttrName='name', parent=self)\n    subAttributes = []\n    for subAttrDesc in self.attributeDesc.groupDesc:\n        childAttr = attributeFactory(subAttrDesc, None, self.isOutput, self.node, self)\n        subAttributes.append(childAttr)\n        childAttr.valueChanged.connect(self.valueChanged)\n    self._value.reset(subAttributes)",
  "def __getattr__(self, key):\n    try:\n        return super(GroupAttribute, self).__getattr__(key)\n    except AttributeError:\n        try:\n            return self._value.get(key)\n        except KeyError:\n            raise AttributeError(key)",
  "def _set_value(self, exportedValue):\n    value = self.desc.validateValue(exportedValue)\n    if isinstance(value, dict):\n        for (key, v) in value.items():\n            self._value.get(key).value = v\n    elif isinstance(value, (list, tuple)):\n        if len(self.desc._groupDesc) != len(value):\n            raise AttributeError('Incorrect number of values on GroupAttribute: {}'.format(str(value)))\n        for (attrDesc, v) in zip(self.desc._groupDesc, value):\n            self._value.get(attrDesc.name).value = v\n    else:\n        raise AttributeError('Failed to set on GroupAttribute: {}'.format(str(value)))",
  "def upgradeValue(self, exportedValue):\n    value = self.desc.validateValue(exportedValue)\n    if isinstance(value, dict):\n        for (key, v) in value.items():\n            if key in self._value.keys():\n                self._value.get(key).upgradeValue(v)\n    elif isinstance(value, (list, tuple)):\n        if len(self.desc._groupDesc) != len(value):\n            raise AttributeError('Incorrect number of values on GroupAttribute: {}'.format(str(value)))\n        for (attrDesc, v) in zip(self.desc._groupDesc, value):\n            self._value.get(attrDesc.name).upgradeValue(v)\n    else:\n        raise AttributeError('Failed to set on GroupAttribute: {}'.format(str(value)))",
  "@Slot(str, result=Attribute)\ndef childAttribute(self, key):\n    try:\n        return self._value.get(key)\n    except KeyError:\n        return None",
  "def uid(self, uidIndex):\n    uids = []\n    for (k, v) in self._value.items():\n        if v.enabled and uidIndex in v.desc.uid:\n            uids.append(v.uid(uidIndex))\n    return hashValue(uids)",
  "def _applyExpr(self):\n    for value in self._value:\n        value._applyExpr()",
  "def getExportValue(self):\n    return {key: attr.getExportValue() for (key, attr) in self._value.objects.items()}",
  "def _isDefault(self):\n    return all((v.isDefault for v in self._value))",
  "def defaultValue(self):\n    return {key: attr.defaultValue() for (key, attr) in self._value.items()}",
  "def getPrimitiveValue(self, exportDefault=True):\n    if exportDefault:\n        return {name: attr.getPrimitiveValue(exportDefault=exportDefault) for (name, attr) in self._value.items()}\n    else:\n        return {name: attr.getPrimitiveValue(exportDefault=exportDefault) for (name, attr) in self._value.items() if not attr.isDefault}",
  "def getValueStr(self):\n    sortedSubValues = [self._value.get(attr.name).getValueStr() for attr in self.attributeDesc.groupDesc]\n    return self.attributeDesc.joinChar.join(sortedSubValues)",
  "def updateInternals(self):\n    super(GroupAttribute, self).updateInternals()\n    for attr in self._value:\n        attr.updateInternals()",
  "def getCgroupMemorySize():\n    pid = os.getpid()\n    filename = f'/proc/{pid}/cgroup'\n    cgroup = None\n    try:\n        with open(filename, 'r') as f:\n            lines = f.readlines()\n            for line in lines:\n                tokens = line.rstrip('\\r\\n').split(':')\n                if len(tokens) < 3:\n                    continue\n                if tokens[1] == 'memory':\n                    cgroup = tokens[2]\n    except OSError:\n        pass\n    if cgroup is None:\n        return -1\n    size = -1\n    filename = f'/sys/fs/cgroup/memory/{cgroup}/memory.limit_in_bytes'\n    try:\n        with open(filename, 'r') as f:\n            value = f.read().rstrip('\\r\\n')\n            if value.isnumeric():\n                size = int(value)\n    except OSError:\n        pass\n    return size",
  "def parseNumericList(numericListString):\n    nList = []\n    for item in numericListString.split(','):\n        if '-' in item:\n            (start, end) = item.split('-')\n            start = int(start)\n            end = int(end)\n            nList.extend(range(start, end + 1))\n        else:\n            value = int(item)\n            nList.append(value)\n    return nList",
  "def getCgroupCpuCount():\n    pid = os.getpid()\n    filename = f'/proc/{pid}/cgroup'\n    cgroup = None\n    try:\n        with open(filename, 'r') as f:\n            lines = f.readlines()\n            for line in lines:\n                tokens = line.rstrip('\\r\\n').split(':')\n                if len(tokens) < 3:\n                    continue\n                if tokens[1] == 'cpuset':\n                    cgroup = tokens[2]\n    except OSError:\n        pass\n    if cgroup is None:\n        return -1\n    size = -1\n    filename = f'/sys/fs/cgroup/cpuset/{cgroup}/cpuset.cpus'\n    try:\n        with open(filename, 'r') as f:\n            value = f.read().rstrip('\\r\\n')\n            nlist = parseNumericList(value)\n            size = len(nlist)\n    except OSError:\n        pass\n    return size",
  "@contextmanager\ndef GraphModification(graph):\n    if not isinstance(graph, Graph):\n        raise ValueError('GraphModification expects a Graph instance')\n    enabled = graph.updateEnabled\n    graph.updateEnabled = False\n    try:\n        yield\n    except Exception:\n        raise\n    finally:\n        graph.updateEnabled = enabled",
  "def changeTopology(func):\n\n    def decorator(self, *args, **kwargs):\n        assert isinstance(self, Graph)\n        result = func(self, *args, **kwargs)\n        self.dirtyTopology = True\n        self.update()\n        return result\n    return decorator",
  "def loadGraph(filepath):\n    graph = Graph('')\n    graph.load(filepath)\n    graph.update()\n    return graph",
  "def getAlreadySubmittedChunks(nodes):\n    out = []\n    for node in nodes:\n        for chunk in node.chunks:\n            if chunk.isAlreadySubmitted():\n                out.append(chunk)\n    return out",
  "def executeGraph(graph, toNodes=None, forceCompute=False, forceStatus=False):\n    if forceCompute:\n        (nodes, edges) = graph.dfsOnFinish(startNodes=toNodes)\n    else:\n        (nodes, edges) = graph.dfsToProcess(startNodes=toNodes)\n        chunksInConflict = getAlreadySubmittedChunks(nodes)\n        if chunksInConflict:\n            chunksStatus = set([chunk.status.status.name for chunk in chunksInConflict])\n            chunksName = [node.name for node in chunksInConflict]\n            msg = 'WARNING: Some nodes are already submitted with status: {}\\nNodes: {}'.format(', '.join(chunksStatus), ', '.join(chunksName))\n            if forceStatus:\n                print(msg)\n            else:\n                raise RuntimeError(msg)\n    print('Nodes to execute: ', str([n.name for n in nodes]))\n    for node in nodes:\n        node.beginSequence(forceCompute)\n    for (n, node) in enumerate(nodes):\n        try:\n            multiChunks = len(node.chunks) > 1\n            for (c, chunk) in enumerate(node.chunks):\n                if multiChunks:\n                    print('\\n[{node}/{nbNodes}]({chunk}/{nbChunks}) {nodeName}'.format(node=n + 1, nbNodes=len(nodes), chunk=c + 1, nbChunks=len(node.chunks), nodeName=node.nodeType))\n                else:\n                    print('\\n[{node}/{nbNodes}] {nodeName}'.format(node=n + 1, nbNodes=len(nodes), nodeName=node.nodeType))\n                chunk.process(forceCompute)\n        except Exception as e:\n            logging.error('Error on node computation: {}'.format(e))\n            graph.clearSubmittedNodes()\n            raise\n    for node in nodes:\n        node.endSequence()",
  "def submitGraph(graph, submitter, toNodes=None, submitLabel='{projectName}'):\n    (nodesToProcess, edgesToProcess) = graph.dfsToProcess(startNodes=toNodes)\n    flowEdges = graph.flowEdges(startNodes=toNodes)\n    edgesToProcess = set(edgesToProcess).intersection(flowEdges)\n    if not nodesToProcess:\n        logging.warning('Nothing to compute')\n        return\n    logging.info('Nodes to process: {}'.format(edgesToProcess))\n    logging.info('Edges to process: {}'.format(edgesToProcess))\n    sub = None\n    if submitter:\n        sub = meshroom.core.submitters.get(submitter, None)\n    elif len(meshroom.core.submitters) == 1:\n        sub = meshroom.core.submitters.values()[0]\n    if sub is None:\n        raise RuntimeError(\"Unknown Submitter: '{submitter}'. Available submitters are: '{allSubmitters}'.\".format(submitter=submitter, allSubmitters=str(meshroom.core.submitters.keys())))\n    try:\n        res = sub.submit(nodesToProcess, edgesToProcess, graph.filepath, submitLabel=submitLabel)\n        if res:\n            for node in nodesToProcess:\n                node.submit()\n    except Exception as e:\n        logging.error('Error on submit : {}'.format(e))",
  "def submit(graphFile, submitter, toNode=None, submitLabel='{projectName}'):\n    graph = loadGraph(graphFile)\n    toNodes = graph.findNodes(toNode) if toNode else None\n    submitGraph(graph, submitter, toNodes, submitLabel=submitLabel)",
  "def default(self, obj):\n    if isinstance(obj, Enum):\n        return obj.name\n    return DefaultJSONEncoder.default(self, obj)",
  "def __init__(self, src, dst, parent=None):\n    super(Edge, self).__init__(parent)\n    self._src = weakref.ref(src)\n    self._dst = weakref.ref(dst)\n    self._repr = '<Edge> {} -> {}'.format(self._src(), self._dst())",
  "@property\ndef src(self):\n    return self._src()",
  "@property\ndef dst(self):\n    return self._dst()",
  "def __init__(self, reverse, dependenciesOnly):\n    super(Visitor, self).__init__()\n    self.reverse = reverse\n    self.dependenciesOnly = dependenciesOnly",
  "def discoverVertex(self, u, g):\n    pass",
  "def examineEdge(self, e, g):\n    pass",
  "def treeEdge(self, e, g):\n    pass",
  "def backEdge(self, e, g):\n    pass",
  "def forwardOrCrossEdge(self, e, g):\n    pass",
  "def finishEdge(self, e, g):\n    pass",
  "def finishVertex(self, u, g):\n    pass",
  "def decorator(self, *args, **kwargs):\n    assert isinstance(self, Graph)\n    result = func(self, *args, **kwargs)\n    self.dirtyTopology = True\n    self.update()\n    return result",
  "def __init__(self, name, parent=None):\n    super(Graph, self).__init__(parent)\n    self.name = name\n    self._updateEnabled = True\n    self._updateRequested = False\n    self.dirtyTopology = False\n    self._nodesMinMaxDepths = {}\n    self._computationBlocked = {}\n    self._canComputeLeaves = True\n    self._nodes = DictModel(keyAttrName='name', parent=self)\n    self._edges = DictModel(keyAttrName='dst', parent=self)\n    self._importedNodes = DictModel(keyAttrName='name', parent=self)\n    self._compatibilityNodes = DictModel(keyAttrName='name', parent=self)\n    self.cacheDir = meshroom.core.defaultCacheFolder\n    self._filepath = ''\n    self.header = {}",
  "def clear(self):\n    self.header.clear()\n    self._compatibilityNodes.clear()\n    self._edges.clear()\n    for node in self._nodes:\n        node.alive = False\n    self._importedNodes.clear()\n    self._nodes.clear()",
  "@property\ndef fileFeatures(self):\n    return Graph.IO.getFeaturesForVersion(self.header.get(Graph.IO.Keys.FileVersion, '0.0'))",
  "@Slot(str)\ndef load(self, filepath, setupProjectFile=True, importProject=False):\n    if not importProject:\n        self.clear()\n    with open(filepath) as jsonFile:\n        fileData = json.load(jsonFile)\n    graphData = fileData.get(Graph.IO.Keys.Graph, fileData)\n    if importProject:\n        self._importedNodes.clear()\n        graphData = self.updateImportedProject(graphData)\n    if not isinstance(graphData, dict):\n        raise RuntimeError('loadGraph error: Graph is not a dict. File: {}'.format(filepath))\n    self.header = fileData.get(Graph.IO.Keys.Header, {})\n    nodesVersions = self.header.get(Graph.IO.Keys.NodesVersions, {})\n    isTemplate = self.header.get('template', False)\n    with GraphModification(self):\n        for (nodeName, nodeData) in sorted(graphData.items(), key=lambda x: self.getNodeIndexFromName(x[0])):\n            if not isinstance(nodeData, dict):\n                raise RuntimeError('loadGraph error: Node is not a dict. File: {}'.format(filepath))\n            if 'version' not in nodeData:\n                nodeData['version'] = nodesVersions.get(nodeData['nodeType'], '0.0')\n            n = nodeFactory(nodeData, nodeName, template=isTemplate)\n            self._addNode(n, nodeName)\n            if importProject:\n                self._importedNodes.add(n)\n        self._applyExpr()\n        if setupProjectFile:\n            self._setFilepath(filepath)\n    return True",
  "def updateImportedProject(self, data):\n    nameCorrespondences = {}\n    updatedData = {}\n\n    def createUniqueNodeName(nodeNames, inputName):\n        i = 1\n        while i:\n            newName = '{name}_{index}'.format(name=inputName, index=i)\n            if newName not in nodeNames and newName not in updatedData.keys():\n                return newName\n            i += 1\n    for (nodeName, nodeData) in sorted(data.items(), key=lambda x: self.getNodeIndexFromName(x[0])):\n        if not isinstance(nodeData, dict):\n            raise RuntimeError('updateImportedProject error: Node is not a dict.')\n        if nodeName in self._nodes.keys() or nodeName in updatedData.keys():\n            newName = createUniqueNodeName(self._nodes.keys(), nodeData['nodeType'])\n            updatedData[newName] = nodeData\n            nameCorrespondences[nodeName] = newName\n        else:\n            updatedData[nodeName] = nodeData\n    newNames = [nodeName for nodeName in updatedData]\n    for (nodeName, nodeData) in updatedData.items():\n        nodeType = nodeData.get('nodeType', None)\n        nodeDesc = meshroom.core.nodesDesc[nodeType]\n        inputs = nodeData.get('inputs', {})\n        outputs = nodeData.get('outputs', {})\n        if inputs:\n            inputs = self.updateLinks(inputs, nameCorrespondences)\n            inputs = self.resetExternalLinks(inputs, nodeDesc.inputs, newNames)\n            updatedData[nodeName]['inputs'] = inputs\n        if outputs:\n            outputs = self.updateLinks(outputs, nameCorrespondences)\n            outputs = self.resetExternalLinks(outputs, nodeDesc.outputs, newNames)\n            updatedData[nodeName]['outputs'] = outputs\n    return updatedData",
  "@staticmethod\ndef updateLinks(attributes, nameCorrespondences):\n    for (key, val) in attributes.items():\n        for corr in nameCorrespondences.keys():\n            if isinstance(val, str) and corr in val:\n                attributes[key] = val.replace(corr, nameCorrespondences[corr])\n            elif isinstance(val, list):\n                for v in val:\n                    if isinstance(v, str):\n                        if corr in v:\n                            val[val.index(v)] = v.replace(corr, nameCorrespondences[corr])\n                    else:\n                        break\n                attributes[key] = val\n    return attributes",
  "@staticmethod\ndef resetExternalLinks(attributes, nodeDesc, newNames):\n    for (key, val) in attributes.items():\n        defaultValue = None\n        for desc in nodeDesc:\n            if desc.name == key:\n                defaultValue = desc.value\n                break\n        if isinstance(val, str):\n            if Attribute.isLinkExpression(val) and (not any((name in val for name in newNames))):\n                if defaultValue is not None:\n                    attributes[key] = defaultValue\n        elif isinstance(val, list):\n            removedCnt = len(val)\n            tmpVal = list(val)\n            for v in tmpVal:\n                if isinstance(v, str) and Attribute.isLinkExpression(v) and (not any((name in v for name in newNames))):\n                    val.remove(v)\n                    removedCnt -= 1\n            if removedCnt == 0 and defaultValue is not None:\n                attributes[key] = defaultValue\n    return attributes",
  "@property\ndef updateEnabled(self):\n    return self._updateEnabled",
  "@updateEnabled.setter\ndef updateEnabled(self, enabled):\n    self._updateEnabled = enabled\n    if enabled and self._updateRequested:\n        self.update()\n        self._updateRequested = False",
  "@changeTopology\ndef _addNode(self, node, uniqueName):\n    if node.graph is not None and node.graph != self:\n        raise RuntimeError('Node \"{}\" cannot be part of the Graph \"{}\", as it is already part of the other graph \"{}\".'.format(node.nodeType, self.name, node.graph.name))\n    assert uniqueName not in self._nodes.keys()\n    node._name = uniqueName\n    node.graph = self\n    self._nodes.add(node)",
  "def addNode(self, node, uniqueName=None):\n    self._addNode(node, uniqueName if uniqueName else self._createUniqueNodeName(node.nodeType))\n    with GraphModification(self):\n        node._applyExpr()\n    return node",
  "def copyNode(self, srcNode, withEdges=False):\n    with GraphModification(self):\n        node = nodeFactory(srcNode.toDict(), srcNode.nodeType)\n        skippedEdges = {}\n        if not withEdges:\n            for (n, attr) in node.attributes.items():\n                if Attribute.isLinkExpression(attr.value):\n                    skippedEdges[attr] = attr.value\n                    attr.resetValue()\n                elif isinstance(attr, ListAttribute):\n                    for child in attr.value:\n                        if Attribute.isLinkExpression(child.value):\n                            skippedEdges[child] = child.value\n                            child.resetValue()\n    return (node, skippedEdges)",
  "def duplicateNodes(self, srcNodes):\n    duplicates = OrderedDict()\n    with GraphModification(self):\n        duplicateEdges = {}\n        for srcNode in srcNodes:\n            (node, edges) = self.copyNode(srcNode, withEdges=False)\n            duplicate = self.addNode(node)\n            duplicateEdges.update(edges)\n            duplicates.setdefault(srcNode, []).append(duplicate)\n        for (attr, linkExpression) in duplicateEdges.items():\n            link = linkExpression[1:-1]\n            (edgeSrcNodeName, edgeSrcAttrName) = link.split('.', 1)\n            edgeSrcNode = self.node(edgeSrcNodeName)\n            if edgeSrcNode in duplicates:\n                edgeSrcNode = duplicates.get(edgeSrcNode)[0]\n            self.addEdge(edgeSrcNode.attribute(edgeSrcAttrName), attr)\n    return duplicates",
  "def pasteNodes(self, data, position):\n    nodes = []\n    with GraphModification(self):\n        positionCnt = 0\n        for key in sorted(data):\n            nodeType = data[key].get('nodeType', None)\n            if not nodeType:\n                pass\n            attributes = {}\n            attributes.update(data[key].get('inputs', {}))\n            attributes.update(data[key].get('outputs', {}))\n            node = Node(nodeType, position=position[positionCnt], **attributes)\n            self._addNode(node, key)\n            nodes.append(node)\n            positionCnt += 1\n        self._applyExpr()\n    return nodes",
  "def outEdges(self, attribute):\n    return [edge for edge in self.edges if edge.src == attribute]",
  "def nodeInEdges(self, node):\n    return [edge for edge in self.edges if edge.dst.node == node]",
  "def nodeOutEdges(self, node):\n    return [edge for edge in self.edges if edge.src.node == node]",
  "@changeTopology\ndef removeNode(self, nodeName):\n    node = self.node(nodeName)\n    inEdges = {}\n    outEdges = {}\n    with GraphModification(self):\n        for edge in self.nodeOutEdges(node):\n            self.removeEdge(edge.dst)\n            outEdges[edge.dst.getFullNameToNode()] = edge.src.getFullNameToNode()\n        for edge in self.nodeInEdges(node):\n            self.removeEdge(edge.dst)\n            inEdges[edge.dst.getFullNameToNode()] = edge.src.getFullNameToNode()\n        node.alive = False\n        self._nodes.remove(node)\n        if node in self._importedNodes:\n            self._importedNodes.remove(node)\n        self.update()\n    return (inEdges, outEdges)",
  "def addNewNode(self, nodeType, name=None, position=None, **kwargs):\n    if name and name in self._nodes.keys():\n        name = self._createUniqueNodeName(name)\n    n = self.addNode(Node(nodeType, position=position, **kwargs), uniqueName=name)\n    n.updateInternals()\n    return n",
  "def _createUniqueNodeName(self, inputName):\n    i = 1\n    while i:\n        newName = '{name}_{index}'.format(name=inputName, index=i)\n        if newName not in self._nodes.objects:\n            return newName\n        i += 1",
  "def node(self, nodeName):\n    return self._nodes.get(nodeName)",
  "def upgradeNode(self, nodeName):\n    node = self.node(nodeName)\n    if not isinstance(node, CompatibilityNode):\n        raise ValueError('Upgrade is only available on CompatibilityNode instances.')\n    upgradedNode = node.upgrade()\n    with GraphModification(self):\n        (inEdges, outEdges) = self.removeNode(nodeName)\n        self.addNode(upgradedNode, nodeName)\n        for (dst, src) in outEdges.items():\n            try:\n                self.addEdge(self.attribute(src), self.attribute(dst))\n            except (KeyError, ValueError) as e:\n                logging.warning('Failed to restore edge {} -> {}: {}'.format(src, dst, str(e)))\n    return (upgradedNode, inEdges, outEdges)",
  "def upgradeAllNodes(self):\n    nodeNames = [name for (name, n) in self._compatibilityNodes.items() if n.canUpgrade]\n    with GraphModification(self):\n        for nodeName in nodeNames:\n            self.upgradeNode(nodeName)",
  "@Slot(str, result=Attribute)\ndef attribute(self, fullName):\n    (node, attribute) = fullName.split('.', 1)\n    return self.node(node).attribute(attribute)",
  "@staticmethod\ndef getNodeIndexFromName(name):\n    try:\n        return int(name.split('_')[-1])\n    except:\n        return -1",
  "@staticmethod\ndef sortNodesByIndex(nodes):\n    return sorted(nodes, key=lambda x: Graph.getNodeIndexFromName(x.name))",
  "def nodesOfType(self, nodeType, sortedByIndex=True):\n    nodes = [n for n in self._nodes.values() if n.nodeType == nodeType]\n    return self.sortNodesByIndex(nodes) if sortedByIndex else nodes",
  "def findInitNodes(self):\n    nodes = [n for n in self._nodes.values() if isinstance(n.nodeDesc, meshroom.core.desc.InitNode)]\n    return nodes",
  "def findNodeCandidates(self, nodeNameExpr):\n    pattern = re.compile(nodeNameExpr)\n    return [v for (k, v) in self._nodes.objects.items() if pattern.match(k)]",
  "def findNode(self, nodeExpr):\n    candidates = self.findNodeCandidates('^' + nodeExpr)\n    if not candidates:\n        raise KeyError('No node candidate for \"{}\"'.format(nodeExpr))\n    if len(candidates) > 1:\n        for c in candidates:\n            if c.name == nodeExpr:\n                return c\n        raise KeyError('Multiple node candidates for \"{}\": {}'.format(nodeExpr, str([c.name for c in candidates])))\n    return candidates[0]",
  "def findNodes(self, nodesExpr):\n    if isinstance(nodesExpr, list):\n        return [self.findNode(nodeName) for nodeName in nodesExpr]\n    return [self.findNode(nodesExpr)]",
  "def edge(self, dstAttributeName):\n    return self._edges.get(dstAttributeName)",
  "def getLeafNodes(self, dependenciesOnly):\n    nodesWithOutputLink = set([edge.src.node for edge in self.getEdges(dependenciesOnly)])\n    return set(self._nodes) - nodesWithOutputLink",
  "def getRootNodes(self, dependenciesOnly):\n    nodesWithInputLink = set([edge.dst.node for edge in self.getEdges(dependenciesOnly)])\n    return set(self._nodes) - nodesWithInputLink",
  "@changeTopology\ndef addEdge(self, srcAttr, dstAttr):\n    assert isinstance(srcAttr, Attribute)\n    assert isinstance(dstAttr, Attribute)\n    if srcAttr.node.graph != self or dstAttr.node.graph != self:\n        raise RuntimeError('The attributes of the edge should be part of a common graph.')\n    if dstAttr in self.edges.keys():\n        raise RuntimeError('Destination attribute \"{}\" is already connected.'.format(dstAttr.getFullNameToNode()))\n    edge = Edge(srcAttr, dstAttr)\n    self.edges.add(edge)\n    self.markNodesDirty(dstAttr.node)\n    dstAttr.valueChanged.emit()\n    dstAttr.isLinkChanged.emit()\n    srcAttr.hasOutputConnectionsChanged.emit()\n    return edge",
  "def addEdges(self, *edges):\n    with GraphModification(self):\n        for edge in edges:\n            self.addEdge(*edge)",
  "@changeTopology\ndef removeEdge(self, dstAttr):\n    if dstAttr not in self.edges.keys():\n        raise RuntimeError('Attribute \"{}\" is not connected'.format(dstAttr.getFullNameToNode()))\n    edge = self.edges.pop(dstAttr)\n    self.markNodesDirty(dstAttr.node)\n    dstAttr.valueChanged.emit()\n    dstAttr.isLinkChanged.emit()\n    edge.src.hasOutputConnectionsChanged.emit()",
  "def getDepth(self, node, minimal=False):\n    assert node.graph == self\n    assert not self.dirtyTopology\n    (minDepth, maxDepth) = self._nodesMinMaxDepths[node]\n    return minDepth if minimal else maxDepth",
  "def getInputEdges(self, node, dependenciesOnly):\n    return set([edge for edge in self.getEdges(dependenciesOnly=dependenciesOnly) if edge.dst.node is node])",
  "def _getInputEdgesPerNode(self, dependenciesOnly):\n    nodeEdges = defaultdict(set)\n    for edge in self.getEdges(dependenciesOnly=dependenciesOnly):\n        nodeEdges[edge.dst.node].add(edge.src.node)\n    return nodeEdges",
  "def _getOutputEdgesPerNode(self, dependenciesOnly):\n    nodeEdges = defaultdict(set)\n    for edge in self.getEdges(dependenciesOnly=dependenciesOnly):\n        nodeEdges[edge.src.node].add(edge.dst.node)\n    return nodeEdges",
  "def dfs(self, visitor, startNodes=None, longestPathFirst=False):\n    nodeChildren = self._getOutputEdgesPerNode(visitor.dependenciesOnly) if visitor.reverse else self._getInputEdgesPerNode(visitor.dependenciesOnly)\n    colors = {}\n    for u in self._nodes:\n        colors[u] = WHITE\n    if longestPathFirst and visitor.reverse:\n        raise NotImplementedError('Graph.dfs(): longestPathFirst=True and visitor.reverse=True are not compatible yet.')\n    nodes = startNodes or (self.getRootNodes(visitor.dependenciesOnly) if visitor.reverse else self.getLeafNodes(visitor.dependenciesOnly))\n    if longestPathFirst:\n        assert not self.dirtyTopology\n        nodes = sorted(nodes, key=lambda item: item.depth)\n    try:\n        for node in nodes:\n            self.dfsVisit(node, visitor, colors, nodeChildren, longestPathFirst)\n    except StopGraphVisit:\n        pass",
  "def dfsVisit(self, u, visitor, colors, nodeChildren, longestPathFirst):\n    try:\n        self._dfsVisit(u, visitor, colors, nodeChildren, longestPathFirst)\n    except StopBranchVisit:\n        pass",
  "def _dfsVisit(self, u, visitor, colors, nodeChildren, longestPathFirst):\n    colors[u] = GRAY\n    visitor.discoverVertex(u, self)\n    children = nodeChildren[u]\n    if longestPathFirst:\n        assert not self.dirtyTopology\n        children = sorted(children, reverse=True, key=lambda item: self._nodesMinMaxDepths[item][1])\n    for v in children:\n        visitor.examineEdge((u, v), self)\n        if colors[v] == WHITE:\n            visitor.treeEdge((u, v), self)\n            self.dfsVisit(v, visitor, colors, nodeChildren, longestPathFirst)\n        elif colors[v] == GRAY:\n            visitor.backEdge((u, v), self)\n        elif colors[v] == BLACK:\n            visitor.forwardOrCrossEdge((u, v), self)\n        visitor.finishEdge((u, v), self)\n    colors[u] = BLACK\n    visitor.finishVertex(u, self)",
  "def dfsOnFinish(self, startNodes=None, longestPathFirst=False, reverse=False, dependenciesOnly=False):\n    nodes = []\n    edges = []\n    visitor = Visitor(reverse=reverse, dependenciesOnly=dependenciesOnly)\n    visitor.finishVertex = lambda vertex, graph: nodes.append(vertex)\n    visitor.finishEdge = lambda edge, graph: edges.append(edge)\n    self.dfs(visitor=visitor, startNodes=startNodes, longestPathFirst=longestPathFirst)\n    return (nodes, edges)",
  "def dfsOnDiscover(self, startNodes=None, filterTypes=None, longestPathFirst=False, reverse=False, dependenciesOnly=False):\n    nodes = []\n    edges = []\n    visitor = Visitor(reverse=reverse, dependenciesOnly=dependenciesOnly)\n\n    def discoverVertex(vertex, graph):\n        if not filterTypes or vertex.nodeType in filterTypes:\n            nodes.append(vertex)\n    visitor.discoverVertex = discoverVertex\n    visitor.examineEdge = lambda edge, graph: edges.append(edge)\n    self.dfs(visitor=visitor, startNodes=startNodes, longestPathFirst=longestPathFirst)\n    return (nodes, edges)",
  "def dfsToProcess(self, startNodes=None):\n    nodes = []\n    edges = []\n    visitor = Visitor(reverse=False, dependenciesOnly=True)\n\n    def discoverVertex(vertex, graph):\n        if vertex.hasStatus(Status.SUCCESS):\n            raise StopBranchVisit()\n\n    def finishVertex(vertex, graph):\n        chunksToProcess = []\n        for chunk in vertex.chunks:\n            if chunk.status.status is not Status.SUCCESS:\n                chunksToProcess.append(chunk)\n        if chunksToProcess:\n            nodes.append(vertex)\n\n    def finishEdge(edge, graph):\n        if edge[0].hasStatus(Status.SUCCESS) or edge[1].hasStatus(Status.SUCCESS):\n            return\n        edges.append(edge)\n    visitor.finishVertex = finishVertex\n    visitor.finishEdge = finishEdge\n    visitor.discoverVertex = discoverVertex\n    self.dfs(visitor=visitor, startNodes=startNodes)\n    return (nodes, edges)",
  "@Slot(Node, result=bool)\ndef canCompute(self, node):\n    if isinstance(node, CompatibilityNode):\n        return False\n    return not self._computationBlocked[node]",
  "def updateNodesTopologicalData(self):\n    self._nodesMinMaxDepths.clear()\n    self._computationBlocked.clear()\n    compatNodes = []\n    visitor = Visitor(reverse=False, dependenciesOnly=True)\n\n    def discoverVertex(vertex, graph):\n        self._nodesMinMaxDepths[vertex] = (0, 0)\n        self._computationBlocked[vertex] = False\n        if isinstance(vertex, CompatibilityNode):\n            compatNodes.append(vertex)\n            if not vertex.hasStatus(Status.SUCCESS):\n                self._computationBlocked[vertex] = True\n\n    def finishEdge(edge, graph):\n        (currentVertex, inputVertex) = edge\n        currentDepths = self._nodesMinMaxDepths[currentVertex]\n        inputDepths = self._nodesMinMaxDepths[inputVertex]\n        if currentDepths[0] == 0:\n            depthMin = inputDepths[0] + 1\n        else:\n            depthMin = min(currentDepths[0], inputDepths[0] + 1)\n        self._nodesMinMaxDepths[currentVertex] = (depthMin, max(currentDepths[1], inputDepths[1] + 1))\n        if currentVertex.hasStatus(Status.SUCCESS):\n            return\n        self._computationBlocked[currentVertex] |= self._computationBlocked[inputVertex]\n    leaves = self.getLeafNodes(visitor.dependenciesOnly)\n    visitor.finishEdge = finishEdge\n    visitor.discoverVertex = discoverVertex\n    self.dfs(visitor=visitor, startNodes=leaves)\n    canComputeLeaves = all([self.canCompute(node) for node in leaves])\n    if self._canComputeLeaves != canComputeLeaves:\n        self._canComputeLeaves = canComputeLeaves\n        self.canComputeLeavesChanged.emit()\n    if len(self._compatibilityNodes) != len(compatNodes):\n        self._compatibilityNodes.reset(compatNodes)",
  "def dfsMaxEdgeLength(self, startNodes=None):\n    nodesStack = []\n    edgesScore = defaultdict(lambda : 0)\n    visitor = Visitor(reverse=False, dependenciesOnly=False)\n\n    def finishEdge(edge, graph):\n        (u, v) = edge\n        for (i, n) in enumerate(reversed(nodesStack)):\n            index = i + 1\n            if index > edgesScore[n, v]:\n                edgesScore[n, v] = index\n\n    def finishVertex(vertex, graph):\n        v = nodesStack.pop()\n        assert v == vertex\n    visitor.discoverVertex = lambda vertex, graph: nodesStack.append(vertex)\n    visitor.finishVertex = finishVertex\n    visitor.finishEdge = finishEdge\n    self.dfs(visitor=visitor, startNodes=startNodes, longestPathFirst=True)\n    return edgesScore",
  "def flowEdges(self, startNodes=None):\n    flowEdges = []\n    edgesScore = self.dfsMaxEdgeLength(startNodes)\n    for (link, score) in edgesScore.items():\n        assert score != 0\n        if score == 1:\n            flowEdges.append(link)\n    return flowEdges",
  "def getEdges(self, dependenciesOnly=False):\n    if not dependenciesOnly:\n        return self.edges\n    outEdges = []\n    for e in self.edges:\n        attr = e.src\n        if dependenciesOnly:\n            if attr.isLink:\n                attr = attr.getLinkParam(recursive=True)\n            if not attr.isOutput:\n                continue\n        newE = Edge(attr, e.dst)\n        outEdges.append(newE)\n    return outEdges",
  "def getInputNodes(self, node, recursive, dependenciesOnly):\n    if not recursive:\n        return set([edge.src.node for edge in self.getEdges(dependenciesOnly) if edge.dst.node is node])\n    (inputNodes, edges) = self.dfsOnDiscover(startNodes=[node], filterTypes=None, reverse=False)\n    return inputNodes[1:]",
  "def getOutputNodes(self, node, recursive, dependenciesOnly):\n    if not recursive:\n        return set([edge.dst.node for edge in self.getEdges(dependenciesOnly) if edge.src.node is node])\n    (outputNodes, edges) = self.dfsOnDiscover(startNodes=[node], filterTypes=None, reverse=True)\n    return outputNodes[1:]",
  "@Slot(Node, result=int)\ndef canSubmitOrCompute(self, startNode):\n    if startNode.isAlreadySubmittedOrFinished():\n        return 0\n\n    class SCVisitor(Visitor):\n\n        def __init__(self, reverse, dependenciesOnly):\n            super(SCVisitor, self).__init__(reverse, dependenciesOnly)\n        canCompute = True\n        canSubmit = True\n\n        def discoverVertex(self, vertex, graph):\n            if vertex.isAlreadySubmitted():\n                self.canSubmit = False\n                if vertex.isExtern():\n                    self.canCompute = False\n    visitor = SCVisitor(reverse=False, dependenciesOnly=True)\n    self.dfs(visitor=visitor, startNodes=[startNode])\n    return visitor.canCompute + 2 * visitor.canSubmit",
  "def _applyExpr(self):\n    with GraphModification(self):\n        for node in self._nodes:\n            node._applyExpr()",
  "def toDict(self):\n    return {k: node.toDict() for (k, node) in self._nodes.objects.items()}",
  "@Slot(result=str)\ndef asString(self):\n    return str(self.toDict())",
  "def save(self, filepath=None, setupProjectFile=True, template=False):\n    path = filepath or self._filepath\n    if not path:\n        raise ValueError('filepath must be specified for unsaved files.')\n    self.header[Graph.IO.Keys.ReleaseVersion] = meshroom.__version__\n    self.header[Graph.IO.Keys.FileVersion] = Graph.IO.__version__\n    usedNodeTypes = set([n.nodeDesc.__class__ for n in self._nodes if isinstance(n, Node)])\n    self.header[Graph.IO.Keys.NodesVersions] = {'{}'.format(p.__name__): meshroom.core.nodeVersion(p, '0.0') for p in usedNodeTypes}\n    self.header['template'] = template\n    data = {}\n    if template:\n        data = {Graph.IO.Keys.Header: self.header, Graph.IO.Keys.Graph: self.getNonDefaultInputAttributes()}\n    else:\n        data = {Graph.IO.Keys.Header: self.header, Graph.IO.Keys.Graph: self.toDict()}\n    with open(path, 'w') as jsonFile:\n        json.dump(data, jsonFile, indent=4)\n    if path != self._filepath and setupProjectFile:\n        self._setFilepath(path)",
  "def getNonDefaultInputAttributes(self):\n    graph = self.toDict()\n    for nodeName in graph.keys():\n        node = self.node(nodeName)\n        inputKeys = list(graph[nodeName]['inputs'].keys())\n        for attrName in inputKeys:\n            attribute = node.attribute(attrName)\n            if attribute.isDefault and (not attribute.isLink):\n                del graph[nodeName]['inputs'][attrName]\n        del graph[nodeName]['outputs']\n        del graph[nodeName]['uids']\n        del graph[nodeName]['internalFolder']\n        del graph[nodeName]['parallelization']\n    return graph",
  "def _setFilepath(self, filepath):\n    if not os.path.isfile(filepath):\n        self._unsetFilepath()\n        return\n    if self._filepath == filepath:\n        return\n    self._filepath = filepath\n    self.name = os.path.splitext(os.path.basename(filepath))[0]\n    self.cacheDir = os.path.join(os.path.abspath(os.path.dirname(filepath)), meshroom.core.cacheFolderName)\n    self.filepathChanged.emit()",
  "def _unsetFilepath(self):\n    self._filepath = ''\n    self.name = ''\n    self.cacheDir = meshroom.core.defaultCacheFolder\n    self.filepathChanged.emit()",
  "def updateInternals(self, startNodes=None, force=False):\n    (nodes, edges) = self.dfsOnFinish(startNodes=startNodes)\n    for node in nodes:\n        if node.dirty or force:\n            node.updateInternals()",
  "def updateStatusFromCache(self, force=False):\n    for node in self._nodes:\n        if node.dirty or force:\n            node.updateStatusFromCache()",
  "def updateStatisticsFromCache(self):\n    for node in self._nodes:\n        node.updateStatisticsFromCache()",
  "def updateNodesPerUid(self):\n    nodesPerUid = {}\n    for node in self.nodes:\n        uid = node._uids.get(0)\n        try:\n            nodesPerUid.get(uid).append(node)\n        except AttributeError:\n            nodesPerUid.update({uid: [node]})\n    for node in self.nodes:\n        node.updateDuplicates(nodesPerUid)",
  "def update(self):\n    if not self._updateEnabled:\n        self._updateRequested = True\n        return\n    self.updateInternals()\n    if os.path.exists(self._cacheDir):\n        self.updateStatusFromCache()\n    for node in self.nodes:\n        node.dirty = False\n    self.updateNodesPerUid()\n    if self.dirtyTopology:\n        self.updateNodesTopologicalData()\n        self.dirtyTopology = False\n    self.updated.emit()",
  "def markNodesDirty(self, fromNode):\n    (nodes, edges) = self.dfsOnDiscover(startNodes=[fromNode], reverse=True)\n    for node in nodes:\n        node.dirty = True",
  "def stopExecution(self):\n    for chunk in self.iterChunksByStatus(Status.RUNNING):\n        if not chunk.isExtern():\n            chunk.stopProcess()",
  "@Slot()\ndef forceUnlockNodes(self):\n    for node in self.nodes:\n        node.setLocked(False)",
  "@Slot()\ndef clearSubmittedNodes(self):\n    for node in self.nodes:\n        node.clearSubmittedChunks()",
  "def clearLocallySubmittedNodes(self):\n    for node in self.nodes:\n        node.clearLocallySubmittedChunks()",
  "def iterChunksByStatus(self, status):\n    for node in self.nodes:\n        for chunk in node.chunks:\n            if chunk.status.status == status:\n                yield chunk",
  "def getChunksByStatus(self, status):\n    chunks = []\n    for node in self.nodes:\n        chunks += [chunk for chunk in node.chunks if chunk.status.status == status]\n    return chunks",
  "def getChunks(self, nodes=None):\n    chunks = []\n    for node in nodes or self.nodes:\n        chunks += [chunk for chunk in node.chunks]\n    return chunks",
  "def getOrderedChunks(self):\n    return self.getChunks(self.dfsOnFinish()[0])",
  "@property\ndef nodes(self):\n    return self._nodes",
  "@property\ndef edges(self):\n    return self._edges",
  "@property\ndef importedNodes(self):\n    return self._importedNodes",
  "@property\ndef cacheDir(self):\n    return self._cacheDir",
  "@cacheDir.setter\ndef cacheDir(self, value):\n    if self._cacheDir == value:\n        return\n    self._cacheDir = value.replace(os.path.sep, '/')\n    self.updateInternals(force=True)\n    self.updateStatusFromCache(force=True)\n    self.cacheDirChanged.emit()",
  "def setVerbose(self, v):\n    with GraphModification(self):\n        for node in self._nodes:\n            if node.hasAttribute('verbose'):\n                try:\n                    node.verbose.value = v\n                except:\n                    pass",
  "@staticmethod\ndef getFeaturesForVersion(fileVersion):\n    if isinstance(fileVersion, str):\n        fileVersion = Version(fileVersion)\n    features = [Graph.IO.Features.Graph]\n    if fileVersion >= Version('1.0'):\n        features += [Graph.IO.Features.Header, Graph.IO.Features.NodesVersions, Graph.IO.Features.PrecomputedOutputs]\n    if fileVersion >= Version('1.1'):\n        features += [Graph.IO.Features.NodesPositions]\n    return tuple(features)",
  "def createUniqueNodeName(nodeNames, inputName):\n    i = 1\n    while i:\n        newName = '{name}_{index}'.format(name=inputName, index=i)\n        if newName not in nodeNames and newName not in updatedData.keys():\n            return newName\n        i += 1",
  "def discoverVertex(vertex, graph):\n    if not filterTypes or vertex.nodeType in filterTypes:\n        nodes.append(vertex)",
  "def discoverVertex(vertex, graph):\n    if vertex.hasStatus(Status.SUCCESS):\n        raise StopBranchVisit()",
  "def finishVertex(vertex, graph):\n    chunksToProcess = []\n    for chunk in vertex.chunks:\n        if chunk.status.status is not Status.SUCCESS:\n            chunksToProcess.append(chunk)\n    if chunksToProcess:\n        nodes.append(vertex)",
  "def finishEdge(edge, graph):\n    if edge[0].hasStatus(Status.SUCCESS) or edge[1].hasStatus(Status.SUCCESS):\n        return\n    edges.append(edge)",
  "def discoverVertex(vertex, graph):\n    self._nodesMinMaxDepths[vertex] = (0, 0)\n    self._computationBlocked[vertex] = False\n    if isinstance(vertex, CompatibilityNode):\n        compatNodes.append(vertex)\n        if not vertex.hasStatus(Status.SUCCESS):\n            self._computationBlocked[vertex] = True",
  "def finishEdge(edge, graph):\n    (currentVertex, inputVertex) = edge\n    currentDepths = self._nodesMinMaxDepths[currentVertex]\n    inputDepths = self._nodesMinMaxDepths[inputVertex]\n    if currentDepths[0] == 0:\n        depthMin = inputDepths[0] + 1\n    else:\n        depthMin = min(currentDepths[0], inputDepths[0] + 1)\n    self._nodesMinMaxDepths[currentVertex] = (depthMin, max(currentDepths[1], inputDepths[1] + 1))\n    if currentVertex.hasStatus(Status.SUCCESS):\n        return\n    self._computationBlocked[currentVertex] |= self._computationBlocked[inputVertex]",
  "def finishEdge(edge, graph):\n    (u, v) = edge\n    for (i, n) in enumerate(reversed(nodesStack)):\n        index = i + 1\n        if index > edgesScore[n, v]:\n            edgesScore[n, v] = index",
  "def finishVertex(vertex, graph):\n    v = nodesStack.pop()\n    assert v == vertex",
  "def __init__(self, reverse, dependenciesOnly):\n    super(SCVisitor, self).__init__(reverse, dependenciesOnly)",
  "def discoverVertex(self, vertex, graph):\n    if vertex.isAlreadySubmitted():\n        self.canSubmit = False\n        if vertex.isExtern():\n            self.canCompute = False",
  "def hashValue(value):\n    hashObject = hashlib.sha1(str(value).encode('utf-8'))\n    return hashObject.hexdigest()",
  "@contextmanager\ndef add_to_path(p):\n    import sys\n    old_path = sys.path\n    sys.path = sys.path[:]\n    sys.path.insert(0, p)\n    try:\n        yield\n    finally:\n        sys.path = old_path",
  "def loadPlugins(folder, packageName, classType):\n    pluginTypes = []\n    errors = []\n    with add_to_path(folder):\n        package = importlib.import_module(packageName)\n        packageName = package.packageName if hasattr(package, 'packageName') else package.__name__\n        packageVersion = getattr(package, '__version__', None)\n        for (importer, pluginName, ispkg) in pkgutil.iter_modules(package.__path__):\n            pluginModuleName = '.' + pluginName\n            try:\n                pluginMod = importlib.import_module(pluginModuleName, package=package.__name__)\n                plugins = [plugin for (name, plugin) in inspect.getmembers(pluginMod, inspect.isclass) if plugin.__module__ == '{}.{}'.format(package.__name__, pluginName) and issubclass(plugin, classType)]\n                if not plugins:\n                    logging.warning('No class defined in plugin: {}'.format(pluginModuleName))\n                importPlugin = True\n                for p in plugins:\n                    if classType == desc.Node:\n                        nodeErrors = validateNodeDesc(p)\n                        if nodeErrors:\n                            errors.append('  * {}: The following parameters do not have valid default values/ranges: {}'.format(pluginName, ', '.join(nodeErrors)))\n                            importPlugin = False\n                            break\n                    p.packageName = packageName\n                    p.packageVersion = packageVersion\n                if importPlugin:\n                    pluginTypes.extend(plugins)\n            except Exception as e:\n                errors.append('  * {}: {}'.format(pluginName, str(e)))\n    if errors:\n        logging.warning('== The following \"{package}\" plugins could not be loaded ==\\n{errorMsg}\\n'.format(package=packageName, errorMsg='\\n'.join(errors)))\n    return pluginTypes",
  "def validateNodeDesc(nodeDesc):\n    errors = []\n    for param in nodeDesc.inputs:\n        err = param.checkValueTypes()\n        if err:\n            errors.append(err)\n    for param in nodeDesc.outputs:\n        err = param.checkValueTypes()\n        if err:\n            errors.append(err)\n    return errors",
  "def moduleVersion(moduleName, default=None):\n    return getattr(sys.modules[moduleName], '__version__', default)",
  "def nodeVersion(nodeDesc, default=None):\n    return moduleVersion(nodeDesc.__module__, default)",
  "def registerNodeType(nodeType):\n    global nodesDesc\n    if nodeType.__name__ in nodesDesc:\n        raise RuntimeError('Node Desc {} is already registered.'.format(nodeType.__name__))\n    nodesDesc[nodeType.__name__] = nodeType",
  "def unregisterNodeType(nodeType):\n    global nodesDesc\n    assert nodeType.__name__ in nodesDesc\n    del nodesDesc[nodeType.__name__]",
  "def loadNodes(folder, packageName):\n    return loadPlugins(folder, packageName, desc.Node)",
  "def loadAllNodes(folder):\n    global nodesDesc\n    for (importer, package, ispkg) in pkgutil.walk_packages([folder]):\n        if ispkg:\n            nodeTypes = loadNodes(folder, package)\n            for nodeType in nodeTypes:\n                registerNodeType(nodeType)\n            logging.debug('Nodes loaded [{}]: {}'.format(package, ', '.join([nodeType.__name__ for nodeType in nodeTypes])))",
  "def registerSubmitter(s):\n    global submitters\n    if s.name in submitters:\n        raise RuntimeError('Submitter {} is already registered.'.format(s.name))\n    submitters[s.name] = s",
  "def loadSubmitters(folder, packageName):\n    return loadPlugins(folder, packageName, BaseSubmitter)",
  "def loadPipelineTemplates(folder):\n    global pipelineTemplates\n    for file in os.listdir(folder):\n        if file.endswith('.mg') and file not in pipelineTemplates:\n            pipelineTemplates[os.path.splitext(file)[0]] = os.path.join(folder, file)",
  "def __init__(self, *args):\n    if len(args) == 0:\n        self.components = tuple()\n    elif len(args) == 1:\n        versionName = args[0]\n        if isinstance(versionName, str):\n            self.components = Version.toComponents(versionName)\n        elif isinstance(versionName, (list, tuple)):\n            self.components = tuple([int(v) for v in versionName])\n        else:\n            raise RuntimeError('Version: Unsupported input type.')\n    else:\n        self.components = tuple([int(v) for v in args])",
  "def __repr__(self):\n    return self.name",
  "def __neg__(self):\n    return not self.name",
  "def __len__(self):\n    return len(self.components)",
  "def __eq__(self, other):\n    return self.name == other.name",
  "def __lt__(self, other):\n    return self.components < other.components",
  "def __le__(self, other):\n    return self.components <= other.components",
  "@staticmethod\ndef toComponents(versionName):\n    if not versionName:\n        return ()\n    return tuple([int(v) for v in versionName.split('.')])",
  "@property\ndef name(self):\n    return '.'.join([str(v) for v in self.components])",
  "@property\ndef major(self):\n    return self.components[0]",
  "@property\ndef minor(self):\n    if len(self) < 2:\n        return 0\n    return self.components[1]",
  "@property\ndef micro(self):\n    if len(self) < 3:\n        return 0\n    return self.components[2]",
  "def __init__(self, manager):\n    Thread.__init__(self, target=self.run)\n    self._state = State.IDLE\n    self._manager = manager\n    self.forceCompute = False",
  "def isRunning(self):\n    return self._state == State.RUNNING",
  "def run(self):\n    self._state = State.RUNNING\n    stopAndRestart = False\n    for (nId, node) in enumerate(self._manager._nodesToProcess):\n        if node.isFinishedOrRunning():\n            continue\n        try:\n            multiChunks = len(node.chunks) > 1\n        except TypeError:\n            continue\n        for (cId, chunk) in enumerate(node.chunks):\n            if chunk.isFinishedOrRunning() or not self.isRunning():\n                continue\n            if multiChunks:\n                logging.info('[{node}/{nbNodes}]({chunk}/{nbChunks}) {nodeName}'.format(node=nId + 1, nbNodes=len(self._manager._nodesToProcess), chunk=cId + 1, nbChunks=len(node.chunks), nodeName=node.nodeType))\n            else:\n                logging.info('[{node}/{nbNodes}] {nodeName}'.format(node=nId + 1, nbNodes=len(self._manager._nodesToProcess), nodeName=node.nodeType))\n            try:\n                chunk.process(self.forceCompute)\n            except Exception as e:\n                if chunk.isStopped():\n                    stopAndRestart = True\n                    break\n                else:\n                    logging.error('Error on node computation: {}'.format(e))\n                    (nodesToRemove, _) = self._manager._graph.dfsOnDiscover(startNodes=[node], reverse=True)\n                    for n in nodesToRemove[1:]:\n                        try:\n                            self._manager._nodesToProcess.remove(n)\n                        except ValueError:\n                            pass\n                        n.clearSubmittedChunks()\n        if stopAndRestart:\n            break\n    if stopAndRestart:\n        self._state = State.STOPPED\n        self._manager.restartRequested.emit()\n    else:\n        self._manager._nodesToProcess = []\n        self._state = State.DEAD",
  "def __init__(self, parent=None):\n    super(TaskManager, self).__init__(parent)\n    self._graph = None\n    self._nodes = DictModel(keyAttrName='_name', parent=self)\n    self._nodesToProcess = []\n    self._nodesExtern = []\n    self._thread = TaskThread(self)\n    self._blockRestart = False\n    self.restartRequested.connect(self.restart)",
  "def requestBlockRestart(self):\n    self._blockRestart = True",
  "def blockRestart(self):\n    for node in self._nodesToProcess:\n        chunkCount = 0\n        for chunk in node.chunks:\n            if chunk.status.status in (Status.SUBMITTED, Status.ERROR):\n                chunk.upgradeStatusTo(Status.NONE)\n                chunkCount += 1\n        if chunkCount == len(node.chunks):\n            self.removeNode(node, displayList=True)\n    self._blockRestart = False\n    self._nodesToProcess = []\n    self._thread._state = State.DEAD",
  "@Slot()\ndef restart(self):\n    self._thread.join()\n    if self._blockRestart:\n        self.blockRestart()\n        return\n    if self._thread._state != State.STOPPED:\n        return\n    for node in self._nodesToProcess:\n        if node.getGlobalStatus() == Status.STOPPED:\n            self.removeNode(node, displayList=False, processList=True)\n            outputNodes = node.getOutputNodes(recursive=True, dependenciesOnly=True)\n            for n in outputNodes:\n                if n.getGlobalStatus() in (Status.ERROR, Status.SUBMITTED):\n                    n.upgradeStatusTo(Status.NONE)\n                    self.removeNode(n, displayList=True, processList=True)\n    self._thread = TaskThread(self)\n    self._thread.start()",
  "def compute(self, graph=None, toNodes=None, forceCompute=False, forceStatus=False):\n    self._graph = graph\n    self.updateNodes()\n    if forceCompute:\n        (nodes, edges) = graph.dfsOnFinish(startNodes=toNodes)\n        self.checkCompatibilityNodes(graph, nodes, 'COMPUTATION')\n        self.checkDuplicates(nodes, 'COMPUTATION')\n    else:\n        if not toNodes:\n            toNodes = graph.getLeafNodes(dependenciesOnly=True)\n        toNodes = list(toNodes)\n        allReady = self.checkNodesDependencies(graph, toNodes, 'COMPUTATION')\n        if not toNodes:\n            self.raiseImpossibleProcess('COMPUTATION')\n        (nodes, edges) = graph.dfsToProcess(startNodes=toNodes)\n        if not nodes:\n            logging.warning('Nothing to compute')\n            return\n        self.checkCompatibilityNodes(graph, nodes, 'COMPUTATION')\n        self.checkDuplicates(nodes, 'COMPUTATION')\n        nodes = [node for node in nodes if not self.contains(node)]\n        chunksInConflict = self.getAlreadySubmittedChunks(nodes)\n        if chunksInConflict:\n            chunksStatus = set([chunk.status.status.name for chunk in chunksInConflict])\n            chunksName = [node.name for node in chunksInConflict]\n            msg = '[COMPUTATION] Already Submitted:\\nWARNING - Some nodes are already submitted with status: {}\\nNodes: {}'.format(', '.join(chunksStatus), ', '.join(chunksName))\n            if forceStatus:\n                logging.warning(msg)\n            else:\n                raise RuntimeError(msg)\n    for node in nodes:\n        node.destroyed.connect(lambda obj=None, name=node.name: self.onNodeDestroyed(obj, name))\n        node.beginSequence(forceCompute)\n    self._nodes.update(nodes)\n    self._nodesToProcess.extend(nodes)\n    if self._thread._state == State.IDLE:\n        self._thread.start()\n    elif self._thread._state in (State.DEAD, State.ERROR):\n        self._thread = TaskThread(self)\n        self._thread.start()\n    if not allReady:\n        self.raiseDependenciesMessage('COMPUTATION')",
  "def onNodeDestroyed(self, obj, name):\n    if name in self._nodes.keys():\n        self._nodes.pop(name)",
  "def contains(self, node):\n    return node in self._nodes.values()",
  "def containsNodeName(self, name):\n    if name in self._nodes.keys():\n        return True\n    return False",
  "def removeNode(self, node, displayList=True, processList=False, externList=False):\n    if displayList and self._nodes.contains(node):\n        self._nodes.pop(node.name)\n    if processList and node in self._nodesToProcess:\n        self._nodesToProcess.remove(node)\n    if externList and node in self._nodesExtern:\n        self._nodesExtern.remove(node)",
  "def clear(self):\n    self._nodes.clear()\n    self._nodesExtern = []\n    self._nodesToProcess = []",
  "def updateNodes(self):\n    self._nodesExtern = [node for node in self._nodesExtern if node.isExtern() and node.isAlreadySubmitted()]\n    newNodes = [node for node in self._nodes if node.isAlreadySubmitted()]\n    if len(newNodes) != len(self._nodes):\n        self._nodes.clear()\n        self._nodes.update(newNodes)",
  "def update(self, graph):\n    for node in graph._nodes:\n        if node.isAlreadySubmitted() and node._chunks.size() > 0 and node.isExtern():\n            self._nodes.add(node)\n            self._nodesExtern.append(node)",
  "def checkCompatibilityNodes(self, graph, nodes, context):\n    compatNodes = []\n    for node in nodes:\n        if node in graph._compatibilityNodes.values():\n            compatNodes.append(node.nameToLabel(node.name))\n    if compatNodes:\n        raise RuntimeError('[{}] Compatibility Issue:\\nCannot compute because of these incompatible nodes:\\n{}'.format(context, sorted(compatNodes)))",
  "def checkDuplicates(self, nodesToProcess, context):\n    for node in nodesToProcess:\n        for duplicate in node.duplicates:\n            if duplicate in nodesToProcess:\n                raise RuntimeError(\"[{}] Duplicates Issue:\\nCannot compute because there are some duplicate nodes to process:\\n\\nFirst match: '{}' and '{}'\\n\\nThere can be other duplicate nodes in the list. Please, check the graph and try again.\".format(context, node.nameToLabel(node.name), node.nameToLabel(duplicate.name)))",
  "def checkNodesDependencies(self, graph, toNodes, context):\n    ready = []\n    computed = []\n    for node in toNodes:\n        if context == 'COMPUTATION':\n            if graph.canCompute(node) and graph.canSubmitOrCompute(node) % 2 == 1:\n                ready.append(node)\n            elif node.isComputed:\n                computed.append(node)\n        elif context == 'SUBMITTING':\n            if graph.canCompute(node) and graph.canSubmitOrCompute(node) > 1:\n                ready.append(node)\n            elif node.isComputed:\n                computed.append(node)\n        else:\n            raise ValueError(\"Argument 'context' must be: 'COMPUTATION' or 'SUBMITTING'\")\n    if len(ready) + len(computed) != len(toNodes):\n        toNodes.clear()\n        toNodes.extend(ready)\n        return False\n    return True",
  "def raiseDependenciesMessage(self, context):\n    raise RuntimeWarning('[{}] Unresolved dependencies:\\nSome nodes cannot be computed in LOCAL/submitted in EXTERN because of unresolved dependencies.\\n\\nNodes which are ready will be processed.'.format(context))",
  "def raiseImpossibleProcess(self, context):\n    raise RuntimeError('[{}] Impossible Process:\\nThere is no node able to be processed.'.format(context))",
  "def submit(self, graph, submitter=None, toNodes=None, submitLabel='{projectName}'):\n    sub = None\n    if submitter:\n        sub = meshroom.core.submitters.get(submitter, None)\n    elif len(meshroom.core.submitters) == 1:\n        allSubmitters = meshroom.core.submitters.values()\n        sub = next(iter(allSubmitters))\n    if sub is None:\n        raise RuntimeError(\"[SUBMITTING] Unknown Submitter:\\nUnknown Submitter called '{submitter}'. Available submitters are: '{allSubmitters}'.\".format(submitter=submitter, allSubmitters=str(meshroom.core.submitters.keys())))\n    self.updateNodes()\n    graph.update()\n    if not toNodes:\n        toNodes = graph.getLeafNodes(dependenciesOnly=True)\n    toNodes = list(toNodes)\n    allReady = self.checkNodesDependencies(graph, toNodes, 'SUBMITTING')\n    if not toNodes:\n        self.raiseImpossibleProcess('SUBMITTING')\n    (nodesToProcess, edgesToProcess) = graph.dfsToProcess(startNodes=toNodes)\n    if not nodesToProcess:\n        logging.warning('Nothing to compute')\n        return\n    self.checkCompatibilityNodes(graph, nodesToProcess, 'SUBMITTING')\n    self.checkDuplicates(nodesToProcess, 'SUBMITTING')\n    flowEdges = graph.flowEdges(startNodes=toNodes)\n    edgesToProcess = set(edgesToProcess).intersection(flowEdges)\n    logging.info('Nodes to process: {}'.format(nodesToProcess))\n    logging.info('Edges to process: {}'.format(edgesToProcess))\n    try:\n        res = sub.submit(nodesToProcess, edgesToProcess, graph.filepath, submitLabel=submitLabel)\n        if res:\n            for node in nodesToProcess:\n                node.destroyed.connect(lambda obj=None, name=node.name: self.onNodeDestroyed(obj, name))\n                node.submit()\n        self._nodes.update(nodesToProcess)\n        self._nodesExtern.extend(nodesToProcess)\n        if not allReady:\n            self.raiseDependenciesMessage('SUBMITTING')\n    except Exception as e:\n        logging.error('Error on submit : {}'.format(e))",
  "def submitFromFile(self, graphFile, submitter, toNode=None, submitLabel='{projectName}'):\n    graph = meshroom.core.graph.loadGraph(graphFile)\n    self.submit(graph, submitter, toNode, submitLabel=submitLabel)",
  "def getAlreadySubmittedChunks(self, nodes):\n    out = []\n    for node in nodes:\n        for chunk in node.chunks:\n            if chunk.isAlreadySubmitted() and (not self.containsNodeName(chunk.statusNodeName)):\n                out.append(chunk)\n    return out",
  "def __init__(self, name, label, description, value, advanced, semantic, uid, group, enabled):\n    super(Attribute, self).__init__()\n    self._name = name\n    self._label = label\n    self._description = description\n    self._value = value\n    self._uid = uid\n    self._group = group\n    self._advanced = advanced\n    self._enabled = enabled\n    self._semantic = semantic",
  "def validateValue(self, value):\n    raise NotImplementedError('Attribute.validateValue is an abstract function that should be implemented in the derived class.')",
  "def checkValueTypes(self):\n    raise NotImplementedError('Attribute.checkValueTypes is an abstract function that should be implemented in the derived class.')",
  "def matchDescription(self, value, strict=True):\n    try:\n        self.validateValue(value)\n    except ValueError:\n        return False\n    return True",
  "def __init__(self, elementDesc, name, label, description, group='allParams', advanced=False, semantic='', enabled=True, joinChar=' '):\n    self._elementDesc = elementDesc\n    self._joinChar = joinChar\n    super(ListAttribute, self).__init__(name=name, label=label, description=description, value=[], uid=(), group=group, advanced=advanced, semantic=semantic, enabled=enabled)",
  "def validateValue(self, value):\n    if JSValue is not None and isinstance(value, JSValue):\n        raise ValueError('ListAttribute.validateValue: cannot recognize QJSValue. Please, use JSON.stringify(value) in QML.')\n    if isinstance(value, str):\n        value = ast.literal_eval(value)\n    if not isinstance(value, (list, tuple)):\n        raise ValueError('ListAttribute only supports list/tuple input values (param:{}, value:{}, type:{})'.format(self.name, value, type(value)))\n    return value",
  "def checkValueTypes(self):\n    return self.elementDesc.checkValueTypes()",
  "def matchDescription(self, value, strict=True):\n    if not super(ListAttribute, self).matchDescription(value, strict):\n        return False\n    if value:\n        return self._elementDesc.matchDescription(value[0], strict)\n    return True",
  "def __init__(self, groupDesc, name, label, description, group='allParams', advanced=False, semantic='', enabled=True, joinChar=' '):\n    self._groupDesc = groupDesc\n    self._joinChar = joinChar\n    super(GroupAttribute, self).__init__(name=name, label=label, description=description, value={}, uid=(), group=group, advanced=advanced, semantic=semantic, enabled=enabled)",
  "def validateValue(self, value):\n    if JSValue is not None and isinstance(value, JSValue):\n        raise ValueError('GroupAttribute.validateValue: cannot recognize QJSValue. Please, use JSON.stringify(value) in QML.')\n    if isinstance(value, str):\n        value = ast.literal_eval(value)\n    if isinstance(value, dict):\n        if self._groupDesc:\n            commonKeys = set(value.keys()).intersection([attr.name for attr in self._groupDesc])\n            if not commonKeys:\n                raise ValueError('Value contains no key that matches with the group description: {}'.format(commonKeys))\n    elif isinstance(value, (list, tuple)):\n        if len(value) != len(self._groupDesc):\n            raise ValueError('Value contains incoherent number of values: desc size: {}, value size: {}'.format(len(self._groupDesc), len(value)))\n    else:\n        raise ValueError('GroupAttribute only supports dict/list/tuple input values (param:{}, value:{}, type:{})'.format(self.name, value, type(value)))\n    return value",
  "def checkValueTypes(self):\n    invalidParams = []\n    for attr in self.groupDesc:\n        name = attr.checkValueTypes()\n        if name:\n            invalidParams.append(name)\n    if invalidParams:\n        return self.name + ':' + str(', ' + self.name + ':').join(invalidParams)\n    return ''",
  "def matchDescription(self, value, strict=True):\n    if not super(GroupAttribute, self).matchDescription(value):\n        return False\n    attrMap = {attr.name: attr for attr in self._groupDesc}\n    matchCount = 0\n    for (k, v) in value.items():\n        if k in attrMap and attrMap[k].matchDescription(v, strict):\n            matchCount += 1\n    if strict:\n        return matchCount == len(value.items()) == len(self._groupDesc)\n    return matchCount > 0",
  "def retrieveChildrenUids(self):\n    allUids = []\n    for desc in self._groupDesc:\n        allUids.extend(desc.uid)\n    return allUids",
  "def __init__(self, name, label, description, value, uid, group, advanced, semantic, enabled):\n    super(Param, self).__init__(name=name, label=label, description=description, value=value, uid=uid, group=group, advanced=advanced, semantic=semantic, enabled=enabled)",
  "def __init__(self, name, label, description, value, uid, group='allParams', advanced=False, semantic='', enabled=True):\n    super(File, self).__init__(name=name, label=label, description=description, value=value, uid=uid, group=group, advanced=advanced, semantic=semantic, enabled=enabled)",
  "def validateValue(self, value):\n    if not isinstance(value, str):\n        raise ValueError('File only supports string input  (param:{}, value:{}, type:{})'.format(self.name, value, type(value)))\n    return os.path.normpath(value).replace('\\\\', '/') if value else ''",
  "def checkValueTypes(self):\n    if not isinstance(self.value, str) and (not callable(self.value)):\n        return self.name\n    return ''",
  "def __init__(self, name, label, description, value, uid, group='allParams', advanced=False, semantic='', enabled=True):\n    super(BoolParam, self).__init__(name=name, label=label, description=description, value=value, uid=uid, group=group, advanced=advanced, semantic=semantic, enabled=enabled)",
  "def validateValue(self, value):\n    try:\n        if isinstance(value, str):\n            return bool(distutils.util.strtobool(value))\n        return bool(value)\n    except:\n        raise ValueError('BoolParam only supports bool value (param:{}, value:{}, type:{})'.format(self.name, value, type(value)))",
  "def checkValueTypes(self):\n    if not isinstance(self.value, bool):\n        return self.name\n    return ''",
  "def __init__(self, name, label, description, value, range, uid, group='allParams', advanced=False, semantic='', enabled=True):\n    self._range = range\n    super(IntParam, self).__init__(name=name, label=label, description=description, value=value, uid=uid, group=group, advanced=advanced, semantic=semantic, enabled=enabled)",
  "def validateValue(self, value):\n    try:\n        return int(value)\n    except:\n        raise ValueError('IntParam only supports int value (param:{}, value:{}, type:{})'.format(self.name, value, type(value)))",
  "def checkValueTypes(self):\n    if not isinstance(self.value, int) or (self.range and (not all([isinstance(r, int) for r in self.range]))):\n        return self.name\n    return ''",
  "def __init__(self, name, label, description, value, range, uid, group='allParams', advanced=False, semantic='', enabled=True):\n    self._range = range\n    super(FloatParam, self).__init__(name=name, label=label, description=description, value=value, uid=uid, group=group, advanced=advanced, semantic=semantic, enabled=enabled)",
  "def validateValue(self, value):\n    try:\n        return float(value)\n    except:\n        raise ValueError('FloatParam only supports float value (param:{}, value:{}, type:{})'.format(self.name, value, type(value)))",
  "def checkValueTypes(self):\n    if not isinstance(self.value, float) or (self.range and (not all([isinstance(r, float) for r in self.range]))):\n        return self.name\n    return ''",
  "def __init__(self, name, label, description, value, values, exclusive, uid, group='allParams', joinChar=' ', advanced=False, semantic='', enabled=True):\n    assert values\n    self._values = values\n    self._exclusive = exclusive\n    self._joinChar = joinChar\n    self._valueType = type(self._values[0])\n    super(ChoiceParam, self).__init__(name=name, label=label, description=description, value=value, uid=uid, group=group, advanced=advanced, semantic=semantic, enabled=enabled)",
  "def conformValue(self, val):\n    val = self._valueType(val)\n    if val not in self.values:\n        raise ValueError('ChoiceParam value \"{}\" is not in \"{}\".'.format(val, str(self.values)))\n    return val",
  "def validateValue(self, value):\n    if self.exclusive:\n        return self.conformValue(value)\n    if isinstance(value, str):\n        value = value.split(',')\n    if not isinstance(value, Iterable):\n        raise ValueError('Non exclusive ChoiceParam value should be iterable (param:{}, value:{}, type:{})'.format(self.name, value, type(value)))\n    return [self.conformValue(v) for v in value]",
  "def checkValueTypes(self):\n    return ''",
  "def __init__(self, name, label, description, value, uid, group='allParams', advanced=False, semantic='', enabled=True):\n    super(StringParam, self).__init__(name=name, label=label, description=description, value=value, uid=uid, group=group, advanced=advanced, semantic=semantic, enabled=enabled)",
  "def validateValue(self, value):\n    if not isinstance(value, str):\n        raise ValueError('StringParam value should be a string (param:{}, value:{}, type:{})'.format(self.name, value, type(value)))\n    return value",
  "def checkValueTypes(self):\n    if not isinstance(self.value, str):\n        return self.name\n    return ''",
  "def __init__(self, iteration=0, blockSize=0, fullSize=0):\n    self.iteration = iteration\n    self.blockSize = blockSize\n    self.fullSize = fullSize",
  "@property\ndef start(self):\n    return self.iteration * self.blockSize",
  "@property\ndef effectiveBlockSize(self):\n    remaining = self.fullSize - self.start + 1\n    return self.blockSize if remaining >= self.blockSize else remaining",
  "@property\ndef end(self):\n    return self.start + self.effectiveBlockSize",
  "@property\ndef last(self):\n    return self.end - 1",
  "def toDict(self):\n    return {'rangeIteration': self.iteration, 'rangeStart': self.start, 'rangeEnd': self.end, 'rangeLast': self.last, 'rangeBlockSize': self.blockSize, 'rangeEffectiveBlockSize': self.effectiveBlockSize, 'rangeFullSize': self.fullSize}",
  "def __init__(self, staticNbBlocks=0, blockSize=0):\n    self.staticNbBlocks = staticNbBlocks\n    self.blockSize = blockSize",
  "def getSizes(self, node):\n    size = node.size\n    if self.blockSize:\n        nbBlocks = int(math.ceil(float(size) / float(self.blockSize)))\n        return (self.blockSize, size, nbBlocks)\n    if self.staticNbBlocks:\n        return (1, self.staticNbBlocks, self.staticNbBlocks)\n    return None",
  "def getRange(self, node, iteration):\n    (blockSize, fullSize, nbBlocks) = self.getSizes(node)\n    return Range(iteration=iteration, blockSize=blockSize, fullSize=fullSize)",
  "def getRanges(self, node):\n    (blockSize, fullSize, nbBlocks) = self.getSizes(node)\n    ranges = []\n    for i in range(nbBlocks):\n        ranges.append(Range(iteration=i, blockSize=blockSize, fullSize=fullSize))\n    return ranges",
  "def __init__(self, param):\n    self._param = param",
  "def computeSize(self, node):\n    param = node.attribute(self._param)\n    if param.isLink:\n        return param.getLinkParam().node.size\n    if isinstance(param.desc, ListAttribute):\n        return len(param)\n    if isinstance(param.desc, IntParam):\n        return param.value\n    return 1",
  "def __init__(self, params):\n    assert isinstance(params, (list, tuple))\n    self._params = params",
  "def computeSize(self, node):\n    size = 0\n    for param in self._params:\n        param = node.attribute(param)\n        if param.isLink:\n            size += param.getLinkParam().node.size\n        elif isinstance(param.desc, ListAttribute):\n            size += len(param)\n        else:\n            size += 1\n    return size",
  "def __init__(self, size):\n    self._size = size",
  "def computeSize(self, node):\n    return self._size",
  "def __init__(self):\n    pass",
  "def upgradeAttributeValues(self, attrValues, fromVersion):\n    return attrValues",
  "@classmethod\ndef update(cls, node):\n    pass",
  "@classmethod\ndef postUpdate(cls, node):\n    pass",
  "def stopProcess(self, chunk):\n    raise NotImplementedError('No stopProcess implementation on node: {}'.format(chunk.node.name))",
  "def processChunk(self, chunk):\n    raise NotImplementedError('No processChunk implementation on node: \"{}\"'.format(chunk.node.name))",
  "def buildCommandLine(self, chunk):\n    cmdPrefix = ''\n    if 'REZ_ENV' in os.environ and chunk.node.packageVersion:\n        alreadyInEnv = os.environ.get('REZ_{}_VERSION'.format(chunk.node.packageName.upper()), '').startswith(chunk.node.packageVersion)\n        if not alreadyInEnv:\n            cmdPrefix = '{rez} {packageFullName} -- '.format(rez=os.environ.get('REZ_ENV'), packageFullName=chunk.node.packageFullName)\n    cmdSuffix = ''\n    if chunk.node.isParallelized and chunk.node.size > 1:\n        cmdSuffix = ' ' + self.commandLineRange.format(**chunk.range.toDict())\n    return cmdPrefix + chunk.node.nodeDesc.commandLine.format(**chunk.node._cmdVars) + cmdSuffix",
  "def stopProcess(self, chunk):\n    if not hasattr(chunk, 'subprocess'):\n        return\n    if chunk.subprocess:\n        processes = chunk.subprocess.children(recursive=True) + [chunk.subprocess]\n        try:\n            for process in processes:\n                process.terminate()\n        except psutil.NoSuchProcess:\n            pass",
  "def processChunk(self, chunk):\n    try:\n        with open(chunk.logFile, 'w') as logF:\n            cmd = self.buildCommandLine(chunk)\n            chunk.status.commandLine = cmd\n            chunk.saveStatusFile()\n            print(' - commandLine: {}'.format(cmd))\n            print(' - logFile: {}'.format(chunk.logFile))\n            chunk.subprocess = psutil.Popen(shlex.split(cmd), stdout=logF, stderr=logF)\n            chunk.statThread.proc = chunk.subprocess\n            (stdout, stderr) = chunk.subprocess.communicate()\n            chunk.subprocess.wait()\n            chunk.status.returnCode = chunk.subprocess.returncode\n        if chunk.subprocess.returncode != 0:\n            with open(chunk.logFile, 'r') as logF:\n                logContent = ''.join(logF.readlines())\n            raise RuntimeError('Error on node \"{}\":\\nLog:\\n{}'.format(chunk.name, logContent))\n    except:\n        raise\n    finally:\n        chunk.subprocess = None",
  "def __init__(self):\n    if AVCommandLineNode.cgroupParsed is False:\n        AVCommandLineNode.cmdMem = ''\n        memSize = cgroup.getCgroupMemorySize()\n        if memSize > 0:\n            AVCommandLineNode.cmdMem = ' --maxMemory={memSize}'.format(memSize=memSize)\n        AVCommandLineNode.cmdCore = ''\n        coresCount = cgroup.getCgroupCpuCount()\n        if coresCount > 0:\n            AVCommandLineNode.cmdCore = ' --maxCores={coresCount}'.format(coresCount=coresCount)\n        AVCommandLineNode.cgroupParsed = True",
  "def buildCommandLine(self, chunk):\n    commandLineString = super(AVCommandLineNode, self).buildCommandLine(chunk)\n    return commandLineString + AVCommandLineNode.cmdMem + AVCommandLineNode.cmdCore",
  "def __init__(self):\n    pass",
  "def initialize(self, node, inputs, recursiveInputs):\n    pass",
  "def resetAttributes(self, node, attributeNames):\n    for attrName in attributeNames:\n        if node.hasAttribute(attrName):\n            node.attribute(attrName).resetValue()",
  "def extendAttributes(self, node, attributesDict):\n    for attr in attributesDict.keys():\n        if node.hasAttribute(attr):\n            node.attribute(attr).extend(attributesDict[attr])",
  "def setAttributes(self, node, attributesDict):\n    for attr in attributesDict:\n        if node.hasAttribute(attr):\n            node.attribute(attr).value = attributesDict[attr]",
  "def bytes2human(n):\n    symbols = ('K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y')\n    prefix = {}\n    for (i, s) in enumerate(symbols):\n        prefix[s] = 1 << (i + 1) * 10\n    for s in reversed(symbols):\n        if n >= prefix[s]:\n            value = float(n) / prefix[s]\n            return '%.2f %s' % (value, s)\n    return '%.2f B' % n",
  "def __init__(self):\n    self.nbCores = 0\n    self.cpuFreq = 0\n    self.ramTotal = 0\n    self.ramAvailable = 0\n    self.vramAvailable = 0\n    self.swapAvailable = 0\n    self.gpuMemoryTotal = 0\n    self.gpuName = ''\n    self.curves = defaultdict(list)\n    self.nvidia_smi = None\n    self._isInit = False",
  "def initOnFirstTime(self):\n    if self._isInit:\n        return\n    self._isInit = True\n    self.cpuFreq = psutil.cpu_freq().max\n    self.ramTotal = psutil.virtual_memory().total / (1024 * 1024 * 1024)\n    if platform.system() == 'Windows':\n        from distutils import spawn\n        self.nvidia_smi = spawn.find_executable('nvidia-smi')\n        if self.nvidia_smi is None:\n            default_nvidia_smi = '%s\\\\Program Files\\\\NVIDIA Corporation\\\\NVSMI\\\\nvidia-smi.exe' % os.environ['systemdrive']\n            if os.path.isfile(default_nvidia_smi):\n                self.nvidia_smi = default_nvidia_smi\n    else:\n        self.nvidia_smi = 'nvidia-smi'",
  "def _addKV(self, k, v):\n    if isinstance(v, tuple):\n        for (ki, vi) in v._asdict().items():\n            self._addKV(k + '.' + ki, vi)\n    elif isinstance(v, list):\n        for (ki, vi) in enumerate(v):\n            self._addKV(k + '.' + str(ki), vi)\n    else:\n        self.curves[k].append(v)",
  "def update(self):\n    try:\n        self.initOnFirstTime()\n        self._addKV('cpuUsage', psutil.cpu_percent(percpu=True))\n        self._addKV('ramUsage', psutil.virtual_memory().percent)\n        self._addKV('swapUsage', psutil.swap_memory().percent)\n        self._addKV('vramUsage', 0)\n        self._addKV('ioCounters', psutil.disk_io_counters())\n        self.updateGpu()\n    except Exception as e:\n        logging.debug('Failed to get statistics: \"{}\".'.format(str(e)))",
  "def updateGpu(self):\n    if not self.nvidia_smi:\n        return\n    try:\n        p = subprocess.Popen([self.nvidia_smi, '-q', '-x'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        (xmlGpu, stdError) = p.communicate(timeout=10)\n        smiTree = ET.fromstring(xmlGpu)\n        gpuTree = smiTree.find('gpu')\n        try:\n            gpuMemoryUsed = gpuTree.find('fb_memory_usage').find('used').text.split(' ')[0]\n            self._addKV('gpuMemoryUsed', gpuMemoryUsed)\n        except Exception as e:\n            logging.debug('Failed to get gpuMemoryUsed: \"{}\".'.format(str(e)))\n            pass\n        try:\n            self.gpuMemoryTotal = gpuTree.find('fb_memory_usage').find('total').text.split(' ')[0]\n        except Exception as e:\n            pass\n        try:\n            gpuUsed = gpuTree.find('utilization').find('gpu_util').text.split(' ')[0]\n            self._addKV('gpuUsed', gpuUsed)\n        except Exception as e:\n            logging.debug('Failed to get gpuUsed: \"{}\".'.format(str(e)))\n            pass\n        try:\n            gpuTemperature = gpuTree.find('temperature').find('gpu_temp').text.split(' ')[0]\n            self._addKV('gpuTemperature', gpuTemperature)\n        except Exception as e:\n            logging.debug('Failed to get gpuTemperature: \"{}\".'.format(str(e)))\n            pass\n    except subprocess.TimeoutExpired as e:\n        logging.debug('Timeout when retrieving information from nvidia_smi: \"{}\".'.format(str(e)))\n        p.kill()\n        (outs, errs) = p.communicate()\n        return\n    except Exception as e:\n        logging.debug('Failed to get information from nvidia_smi: \"{}\".'.format(str(e)))\n        return",
  "def toDict(self):\n    return self.__dict__",
  "def fromDict(self, d):\n    for (k, v) in d.items():\n        setattr(self, k, v)",
  "def __init__(self):\n    self.iterIndex = 0\n    self.lastIterIndexWithFiles = -1\n    self.duration = 0\n    self.curves = defaultdict(list)\n    self.openFiles = {}",
  "def _addKV(self, k, v):\n    if isinstance(v, tuple):\n        for (ki, vi) in v._asdict().items():\n            self._addKV(k + '.' + ki, vi)\n    elif isinstance(v, list):\n        for (ki, vi) in enumerate(v):\n            self._addKV(k + '.' + str(ki), vi)\n    else:\n        self.curves[k].append(v)",
  "def update(self, proc):\n    data = proc.as_dict(self.dynamicKeys)\n    for (k, v) in data.items():\n        self._addKV(k, v)\n    self.iterIndex += 1",
  "def toDict(self):\n    return {'duration': self.duration, 'curves': self.curves, 'openFiles': self.openFiles}",
  "def fromDict(self, d):\n    self.duration = d.get('duration', 0)\n    self.curves = d.get('curves', defaultdict(list))\n    self.openFiles = d.get('openFiles', {})",
  "def __init__(self):\n    self.computer = ComputerStatistics()\n    self.process = ProcStatistics()\n    self.times = []\n    self.interval = 10",
  "def update(self, proc):\n    if proc is None or not proc.is_running():\n        return False\n    self.times.append(time.time())\n    self.computer.update()\n    self.process.update(proc)\n    return True",
  "def toDict(self):\n    return {'fileVersion': self.fileVersion, 'computer': self.computer.toDict(), 'process': self.process.toDict(), 'times': self.times, 'interval': self.interval}",
  "def fromDict(self, d):\n    version = d.get('fileVersion', 0.0)\n    if version != self.fileVersion:\n        logging.debug('Statistics: file version was {} and the current version is {}.'.format(version, self.fileVersion))\n    self.computer = {}\n    self.process = {}\n    self.times = []\n    try:\n        self.computer.fromDict(d.get('computer', {}))\n    except Exception as e:\n        logging.debug('Failed while loading statistics: computer: \"{}\".'.format(str(e)))\n    try:\n        self.process.fromDict(d.get('process', {}))\n    except Exception as e:\n        logging.debug('Failed while loading statistics: process: \"{}\".'.format(str(e)))\n    try:\n        self.times = d.get('times', [])\n    except Exception as e:\n        logging.debug('Failed while loading statistics: times: \"{}\".'.format(str(e)))",
  "def __init__(self, chunk):\n    threading.Thread.__init__(self)\n    self.chunk = chunk\n    self.proc = psutil.Process()\n    self.statistics = chunk.statistics\n    self._stopFlag = threading.Event()",
  "def updateStats(self):\n    self.lastTime = time.time()\n    if self.chunk.statistics.update(self.proc):\n        self.chunk.saveStatistics()",
  "def run(self):\n    try:\n        while True:\n            self.updateStats()\n            if self._stopFlag.wait(self.statistics.interval):\n                if self.proc.is_running():\n                    self.updateStats()\n                return\n    except (KeyboardInterrupt, SystemError, GeneratorExit, psutil.NoSuchProcess):\n        pass",
  "def stopRequest(self):\n    self._stopFlag.set()",
  "def getWritingFilepath(filepath):\n    return filepath + '.writing.' + str(uuid.uuid4())",
  "def renameWritingToFinalPath(writingFilepath, filepath):\n    if platform.system() == 'Windows':\n        for i in range(20):\n            try:\n                os.remove(filepath)\n                break\n            except WindowsError:\n                pass\n    os.rename(writingFilepath, filepath)",
  "@atexit.register\ndef clearProcessesStatus():\n    global runningProcesses\n    for (k, v) in runningProcesses.items():\n        v.upgradeStatusTo(Status.KILLED)",
  "def nodeFactory(nodeDict, name=None, template=False):\n    nodeType = nodeDict['nodeType']\n    if 'inputs' not in nodeDict and 'attributes' in nodeDict:\n        nodeDict['inputs'] = nodeDict['attributes']\n        del nodeDict['attributes']\n    inputs = nodeDict.get('inputs', {})\n    outputs = nodeDict.get('outputs', {})\n    version = nodeDict.get('version', None)\n    internalFolder = nodeDict.get('internalFolder', None)\n    position = Position(*nodeDict.get('position', []))\n    compatibilityIssue = None\n    nodeDesc = None\n    try:\n        nodeDesc = meshroom.core.nodesDesc[nodeType]\n    except KeyError:\n        compatibilityIssue = CompatibilityIssue.UnknownNodeType\n    if nodeDesc:\n        currentNodeVersion = meshroom.core.nodeVersion(nodeDesc)\n        if version and currentNodeVersion and (Version(version).major != Version(currentNodeVersion).major):\n            compatibilityIssue = CompatibilityIssue.VersionConflict\n        else:\n            if not template and (sorted([attr.name for attr in nodeDesc.inputs]) != sorted(inputs.keys()) or sorted([attr.name for attr in nodeDesc.outputs]) != sorted(outputs.keys())):\n                compatibilityIssue = CompatibilityIssue.DescriptionConflict\n            for (attrName, value) in inputs.items():\n                if not CompatibilityNode.attributeDescFromName(nodeDesc.inputs, attrName, value):\n                    compatibilityIssue = CompatibilityIssue.DescriptionConflict\n                    break\n            for (attrName, value) in outputs.items():\n                if not CompatibilityNode.attributeDescFromName(nodeDesc.outputs, attrName, value):\n                    compatibilityIssue = CompatibilityIssue.DescriptionConflict\n                    break\n    if compatibilityIssue is None:\n        node = Node(nodeType, position, **inputs)\n    else:\n        logging.warning(\"Compatibility issue detected for node '{}': {}\".format(name, compatibilityIssue.name))\n        node = CompatibilityNode(nodeType, nodeDict, position, compatibilityIssue)\n        if not internalFolder and nodeDesc:\n            logging.warning(\"No serialized output data: performing automatic upgrade on '{}'\".format(name))\n            node = node.upgrade()\n        elif template:\n            node = node.upgrade()\n    return node",
  "def __init__(self, nodeName='', nodeType='', packageName='', packageVersion='', parent=None):\n    super(StatusData, self).__init__(parent)\n    self.status = Status.NONE\n    self.execMode = ExecMode.NONE\n    self.nodeName = nodeName\n    self.nodeType = nodeType\n    self.packageName = packageName\n    self.packageVersion = packageVersion\n    self.graph = ''\n    self.commandLine = None\n    self.env = None\n    self.startDateTime = ''\n    self.endDateTime = ''\n    self.elapsedTime = 0\n    self.hostname = ''\n    self.sessionUid = meshroom.core.sessionUid",
  "def merge(self, other):\n    self.startDateTime = min(self.startDateTime, other.startDateTime)\n    self.endDateTime = max(self.endDateTime, other.endDateTime)\n    self.elapsedTime += other.elapsedTime",
  "def reset(self):\n    self.status = Status.NONE\n    self.execMode = ExecMode.NONE\n    self.graph = ''\n    self.commandLine = None\n    self.env = None\n    self.startDateTime = ''\n    self.endDateTime = ''\n    self.elapsedTime = 0\n    self.hostname = ''\n    self.sessionUid = meshroom.core.sessionUid",
  "def initStartCompute(self):\n    import platform\n    self.sessionUid = meshroom.core.sessionUid\n    self.hostname = platform.node()\n    self.startDateTime = datetime.datetime.now().strftime(self.dateTimeFormatting)",
  "def initEndCompute(self):\n    self.sessionUid = meshroom.core.sessionUid\n    self.endDateTime = datetime.datetime.now().strftime(self.dateTimeFormatting)",
  "@property\ndef elapsedTimeStr(self):\n    return str(datetime.timedelta(seconds=self.elapsedTime))",
  "def toDict(self):\n    d = self.__dict__.copy()\n    d.pop('destroyed', None)\n    d['elapsedTimeStr'] = self.elapsedTimeStr\n    return d",
  "def fromDict(self, d):\n    self.status = d.get('status', Status.NONE)\n    if not isinstance(self.status, Status):\n        self.status = Status[self.status]\n    self.execMode = d.get('execMode', ExecMode.NONE)\n    if not isinstance(self.execMode, ExecMode):\n        self.execMode = ExecMode[self.execMode]\n    self.nodeName = d.get('nodeName', '')\n    self.nodeType = d.get('nodeType', '')\n    self.packageName = d.get('packageName', '')\n    self.packageVersion = d.get('packageVersion', '')\n    self.graph = d.get('graph', '')\n    self.commandLine = d.get('commandLine', '')\n    self.env = d.get('env', '')\n    self.startDateTime = d.get('startDateTime', '')\n    self.endDateTime = d.get('endDateTime', '')\n    self.elapsedTime = d.get('elapsedTime', 0)\n    self.hostname = d.get('hostname', '')\n    self.sessionUid = d.get('sessionUid', '')",
  "def __init__(self, chunk):\n    self.chunk = chunk\n    self.logger = logging.getLogger(chunk.node.getName())",
  "def configureLogger(self):\n    for handler in self.logger.handlers[:]:\n        self.logger.removeHandler(handler)\n    handler = logging.FileHandler(self.chunk.logFile)\n    formatter = self.Formatter('[%(asctime)s.%(msecs)03d][%(levelname)s] %(message)s', self.dateTimeFormatting)\n    handler.setFormatter(formatter)\n    self.logger.addHandler(handler)",
  "def start(self, level):\n    open(self.chunk.logFile, 'w').close()\n    self.configureLogger()\n    self.logger.setLevel(self.textToLevel(level))\n    self.progressBar = False",
  "def end(self):\n    for handler in self.logger.handlers[:]:\n        handler.close()",
  "def makeProgressBar(self, end, message=''):\n    assert end > 0\n    assert not self.progressBar\n    self.progressEnd = end\n    self.currentProgressTics = 0\n    self.progressBar = True\n    with open(self.chunk.logFile, 'a') as f:\n        if message:\n            f.write(message + '\\n')\n        f.write('0%   10   20   30   40   50   60   70   80   90   100%\\n')\n        f.write('|----|----|----|----|----|----|----|----|----|----|\\n\\n')\n        f.close()\n    with open(self.chunk.logFile, 'r') as f:\n        content = f.read()\n        self.progressBarPosition = content.rfind('\\n')\n        f.close()",
  "def updateProgressBar(self, value):\n    assert self.progressBar\n    assert value <= self.progressEnd\n    tics = round(value / self.progressEnd * 51)\n    with open(self.chunk.logFile, 'r+') as f:\n        text = f.read()\n        for i in range(tics - self.currentProgressTics):\n            text = text[:self.progressBarPosition] + '*' + text[self.progressBarPosition:]\n        f.seek(0)\n        f.write(text)\n        f.close()\n    self.currentProgressTics = tics",
  "def completeProgressBar(self):\n    assert self.progressBar\n    self.progressBar = False",
  "def textToLevel(self, text):\n    if text == 'critical':\n        return logging.CRITICAL\n    elif text == 'error':\n        return logging.ERROR\n    elif text == 'warning':\n        return logging.WARNING\n    elif text == 'info':\n        return logging.INFO\n    elif text == 'debug':\n        return logging.DEBUG\n    else:\n        return logging.NOTSET",
  "def __init__(self, node, range, parent=None):\n    super(NodeChunk, self).__init__(parent)\n    self.node = node\n    self.range = range\n    self.logManager = LogManager(self)\n    self._status = StatusData(node.name, node.nodeType, node.packageName, node.packageVersion)\n    self.statistics = stats.Statistics()\n    self.statusFileLastModTime = -1\n    self._subprocess = None\n    self.node.internalFolderChanged.connect(self.nodeFolderChanged)\n    self.execModeNameChanged.connect(self.node.globalExecModeChanged)",
  "@property\ndef index(self):\n    return self.range.iteration",
  "@property\ndef name(self):\n    if self.range.blockSize:\n        return '{}({})'.format(self.node.name, self.index)\n    else:\n        return self.node.name",
  "@property\ndef statusName(self):\n    return self._status.status.name",
  "@property\ndef logger(self):\n    return self.logManager.logger",
  "@property\ndef execModeName(self):\n    return self._status.execMode.name",
  "def updateStatusFromCache(self):\n    statusFile = self.statusFile\n    oldStatus = self._status.status\n    if not os.path.exists(statusFile):\n        self.statusFileLastModTime = -1\n        self._status.reset()\n    else:\n        try:\n            with open(statusFile, 'r') as jsonFile:\n                statusData = json.load(jsonFile)\n            self.status.fromDict(statusData)\n            self.statusFileLastModTime = os.path.getmtime(statusFile)\n        except Exception as e:\n            self.statusFileLastModTime = -1\n            self.status.reset()\n    if oldStatus != self.status.status:\n        self.statusChanged.emit()",
  "@property\ndef statusFile(self):\n    if self.range.blockSize == 0:\n        return os.path.join(self.node.graph.cacheDir, self.node.internalFolder, 'status')\n    else:\n        return os.path.join(self.node.graph.cacheDir, self.node.internalFolder, str(self.index) + '.status')",
  "@property\ndef statisticsFile(self):\n    if self.range.blockSize == 0:\n        return os.path.join(self.node.graph.cacheDir, self.node.internalFolder, 'statistics')\n    else:\n        return os.path.join(self.node.graph.cacheDir, self.node.internalFolder, str(self.index) + '.statistics')",
  "@property\ndef logFile(self):\n    if self.range.blockSize == 0:\n        return os.path.join(self.node.graph.cacheDir, self.node.internalFolder, 'log')\n    else:\n        return os.path.join(self.node.graph.cacheDir, self.node.internalFolder, str(self.index) + '.log')",
  "def saveStatusFile(self):\n    data = self._status.toDict()\n    statusFilepath = self.statusFile\n    folder = os.path.dirname(statusFilepath)\n    try:\n        os.makedirs(folder)\n    except Exception as e:\n        pass\n    statusFilepathWriting = getWritingFilepath(statusFilepath)\n    with open(statusFilepathWriting, 'w') as jsonFile:\n        json.dump(data, jsonFile, indent=4)\n    renameWritingToFinalPath(statusFilepathWriting, statusFilepath)",
  "def upgradeStatusTo(self, newStatus, execMode=None):\n    if newStatus.value <= self._status.status.value:\n        logging.warning('Downgrade status on node \"{}\" from {} to {}'.format(self.name, self._status.status, newStatus))\n    if newStatus == Status.SUBMITTED:\n        self._status = StatusData(self.node.name, self.node.nodeType, self.node.packageName, self.node.packageVersion)\n    if execMode is not None:\n        self._status.execMode = execMode\n        self.execModeNameChanged.emit()\n    self._status.status = newStatus\n    self.saveStatusFile()\n    self.statusChanged.emit()",
  "def updateStatisticsFromCache(self):\n    oldTimes = self.statistics.times\n    statisticsFile = self.statisticsFile\n    if not os.path.exists(statisticsFile):\n        return\n    with open(statisticsFile, 'r') as jsonFile:\n        statisticsData = json.load(jsonFile)\n    self.statistics.fromDict(statisticsData)\n    if oldTimes != self.statistics.times:\n        self.statisticsChanged.emit()",
  "def saveStatistics(self):\n    data = self.statistics.toDict()\n    statisticsFilepath = self.statisticsFile\n    folder = os.path.dirname(statisticsFilepath)\n    if not os.path.exists(folder):\n        os.makedirs(folder)\n    statisticsFilepathWriting = getWritingFilepath(statisticsFilepath)\n    with open(statisticsFilepathWriting, 'w') as jsonFile:\n        json.dump(data, jsonFile, indent=4)\n    renameWritingToFinalPath(statisticsFilepathWriting, statisticsFilepath)",
  "def isAlreadySubmitted(self):\n    return self._status.status in (Status.SUBMITTED, Status.RUNNING)",
  "def isAlreadySubmittedOrFinished(self):\n    return self._status.status in (Status.SUBMITTED, Status.RUNNING, Status.SUCCESS)",
  "def isFinishedOrRunning(self):\n    return self._status.status in (Status.SUCCESS, Status.RUNNING)",
  "def isRunning(self):\n    return self._status.status == Status.RUNNING",
  "def isStopped(self):\n    return self._status.status == Status.STOPPED",
  "def isFinished(self):\n    return self._status.status == Status.SUCCESS",
  "def process(self, forceCompute=False):\n    if not forceCompute and self._status.status == Status.SUCCESS:\n        logging.info('Node chunk already computed: {}'.format(self.name))\n        return\n    global runningProcesses\n    runningProcesses[self.name] = self\n    self._status.initStartCompute()\n    startTime = time.time()\n    self.upgradeStatusTo(Status.RUNNING)\n    self.statThread = stats.StatisticsThread(self)\n    self.statThread.start()\n    try:\n        self.node.nodeDesc.processChunk(self)\n    except Exception as e:\n        if self._status.status != Status.STOPPED:\n            self.upgradeStatusTo(Status.ERROR)\n        raise\n    except (KeyboardInterrupt, SystemError, GeneratorExit) as e:\n        self.upgradeStatusTo(Status.STOPPED)\n        raise\n    finally:\n        self._status.initEndCompute()\n        self._status.elapsedTime = time.time() - startTime\n        logging.info(' - elapsed time: {}'.format(self._status.elapsedTimeStr))\n        self.statThread.stopRequest()\n        self.statThread.join()\n        self.statistics = stats.Statistics()\n        del runningProcesses[self.name]\n    self.upgradeStatusTo(Status.SUCCESS)",
  "def stopProcess(self):\n    self.upgradeStatusTo(Status.STOPPED)\n    self.node.nodeDesc.stopProcess(self)",
  "def isExtern(self):\n    return self._status.execMode == ExecMode.EXTERN or (self._status.execMode == ExecMode.LOCAL and self._status.sessionUid != meshroom.core.sessionUid)",
  "def __init__(self, nodeType, position=None, parent=None, **kwargs):\n    super(BaseNode, self).__init__(parent)\n    self._nodeType = nodeType\n    self.nodeDesc = None\n    if nodeType in meshroom.core.nodesDesc:\n        self.nodeDesc = meshroom.core.nodesDesc[nodeType]()\n    self.packageName = self.packageVersion = ''\n    self._internalFolder = ''\n    self._name = None\n    self.graph = None\n    self.dirty = True\n    self._chunks = ListModel(parent=self)\n    self._uids = dict()\n    self._cmdVars = {}\n    self._size = 0\n    self._position = position or Position()\n    self._attributes = DictModel(keyAttrName='name', parent=self)\n    self.attributesPerUid = defaultdict(set)\n    self._alive = True\n    self._locked = False\n    self._duplicates = ListModel(parent=self)\n    self._hasDuplicates = False\n    self.globalStatusChanged.connect(self.updateDuplicatesStatusAndLocked)",
  "def __getattr__(self, k):\n    try:\n        return object.__getattribute__(self, k)\n    except AttributeError as e:\n        try:\n            return self.attribute(k)\n        except KeyError:\n            raise e",
  "def getName(self):\n    return self._name",
  "def getLabel(self):\n    return self.nameToLabel(self._name)",
  "@Slot(str, result=str)\ndef nameToLabel(self, name):\n    (t, idx) = name.split('_')\n    return '{}{}'.format(t, idx if int(idx) > 1 else '')",
  "def getDocumentation(self):\n    if not self.nodeDesc:\n        return ''\n    return self.nodeDesc.documentation",
  "@property\ndef packageFullName(self):\n    return '-'.join([self.packageName, self.packageVersion])",
  "@Slot(str, result=Attribute)\ndef attribute(self, name):\n    att = None\n    if '[' in name or '.' in name:\n        p = self.attributeRE.findall(name)\n        for (n, idx) in p:\n            if att is None:\n                att = self._attributes.get(n)\n            else:\n                assert isinstance(att, GroupAttribute)\n                att = att.value.get(n)\n            if idx != '':\n                assert isinstance(att, ListAttribute)\n                att = att.value.at(int(idx))\n    else:\n        att = self._attributes.get(name)\n    return att",
  "def getAttributes(self):\n    return self._attributes",
  "@Slot(str, result=bool)\ndef hasAttribute(self, name):\n    return name in self._attributes.keys()",
  "def _applyExpr(self):\n    for attr in self._attributes:\n        attr._applyExpr()",
  "@property\ndef nodeType(self):\n    return self._nodeType",
  "@property\ndef position(self):\n    return self._position",
  "@position.setter\ndef position(self, value):\n    if self._position == value:\n        return\n    self._position = value\n    self.positionChanged.emit()",
  "@property\ndef alive(self):\n    return self._alive",
  "@alive.setter\ndef alive(self, value):\n    if self._alive == value:\n        return\n    self._alive = value\n    self.aliveChanged.emit()",
  "@property\ndef depth(self):\n    return self.graph.getDepth(self)",
  "@property\ndef minDepth(self):\n    return self.graph.getDepth(self, minimal=True)",
  "def getInputNodes(self, recursive, dependenciesOnly):\n    return self.graph.getInputNodes(self, recursive=recursive, dependenciesOnly=dependenciesOnly)",
  "def getOutputNodes(self, recursive, dependenciesOnly):\n    return self.graph.getOutputNodes(self, recursive=recursive, dependenciesOnly=dependenciesOnly)",
  "def toDict(self):\n    pass",
  "def _computeUids(self):\n    for (uidIndex, associatedAttributes) in self.attributesPerUid.items():\n        uidAttributes = [(a.getName(), a.uid(uidIndex)) for a in associatedAttributes if a.enabled]\n        uidAttributes.sort()\n        self._uids[uidIndex] = hashValue(uidAttributes)",
  "def _buildCmdVars(self):\n\n    def _buildAttributeCmdVars(cmdVars, name, attr):\n        if attr.enabled:\n            group = attr.attributeDesc.group(attr.node) if isinstance(attr.attributeDesc.group, types.FunctionType) else attr.attributeDesc.group\n            if group is not None:\n                v = attr.getValueStr()\n                cmdVars[name] = '--{name} {value}'.format(name=name, value=v)\n                cmdVars[name + 'Value'] = str(v)\n                if v:\n                    cmdVars[group] = cmdVars.get(group, '') + ' ' + cmdVars[name]\n            elif isinstance(attr, GroupAttribute):\n                assert isinstance(attr.value, DictModel)\n                for v in attr._value:\n                    _buildAttributeCmdVars(cmdVars, v.name, v)\n    ' Generate command variables using input attributes and resolved output attributes names and values. '\n    for (uidIndex, value) in self._uids.items():\n        self._cmdVars['uid{}'.format(uidIndex)] = value\n    for (name, attr) in self._attributes.objects.items():\n        if attr.isOutput:\n            continue\n        _buildAttributeCmdVars(self._cmdVars, name, attr)\n    cmdVarsNoCache = self._cmdVars.copy()\n    cmdVarsNoCache['cache'] = ''\n    for (name, attr) in self._attributes.objects.items():\n        if attr.isInput:\n            continue\n        if not isinstance(attr.attributeDesc, desc.File):\n            continue\n        try:\n            defaultValue = attr.defaultValue()\n        except AttributeError as e:\n            logging.warning('Invalid lambda evaluation for \"{nodeName}.{attrName}\"'.format(nodeName=self.name, attrName=attr.name))\n        else:\n            try:\n                attr.value = defaultValue.format(**self._cmdVars)\n                attr._invalidationValue = defaultValue.format(**cmdVarsNoCache)\n            except KeyError as e:\n                logging.warning('Invalid expression with missing key on \"{nodeName}.{attrName}\" with value \"{defaultValue}\".\\nError: {err}'.format(nodeName=self.name, attrName=attr.name, defaultValue=defaultValue, err=str(e)))\n            except ValueError as e:\n                logging.warning('Invalid expression value on \"{nodeName}.{attrName}\" with value \"{defaultValue}\".\\nError: {err}'.format(nodeName=self.name, attrName=attr.name, defaultValue=defaultValue, err=str(e)))\n        v = attr.getValueStr()\n        self._cmdVars[name] = '--{name} {value}'.format(name=name, value=v)\n        self._cmdVars[name + 'Value'] = str(v)\n        if v:\n            self._cmdVars[attr.attributeDesc.group] = self._cmdVars.get(attr.attributeDesc.group, '') + ' ' + self._cmdVars[name]",
  "@property\ndef isParallelized(self):\n    return bool(self.nodeDesc.parallelization) if meshroom.useMultiChunks else False",
  "@property\ndef nbParallelizationBlocks(self):\n    return len(self._chunks)",
  "def hasStatus(self, status):\n    if not self._chunks:\n        return False\n    for chunk in self._chunks:\n        if chunk.status.status != status:\n            return False\n    return True",
  "def _isComputed(self):\n    return self.hasStatus(Status.SUCCESS)",
  "def clearData(self):\n    if self.internalFolder and os.path.exists(self.internalFolder):\n        shutil.rmtree(self.internalFolder)\n        self.updateStatusFromCache()",
  "def isAlreadySubmitted(self):\n    for chunk in self._chunks:\n        if chunk.isAlreadySubmitted():\n            return True\n    return False",
  "def isAlreadySubmittedOrFinished(self):\n    for chunk in self._chunks:\n        if not chunk.isAlreadySubmittedOrFinished():\n            return False\n    return True",
  "@Slot(result=bool)\ndef isSubmittedOrRunning(self):\n    if not self.isAlreadySubmittedOrFinished():\n        return False\n    for chunk in self._chunks:\n        if chunk.isRunning():\n            return True\n    return False",
  "@Slot(result=bool)\ndef isFinishedOrRunning(self):\n    return all((chunk.isFinishedOrRunning() for chunk in self._chunks))",
  "@Slot(result=bool)\ndef isPartiallyFinished(self):\n    return any((chunk.isFinished() for chunk in self._chunks))",
  "def alreadySubmittedChunks(self):\n    return [ch for ch in self._chunks if ch.isAlreadySubmitted()]",
  "def isExtern(self):\n    return self._chunks.at(0).isExtern()",
  "@Slot()\ndef clearSubmittedChunks(self):\n    for chunk in self._chunks:\n        if chunk.isAlreadySubmitted():\n            chunk.upgradeStatusTo(Status.NONE, ExecMode.NONE)",
  "def clearLocallySubmittedChunks(self):\n    for chunk in self._chunks:\n        if chunk.isAlreadySubmitted() and (not chunk.isExtern()):\n            chunk.upgradeStatusTo(Status.NONE, ExecMode.NONE)",
  "def upgradeStatusTo(self, newStatus):\n    for chunk in self._chunks:\n        chunk.upgradeStatusTo(newStatus)",
  "def updateStatisticsFromCache(self):\n    for chunk in self._chunks:\n        chunk.updateStatisticsFromCache()",
  "def _updateChunks(self):\n    pass",
  "def updateInternals(self, cacheDir=None):\n    if self.nodeDesc:\n        self.nodeDesc.update(self)\n    for attr in self._attributes:\n        attr.updateInternals()\n    self._updateChunks()\n    try:\n        folder = self.internalFolder\n    except KeyError:\n        folder = ''\n    self._cmdVars = {'cache': cacheDir or self.graph.cacheDir, 'nodeType': self.nodeType}\n    self._computeUids()\n    self._buildCmdVars()\n    if self.nodeDesc:\n        self.nodeDesc.postUpdate(self)\n    if self.internalFolder != folder:\n        self.internalFolderChanged.emit()",
  "@property\ndef internalFolder(self):\n    return self._internalFolder.format(**self._cmdVars)",
  "def updateStatusFromCache(self):\n    for chunk in self._chunks:\n        chunk.updateStatusFromCache()",
  "def submit(self, forceCompute=False):\n    for chunk in self._chunks:\n        if forceCompute or chunk.status.status != Status.SUCCESS:\n            chunk.upgradeStatusTo(Status.SUBMITTED, ExecMode.EXTERN)",
  "def beginSequence(self, forceCompute=False):\n    for chunk in self._chunks:\n        if forceCompute or chunk.status.status not in (Status.RUNNING, Status.SUCCESS):\n            chunk.upgradeStatusTo(Status.SUBMITTED, ExecMode.LOCAL)",
  "def processIteration(self, iteration):\n    self._chunks[iteration].process()",
  "def process(self, forceCompute=False):\n    for chunk in self._chunks:\n        chunk.process(forceCompute)",
  "def endSequence(self):\n    pass",
  "def stopComputation(self):\n    for chunk in self._chunks.values():\n        if not chunk.isExtern():\n            chunk.stopProcess()",
  "def getGlobalStatus(self):\n    chunksStatus = [chunk.status.status for chunk in self._chunks]\n    anyOf = (Status.ERROR, Status.STOPPED, Status.KILLED, Status.RUNNING, Status.SUBMITTED)\n    allOf = (Status.SUCCESS,)\n    for status in anyOf:\n        if any((s == status for s in chunksStatus)):\n            return status\n    for status in allOf:\n        if all((s == status for s in chunksStatus)):\n            return status\n    return Status.NONE",
  "@Slot(result=StatusData)\ndef getFusedStatus(self):\n    fusedStatus = StatusData()\n    if self._chunks:\n        fusedStatus.fromDict(self._chunks[0].status.toDict())\n        for chunk in self._chunks[1:]:\n            fusedStatus.merge(chunk.status)\n    fusedStatus.status = self.getGlobalStatus()\n    return fusedStatus",
  "@Slot(result=StatusData)\ndef getRecursiveFusedStatus(self):\n    fusedStatus = self.getFusedStatus()\n    nodes = self.getInputNodes(recursive=True, dependenciesOnly=True)\n    for node in nodes:\n        fusedStatus.merge(node.fusedStatus)\n    return fusedStatus",
  "def _isCompatibilityNode(self):\n    return False",
  "@property\ndef globalExecMode(self):\n    return self._chunks.at(0).execModeName",
  "def getChunks(self):\n    return self._chunks",
  "def getSize(self):\n    return self._size",
  "def setSize(self, value):\n    if self._size == value:\n        return\n    self._size = value\n    self.sizeChanged.emit()",
  "def __repr__(self):\n    return self.name",
  "def getLocked(self):\n    return self._locked",
  "def setLocked(self, lock):\n    if self._locked == lock:\n        return\n    self._locked = lock\n    self.lockedChanged.emit()",
  "@Slot()\ndef updateDuplicatesStatusAndLocked(self):\n    if self.name == self._chunks.at(0).statusNodeName:\n        for node in self._duplicates:\n            node.updateStatusFromCache()\n        self.updateLocked()",
  "def updateLocked(self):\n    currentStatus = self.getGlobalStatus()\n    lockedStatus = (Status.RUNNING, Status.SUBMITTED)\n    if self._locked and currentStatus in (Status.ERROR, Status.STOPPED, Status.NONE):\n        self.setLocked(False)\n        inputNodes = self.getInputNodes(recursive=True, dependenciesOnly=True)\n        for node in inputNodes:\n            if node.getGlobalStatus() == Status.RUNNING:\n                return\n        for node in inputNodes:\n            node.setLocked(False)\n        return\n    if not self._locked and currentStatus == Status.SUCCESS:\n        return\n    if currentStatus == Status.SUCCESS:\n        inputNodes = self.getInputNodes(recursive=True, dependenciesOnly=True)\n        outputNodes = self.getOutputNodes(recursive=True, dependenciesOnly=True)\n        stayLocked = None\n        for node in outputNodes:\n            if node.getGlobalStatus() in lockedStatus and node._chunks.at(0).statusNodeName == node.name:\n                stayLocked = True\n                break\n        if not stayLocked:\n            self.setLocked(False)\n            for node in inputNodes:\n                node.setLocked(False)\n        return\n    elif currentStatus in lockedStatus and self._chunks.at(0).statusNodeName == self.name:\n        self.setLocked(True)\n        inputNodes = self.getInputNodes(recursive=True, dependenciesOnly=True)\n        for node in inputNodes:\n            node.setLocked(True)\n        return\n    self.setLocked(False)",
  "def updateDuplicates(self, nodesPerUid):\n    uid = self._uids.get(0)\n    if not nodesPerUid or not uid:\n        if len(self._duplicates) > 0:\n            self._duplicates.clear()\n            self._hasDuplicates = False\n            self.hasDuplicatesChanged.emit()\n        return\n    newList = [node for node in nodesPerUid.get(uid) if node != self]\n    if len(newList) == len(self._duplicates):\n        newListName = set([node.name for node in newList])\n        oldListName = set([node.name for node in self._duplicates.values()])\n        if newListName == oldListName:\n            return\n    self._duplicates.setObjectList(newList)\n    if bool(len(newList)) != self._hasDuplicates:\n        self._hasDuplicates = bool(len(newList))\n        self.hasDuplicatesChanged.emit()",
  "def statusInThisSession(self):\n    if not self._chunks:\n        return False\n    for chunk in self._chunks:\n        if chunk.status.sessionUid != meshroom.core.sessionUid:\n            return False\n    return True",
  "@Slot(result=bool)\ndef canBeStopped(self):\n    return self.locked and self.getGlobalStatus() == Status.RUNNING and (self.globalExecMode == 'LOCAL') and self.statusInThisSession()",
  "@Slot(result=bool)\ndef canBeCanceled(self):\n    return self.locked and self.getGlobalStatus() == Status.SUBMITTED and (self.globalExecMode == 'LOCAL') and self.statusInThisSession()",
  "def __init__(self, nodeType, position=None, parent=None, **kwargs):\n    super(Node, self).__init__(nodeType, position, parent, **kwargs)\n    if not self.nodeDesc:\n        raise UnknownNodeTypeError(nodeType)\n    self.packageName = self.nodeDesc.packageName\n    self.packageVersion = self.nodeDesc.packageVersion\n    self._internalFolder = self.nodeDesc.internalFolder\n    for attrDesc in self.nodeDesc.inputs:\n        self._attributes.add(attributeFactory(attrDesc, None, False, self))\n    for attrDesc in self.nodeDesc.outputs:\n        self._attributes.add(attributeFactory(attrDesc, None, True, self))\n    for attr in self._attributes:\n        for uidIndex in attr.attributeDesc.uid:\n            self.attributesPerUid[uidIndex].add(attr)\n    self.setAttributeValues(kwargs)",
  "def setAttributeValues(self, values):\n    for (k, v) in values.items():\n        attr = self.attribute(k)\n        if attr.isInput:\n            attr.value = v",
  "def upgradeAttributeValues(self, values):\n    for (k, v) in values.items():\n        if not self.hasAttribute(k):\n            continue\n        attr = self.attribute(k)\n        if attr.isInput:\n            try:\n                attr.upgradeValue(v)\n            except ValueError:\n                pass",
  "def toDict(self):\n    inputs = {k: v.getExportValue() for (k, v) in self._attributes.objects.items() if v.isInput}\n    outputs = {k: v.getExportValue() for (k, v) in self._attributes.objects.items() if v.isOutput}\n    return {'nodeType': self.nodeType, 'position': self._position, 'parallelization': {'blockSize': self.nodeDesc.parallelization.blockSize if self.isParallelized else 0, 'size': self.size, 'split': self.nbParallelizationBlocks}, 'uids': self._uids, 'internalFolder': self._internalFolder, 'inputs': {k: v for (k, v) in inputs.items() if v is not None}, 'outputs': outputs}",
  "def _updateChunks(self):\n    self.setSize(self.nodeDesc.size.computeSize(self))\n    if self.isParallelized:\n        try:\n            ranges = self.nodeDesc.parallelization.getRanges(self)\n            if len(ranges) != len(self._chunks):\n                self._chunks.setObjectList([NodeChunk(self, range) for range in ranges])\n                for c in self._chunks:\n                    c.statusChanged.connect(self.globalStatusChanged)\n            else:\n                for (chunk, range) in zip(self._chunks, ranges):\n                    chunk.range = range\n        except RuntimeError:\n            logging.warning('Invalid Parallelization on node {}'.format(self._name))\n            self._chunks.clear()\n    elif len(self._chunks) != 1:\n        self._chunks.setObjectList([NodeChunk(self, desc.Range())])\n        self._chunks[0].statusChanged.connect(self.globalStatusChanged)\n    else:\n        self._chunks[0].range = desc.Range()",
  "def __init__(self, nodeType, nodeDict, position=None, issue=CompatibilityIssue.UnknownIssue, parent=None):\n    super(CompatibilityNode, self).__init__(nodeType, position, parent)\n    self.issue = issue\n    self.nodeDict = copy.deepcopy(nodeDict)\n    self.version = Version(self.nodeDict.get('version', None))\n    self._inputs = self.nodeDict.get('inputs', {})\n    self.outputs = self.nodeDict.get('outputs', {})\n    self._internalFolder = self.nodeDict.get('internalFolder', '')\n    self._uids = self.nodeDict.get('uids', {})\n    self.parallelization = self.nodeDict.get('parallelization', {})\n    self.splitCount = self.parallelization.get('split', 1)\n    self.setSize(self.parallelization.get('size', 1))\n    for (attrName, value) in self._inputs.items():\n        self._addAttribute(attrName, value, False)\n    for (attrName, value) in self.outputs.items():\n        self._addAttribute(attrName, value, True)\n    self._chunks.setObjectList([NodeChunk(self, desc.Range(i, blockSize=self.parallelization.get('blockSize', 0))) for i in range(self.splitCount)])",
  "def _isCompatibilityNode(self):\n    return True",
  "@staticmethod\ndef attributeDescFromValue(attrName, value, isOutput):\n    params = {'name': attrName, 'label': attrName, 'description': 'Incompatible parameter', 'value': value, 'uid': (), 'group': 'incompatible'}\n    if isinstance(value, bool):\n        return desc.BoolParam(**params)\n    if isinstance(value, int):\n        return desc.IntParam(range=None, **params)\n    elif isinstance(value, float):\n        return desc.FloatParam(range=None, **params)\n    elif isinstance(value, str):\n        if isOutput or os.path.isabs(value) or Attribute.isLinkExpression(value):\n            return desc.File(**params)\n        else:\n            return desc.StringParam(**params)\n    elif isinstance(value, (list, dict)):\n        del params['value']\n        del params['uid']\n        attrDesc = None\n        if isinstance(value, list):\n            elt = value[0] if value else ''\n            eltDesc = CompatibilityNode.attributeDescFromValue('element', elt, isOutput)\n            attrDesc = desc.ListAttribute(elementDesc=eltDesc, **params)\n        elif isinstance(value, dict):\n            groupDesc = []\n            for (key, value) in value.items():\n                eltDesc = CompatibilityNode.attributeDescFromValue(key, value, isOutput)\n                groupDesc.append(eltDesc)\n            attrDesc = desc.GroupAttribute(groupDesc=groupDesc, **params)\n        attrDesc._value = value\n        return attrDesc\n    return desc.StringParam(**params)",
  "@staticmethod\ndef attributeDescFromName(refAttributes, name, value, strict=True):\n    attrDesc = next((d for d in refAttributes if d.name == name), None)\n    if attrDesc is None:\n        return None\n    if Attribute.isLinkExpression(value):\n        return attrDesc\n    if attrDesc.matchDescription(value, strict):\n        return attrDesc\n    return None",
  "def _addAttribute(self, name, val, isOutput):\n    attrDesc = None\n    if self.nodeDesc:\n        refAttrs = self.nodeDesc.outputs if isOutput else self.nodeDesc.inputs\n        attrDesc = CompatibilityNode.attributeDescFromName(refAttrs, name, val)\n    matchDesc = attrDesc is not None\n    if not matchDesc:\n        attrDesc = CompatibilityNode.attributeDescFromValue(name, val, isOutput)\n    attribute = attributeFactory(attrDesc, val, isOutput, self)\n    self._attributes.add(attribute)\n    return matchDesc",
  "@property\ndef issueDetails(self):\n    if self.issue == CompatibilityIssue.UnknownNodeType:\n        return \"Unknown node type: '{}'.\".format(self.nodeType)\n    elif self.issue == CompatibilityIssue.VersionConflict:\n        return \"Node version '{}' conflicts with current version '{}'.\".format(self.nodeDict['version'], nodeVersion(self.nodeDesc))\n    elif self.issue == CompatibilityIssue.DescriptionConflict:\n        return 'Node attributes do not match node description.'\n    else:\n        return 'Unknown error.'",
  "@property\ndef inputs(self):\n    if not self.graph:\n        return self._inputs\n    return {k: v.getExportValue() for (k, v) in self._attributes.objects.items() if v.isInput}",
  "def toDict(self):\n    self.nodeDict.update({'inputs': self.inputs})\n    self.nodeDict.update({'position': self.position})\n    return self.nodeDict",
  "@property\ndef canUpgrade(self):\n    return self.nodeDesc is not None",
  "def upgrade(self):\n    if not self.canUpgrade:\n        raise NodeUpgradeError(self.name, 'no matching node type')\n    commonInputs = []\n    for (attrName, value) in self._inputs.items():\n        if self.attributeDescFromName(self.nodeDesc.inputs, attrName, value, strict=False):\n            commonInputs.append(attrName)\n    node = Node(self.nodeType, position=self.position)\n    attrValues = {key: value for (key, value) in self.inputs.items()}\n    try:\n        upgradedAttrValues = node.nodeDesc.upgradeAttributeValues(attrValues, self.version)\n    except Exception as e:\n        logging.error('Error in the upgrade implementation of the node: {}.\\n{}'.format(self.name, str(e)))\n        upgradedAttrValues = attrValues\n    if not isinstance(upgradedAttrValues, dict):\n        logging.error('Error in the upgrade implementation of the node: {}. The return type is incorrect.'.format(self.name))\n        upgradedAttrValues = attrValues\n    upgradedAttrValuesTmp = {key: value for (key, value) in upgradedAttrValues.items() if key in commonInputs}\n    node.upgradeAttributeValues(upgradedAttrValues)\n    return node",
  "def format(self, record):\n    record.levelname = record.levelname.lower()\n    return logging.Formatter.format(self, record)",
  "def _buildAttributeCmdVars(cmdVars, name, attr):\n    if attr.enabled:\n        group = attr.attributeDesc.group(attr.node) if isinstance(attr.attributeDesc.group, types.FunctionType) else attr.attributeDesc.group\n        if group is not None:\n            v = attr.getValueStr()\n            cmdVars[name] = '--{name} {value}'.format(name=name, value=v)\n            cmdVars[name + 'Value'] = str(v)\n            if v:\n                cmdVars[group] = cmdVars.get(group, '') + ' ' + cmdVars[name]\n        elif isinstance(attr, GroupAttribute):\n            assert isinstance(attr.value, DictModel)\n            for v in attr._value:\n                _buildAttributeCmdVars(cmdVars, v.name, v)",
  "def __init__(self, name, parent=None):\n    super(BaseSubmitter, self).__init__(parent)\n    self._name = name",
  "def submit(self, nodes, edges, filepath, submitLabel='{projectName}'):\n    raise NotImplementedError(\"'submit' method must be implemented in subclasses\")",
  "def progressUpdate(size=None, progress=None, logManager=None):\n    if not logManager.progressBar:\n        logManager.makeProgressBar(size, 'Upload progress:')\n    logManager.updateProgressBar(progress)",
  "def __init__(self, buf=b'', callback=None, cb_args=(), cb_kwargs={}, stopped=None):\n    self._callback = callback\n    self._cb_args = cb_args\n    self._cb_kwargs = cb_kwargs\n    self._stopped = stopped\n    self._progress = 0\n    self._len = len(buf)\n    io.BytesIO.__init__(self, buf)",
  "def __len__(self):\n    return self._len",
  "def read(self, n=-1):\n    chunk = io.BytesIO.read(self, n)\n    self._progress += int(len(chunk))\n    self._cb_kwargs.update({'size': self._len, 'progress': self._progress})\n    if self._callback:\n        try:\n            self._callback(*self._cb_args, **self._cb_kwargs)\n        except Exception as e:\n            self._cb_kwargs['logManager'].logger.warning('Error at callback: {}'.format(e))\n    if self._stopped():\n        raise RuntimeError('Node stopped by user')\n    return chunk",
  "def upload(self, apiToken, modelFile, data, chunk):\n    modelEndpoint = 'https://api.sketchfab.com/v3/models'\n    f = open(modelFile, 'rb')\n    file = {'modelFile': (os.path.basename(modelFile), f.read())}\n    file.update(data)\n    f.close()\n    (files, contentType) = requests.packages.urllib3.filepost.encode_multipart_formdata(file)\n    headers = {'Authorization': 'Token {}'.format(apiToken), 'Content-Type': contentType}\n    body = BufferReader(files, progressUpdate, cb_kwargs={'logManager': chunk.logManager}, stopped=self.stopped)\n    chunk.logger.info('Uploading...')\n    try:\n        r = requests.post(modelEndpoint, **{'data': body, 'headers': headers})\n        chunk.logManager.completeProgressBar()\n    except requests.exceptions.RequestException as e:\n        chunk.logger.error(u'An error occurred: {}'.format(e))\n        raise RuntimeError()\n    if r.status_code != requests.codes.created:\n        chunk.logger.error(u'Upload failed with error: {}'.format(r.json()))\n        raise RuntimeError()",
  "def resolvedPaths(self, inputFiles):\n    paths = []\n    for inputFile in inputFiles:\n        if os.path.isdir(inputFile.value):\n            for (path, subdirs, files) in os.walk(inputFile.value):\n                for name in files:\n                    paths.append(os.path.join(path, name))\n        else:\n            for f in glob.glob(inputFile.value):\n                paths.append(f)\n    return paths",
  "def stopped(self):\n    return self._stopped",
  "def processChunk(self, chunk):\n    try:\n        self._stopped = False\n        chunk.logManager.start(chunk.node.verboseLevel.value)\n        uploadFile = ''\n        if not chunk.node.inputFiles:\n            chunk.logger.warning('Nothing to upload')\n            return\n        if chunk.node.apiToken.value == '':\n            chunk.logger.error('Need API token.')\n            raise RuntimeError()\n        if len(chunk.node.title.value) > 48:\n            chunk.logger.error('Title cannot be longer than 48 characters.')\n            raise RuntimeError()\n        if len(chunk.node.description.value) > 1024:\n            chunk.logger.error('Description cannot be longer than 1024 characters.')\n            raise RuntimeError()\n        tags = [i.value.replace(' ', '-') for i in chunk.node.tags.value.values()]\n        if all((len(i) > 48 for i in tags)) and len(tags) > 0:\n            chunk.logger.error('Tags cannot be longer than 48 characters.')\n            raise RuntimeError()\n        if len(tags) > 42:\n            chunk.logger.error('Maximum of 42 separate tags.')\n            raise RuntimeError()\n        data = {'name': chunk.node.title.value, 'description': chunk.node.description.value, 'license': chunk.node.license.value, 'tags': str(tags), 'isPublished': chunk.node.isPublished.value, 'isInspectable': chunk.node.isInspectable.value, 'private': chunk.node.isPrivate.value, 'password': chunk.node.password.value}\n        if chunk.node.category.value != 'none':\n            data.update({'categories': chunk.node.category.value})\n        chunk.logger.debug('Data to be sent: {}'.format(str(data)))\n        uploadFile = os.path.join(chunk.node.internalFolder, 'temp.zip')\n        files = self.resolvedPaths(chunk.node.inputFiles.value)\n        zf = zipfile.ZipFile(uploadFile, 'w')\n        for file in files:\n            zf.write(file, os.path.basename(file))\n        zf.close()\n        chunk.logger.debug('Files added to zip: {}'.format(str(files)))\n        chunk.logger.debug('Created {}'.format(uploadFile))\n        chunk.logger.info('File size: {}MB'.format(round(os.path.getsize(uploadFile) / (1024 * 1024), 3)))\n        self.upload(chunk.node.apiToken.value, uploadFile, data, chunk)\n        chunk.logger.info('Upload successful. Your model is being processed on Sketchfab. It may take some time to show up on your \"models\" page.')\n    except Exception as e:\n        chunk.logger.error(e)\n        raise RuntimeError()\n    finally:\n        if os.path.isfile(uploadFile):\n            os.remove(uploadFile)\n            chunk.logger.debug('Deleted {}'.format(uploadFile))\n        chunk.logManager.end()",
  "def stopProcess(self, chunk):\n    self._stopped = True",
  "def findMetadata(d, keys, defaultValue):\n    v = None\n    for key in keys:\n        v = d.get(key, None)\n        k = key.lower()\n        if v is not None:\n            return v\n        for (dk, dv) in d.items():\n            dkm = dk.lower().replace(' ', '')\n            if dkm == key.lower():\n                return dv\n            dkm = dkm.split(':')[-1]\n            dkm = dkm.split('/')[-1]\n            if dkm == k:\n                return dv\n    return defaultValue",
  "def processChunk(self, chunk):\n    if chunk.node.nbBrackets.value == 1 or chunk.node.byPass.value:\n        return\n    super(LdrToHdrCalibration, self).processChunk(chunk)",
  "@classmethod\ndef update(cls, node):\n    if not isinstance(node.nodeDesc, cls):\n        raise ValueError('Node {} is not an instance of type {}'.format(node, cls))\n    if 'userNbBrackets' not in node.getAttributes().keys():\n        return\n    if node.userNbBrackets.value != 0:\n        node.nbBrackets.value = node.userNbBrackets.value\n        return\n    cameraInitOutput = node.input.getLinkParam(recursive=True)\n    if not cameraInitOutput:\n        node.nbBrackets.value = 0\n        return\n    if not cameraInitOutput.node.hasAttribute('viewpoints'):\n        if cameraInitOutput.node.hasAttribute('input'):\n            cameraInitOutput = cameraInitOutput.node.input.getLinkParam(recursive=True)\n    if cameraInitOutput and cameraInitOutput.node and cameraInitOutput.node.hasAttribute('viewpoints'):\n        viewpoints = cameraInitOutput.node.viewpoints.value\n    else:\n        node.nbBrackets.value = 0\n        return\n    inputs = []\n    for viewpoint in viewpoints:\n        jsonMetadata = viewpoint.metadata.value\n        if not jsonMetadata:\n            node.nbBrackets.value = 0\n            return\n        d = json.loads(jsonMetadata)\n        fnumber = findMetadata(d, ['FNumber', 'Exif:ApertureValue', 'ApertureValue', 'Aperture'], '')\n        shutterSpeed = findMetadata(d, ['Exif:ShutterSpeedValue', 'ShutterSpeedValue', 'ShutterSpeed'], '')\n        iso = findMetadata(d, ['Exif:ISOSpeedRatings', 'ISOSpeedRatings', 'ISO'], '')\n        if not fnumber and (not shutterSpeed):\n            node.nbBrackets.value = 1\n            return\n        inputs.append((viewpoint.path.value, (fnumber, shutterSpeed, iso)))\n    inputs.sort()\n    exposureGroups = []\n    exposures = []\n    for (path, exp) in inputs:\n        if exposures and exp != exposures[-1] and (exp == exposures[0]):\n            exposureGroups.append(exposures)\n            exposures = [exp]\n        else:\n            exposures.append(exp)\n    exposureGroups.append(exposures)\n    exposures = None\n    bracketSizes = set()\n    if len(exposureGroups) == 1:\n        if len(set(exposureGroups[0])) == 1:\n            node.nbBrackets.value = 1\n        else:\n            node.nbBrackets.value = len(exposureGroups[0])\n    else:\n        for expGroup in exposureGroups:\n            bracketSizes.add(len(expGroup))\n        if len(bracketSizes) == 1:\n            node.nbBrackets.value = bracketSizes.pop()\n        else:\n            node.nbBrackets.value = 0",
  "def readSfMData(sfmFile):\n    with open(sfmFile, 'r', encoding='utf-8', errors='ignore') as f:\n        data = json.load(f)\n    intrinsicsKeys = [i.name for i in Intrinsic]\n    intrinsics = [{k: v for (k, v) in item.items() if k in intrinsicsKeys} for item in data.get('intrinsics', [])]\n    for intrinsic in intrinsics:\n        pp = intrinsic['principalPoint']\n        intrinsic['principalPoint'] = {}\n        intrinsic['principalPoint']['x'] = pp[0]\n        intrinsic['principalPoint']['y'] = pp[1]\n        if intrinsic['distortionParams'] == '':\n            intrinsic['distortionParams'] = list()\n    viewsKeys = [v.name for v in Viewpoint]\n    views = [{k: v for (k, v) in item.items() if k in viewsKeys} for item in data.get('views', [])]\n    for view in views:\n        view['metadata'] = json.dumps(view['metadata'])\n    return (views, intrinsics)",
  "def __init__(self):\n    super(CameraInit, self).__init__()",
  "def initialize(self, node, inputs, recursiveInputs):\n    self.resetAttributes(node, ['viewpoints', 'intrinsics'])\n    filesByType = FilesByType()\n    searchedForImages = False\n    if recursiveInputs:\n        filesByType.extend(findFilesByTypeInFolder(recursiveInputs, recursive=True))\n        searchedForImages = True\n    if len(inputs) == 1 and os.path.isfile(inputs[0]) and (os.path.splitext(inputs[0])[-1] in ('.json', '.sfm')):\n        (views, intrinsics) = readSfMData(inputs[0])\n        self.extendAttributes(node, {'viewpoints': views, 'intrinsics': intrinsics})\n    else:\n        filesByType.extend(findFilesByTypeInFolder(inputs, recursive=False))\n        searchedForImages = True\n    if searchedForImages and (not filesByType.images):\n        raise ValueError('No valid input file or no image in the provided directories')\n    (views, intrinsics) = self.buildIntrinsics(node, filesByType.images)\n    self.setAttributes(node, {'viewpoints': views, 'intrinsics': intrinsics})",
  "def upgradeAttributeValues(self, attrValues, fromVersion):\n    if fromVersion < Version(6, 0):\n        for intrinsic in attrValues['intrinsics']:\n            principalPoint = intrinsic['principalPoint']\n            intrinsic['principalPoint'] = {'x': int(principalPoint['x'] - 0.5 * intrinsic['width']), 'y': int(principalPoint['y'] - 0.5 * intrinsic['height'])}\n    if fromVersion < Version(7, 0):\n        for intrinsic in attrValues['intrinsics']:\n            pxInitialFocalLength = intrinsic['pxInitialFocalLength']\n            pxFocalLength = intrinsic['pxFocalLength']\n            sensorWidth = intrinsic['sensorWidth']\n            width = intrinsic['width']\n            focalLength = pxFocalLength / width * sensorWidth\n            initialFocalLength = pxInitialFocalLength / width * sensorWidth\n            intrinsic['initialFocalLength'] = initialFocalLength\n            intrinsic['focalLength'] = focalLength\n            intrinsic['pixelRatio'] = 1.0\n            intrinsic['pixelRatioLocked'] = False\n    return attrValues",
  "def readSfMData(self, sfmFile):\n    return readSfMData(sfmFile)",
  "def buildIntrinsics(self, node, additionalViews=()):\n    assert isinstance(node.nodeDesc, CameraInit)\n    if node.graph:\n        node = node.graph.copyNode(node)[0]\n    tmpCache = tempfile.mkdtemp()\n    node.updateInternals(tmpCache)\n    try:\n        os.makedirs(os.path.join(tmpCache, node.internalFolder))\n        self.createViewpointsFile(node, additionalViews)\n        cmd = self.buildCommandLine(node.chunks[0])\n        logging.debug(' - commandLine: {}'.format(cmd))\n        proc = psutil.Popen(cmd, stdout=None, stderr=None, shell=True)\n        (stdout, stderr) = proc.communicate()\n        if proc.returncode != 0:\n            raise RuntimeError('CameraInit failed with error code {}.\\nCommand was: \"{}\".\\n'.format(proc.returncode, cmd))\n        cameraInitSfM = node.output.value\n        return readSfMData(cameraInitSfM)\n    except Exception as e:\n        logging.debug('[CameraInit] Error while building intrinsics: {}'.format(str(e)))\n        raise\n    finally:\n        if os.path.exists(tmpCache):\n            logging.debug('[CameraInit] Remove temp files in: {}'.format(tmpCache))\n            shutil.rmtree(tmpCache)",
  "def createViewpointsFile(self, node, additionalViews=()):\n    node.viewpointsFile = ''\n    if node.viewpoints or additionalViews:\n        newViews = []\n        for path in additionalViews:\n            newViews.append({'path': path})\n        intrinsics = node.intrinsics.getPrimitiveValue(exportDefault=True)\n        for intrinsic in intrinsics:\n            intrinsic['principalPoint'] = [intrinsic['principalPoint']['x'], intrinsic['principalPoint']['y']]\n        views = node.viewpoints.getPrimitiveValue(exportDefault=False)\n        for view in views:\n            if 'metadata' in view:\n                view['metadata'] = json.loads(view['metadata'])\n        sfmData = {'version': [1, 2, 2], 'views': views + newViews, 'intrinsics': intrinsics, 'featureFolder': '', 'matchingFolder': ''}\n        node.viewpointsFile = os.path.join(node.nodeDesc.internalFolder, 'viewpoints.sfm').format(**node._cmdVars)\n        with open(node.viewpointsFile, 'w') as f:\n            json.dump(sfmData, f, indent=4)",
  "def buildCommandLine(self, chunk):\n    cmd = desc.CommandLineNode.buildCommandLine(self, chunk)\n    if chunk.node.viewpointsFile:\n        cmd += ' --input \"{}\"'.format(chunk.node.viewpointsFile)\n    return cmd",
  "def processChunk(self, chunk):\n    self.createViewpointsFile(chunk.node)\n    desc.CommandLineNode.processChunk(self, chunk)",
  "def findMetadata(d, keys, defaultValue):\n    v = None\n    for key in keys:\n        v = d.get(key, None)\n        k = key.lower()\n        if v is not None:\n            return v\n        for (dk, dv) in d.items():\n            dkm = dk.lower().replace(' ', '')\n            if dkm == key.lower():\n                return dv\n            dkm = dkm.split(':')[-1]\n            dkm = dkm.split('/')[-1]\n            if dkm == k:\n                return dv\n    return defaultValue",
  "@classmethod\ndef update(cls, node):\n    if not isinstance(node.nodeDesc, cls):\n        raise ValueError('Node {} is not an instance of type {}'.format(node, cls))\n    if 'userNbBrackets' not in node.getAttributes().keys():\n        return\n    if node.userNbBrackets.value != 0:\n        node.nbBrackets.value = node.userNbBrackets.value\n        return\n    cameraInitOutput = node.input.getLinkParam(recursive=True)\n    if not cameraInitOutput:\n        node.nbBrackets.value = 0\n        return\n    if not cameraInitOutput.node.hasAttribute('viewpoints'):\n        if cameraInitOutput.node.hasAttribute('input'):\n            cameraInitOutput = cameraInitOutput.node.input.getLinkParam(recursive=True)\n    if cameraInitOutput and cameraInitOutput.node and cameraInitOutput.node.hasAttribute('viewpoints'):\n        viewpoints = cameraInitOutput.node.viewpoints.value\n    else:\n        node.nbBrackets.value = 0\n        return\n    inputs = []\n    for viewpoint in viewpoints:\n        jsonMetadata = viewpoint.metadata.value\n        if not jsonMetadata:\n            node.nbBrackets.value = 0\n            return\n        d = json.loads(jsonMetadata)\n        fnumber = findMetadata(d, ['FNumber', 'Exif:ApertureValue', 'ApertureValue', 'Aperture'], '')\n        shutterSpeed = findMetadata(d, ['Exif:ShutterSpeedValue', 'ShutterSpeedValue', 'ShutterSpeed'], '')\n        iso = findMetadata(d, ['Exif:ISOSpeedRatings', 'ISOSpeedRatings', 'ISO'], '')\n        if not fnumber and (not shutterSpeed):\n            node.nbBrackets.value = 1\n            return\n        inputs.append((viewpoint.path.value, (fnumber, shutterSpeed, iso)))\n    inputs.sort()\n    exposureGroups = []\n    exposures = []\n    for (path, exp) in inputs:\n        if exposures and exp != exposures[-1] and (exp == exposures[0]):\n            exposureGroups.append(exposures)\n            exposures = [exp]\n        else:\n            exposures.append(exp)\n    exposureGroups.append(exposures)\n    exposures = None\n    bracketSizes = set()\n    if len(exposureGroups) == 1:\n        if len(set(exposureGroups[0])) == 1:\n            node.nbBrackets.value = 1\n        else:\n            node.nbBrackets.value = len(exposureGroups[0])\n    else:\n        for expGroup in exposureGroups:\n            bracketSizes.add(len(expGroup))\n        if len(bracketSizes) == 1:\n            node.nbBrackets.value = bracketSizes.pop()\n        else:\n            node.nbBrackets.value = 0",
  "def upgradeAttributeValues(self, attrValues, fromVersion):\n    if fromVersion < Version(6, 0):\n        outputTextureFileType = attrValues['outputTextureFileType']\n        if isinstance(outputTextureFileType, str):\n            attrValues['colorMapping'] = {}\n            attrValues['colorMapping']['colorMappingFileType'] = outputTextureFileType\n    return attrValues",
  "def findMetadata(d, keys, defaultValue):\n    v = None\n    for key in keys:\n        v = d.get(key, None)\n        k = key.lower()\n        if v is not None:\n            return v\n        for (dk, dv) in d.items():\n            dkm = dk.lower().replace(' ', '')\n            if dkm == key.lower():\n                return dv\n            dkm = dkm.split(':')[-1]\n            dkm = dkm.split('/')[-1]\n            if dkm == k:\n                return dv\n    return defaultValue",
  "def __init__(self, param, divParam):\n    super(DividedInputNodeSize, self).__init__(param)\n    self._divParam = divParam",
  "def computeSize(self, node):\n    s = super(DividedInputNodeSize, self).computeSize(node)\n    divParam = node.attribute(self._divParam)\n    if divParam.value == 0:\n        return s\n    return s / divParam.value",
  "def processChunk(self, chunk):\n    if chunk.node.nbBrackets.value == 1 or chunk.node.byPass.value:\n        return\n    super(LdrToHdrSampling, self).processChunk(chunk)",
  "@classmethod\ndef update(cls, node):\n    if not isinstance(node.nodeDesc, cls):\n        raise ValueError('Node {} is not an instance of type {}'.format(node, cls))\n    if 'userNbBrackets' not in node.getAttributes().keys():\n        return\n    if node.userNbBrackets.value != 0:\n        node.nbBrackets.value = node.userNbBrackets.value\n        return\n    cameraInitOutput = node.input.getLinkParam(recursive=True)\n    if not cameraInitOutput:\n        node.nbBrackets.value = 0\n        return\n    if not cameraInitOutput.node.hasAttribute('viewpoints'):\n        if cameraInitOutput.node.hasAttribute('input'):\n            cameraInitOutput = cameraInitOutput.node.input.getLinkParam(recursive=True)\n    if cameraInitOutput and cameraInitOutput.node and cameraInitOutput.node.hasAttribute('viewpoints'):\n        viewpoints = cameraInitOutput.node.viewpoints.value\n    else:\n        node.nbBrackets.value = 0\n        return\n    inputs = []\n    for viewpoint in viewpoints:\n        jsonMetadata = viewpoint.metadata.value\n        if not jsonMetadata:\n            node.nbBrackets.value = 0\n            return\n        d = json.loads(jsonMetadata)\n        fnumber = findMetadata(d, ['FNumber', 'Exif:ApertureValue', 'ApertureValue', 'Aperture'], '')\n        shutterSpeed = findMetadata(d, ['Exif:ShutterSpeedValue', 'ShutterSpeedValue', 'ShutterSpeed'], '')\n        iso = findMetadata(d, ['Exif:ISOSpeedRatings', 'ISOSpeedRatings', 'ISO'], '')\n        if not fnumber and (not shutterSpeed):\n            node.nbBrackets.value = 1\n            return\n        inputs.append((viewpoint.path.value, (fnumber, shutterSpeed, iso)))\n    inputs.sort()\n    exposureGroups = []\n    exposures = []\n    for (path, exp) in inputs:\n        if exposures and exp != exposures[-1] and (exp == exposures[0]):\n            exposureGroups.append(exposures)\n            exposures = [exp]\n        else:\n            exposures.append(exp)\n    exposureGroups.append(exposures)\n    exposures = None\n    bracketSizes = set()\n    if len(exposureGroups) == 1:\n        if len(set(exposureGroups[0])) == 1:\n            node.nbBrackets.value = 1\n        else:\n            node.nbBrackets.value = len(exposureGroups[0])\n    else:\n        for expGroup in exposureGroups:\n            bracketSizes.add(len(expGroup))\n        if len(bracketSizes) == 1:\n            node.nbBrackets.value = bracketSizes.pop()\n        else:\n            node.nbBrackets.value = 0",
  "def resolvedPaths(self, inputFiles, outDir):\n    paths = {}\n    for inputFile in inputFiles:\n        for f in glob.glob(inputFile.value):\n            paths[f] = os.path.join(outDir, os.path.basename(f))\n    return paths",
  "def processChunk(self, chunk):\n    try:\n        chunk.logManager.start(chunk.node.verboseLevel.value)\n        if not chunk.node.inputFiles:\n            chunk.logger.warning('Nothing to publish')\n            return\n        if not chunk.node.output.value:\n            return\n        outFiles = self.resolvedPaths(chunk.node.inputFiles.value, chunk.node.output.value)\n        if not outFiles:\n            error = 'Publish: input files listed, but nothing to publish'\n            chunk.logger.error(error)\n            chunk.logger.info('Listed input files: {}'.format([i.value for i in chunk.node.inputFiles.value]))\n            raise RuntimeError(error)\n        if not os.path.exists(chunk.node.output.value):\n            os.mkdir(chunk.node.output.value)\n        for (iFile, oFile) in outFiles.items():\n            chunk.logger.info('Publish file {} into {}'.format(iFile, oFile))\n            shutil.copyfile(iFile, oFile)\n        chunk.logger.info('Publish end')\n    finally:\n        chunk.logManager.end()",
  "def outputImagesValueFunct(attr):\n    basename = os.path.basename(attr.node.input.value)\n    fileStem = os.path.splitext(basename)[0]\n    inputExt = os.path.splitext(basename)[1]\n    outputExt = '.' + attr.node.extension.value if attr.node.extension.value else None\n    if inputExt in ['.abc', '.sfm']:\n        return desc.Node.internalFolder + '<VIEW_ID>' + (outputExt or '.*')\n    if inputExt:\n        return desc.Node.internalFolder + fileStem + (outputExt or inputExt)\n    if '*' in fileStem:\n        return desc.Node.internalFolder + fileStem + (outputExt or '.*')\n    return desc.Node.internalFolder + '*' + (outputExt or '.*')",
  "def main():\n    argv = sys.argv\n    if '--' not in argv:\n        argv = []\n    else:\n        argv = argv[argv.index('--') + 1:]\n    usage_text = 'Run blender in background mode with this script:  blender --background --python ' + __file__ + ' -- [options]'\n    parser = argparse.ArgumentParser(description=usage_text)\n    parser.add_argument('--sfmCameraPath', metavar='FILE', required=True, help='sfmData with the animated camera.')\n    parser.add_argument('--useBackground', type=strtobool, required=True, help='Display the background image or not.')\n    parser.add_argument('--undistortedImages', metavar='FILE', required=False, help='Save the generated file to the specified path')\n    parser.add_argument('--model', metavar='FILE', required=True, help='Point Cloud or Mesh used in the rendering.')\n    parser.add_argument('--pointCloudDensity', type=float, required=False, help='Number of point from the cloud rendered')\n    parser.add_argument('--particleSize', type=float, required=False, help='Scale of particles used to show the point cloud')\n    parser.add_argument('--particleColor', type=str, required=False, help='Color of particles used to show the point cloud (SFM Data is .abc)')\n    parser.add_argument('--edgeColor', type=str, required=False, help='Color of the edges of the rendered object (SFM Data is .obj)')\n    parser.add_argument('--videoFormat', type=str, required=True, help='Format of the video output')\n    parser.add_argument('--outputPath', metavar='FILE', required=True, help='Render an image to the specified path')\n    args = parser.parse_args(argv)\n    if not argv:\n        parser.print_help()\n        return -1\n    if not args.undistortedImages and args.useBackground:\n        print('Error: --undistortedImages argument not given, aborting.')\n        parser.print_help()\n        return -1\n    try:\n        for objects in bpy.data.objects:\n            bpy.data.objects.remove(objects)\n    except RuntimeError:\n        print('Error while clearing current scene')\n        raise\n    switcher = {'Grey': (0.2, 0.2, 0.2, 1), 'White': (1, 1, 1, 1), 'Red': (0.5, 0, 0, 1), 'Green': (0, 0.5, 0, 1), 'Magenta': (1.0, 0, 0.75, 1)}\n    print('Import Undistorted Images')\n    undis_imgs = []\n    number_of_frame = 0\n    offset = 0\n    first_image_name = ''\n    try:\n        if args.useBackground:\n            files = os.listdir(args.undistortedImages)\n            for f in files:\n                if f.endswith('.exr') and (not f.__contains__('UVMap')):\n                    undis_imgs.append({'name': f})\n            number_of_frame = len(undis_imgs)\n            print('undis_imgs: ' + str(undis_imgs))\n            first_image_name = undis_imgs[0]['name']\n            offset = int(re.findall('\\\\d+', first_image_name)[-1]) - 1\n    except RuntimeError:\n        print('Error while importing the undistorted images.')\n        raise\n    print('Import Animated Camera')\n    try:\n        bpy.ops.wm.alembic_import(filepath=args.sfmCameraPath)\n        animated_cams = bpy.context.selected_editable_objects[:]\n        cam_location = mathutils.Vector((0, 0, 0))\n        cam_obj = None\n        for obj in animated_cams:\n            if obj.data and obj.data.type == 'PERSP' and ('anim' in obj.data.name):\n                bpy.context.scene.collection.objects.link(obj)\n                bpy.context.view_layer.objects.active = obj\n                bpy.context.scene.camera = obj\n                cam_location = obj.location\n                cam_obj = obj\n                if args.useBackground:\n                    bpy.ops.image.open(filepath=args.undistortedImages + '/' + first_image_name, directory=args.undistortedImages, files=undis_imgs, relative_path=True, show_multiview=False)\n                    bpy.data.cameras[obj.data.name].background_images.new()\n                    bpy.data.cameras[obj.data.name].show_background_images = True\n                    bpy.data.cameras[obj.data.name].background_images[0].image = bpy.data.images[first_image_name]\n                    bpy.data.cameras[obj.data.name].background_images[0].frame_method = 'CROP'\n                    bpy.data.cameras[obj.data.name].background_images[0].image_user.frame_offset = offset\n                    bpy.data.cameras[obj.data.name].background_images[0].image_user.frame_duration = number_of_frame\n                    bpy.data.cameras[obj.data.name].background_images[0].image_user.frame_start = 1\n                    bpy.context.scene.render.film_transparent = True\n    except RuntimeError:\n        print('Error while importing the alembic file (Animated Camera): ' + args.sfmCameraPath)\n        raise\n    print('Create the particle plane')\n    try:\n        plane = bpy.data.meshes.new('Plane')\n        objectsPlane = bpy.data.objects.new(name='Plane', object_data=plane)\n        bm = bmesh.new()\n        bmesh.ops.create_grid(bm, x_segments=1, y_segments=1, size=1.0)\n        bm.to_mesh(plane)\n        bm.free()\n        if args.model.lower().endswith('.abc'):\n            objectsPlane.scale = mathutils.Vector((args.particleSize, args.particleSize, args.particleSize))\n        cam_location.y += -2.0\n        objectsPlane.location = cam_location\n        bpy.context.scene.collection.objects.link(objectsPlane)\n        bpy.data.objects['Plane'].parent = cam_obj\n        bpy.context.view_layer.objects.active = objectsPlane\n        col = bpy.data.materials.new('Color')\n        objectsPlane.active_material = col\n        objectsPlane.active_material.use_nodes = True\n        objectsPlane.active_material.node_tree.links.clear()\n        objectsPlane.active_material.node_tree.nodes.new(type='ShaderNodeEmission')\n        objectsPlane.active_material.node_tree.links.new(objectsPlane.active_material.node_tree.nodes['Emission'].outputs['Emission'], objectsPlane.active_material.node_tree.nodes['Material Output'].inputs['Surface'])\n        if args.model.lower().endswith('.abc'):\n            objectsPlane.active_material.node_tree.nodes['Emission'].inputs[0].default_value = switcher.get(args.particleColor, 'Invalid Color')\n    except RuntimeError:\n        print('Error: while setting up the particle model.')\n        raise\n    if args.model.lower().endswith('.abc'):\n        print('Import ABC Point Cloud')\n        try:\n            bpy.ops.wm.alembic_import(filepath=args.model)\n            all_abc_info = bpy.context.selected_editable_objects[:]\n            for obj in all_abc_info:\n                if obj.name == 'mvgPointCloud.001':\n                    bpy.context.scene.collection.objects.link(obj)\n                    bpy.context.view_layer.objects.active = obj\n                    obj.modifiers.new('ParticleSystem', 'PARTICLE_SYSTEM')\n                    particle_system = bpy.data.particles['ParticleSystem']\n                    particle_system.render_type = 'OBJECT'\n                    particle_system.instance_object = bpy.data.objects['Plane']\n                    particle_system.emit_from = 'VERT'\n                    if args.model.lower().endswith('.abc'):\n                        particle_system.count = int(args.pointCloudDensity * len(obj.data.vertices.values()))\n                    particle_system.frame_end = 1.0\n                    particle_system.use_emit_random = False\n                    particle_system.particle_size = 0.02\n                    particle_system.physics_type = 'NO'\n                    particle_system.use_rotations = True\n                    particle_system.use_rotation_instance = True\n                    particle_system.rotation_mode = 'GLOB_X'\n        except RuntimeError:\n            print('Error while importing the alembic file (Point Cloud): ' + args.model)\n            raise\n    elif args.model.lower().endswith('.obj'):\n        print('Import OBJ')\n        bpy.ops.import_scene.obj(filepath=args.model)\n        center = bpy.data.materials.new('Center')\n        center.use_nodes = True\n        center.node_tree.links.clear()\n        center.node_tree.nodes.new(type='ShaderNodeEmission')\n        center.node_tree.links.new(center.node_tree.nodes['Emission'].outputs['Emission'], center.node_tree.nodes['Material Output'].inputs['Surface'])\n        center.node_tree.nodes['Emission'].inputs[0].default_value = (0, 0, 0, 0)\n        if not args.useBackground and args.model.lower().endswith('.obj'):\n            center.node_tree.nodes['Emission'].inputs[0].default_value = (0.05, 0.05, 0.05, 1)\n        edge = bpy.data.materials.new('Edge')\n        edge.use_nodes = True\n        edge.node_tree.links.clear()\n        edge.node_tree.nodes.new(type='ShaderNodeEmission')\n        edge.use_backface_culling = True\n        edge.node_tree.links.new(edge.node_tree.nodes['Emission'].outputs['Emission'], edge.node_tree.nodes['Material Output'].inputs['Surface'])\n        edge.node_tree.nodes['Emission'].inputs[0].default_value = switcher.get(args.edgeColor, 'Invalid Color')\n        bpy.data.meshes['mesh'].materials.clear()\n        bpy.data.meshes['mesh'].materials.append(bpy.data.materials['Center'])\n        bpy.data.meshes['mesh'].materials.append(bpy.data.materials['Edge'])\n        print(bpy.data.meshes['mesh'].materials.values())\n        bpy.data.objects['mesh'].modifiers.new('New', type='SOLIDIFY')\n        bpy.data.objects['mesh'].modifiers['New'].thickness = -0.01\n        bpy.data.objects['mesh'].modifiers['New'].use_rim = False\n        bpy.data.objects['mesh'].modifiers['New'].use_flip_normals = True\n        bpy.data.objects['mesh'].modifiers['New'].material_offset = 1\n    else:\n        raise ValueError('sfmData: unknown file format, only alembic (.abc) and object (.obj) are supported: ' + args.model)\n    print('Create compositing graph')\n    try:\n        bpy.context.scene.use_nodes = True\n        bpy.context.scene.node_tree.nodes.new(type='CompositorNodeAlphaOver')\n        bpy.context.scene.node_tree.nodes.new(type='CompositorNodeScale')\n        bpy.context.scene.node_tree.nodes.new(type='CompositorNodeImage')\n        bpy.context.scene.node_tree.nodes.new(type='CompositorNodePremulKey')\n        bpy.context.scene.node_tree.nodes.new(type='CompositorNodeMixRGB')\n        bpy.data.scenes['Scene'].node_tree.nodes['Mix'].blend_type = 'LIGHTEN'\n        bpy.data.scenes['Scene'].node_tree.nodes['Image'].frame_duration = number_of_frame\n        bpy.data.scenes['Scene'].node_tree.nodes['Image'].frame_offset = offset\n        bpy.data.scenes['Scene'].node_tree.nodes['Scale'].space = 'RENDER_SIZE'\n        bpy.data.scenes['Scene'].node_tree.nodes['Scale'].frame_method = 'CROP'\n        if args.useBackground:\n            if args.model.lower().endswith('.obj'):\n                bpy.context.scene.node_tree.nodes['Image'].image = bpy.data.images[first_image_name]\n                bpy.context.scene.node_tree.links.new(bpy.context.scene.node_tree.nodes['Mix'].outputs['Image'], bpy.context.scene.node_tree.nodes['Composite'].inputs['Image'])\n                bpy.context.scene.node_tree.links.new(bpy.context.scene.node_tree.nodes['Render Layers'].outputs['Image'], bpy.context.scene.node_tree.nodes['Alpha Convert'].inputs['Image'])\n                bpy.context.scene.node_tree.links.new(bpy.context.scene.node_tree.nodes['Alpha Convert'].outputs['Image'], bpy.context.scene.node_tree.nodes['Mix'].inputs[2])\n                bpy.context.scene.node_tree.links.new(bpy.context.scene.node_tree.nodes['Scale'].outputs['Image'], bpy.context.scene.node_tree.nodes['Mix'].inputs[1])\n                bpy.context.scene.node_tree.links.new(bpy.context.scene.node_tree.nodes['Image'].outputs['Image'], bpy.context.scene.node_tree.nodes['Scale'].inputs['Image'])\n            else:\n                bpy.context.scene.node_tree.nodes['Image'].image = bpy.data.images[first_image_name]\n                bpy.context.scene.node_tree.links.new(bpy.context.scene.node_tree.nodes['Alpha Over'].outputs['Image'], bpy.context.scene.node_tree.nodes['Composite'].inputs['Image'])\n                bpy.context.scene.node_tree.links.new(bpy.context.scene.node_tree.nodes['Render Layers'].outputs['Image'], bpy.context.scene.node_tree.nodes['Alpha Over'].inputs[2])\n                bpy.context.scene.node_tree.links.new(bpy.context.scene.node_tree.nodes['Scale'].outputs['Image'], bpy.context.scene.node_tree.nodes['Alpha Over'].inputs[1])\n                bpy.context.scene.node_tree.links.new(bpy.context.scene.node_tree.nodes['Image'].outputs['Image'], bpy.context.scene.node_tree.nodes['Scale'].inputs['Image'])\n        elif args.model.lower().endswith('.obj'):\n            bpy.context.scene.node_tree.links.new(bpy.context.scene.node_tree.nodes['Mix'].outputs['Image'], bpy.context.scene.node_tree.nodes['Composite'].inputs['Image'])\n            bpy.context.scene.node_tree.links.new(bpy.context.scene.node_tree.nodes['Render Layers'].outputs['Image'], bpy.context.scene.node_tree.nodes['Alpha Convert'].inputs['Image'])\n            bpy.context.scene.node_tree.links.new(bpy.context.scene.node_tree.nodes['Alpha Convert'].outputs['Image'], bpy.context.scene.node_tree.nodes['Mix'].inputs[2])\n            bpy.context.scene.node_tree.links.new(bpy.context.scene.node_tree.nodes['Scale'].outputs['Image'], bpy.context.scene.node_tree.nodes['Mix'].inputs[1])\n            bpy.context.scene.node_tree.links.new(bpy.context.scene.node_tree.nodes['Image'].outputs['Image'], bpy.context.scene.node_tree.nodes['Scale'].inputs['Image'])\n    except RuntimeError:\n        print('Error while creating the compositing graph.')\n        raise\n    try:\n        bpy.context.scene.render.image_settings.file_format = 'FFMPEG'\n        if args.videoFormat == 'mkv':\n            bpy.context.scene.render.ffmpeg.format = 'MKV'\n        elif args.videoFormat == 'avi':\n            bpy.context.scene.render.ffmpeg.format = 'AVI'\n        elif args.videoFormat == 'mov':\n            bpy.context.scene.render.ffmpeg.format = 'QUICKTIME'\n        else:\n            bpy.context.scene.render.ffmpeg.format = 'MPEG4'\n        bpy.context.scene.render.filepath = args.outputPath + '/render.' + args.videoFormat\n        print('Start Rendering')\n        bpy.ops.render.render(animation=True)\n        print('Rendering Done')\n    except RuntimeError:\n        print('Error while rendering the scene')\n        raise\n    return 0",
  "def __init__(self, keyAttrName='', parent=None):\n    super(QObjectListModel, self).__init__(parent)\n    self._objects = list()\n    self._keyAttrName = keyAttrName\n    self._objectByKey = {}\n    self.roles = QtCore.QAbstractListModel.roleNames(self)\n    self.roles[self.ObjectRole] = b'object'\n    self.requestDeletion.connect(self.onRequestDeletion, QtCore.Qt.QueuedConnection)",
  "def roleNames(self):\n    return self.roles",
  "def __iter__(self):\n    return iter(self._objects)",
  "def keys(self):\n    return self._objectByKey.keys()",
  "def items(self):\n    return self._objectByKey.items()",
  "def __len__(self):\n    return self.size()",
  "def __bool__(self):\n    return self.size() > 0",
  "def __getitem__(self, index):\n    return self._objects[index]",
  "def data(self, index, role):\n    if index.row() < 0 or index.row() >= len(self._objects):\n        return None\n    return self._objects[index.row()]",
  "def rowCount(self, parent):\n    return self.size()",
  "def objectList(self):\n    return self._objects",
  "def values(self):\n    return self._objects",
  "def setObjectList(self, objects):\n    oldSize = self.size()\n    self.beginResetModel()\n    for obj in self._objects:\n        self._dereferenceItem(obj)\n    self._objects = objects\n    for obj in self._objects:\n        self._referenceItem(obj)\n    self.endResetModel()\n    self.dataChanged.emit(self.index(0), self.index(self.size() - 1), [])\n    if self.size() != oldSize:\n        self.countChanged.emit()",
  "@property\ndef objects(self):\n    return self._objectByKey",
  "@QtCore.Slot(str, result=QtCore.QObject)\ndef get(self, key):\n    return self._objectByKey[key]",
  "def add(self, obj):\n    self.append(obj)",
  "def pop(self, key):\n    obj = self.get(key)\n    self.remove(obj)\n    return obj",
  "@QtCore.Slot(QtCore.QObject)\ndef append(self, obj):\n    self.extend([obj])",
  "def extend(self, iterable):\n    self.beginInsertRows(QtCore.QModelIndex(), self.size(), self.size() + len(iterable) - 1)\n    [self._referenceItem(obj) for obj in iterable]\n    self._objects.extend(iterable)\n    self.endInsertRows()\n    self.countChanged.emit()",
  "def insert(self, i, toInsert):\n    if not isinstance(toInsert, list):\n        toInsert = [toInsert]\n    self.beginInsertRows(QtCore.QModelIndex(), i, i + len(toInsert) - 1)\n    for obj in reversed(toInsert):\n        self._referenceItem(obj)\n        self._objects.insert(i, obj)\n    self.endInsertRows()\n    self.countChanged.emit()",
  "@QtCore.Slot(int, result=QtCore.QObject)\ndef at(self, i):\n    return self._objects[i]",
  "def replace(self, i, obj):\n    self._dereferenceItem(self._objects[i])\n    self._referenceItem(obj)\n    self._objects[i] = obj\n    self.dataChanged.emit(self.index(i), self.index(i), [])",
  "def move(self, fromIndex, toIndex):\n    value = toIndex\n    if toIndex > fromIndex:\n        value += 1\n    if not self.beginMoveRows(QtCore.QModelIndex(), fromIndex, fromIndex, QtCore.QModelIndex(), value):\n        return\n    self._objects.insert(toIndex, self._objects.pop(fromIndex))\n    self.endMoveRows()",
  "def removeAt(self, i, count=1):\n    self.beginRemoveRows(QtCore.QModelIndex(), i, i + count - 1)\n    for cpt in range(count):\n        obj = self._objects.pop(i)\n        self._dereferenceItem(obj)\n    self.endRemoveRows()\n    self.countChanged.emit()",
  "@QtCore.Slot(QtCore.QObject)\ndef remove(self, obj):\n    if not self.contains(obj):\n        raise ValueError('QObjectListModel.remove(obj) : obj not in list')\n    self.removeAt(self.indexOf(obj))",
  "def takeAt(self, i):\n    self.beginRemoveRows(QtCore.QModelIndex(), i, i)\n    obj = self._objects.pop(i)\n    self._dereferenceItem(obj)\n    self.endRemoveRows()\n    self.countChanged.emit()\n    return obj",
  "def clear(self):\n    if not self._objects:\n        return\n    self.beginResetModel()\n    for obj in self._objects:\n        self._dereferenceItem(obj)\n    self._objects = []\n    self.endResetModel()\n    self.countChanged.emit()",
  "def update(self, objects):\n    self.extend(objects)",
  "def reset(self, objects):\n    self.setObjectList(objects)",
  "@QtCore.Slot(QtCore.QObject, result=bool)\ndef contains(self, obj):\n    return obj in self._objects",
  "@QtCore.Slot(QtCore.QObject, result=int)\ndef indexOf(self, matchObj, fromIndex=0, positive=True):\n    index = self._objects[fromIndex:].index(matchObj) + fromIndex\n    if positive and index < 0:\n        index += self.size()\n    return index",
  "def lastIndexOf(self, matchObj, fromIndex=-1, positive=True):\n    r = list(self._objects)\n    r.reverse()\n    index = -r[-fromIndex - 1:].index(matchObj) + fromIndex\n    if positive and index < 0:\n        index += self.size()\n    return index",
  "def size(self):\n    return len(self._objects)",
  "@QtCore.Slot(result=bool)\ndef isEmpty(self):\n    return len(self._objects) == 0",
  "def _referenceItem(self, item):\n    if not item.parent():\n        item.setParent(self)\n    if not self._keyAttrName:\n        return\n    key = getattr(item, self._keyAttrName, None)\n    if key is None:\n        return\n    if key in self._objectByKey:\n        raise ValueError('Object key {}:{} is not unique'.format(self._keyAttrName, key))\n    self._objectByKey[key] = item",
  "def _dereferenceItem(self, item):\n    if shiboken2.isValid(item) and item.parent() == self:\n        self.requestDeletion.emit(item)\n    if not self._keyAttrName:\n        return\n    key = getattr(item, self._keyAttrName, None)\n    if key is None:\n        return\n    assert key in self._objectByKey\n    del self._objectByKey[key]",
  "def onRequestDeletion(self, item):\n    item.deleteLater()",
  "def __init__(self, keyAttrName='name', T=QtCore.QObject, parent=None):\n    super(QTypedObjectListModel, self).__init__(keyAttrName, parent)\n    self._T = T\n    blacklist = ['id', 'index', 'class', 'model', 'modelData']\n    self._metaObject = T.staticMetaObject\n    propCount = self._metaObject.propertyCount()\n    role = self.ObjectRole + 1\n    for i in range(0, propCount):\n        prop = self._metaObject.property(i)\n        if not prop.name() in blacklist:\n            self.roles[role] = prop.name()\n            role += 1\n        else:\n            print('Reserved role name: ' + prop.name())",
  "def data(self, index, role):\n    obj = super(QTypedObjectListModel, self).data(index, self.ObjectRole)\n    if role == self.ObjectRole:\n        return obj\n    if obj:\n        return obj.property(self.roles[role])\n    return None",
  "def roleForName(self, name):\n    roles = [role for (role, value) in self.roles.items() if value == name]\n    return roles[0] if roles else -1",
  "def _referenceItem(self, item):\n    if item.staticMetaObject != self._metaObject:\n        raise TypeError('Invalid object type: expected {}, got {}'.format(self._metaObject.className(), item.staticMetaObject.className()))\n    super(QTypedObjectListModel, self)._referenceItem(item)",
  "def __init__(self, parent):\n    super(SortedModelByReference, self).__init__(parent)\n    self._reference = []",
  "def setReference(self, iterable):\n    self._reference = iterable\n    self.sort()",
  "def reference(self):\n    return self._reference",
  "def lessThan(self, left, right):\n    l = self.sourceModel().data(left, QObjectListModel.ObjectRole)\n    r = self.sourceModel().data(right, QObjectListModel.ObjectRole)\n    if l not in self._reference:\n        return False\n    if r not in self._reference:\n        return True\n    return self._reference.index(l) < self._reference.index(r)",
  "def sort(self):\n    super(SortedModelByReference, self).sort(0, QtCore.Qt.AscendingOrder)\n    self.invalidate()",
  "def init(backend):\n    global DictModel, ListModel, Slot, Signal, Property, BaseObject, Variant, VariantList, JSValue\n    if backend == Backend.PYSIDE:\n        from .qt import DictModel, ListModel, Slot, Signal, Property, BaseObject, Variant, VariantList, JSValue\n    elif backend == Backend.STANDALONE:\n        from .core import DictModel, ListModel, Slot, Signal, Property, BaseObject, Variant, VariantList, JSValue",
  "def CoreSlot(*args, **kwargs):\n\n    def slot_decorator(func):\n\n        def func_wrapper(*f_args, **f_kwargs):\n            return func(*f_args, **f_kwargs)\n        return func_wrapper\n    return slot_decorator",
  "def __init__(self, keyAttrName, **kwargs):\n    self._objects = {}\n    self._keyAttrName = keyAttrName",
  "def __len__(self):\n    return len(self._objects)",
  "def __iter__(self):\n    return iter(self._objects.values())",
  "def keys(self):\n    return self._objects.keys()",
  "def items(self):\n    return self._objects.items()",
  "def values(self):\n    return self._objects.values()",
  "@property\ndef objects(self):\n    return self._objects",
  "def get(self, key):\n    return self._objects[key]",
  "def add(self, obj):\n    key = getattr(obj, self._keyAttrName, None)\n    assert key is not None\n    assert key not in self._objects\n    self._objects[key] = obj",
  "def pop(self, key):\n    assert key in self._objects\n    return self._objects.pop(key)",
  "def remove(self, obj):\n    assert obj in self._objects.values()\n    del self._objects[getattr(obj, self._keyAttrName)]",
  "def clear(self):\n    self._objects.clear()",
  "def update(self, objects):\n    for obj in objects:\n        self.add(obj)",
  "def reset(self, objects):\n    self.clear()\n    self.update(objects)",
  "def __init__(self, parent=None):\n    self._objects = []",
  "def __iter__(self):\n    return self._objects.__iter__()",
  "def __len__(self):\n    return len(self._objects)",
  "def __getitem__(self, idx):\n    return self._objects[idx]",
  "def values(self):\n    return self._objects",
  "def setObjectList(self, iterable):\n    self.clear()\n    self._objects = iterable",
  "def at(self, idx):\n    return self._objects[idx]",
  "def append(self, obj):\n    self._objects.append(obj)",
  "def extend(self, iterable):\n    self._objects.extend(iterable)",
  "def indexOf(self, obj):\n    return self._objects.index(obj)",
  "def removeAt(self, idx, count=1):\n    del self._objects[idx:idx + count]",
  "def remove(self, obj):\n    self._objects.remove(obj)",
  "def clear(self):\n    self._objects = []",
  "def insert(self, index, iterable):\n    self._objects[index:index] = iterable",
  "def slot_decorator(func):\n\n    def func_wrapper(*f_args, **f_kwargs):\n        return func(*f_args, **f_kwargs)\n    return func_wrapper",
  "def __init__(self, ptype, fget=None, fset=None, **kwargs):\n    super(CoreProperty, self).__init__(fget, fset)",
  "def __init__(self, parent=None, *args, **kwargs):\n    super(CoreObject, self).__init__()\n    self._parent = parent\n    self.destroyed = PySignal.Signal()",
  "def __del__(self):\n    self.destroyed.emit()",
  "def parent(self):\n    return self._parent",
  "def func_wrapper(*f_args, **f_kwargs):\n    return func(*f_args, **f_kwargs)",
  "def __init__(self):\n    super(Signal, self).__init__()\n    self._block = False\n    self._sender = None\n    self._slots = []",
  "def __call__(self, *args, **kwargs):\n    self.emit(*args, **kwargs)",
  "def emit(self, *args, **kwargs):\n    if self._block:\n        return\n\n    def _get_sender():\n        prev_frame = sys._getframe(2)\n        func_name = prev_frame.f_code.co_name\n        try:\n            return getattr(prev_frame.f_locals['self'], func_name)\n        except KeyError:\n            return getattr(inspect.getmodule(prev_frame), func_name)\n    try:\n        self._sender = WeakMethod(_get_sender())\n    except AttributeError:\n        self._sender = None\n    except TypeError:\n        self._sender = None\n    for slot in self._slots:\n        if not slot:\n            continue\n        elif isinstance(slot, partial):\n            slot()\n        elif isinstance(slot, weakref.WeakKeyDictionary):\n            for (obj, method) in slot.items():\n                method(obj, *args, **kwargs)\n        elif isinstance(slot, weakref.ref):\n            tested_slot = slot()\n            if tested_slot is not None:\n                tested_slot(*args, **kwargs)\n        else:\n            slot(*args, **kwargs)",
  "def connect(self, slot):\n    if not callable(slot):\n        raise ValueError(\"Connection to non-callable '%s' object failed\" % slot.__class__.__name__)\n    if isinstance(slot, (partial, Signal)) or '<' in slot.__name__:\n        if slot not in self._slots:\n            self._slots.append(slot)\n    elif inspect.ismethod(slot):\n        slotSelf = slot.__self__\n        slotDict = weakref.WeakKeyDictionary()\n        slotDict[slotSelf] = slot.__func__\n        if slotDict not in self._slots:\n            self._slots.append(slotDict)\n    else:\n        newSlotRef = weakref.ref(slot)\n        if newSlotRef not in self._slots:\n            self._slots.append(newSlotRef)",
  "def disconnect(self, slot):\n    if not callable(slot):\n        return\n    if inspect.ismethod(slot):\n        slotSelf = slot.__self__\n        for s in self._slots:\n            if isinstance(s, weakref.WeakKeyDictionary) and slotSelf in s and (s[slotSelf] is slot.__func__):\n                self._slots.remove(s)\n                break\n    elif isinstance(slot, (partial, Signal)) or '<' in slot.__name__:\n        try:\n            self._slots.remove(slot)\n        except ValueError:\n            pass\n    else:\n        try:\n            self._slots.remove(weakref.ref(slot))\n        except ValueError:\n            pass",
  "def clear(self):\n    self._slots = []",
  "def block(self, isBlocked):\n    self._block = bool(isBlocked)",
  "def sender(self):\n    try:\n        return self._sender()\n    except TypeError:\n        return None",
  "def __get__(self, instance, owner):\n    if instance is None:\n        return self\n    tmp = self._map.setdefault(self, weakref.WeakKeyDictionary())\n    return tmp.setdefault(instance, Signal())",
  "def __set__(self, instance, value):\n    raise RuntimeError('Cannot assign to a Signal object')",
  "def register(self, name, *slots):\n    if name not in self:\n        self[name] = Signal()\n    for slot in slots:\n        self[name].connect(slot)",
  "def deregister(self, name):\n    self.pop(name, None)",
  "def emit(self, signalName, *args, **kwargs):\n    assert signalName in self, '%s is not a registered signal' % signalName\n    self[signalName].emit(*args, **kwargs)",
  "def connect(self, signalName, slot):\n    assert signalName in self, '%s is not a registered signal' % signalName\n    self[signalName].connect(slot)",
  "def block(self, signals=None, isBlocked=True):\n    if signals:\n        try:\n            if isinstance(signals, basestring):\n                signals = [signals]\n        except NameError:\n            if isinstance(signals, str):\n                signals = [signals]\n    signals = signals or self.keys()\n    for signal in signals:\n        if signal not in self:\n            raise RuntimeError('Could not find signal matching %s' % signal)\n        self[signal].block(isBlocked)",
  "def __get__(self, instance, owner):\n    tmp = self._map.setdefault(self, weakref.WeakKeyDictionary())\n    signal = tmp.setdefault(instance, SignalFactory())\n    for name in self._names:\n        signal.register(name)\n    return signal",
  "def __set__(self, instance, value):\n    raise RuntimeError('Cannot assign to a Signal object')",
  "def register(self, name):\n    self._names.add(name)",
  "def _get_sender():\n    prev_frame = sys._getframe(2)\n    func_name = prev_frame.f_code.co_name\n    try:\n        return getattr(prev_frame.f_locals['self'], func_name)\n    except KeyError:\n        return getattr(inspect.getmodule(prev_frame), func_name)"
]