{"prompt": "def row_kills(grid, i, j):\n    num = 0\n    len_row = len(grid[0])\n    while j < len_row and grid[i][j] != 'W':\n        if grid[i][j] == 'E':\n            num += 1\n        j += 1\n    return num\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function takes a 2D grid, and two indices i and j, and returns the number of enemy units in the row starting at (i, j)."}
{"prompt": "def hosoya(height, width):\n    if width == 0 and height in (0, 1):\n        return 1\n    if width == 1 and height in (1, 2):\n        return 1\n    if height > width:\n        return hosoya(height - 1, width) + hosoya(height - 2, width)\n    if width == height:\n        return hosoya(height - 1, width - 1) + hosoya(height - 2, width - 2)\n    return 0\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCalculates the Hosoya triangle value at the given height and width.\n\nThe Hosoya triangle is a triangular array of numbers in which each number is the sum of the two numbers directly above it.\n\nArgs:\n    height (int): The height of the Hosoya triangle.\n    width (int): The width of the Hosoya triangle.\n\nReturns:\n    int: The value at the given height and width.\n\"\"\""}
{"prompt": "def is_valid(s: str) -> bool:\n    stack = []\n    dic = {')': '(', '}': '{', ']': '['}\n    for char in s:\n        if char in dic.values():\n            stack.append(char)\n        elif char in dic:\n            if not stack or dic[char] != stack.pop():\n                return False\n    return not stack\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturns True if the given string s consists of matching pairs of brackets (e.g. (), {}, []) and False otherwise."}
{"prompt": "def build_string(node):\n    if node:\n        vals.append(str(node.val))\n        build_string(node.left)\n        build_string(node.right)\n    else:\n        vals.append('#')\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function builds a string representation of a binary tree. It appends the node's value to a list, then recursively calls the function for its left and right subtrees. If the node is None, it appends a '#' to the list."}
{"prompt": "def match_symbol(words, symbols):\n    import re\n    combined = []\n    for s in symbols:\n        for c in words:\n            r = re.search(s, c)\n            if r:\n                combined.append(re.sub(s, '[{}]'.format(s), c))\n    return combined\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes in two parameters - 'words' and 'symbols' - and returns a list of words from 'words' with the symbols from 'symbols' replaced with a bracketed version of the symbol. It does this by using a regex search to check if a word from 'words' contains a symbol from 'symbols', and if it does, it will use regex to replace the symbol with a bracketed version of the symbol. \n\"\"\""}
{"prompt": "def tree_print(tree):\n    for key in tree:\n        print(key, end=' ')\n        tree_element = tree[key]\n        for subElem in tree_element:\n            print(' -> ', subElem, end=' ')\n            if type(subElem) != str:\n                print('\\n ')\n        print()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function prints a tree structure. \nIt takes a dictionary as input, and prints each key, followed by its associated elements. \nIf an element is not a string, it prints a new line and the function is called recursively on the element. \n\"\"\""}
{"prompt": "def __iter__(self):\n    probe = self._front\n    while True:\n        if probe is None:\n            return\n        yield probe.value\n        probe = probe.next\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"This function is an iterator for a data structure. It yields the value of the element at the front of the data structure, then moves the pointer to the next element and yields that value, and so on until the end of the data structure is reached, at which point it returns None.\"\"\""}
{"prompt": "def pythagoras(opposite, adjacent, hypotenuse):\n    try:\n        if opposite == str('?'):\n            return 'Opposite = ' + str((hypotenuse ** 2 - adjacent ** 2) ** 0.5)\n        if adjacent == str('?'):\n            return 'Adjacent = ' + str((hypotenuse ** 2 - opposite ** 2) ** 0.5)\n        if hypotenuse == str('?'):\n            return 'Hypotenuse = ' + str((opposite ** 2 + adjacent ** 2) ** 0.5)\n        return 'You already know the answer!'\n    except:\n        raise ValueError('invalid argument(s) were given.')\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes three parameters, opposite, adjacent, and hypotenuse, and returns a value depending on which parameter is given a value of '?'. If '?' is passed as the opposite parameter, the function will return the value of the opposite side of a right triangle. If '?' is passed as the adjacent parameter, the function will return the value of the adjacent side of a right triangle. If '?' is passed as the hypotenuse parameter, the function will return the value of the hypotenuse side of a right triangle. If none of the parameters are given a value of '?', the function will return the statement 'You already know the answer!'. If an invalid argument is given, the function will throw a ValueError."}
{"prompt": "def __init__(self, t_val=2):\n    self.min_numbers_of_keys = t_val - 1\n    self.max_number_of_keys = 2 * t_val - 1\n    self.root = Node()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function initializes a B-Tree object with a given t-value. It sets the minimum and maximum number of keys in a node of the tree based on the given t-value, and creates a root node for the tree."}
{"prompt": "def insert(self, val):\n    if val not in self.idxs:\n        self.nums.append(val)\n        self.idxs[val] = len(self.nums) - 1\n        return True\n    return False\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\ninsert(self, val) adds the value 'val' to the list 'nums' and adds an index for 'val' to the dictionary 'idxs'. If 'val' is already present in 'idxs', the function returns False, otherwise it returns True."}
{"prompt": "def house_robber(houses):\n    (last, now) = (0, 0)\n    for house in houses:\n        (last, now) = (now, max(last + house, now))\n    return now\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes a list of integers representing houses and returns the maximum possible amount of money that can be robbed without robbing any adjacent houses."}
{"prompt": "def serialize(root):\n\n    def build_string(node):\n        if node:\n            vals.append(str(node.val))\n            build_string(node.left)\n            build_string(node.right)\n        else:\n            vals.append('#')\n    vals = []\n    build_string(root)\n    return ' '.join(vals)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function takes a root node of a binary tree and returns the values of the nodes in the tree in a serialized form. It utilizes a helper function, build_string, to traverse the tree in a depth-first manner and add the node values to a list that is ultimately returned as a string."}
{"prompt": "def dfs(self):\n    visited = [False] * self.vertex_count\n    self.dfs_util(0, visited)\n    if visited == [True] * self.vertex_count:\n        return True\n    return False\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function performs a depth-first search (DFS) on a graph. It sets all vertices to False in the visited list, and then calls the dfs_util() function to begin the search. If all vertices in the graph have been visited, it will return True, otherwise False."}
{"prompt": "def maximum_flow_dfs(adjacency_matrix):\n    new_array = copy.deepcopy(adjacency_matrix)\n    total = 0\n    while True:\n        min = math.inf\n        visited = [0] * len(new_array)\n        path = [0] * len(new_array)\n        stack = []\n        visited[0] = 1\n        stack.append(0)\n        while len(stack) > 0:\n            src = stack.pop()\n            for k in range(len(new_array)):\n                if new_array[src][k] > 0 and visited[k] == 0:\n                    visited[k] = 1\n                    stack.append(k)\n                    path[k] = src\n        if visited[len(new_array) - 1] == 0:\n            break\n        tmp = len(new_array) - 1\n        while tmp != 0:\n            if min > new_array[path[tmp]][tmp]:\n                min = new_array[path[tmp]][tmp]\n            tmp = path[tmp]\n        tmp = len(new_array) - 1\n        while tmp != 0:\n            new_array[path[tmp]][tmp] = new_array[path[tmp]][tmp] - min\n            tmp = path[tmp]\n        total = total + min\n    return total\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function finds the maximum flow in a given adjacency matrix using Depth-First Search. It uses a copy of the matrix to preserve the original, finds the minimum flow in each path, subtracts this from the copied matrix, and adds it to a total. It returns the maximum flow."}
{"prompt": "def longest_common(strs, left, right):\n    if left == right:\n        return strs[left]\n    mid = (left + right) // 2\n    lcp_left = longest_common(strs, left, mid)\n    lcp_right = longest_common(strs, mid + 1, right)\n    return common_prefix(lcp_left, lcp_right)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nFind the longest common prefix of a list of strings between two given indices.\n\nParameters:\nstrs (list): List of strings\nleft (int): Left index\nright (int): Right index\n\nReturns:\nstr: The longest common prefix of strings between the two indices.\n\"\"\""}
{"prompt": "def judge_circle(moves):\n    dict_moves = {'U': 0, 'D': 0, 'R': 0, 'L': 0}\n    for char in moves:\n        dict_moves[char] = dict_moves[char] + 1\n    return dict_moves['L'] == dict_moves['R'] and dict_moves['U'] == dict_moves['D']\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\njudge_circle(moves)\n\nReturns a boolean value based on whether or not the number of left and right moves, and up and down moves are equal.\n\"\"\""}
{"prompt": "def trailing_zero(x):\n    count = 0\n    while x and (not x & 1):\n        count += 1\n        x >>= 1\n    return count\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"This function returns the number of trailing zeros in a given number 'x'.\"\"\""}
{"prompt": "def sum_sub_squares(matrix, k):\n    n = len(matrix)\n    result = [[0 for i in range(k)] for j in range(k)]\n    if k > n:\n        return\n    for i in range(n - k + 1):\n        l = 0\n        for j in range(n - k + 1):\n            sum = 0\n            for p in range(i, k + i):\n                for q in range(j, k + j):\n                    sum += matrix[p][q]\n            result[i][l] = sum\n            l += 1\n    return result\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes a matrix and an integer k as input, and returns a matrix of size k x k which contains the sum of each sub-square of size k x k in the original matrix. If k is larger than the size of the original matrix, the function will return None.\n\"\"\""}
{"prompt": "def get_max(pos, left, right, start, end):\n    if left > end or right < start:\n        return 0\n    if left >= start and right <= end:\n        return tree[pos]\n    mid = left + right >> 1\n    return max(get_max(pos << 1, left, mid, start, end), get_max(pos << 1 | 1, mid + 1, right, start, end))\n##############\nEND_FUNC\n##############\n", "completion": "\n\n'''\nThis function returns the maximum value from a given range within a binary tree. \nIt takes in five parameters: pos (position in the tree), left (left range), right (right range), start (desired start range), and end (desired end range). \nIt will return 0 if the left range is greater than the end range or if the right range is less than the start range. \nOtherwise, it will return the maximum value within the range specified by the parameters. \nIt does this by recursively scanning the tree, finding the midpoint of the given range, and then finding the maximum value between the two halves."}
{"prompt": "def __init__(self, value):\n    self.value = value\n    self.next = None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function is the constructor for a Node object that stores a value and a reference to the next node in a linked list.\n\nParameters:\nvalue (any type): The value that the node stores.\n\nReturns:\nNone."}
{"prompt": "def __iter__(self):\n    return iter(range(self.start, self.end))\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function returns an iterator object that iterates over the range of integers from self.start to self.end."}
{"prompt": "def __init__(self, v1, v2):\n    self.queue = [_ for _ in (v1, v2) if _]\n    print(self.queue)\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nThis function initializes a queue data structure with two given values. The queue will be a list of non-empty values from the given values v1 and v2. The queue is printed upon initialization."}
{"prompt": "def add_binary(a, b):\n    s = ''\n    (c, i, j) = (0, len(a) - 1, len(b) - 1)\n    zero = ord('0')\n    while i >= 0 or j >= 0 or c == 1:\n        if i >= 0:\n            c += ord(a[i]) - zero\n            i -= 1\n        if j >= 0:\n            c += ord(b[j]) - zero\n            j -= 1\n        s = chr(c % 2 + zero) + s\n        c //= 2\n    return s\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nadd_binary(a, b) -> str\n\nTakes two binary numbers as strings and adds them together, returning the sum as a binary string.\n\"\"\""}
{"prompt": "def base_to_int(str_to_convert, base):\n    digit = {}\n    for (ind, char) in enumerate(string.digits + string.ascii_uppercase):\n        digit[char] = ind\n    multiplier = 1\n    res = 0\n    for char in str_to_convert[::-1]:\n        res += digit[char] * multiplier\n        multiplier *= base\n    return res\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nbase_to_int(str_to_convert, base)\n\nConverts a string in a given base to an integer.\n\nParameters:\nstr_to_convert (str): The string to be converted.\nbase (int): The base of the string.\n\nReturns:\nint: The converted string as an integer.\n\"\"\""}
{"prompt": "def _merge(self, parent_node: Node, to_merge_index: int, transfered_child_index: int):\n    from_merge_node = parent_node.children.pop(transfered_child_index)\n    parent_key_to_merge = parent_node.keys.pop(to_merge_index)\n    to_merge_node = parent_node.children[to_merge_index]\n    to_merge_node.keys.append(parent_key_to_merge)\n    to_merge_node.keys.extend(from_merge_node.keys)\n    if not to_merge_node.is_leaf:\n        to_merge_node.children.extend(from_merge_node.children)\n    if parent_node == self.root and (not parent_node.keys):\n        self.root = to_merge_node\n##############\nEND_FUNC\n##############\n", "completion": "\n\n_merge() merges two children of a node into one, by taking a key from the parent node and merging it with one of the children. If the parent node is the root and no keys are left in it, the root node is updated to the merged node."}
{"prompt": "def _remove_key(self, node: Node, key) -> bool:\n    try:\n        key_index = node.keys.index(key)\n        if node.is_leaf:\n            node.keys.remove(key)\n        else:\n            self._remove_from_nonleaf_node(node, key_index)\n        return True\n    except ValueError:\n        if node.is_leaf:\n            print('Key not found.')\n            return False\n        else:\n            i = 0\n            number_of_keys = len(node.keys)\n            while i < number_of_keys and key > node.keys[i]:\n                i += 1\n            action_performed = self._repair_tree(node, i)\n            if action_performed:\n                return self._remove_key(node, key)\n            else:\n                return self._remove_key(node.children[i], key)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n_remove_key(self, node: Node, key) -> bool\n\nRemoves the key from the node (or its children) if it exists.\nReturns True if the key is successfully removed, False otherwise.\n\"\"\""}
{"prompt": "def depth_sum(root, n):\n    if root:\n        return recur_depth_sum(root, 1)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCalculate the total sum of all elements at each level of the given tree.\n\nParameters: \nroot (Node): The root node of the tree \nn (int): The number of levels in the tree\n\nReturns: \nint: The total sum of all elements at each level of the tree. \n\"\"\""}
{"prompt": "def push_t(self, item):\n    self.items.append(item)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Adds an item to the end of the list.\"\"\""}
{"prompt": "def three_sum(array):\n    res = set()\n    array.sort()\n    for i in range(len(array) - 2):\n        if i > 0 and array[i] == array[i - 1]:\n            continue\n        (l, r) = (i + 1, len(array) - 1)\n        while l < r:\n            s = array[i] + array[l] + array[r]\n            if s > 0:\n                r -= 1\n            elif s < 0:\n                l += 1\n            else:\n                res.add((array[i], array[l], array[r]))\n                while l < r and array[l] == array[l + 1]:\n                    l += 1\n                while l < r and array[r] == array[r - 1]:\n                    r -= 1\n                l += 1\n                r -= 1\n    return res\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes an array of numbers as an argument and returns a set of all possible triplets in the array that sum to 0.  It sorts the input array and uses a combination of two pointers and a loop to find these triplets."}
{"prompt": "def random_element(self):\n    return random.choice(self.elements)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturns a random element from the list of elements stored in the calling object."}
{"prompt": "def string_reverse(s):\n    return s[::-1]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes a string as input and returns the string reversed."}
{"prompt": "def __truediv__(self, other: Union[int, float, Fraction]):\n    if isinstance(other, int) or isinstance(other, float) or isinstance(other, Fraction):\n        mono = {i: self.variables[i] for i in self.variables}\n        if other == 0:\n            raise ValueError('Cannot divide by 0.')\n        return Monomial(mono, Monomial._rationalize_if_possible(self.coeff / other)).clean()\n    o = other.inverse()\n    return self.__mul__(o)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Divide a Monomial by a given number or Fraction.\n\nArgs:\n    other (Union[int, float, Fraction]): The number or Fraction to divide by.\n\nRaises:\n    ValueError: If `other` is 0.\n\nReturns:\n    Monomial: The result of the division.\n\"\"\""}
{"prompt": "def transpose_and_multiply(m, multiplier=1):\n    for row in range(len(m)):\n        for col in range(row + 1):\n            temp = m[row][col] * multiplier\n            m[row][col] = m[col][row] * multiplier\n            m[col][row] = temp\n    return m\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"This function takes in a matrix 'm' and an optional multiplier, and transposes each element in the matrix by swapping the row and column indices and multiplying each element by the multiplier. It then returns the resulting matrix.\"\"\""}
{"prompt": "def max_profit_optimized(prices):\n    (cur_max, max_so_far) = (0, 0)\n    for i in range(1, len(prices)):\n        cur_max = max(0, cur_max + prices[i] - prices[i - 1])\n        max_so_far = max(max_so_far, cur_max)\n    return max_so_far\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCalculate the maximum profit from buying and selling stock, using an optimized algorithm.\n\nInput: \nprices - a list of stock prices\n\nOutput: \nmax_so_far - the maximum profit that can be made from the given stock prices.\n\"\"\""}
{"prompt": "def preorder(self, root):\n    if root:\n        print(str(root.data), end=' ')\n        self.preorder(root.left)\n        self.preorder(root.right)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nTraverse a given binary tree in preorder traversal.\nPrints the root data, then recursively traverses the left subtree, then the right subtree. \n\"\"\""}
{"prompt": "@staticmethod\ndef get_name(obj):\n    if isinstance(obj, Node):\n        return obj.name\n    if isinstance(obj, str):\n        return obj\n    return ''\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes in an object and returns the name of the object if it is a Node instance or a string. Returns an empty string otherwise."}
{"prompt": "def all_monomials(self) -> Iterable[Monomial]:\n    return {m for m in self.monomials if m != Monomial({}, 0)}\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturn an iterable of all non-zero monomials in the Polynomial."}
{"prompt": "def next(self):\n    v = self.queue.pop(0)\n    ret = v.pop(0)\n    if v:\n        self.queue.append(v)\n    return ret\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nnext(self)\n\nReturn the next item from the queue. Removes the first item from the queue and returns it. If the item is a list, the first element is returned and the rest is added back to the queue."}
{"prompt": "def del_(self, key):\n    hash_ = self.hash(key)\n    node_ = self._table[hash_]\n    pre_node = None\n    while node_ is not None:\n        if node_.key == key:\n            if pre_node is None:\n                self._table[hash_] = node_.next\n            else:\n                pre_node.next = node_.next\n            self._len -= 1\n        pre_node = node_\n        node_ = node_.next\n##############\nEND_FUNC\n##############\n", "completion": "\n\nDelete the key-value pair with the given key from the hash table."}
{"prompt": "def dfsutil(self, visited, source, target):\n    visited[source] = True\n    for i in self.graph[source]:\n        if target in self.graph[source]:\n            self.has_path = True\n            return\n        if not visited[i]:\n            self.dfsutil(visited, source, i)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function recursively performs a depth-first search on the graph to determine if there is a path between the given source and target vertices. It sets the has_path instance variable to True if a path is found, and returns if no further exploration is necessary. It updates the visited list to keep track of vertices that have been visited."}
{"prompt": "def int_to_base(num, base):\n    is_negative = False\n    if num == 0:\n        return '0'\n    if num < 0:\n        is_negative = True\n        num *= -1\n    digit = string.digits + string.ascii_uppercase\n    res = ''\n    while num > 0:\n        res += digit[num % base]\n        num //= base\n    if is_negative:\n        return '-' + res[::-1]\n    return res[::-1]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nConvert a given integer to a string of its representation in a given base.\n\nParameters: \nnum (int): The integer to convert.\nbase (int): The base to represent the number in.\n\nReturns: \nstr: The string representation of the number in the given base.\n\"\"\""}
{"prompt": "def decode(s):\n    strs = []\n    i = 0\n    while i < len(s):\n        index = s.find(':', i)\n        size = int(s[i:index])\n        strs.append(s[index + 1:index + 1 + size])\n        i = index + 1 + size\n    return strs\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\ndecode(s)\n\nInput:\n    s (str): a string to be decoded\n\nOutput:\n    strs (list): the resulting decoded string\n\nFunctionality:\n    Decodes a string with the format \"length:string\" into a list of strings.\n    The length is the number of characters in the given string.\n\"\"\""}
{"prompt": "def __floordiv__(self, other: Union[int, float, Fraction, Monomial]):\n    return self.__truediv__(other)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Returns the floored division of self by other. Floored division is the same as true division, except that the result is rounded down (towards negative infinity) to the nearest integer if the result is not already an integer.\"\"\""}
{"prompt": "def _l2_distance(vec):\n    norm = 0.0\n    for element in vec:\n        norm += element * element\n    norm = math.sqrt(norm)\n    return norm\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCalculate the l2 norm of a given vector\n\nParameters:\nvec (list): A list of numerical values\n\nReturns:\nnorm (float): The l2 norm of the vector\n\"\"\""}
{"prompt": "def num_decodings(enc_mes):\n    if not enc_mes or enc_mes[0] == '0':\n        return 0\n    (last_char, last_two_chars) = (1, 1)\n    for i in range(1, len(enc_mes)):\n        last = last_char if enc_mes[i] != '0' else 0\n        last_two = last_two_chars if int(enc_mes[i - 1:i + 1]) < 27 and enc_mes[i - 1] != '0' else 0\n        last_two_chars = last_char\n        last_char = last + last_two\n    return last_char\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nnum_decodings(enc_mes) - Calculate the number of ways to decode an encoded message\n\nParameters:\n    enc_mes (str): The encoded message to decode\n\nReturns:\n    int: The number of ways to decode the message\n\"\"\""}
{"prompt": "def backtrack(pattern, string, dic):\n    if len(pattern) == 0 and len(string) > 0:\n        return False\n    if len(pattern) == len(string) == 0:\n        return True\n    for end in range(1, len(string) - len(pattern) + 2):\n        if pattern[0] not in dic and string[:end] not in dic.values():\n            dic[pattern[0]] = string[:end]\n            if backtrack(pattern[1:], string[end:], dic):\n                return True\n            del dic[pattern[0]]\n        elif pattern[0] in dic and dic[pattern[0]] == string[:end]:\n            if backtrack(pattern[1:], string[end:], dic):\n                return True\n    return False\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function checks if a string matches a given pattern. \nIt takes three arguments: \npattern (string): The pattern to match. \nstring (string): The string to check.\ndic (dict): A dictionary to store the pattern and string.\nIt returns True if the pattern matches the string, False otherwise."}
{"prompt": "def __init__(self, x):\n    self.val = x\n    self.next = None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function is used to initialize a node with a given value and set the next pointer to None. \nIt takes in one parameter, x, which is the value of the node."}
{"prompt": "def rotate_v3(array, k):\n    if array is None:\n        return None\n    length = len(array)\n    k = k % length\n    return array[length - k:] + array[:length - k]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nRotate array by k steps in-place.\n\nParameters: \narray (list): The array to rotate.\nk (int): The number of steps to rotate by.\n\nReturns:\nlist: The rotated array. None if array is None."}
{"prompt": "def find_min_rotate_recur(array, low, high):\n    mid = (low + high) // 2\n    if mid == low:\n        return array[low]\n    if array[mid] > array[high]:\n        return find_min_rotate_recur(array, mid + 1, high)\n    return find_min_rotate_recur(array, low, mid)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nFinds the minimum element in a rotated sorted array, recursively.\n\nArgs:\n    array (list): The rotated sorted array.\n    low (int): The starting index of the array.\n    high (int): The ending index of the array.\n\nReturns:\n    int: The minimum element in the given array.\n\"\"\""}
{"prompt": "def __init__(self, size=11):\n    self.size = size\n    self._len = 0\n    self._table = [self._empty] * size\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis is the constructor for the class. It initializes an instance of the class with an optional size parameter, which defaults to 11. It also initializes the _len and _table properties with the empty value and an array of size \"size\"."}
{"prompt": "def word_range(word):\n    for ind in range(len(word)):\n        temp = word[ind]\n        for c in [chr(x) for x in range(ord('a'), ord('z') + 1)]:\n            if c != temp:\n                yield (word[:ind] + c + word[ind + 1:])\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes in a string word and yields all strings within a single edit distance of the word. An edit distance is defined as the number of changes needed to make one word into the other.\n\nReturns:\n    An iterator that yields strings within a single edit distance of the given word."}
{"prompt": "def clone_graph(node):\n    if not node:\n        return None\n    node_copy = node.shallow_copy()\n    dic = {node: node_copy}\n    dfs(node, dic)\n    return node_copy\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nClone a graph, given a node in the graph.\n\nThis function performs a depth-first search to recursively clone each node in the graph, then returns a shallow copy of the node passed in. \n\nArgs: \n    node (Node): The node to be cloned in the graph.\n\nReturns:\n    node_copy (Node): A shallow copy of the node passed in."}
{"prompt": "def merge_set(self, node1, node2):\n    node1 = self.find_set(node1)\n    node2 = self.find_set(node2)\n    if self.size[node1] < self.size[node2]:\n        self.parent[node1] = node2\n        self.size[node2] += self.size[node1]\n    else:\n        self.parent[node2] = node1\n        self.size[node1] += self.size[node2]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"Merge two sets by unioning the node1 set and node2 set, by making the larger set's parent become the parent of the smaller set.\""}
{"prompt": "def __len__(self):\n    return self._len\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function returns the length of the object it is called on."}
{"prompt": "def count_components(adjacency_list, size):\n    count = 0\n    visited = [False] * (size + 1)\n    for i in range(1, size + 1):\n        if not visited[i]:\n            dfs(i, visited, adjacency_list)\n            count += 1\n    return count\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function counts the number of connected components in a graph represented by an adjacency list.\nIt takes two parameters: \n- adjacency_list: A list of lists representing the graph's adjacency list\n- size: The number of nodes in the graph\n\nIt returns the number of connected components in the graph.\n\"\"\""}
{"prompt": "def count_binary_substring(s):\n    cur = 1\n    pre = 0\n    count = 0\n    for i in range(1, len(s)):\n        if s[i] != s[i - 1]:\n            count = count + min(pre, cur)\n            pre = cur\n            cur = 1\n        else:\n            cur = cur + 1\n    count = count + min(pre, cur)\n    return count\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\ncount_binary_substring(s)\n\nReturns the number of binary substrings in a given string s. A binary substring is a substring of s that contains only 0s and 1s. \n\"\"\""}
{"prompt": "def int_to_bytes_big_endian(num):\n    bytestr = deque()\n    while num > 0:\n        bytestr.appendleft(num & 255)\n        num >>= 8\n    return bytes(bytestr)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nConvert an integer to bytes in big-endian format.\n\nParameters\n----------\nnum : int\n    The integer to be converted.\n\nReturns\n-------\nbytes\n    The bytes representation of the integer in big-endian format.\n\"\"\""}
{"prompt": "def pop(self):\n    if self.is_empty():\n        raise IndexError('Stack is empty')\n    value = self._array[self._top]\n    self._top -= 1\n    return value\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Removes the top element from the stack and returns it. Raises an IndexError if the stack is empty.\"\"\""}
{"prompt": "def combination_sum_topdown(nums, target):\n    global DP\n    DP = [-1] * (target + 1)\n    DP[0] = 1\n    return helper_topdown(nums, target)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nHelper function for combination_sum_topdown\n\nThis function uses a top-down approach with memoization to find the total number of unique combinations of the given numbers that sum up to the given target.\n\nArgs:\n    nums (list): List of integers\n    target (int): Target value\n\nReturns:\n    int: Total number of unique combinations that sum up to the given target\n\"\"\""}
{"prompt": "def solve_chinese_remainder(nums: List[int], rems: List[int]):\n    if not len(nums) == len(rems):\n        raise Exception('nums and rems should have equal length')\n    if not len(nums) > 0:\n        raise Exception('Lists nums and rems need to contain at least one element')\n    for num in nums:\n        if not num > 1:\n            raise Exception('All numbers in nums needs to be > 1')\n    if not _check_coprime(nums):\n        raise Exception('All pairs of numbers in nums are not coprime')\n    k = len(nums)\n    x = 1\n    while True:\n        i = 0\n        while i < k:\n            if x % nums[i] != rems[i]:\n                break\n            i += 1\n        if i == k:\n            return x\n        x += 1\n##############\nEND_FUNC\n##############\n", "completion": "\n\nsolve_chinese_remainder(nums: List[int], rems: List[int]):\n    \"\"\"Solve a system of linear congruences with moduli given by nums and remainders given by rems.\n    \n    Parameters:\n    nums (List[int]): A list of the moduli.\n    rems (List[int]): A list of the remainders.\n    \n    Returns:\n    int: The smallest non-negative solution to the system of linear congruences.\n    \n    Raises:\n    Exception: If nums and rems have different length, if nums contains a number which is not greater than 1, or if all pairs of numbers in nums are not coprime.\n    \"\"\""}
{"prompt": "def is_symmetric(root):\n    if root is None:\n        return True\n    return helper(root.left, root.right)\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nReturn a boolean indicating whether the given binary tree is symmetric. A symmetric binary tree is one in which the left and right subtrees are mirror images of each other.\n\nReturns:\n    bool: True if the binary tree is symmetric, False otherwise."}
{"prompt": "def construct_tree(pre: list, post: list, size: int):\n    global pre_index\n    root = construct_tree_util(pre, post, 0, size - 1, size)\n    return print_inorder(root)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nConstructs a binary tree from preorder and postorder traversals. \n\nParameters: \npre (list): List of preorder traversal \npost (list): List of postorder traversal \nsize (int): Number of elements in preorder and postorder traversals. \n\nReturns: \nPrints the inorder traversal of the constructed tree. \n\"\"\""}
{"prompt": "def dfs(node):\n    state[node] = GRAY\n    for k in graph.get(node, ()):\n        sk = state.get(k, None)\n        if sk == GRAY:\n            raise ValueError('cycle')\n        if sk == BLACK:\n            continue\n        enter.discard(k)\n        dfs(k)\n    order.append(node)\n    state[node] = BLACK\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\ndfs(node):\n    Perform a depth-first search on the given node. \n    Raise a ValueError if a cycle is detected in the graph. \n    Append the node to the order list and mark it as BLACK in the state dictionary when finished.\n\"\"\""}
{"prompt": "def top_left_invert(matrix):\n    new = []\n    for row in matrix:\n        for (i, elem) in enumerate(row):\n            try:\n                new[i].append(elem)\n            except IndexError:\n                new.insert(i, [])\n                new[i].append(elem)\n    return new\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes a matrix as an argument and returns a matrix with the top left inversion applied to it. The top left inversion swaps the first and last elements of the first row and the first and last elements of the first column."}
{"prompt": "def magic_number(n):\n    total_sum = 0\n    while n > 0 or total_sum > 9:\n        if n == 0:\n            n = total_sum\n            total_sum = 0\n        total_sum += n % 10\n        n //= 10\n    return total_sum == 1\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes an integer n and returns True if the sum of the digits of n is equal to 1, and False otherwise."}
{"prompt": "def compare(arr, reverse):\n    n = len(arr) // 2\n    for i in range(n):\n        if reverse != (arr[i] > arr[i + n]):\n            (arr[i], arr[i + n]) = (arr[i + n], arr[i])\n    return arr\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCompares and swaps elements in an array based on the reverse argument.\n\nParameters:\narr (list): The array to compare and swap elements from. \nreverse (bool): A boolean value that determines the direction of comparison. \n\nReturns:\narr (list): The modified array after comparison and swapping. \n\"\"\""}
{"prompt": "def modular_exponential(base, exponent, mod):\n    if exponent < 0:\n        raise ValueError('Exponent must be positive.')\n    base %= mod\n    result = 1\n    while exponent > 0:\n        if exponent & 1:\n            result = result * base % mod\n        exponent = exponent >> 1\n        base = base * base % mod\n    return result\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCalculate the result of raising a base to an exponent modulo a modulus.\n\nParameters:\n    base (int): The base to raise.\n    exponent (int): The exponent. Must be positive.\n    mod (int): The modulus.\n\nReturns:\n    int: The result of raising base to the exponent modulo mod.\n\"\"\""}
{"prompt": "def successor(root, node):\n    succ = None\n    while root:\n        if node.val < root.val:\n            succ = root\n            root = root.left\n        else:\n            root = root.right\n    return succ\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function returns the successor of a given node in a binary search tree. It will traverse the tree from the root node, checking if the given node's value is less than the root node's value. If true, it will assign the root node to the successor and traverse the left subtree. If false, it will traverse the right subtree. If there is no successor, it will return None."}
{"prompt": "def test_first_cyclic_node(self):\n    head = Node('A')\n    head.next = Node('B')\n    curr = head.next\n    cyclic_node = Node('C')\n    curr.next = cyclic_node\n    curr = curr.next\n    curr.next = Node('D')\n    curr = curr.next\n    curr.next = Node('E')\n    curr = curr.next\n    curr.next = cyclic_node\n    self.assertEqual('C', first_cyclic_node(head).val)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Test the first cyclic node in a linked list and assert if the value is correct.\"\"\""}
{"prompt": "def encode(strs):\n    res = ''\n    for string in strs.split():\n        res += str(len(string)) + ':' + string\n    return res\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nEncode a given string into a string of the form '<length of the string>:<string>'.\n\nParameters:\nstrs (str): The string to encode.\n\nReturns:\nres (str): The encoded string."}
{"prompt": "def insert(self, val):\n    self.heap.append(val)\n    self.current_size = self.current_size + 1\n    self.perc_up(self.current_size)\n    '\\n        Method min_child returns the index of smaller of 2 children of parent at index i\\n        '\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function inserts a value into the heap and adjusts the heap accordingly. It increases the current size of the heap and then calls the perc_up function to maintain the heap structure."}
{"prompt": "def dfs(nums, target, index, path, res):\n    if target < 0:\n        return\n    if target == 0:\n        res.append(path)\n        return\n    for i in range(index, len(nums)):\n        dfs(nums, target - nums[i], i, path + [nums[i]], res)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function performs a Depth-First Search on a given array of numbers to find combinations of values that add up to a given target. It takes in 5 parameters: nums (array of numbers to search through), target (the sum to reach), index (the current index of the array), path (the current combination of values found so far), and res (the final result). If the target is reached, the combination of values is added to the result, otherwise it continues to search."}
{"prompt": "def is_one_edit2(s, t):\n    (l1, l2) = (len(s), len(t))\n    if l1 > l2:\n        return is_one_edit2(t, s)\n    if len(t) - len(s) > 1 or t == s:\n        return False\n    for i in range(len(s)):\n        if s[i] != t[i]:\n            if l1 == l2:\n                s = s[:i] + t[i] + s[i + 1:]\n            else:\n                s = s[:i] + t[i] + s[i:]\n            break\n    return s == t or s == t[:-1]\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function takes two strings, s and t, as parameters. It returns True if the two strings are one edit away from each other, False otherwise. It checks if the length of s is greater than the length of t and if so, it reverses the two strings. If the difference between the lengths of the two strings is greater than 1 or if the two strings are equal, False is returned. It then loops through the characters in s and if they don't match the characters in t, a character from t is inserted into s at the same index as t. Finally, it checks if s is equal to t or t without its last character."}
{"prompt": "@abstractmethod\ndef dequeue(self):\n    pass\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis is an abstract method for dequeuing a data structure. It does not include an implementation."}
{"prompt": "def is_prime(n, k):\n\n    def pow2_factor(num):\n        power = 0\n        while num % 2 == 0:\n            num /= 2\n            power += 1\n        return (power, num)\n\n    def valid_witness(a):\n        x = pow(int(a), int(d), int(n))\n        if x == 1 or x == n - 1:\n            return False\n        for _ in range(r - 1):\n            x = pow(int(x), int(2), int(n))\n            if x == 1:\n                return True\n            if x == n - 1:\n                return False\n        return True\n    if n < 5:\n        return n == 2 or n == 3\n    (r, d) = pow2_factor(n - 1)\n    for _ in range(k):\n        if valid_witness(random.randrange(2, n - 2)):\n            return False\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nis_prime(n, k) is a function that determines whether a number 'n' is prime or not. It uses the randomized Miller-Rabin primality test to check if 'n' is prime and returns True if 'n' is prime and False if it is not. 'k' is the number of iterations of the test. \n\"\"\""}
{"prompt": "def radix_sort(arr, simulation=False):\n    position = 1\n    max_number = max(arr)\n    iteration = 0\n    if simulation:\n        print('iteration', iteration, ':', *arr)\n    while position <= max_number:\n        queue_list = [list() for _ in range(10)]\n        for num in arr:\n            digit_number = num // position % 10\n            queue_list[digit_number].append(num)\n        index = 0\n        for numbers in queue_list:\n            for num in numbers:\n                arr[index] = num\n                index += 1\n        if simulation:\n            iteration = iteration + 1\n            print('iteration', iteration, ':', *arr)\n        position *= 10\n    return arr\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function performs a radix sort on a given array, with an optional 'simulation' parameter to visualize the sorting process. It sorts the array in-place and returns the sorted array."}
{"prompt": "def dequeue(self):\n    if self.is_empty():\n        raise IndexError('Queue is empty')\n    value = self._array[self._front]\n    self._array[self._front] = None\n    self._front += 1\n    self._size -= 1\n    return value\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Removes and returns the element at the front of the queue. Raises an IndexError if the queue is empty.\"\"\""}
{"prompt": "def reverse(arr, a, b):\n    while a < b:\n        (arr[a], arr[b]) = (arr[b], arr[a])\n        a += 1\n        b -= 1\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReverse a portion of an array in-place.\n\nParameters:\narr (list): The array to be modified.\na (int): The start index of the portion of the array to reverse.\nb (int): The end index of the portion of the array to reverse.\n\nReturns:\nNone\n\"\"\""}
{"prompt": "def dfs(source, visited, adjacency_list):\n    visited[source] = True\n    for child in adjacency_list[source]:\n        if not visited[child]:\n            dfs(child, visited, adjacency_list)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function performs a depth-first search given a source vertex, a visited set, and an adjacency list. It marks the source vertex as visited and then recursively visits each of its children, if they have not already been visited."}
{"prompt": "def undo(self, kee, update):\n    self.board[kee[0]][kee[1]] = '.'\n    for k in update:\n        if k not in self.val:\n            self.val[k] = update[k]\n        else:\n            self.val[k].append(update[k])\n    return None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"This function updates the board and value dictionaries by resetting the position of the given key to a blank space and adding any new values to the value dictionary.\n\nArgs:\n    self: The current instance of the class.\n    kee: The position in the board to reset to a blank space.\n    update: A dictionary of values to update the value dictionary with.\n\nReturns:\n    None. The board and value dictionaries are updated in place. \"\"\""}
{"prompt": "def check_sum(n, *nums):\n    if sum((x for x in nums)) == n:\n        return (True, nums)\n    else:\n        return (False, nums)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function checks if the sum of a set of numbers is equal to a given number 'n'.\nIt takes two arguments, n and *nums, where 'n' is the number to be checked against,\nand *nums is the set of numbers whose sum should be checked.\nThe function returns a tuple containing a boolean (True or False) and the set of numbers.\nIf the sum of the numbers is equal to n, the boolean will be True, else False."}
{"prompt": "def helper(self, node, count):\n    if not node:\n        return\n    self.helper(node.left, count)\n    count.append(node.val)\n    self.helper(node.right, count)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"Recursively traverse through a binary tree and add its node values to a given count list\""}
{"prompt": "def is_subtree(big, small):\n    flag = False\n    queue = collections.deque()\n    queue.append(big)\n    while queue:\n        node = queue.popleft()\n        if node.val == small.val:\n            flag = comp(node, small)\n            break\n        else:\n            queue.append(node.left)\n            queue.append(node.right)\n    return flag\n##############\nEND_FUNC\n##############\n", "completion": "\n\nCheck if a binary tree is a subtree of another binary tree.\n\nParameters:\nbig (TreeNode): The root node of the bigger tree.\nsmall (TreeNode): The root node of the smaller tree.\n\nReturns:\nflag (bool): True if the smaller tree is a subtree of the bigger tree, False otherwise."}
{"prompt": "def __init__(self, label):\n    self.label = label\n    self.next = None\n    self.random = None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis is the constructor for a Node object. It initializes the label, next and random attributes of the node. \nlabel: The label of the node\nnext: A reference to the next node in the linked list\nrandom: A reference to another random node in the linked list"}
{"prompt": "def fib_recursive(n):\n    assert n >= 0, 'n must be a positive integer'\n    if n <= 1:\n        return n\n    return fib_recursive(n - 1) + fib_recursive(n - 2)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCalculate the nth Fibonacci number using a recursive algorithm.\n\nParameters:\n    n (int): A positive integer representing the nth Fibonacci number to calculate.\n\nReturns:\n    int: The nth Fibonacci number.\n\"\"\""}
{"prompt": "def insert(self, node):\n    root = self.root\n    insert_node_parent = None\n    while root is not None:\n        insert_node_parent = root\n        if insert_node_parent.val < node.val:\n            root = root.right\n        else:\n            root = root.left\n    node.parent = insert_node_parent\n    if insert_node_parent is None:\n        self.root = node\n    elif insert_node_parent.val > node.val:\n        insert_node_parent.left = node\n    else:\n        insert_node_parent.right = node\n    node.left = None\n    node.right = None\n    node.color = 1\n    self.fix_insert(node)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nInserts a node into a binary search tree, setting the correct parent node and color. \nFixes the tree if it has become unbalanced due to the insertion.\n\"\"\""}
{"prompt": "def insert(self, new_one):\n    if new_one in self.index_map:\n        return\n    self.index_map[new_one] = len(self.elements)\n    self.elements.append(new_one)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nInsert a new element into a given collection. \nChecks if the element is already present in the collection, and if not, adds it. \nUpdates the elements list and index_map accordingly."}
{"prompt": "def single_number(nums):\n    i = 0\n    for num in nums:\n        i ^= num\n    return i\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes in a list of numbers, and returns the single number that is not repeated in the list. It does this by using the XOR (^) operator to \"cancel out\" all the duplicates."}
{"prompt": "def find_next_square2(sq):\n    root = sq ** 0.5\n    return -1 if root % 1 else (root + 1) ** 2\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes in a square number and returns the next square number if the given number is a perfect square. If the given number is not a perfect square, it will return -1."}
{"prompt": "def test_intersection(self):\n    a1 = Node(1)\n    b1 = Node(3)\n    c1 = Node(5)\n    d = Node(7)\n    a2 = Node(2)\n    b2 = Node(4)\n    c2 = Node(6)\n    e = Node(9)\n    f = Node(11)\n    a1.next = b1\n    b1.next = c1\n    c1.next = d\n    a2.next = b2\n    b2.next = c2\n    c2.next = d\n    d.next = e\n    e.next = f\n    self.assertEqual(7, intersection(a1, a2).val)\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\n\nThis function tests the intersection of two linked lists. It creates two linked lists, a1 and a2, and then checks if their intersection is equal to the value 7."}
{"prompt": "def dfs(root, cur, target, max_len):\n    if root is None:\n        return\n    if root.val == target:\n        cur += 1\n    else:\n        cur = 1\n    max_len = max(cur, max_len)\n    dfs(root.left, cur, root.val + 1, max_len)\n    dfs(root.right, cur, root.val + 1, max_len)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function traverses a binary tree and finds the maximum length of consecutive increasing sequence of nodes, starting from the given root node.\nIt takes in four parameters:\nroot - the root of the binary tree\ncur - an integer to store the current consecutive length\ntarget - the target value\nmax_len - the maximum length of consecutive sequence found so far\nIt returns the maximum length of consecutive increasing sequence of nodes."}
{"prompt": "def __init__(self):\n    self.root = TrieNode()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__(self) initializes a TrieNode object as the root of the Trie."}
{"prompt": "def maximum_flow_bfs(adjacency_matrix):\n    new_array = copy.deepcopy(adjacency_matrix)\n    total = 0\n    while True:\n        min_flow = math.inf\n        visited = [0] * len(new_array)\n        path = [0] * len(new_array)\n        bfs = queue.Queue()\n        visited[0] = 1\n        bfs.put(0)\n        while bfs.qsize() > 0:\n            src = bfs.get()\n            for k in range(len(new_array)):\n                if new_array[src][k] > 0 and visited[k] == 0:\n                    visited[k] = 1\n                    bfs.put(k)\n                    path[k] = src\n        if visited[len(new_array) - 1] == 0:\n            break\n        tmp = len(new_array) - 1\n        while tmp != 0:\n            if min_flow > new_array[path[tmp]][tmp]:\n                min_flow = new_array[path[tmp]][tmp]\n            tmp = path[tmp]\n        tmp = len(new_array) - 1\n        while tmp != 0:\n            new_array[path[tmp]][tmp] = new_array[path[tmp]][tmp] - min_flow\n            tmp = path[tmp]\n        total = total + min_flow\n    return total\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function finds the maximum flow from a given adjacency matrix using Breadth-First Search (BFS) algorithm. It returns an integer total which is the maximum flow from the given matrix."}
{"prompt": "def bogo_sort(arr, simulation=False):\n    iteration = 0\n    if simulation:\n        print('iteration', iteration, ':', *arr)\n\n    def is_sorted(arr):\n        i = 0\n        arr_len = len(arr)\n        while i + 1 < arr_len:\n            if arr[i] > arr[i + 1]:\n                return False\n            i += 1\n        return True\n    while not is_sorted(arr):\n        random.shuffle(arr)\n        if simulation:\n            iteration = iteration + 1\n            print('iteration', iteration, ':', *arr)\n    return arr\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nbogo_sort(arr, simulation=False)\n\nSorts a given array using the Bogo Sort algorithm.\n\nParameters:\n    arr (list): The array to sort.\n    simulation (bool, optional): Whether to print the current state of the array after each iteration. Defaults to False.\n\nReturns:\n    The sorted array.\n\"\"\""}
{"prompt": "def longest_palindromic_subsequence(s):\n    k = len(s)\n    olist = [0] * k\n    nList = [0] * k\n    logestSubStr = ''\n    logestLen = 0\n    for j in range(0, k):\n        for i in range(0, j + 1):\n            if j - i <= 1:\n                if s[i] == s[j]:\n                    nList[i] = 1\n                    len_t = j - i + 1\n                    if logestLen < len_t:\n                        logestSubStr = s[i:j + 1]\n                        logestLen = len_t\n            elif s[i] == s[j] and olist[i + 1]:\n                nList[i] = 1\n                len_t = j - i + 1\n                if logestLen < len_t:\n                    logestSubStr = s[i:j + 1]\n                    logestLen = len_t\n        olist = nList\n        nList = [0] * k\n    return logestLen\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function finds the longest palindromic subsequence in a given string. It takes a string as an argument and returns an integer representing the length of the longest palindromic subsequence."}
{"prompt": "@staticmethod\ndef encode_file(file_in_name, file_out_name):\n    with open(file_in_name, 'rb') as file_in, open(file_out_name, mode='wb+') as file_out:\n        signs_frequency = HuffmanCoding._get_char_frequency(file_in)\n        file_in.seek(0)\n        tree = HuffmanCoding._create_tree(signs_frequency)\n        codes = HuffmanCoding._generate_codes(tree)\n        writer = HuffmanWriter(file_out)\n        writer.write_bits('000')\n        writer.save_tree(tree)\n        HuffmanCoding._encode_and_write_signs_to_file(file_in, writer, codes)\n        writer.close()\n    print('File encoded.')\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis staticmethod encodes a given file using the Huffman coding method. It calculates the frequency of characters in the file, creates a Huffman tree from the frequency, generates codes from the tree, writes the tree to the output file and finally encodes the signs from the input file and writes them to the output file. Prints 'File encoded.' when finished."}
{"prompt": "def palindromic_substrings(s):\n    if not s:\n        return [[]]\n    results = []\n    for i in range(len(s), 0, -1):\n        sub = s[:i]\n        if sub == sub[::-1]:\n            for rest in palindromic_substrings(s[i:]):\n                results.append([sub] + rest)\n    return results\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturn all possible palindromic substrings of a given string.\n\nArgs:\n    s (str): The given string.\n\nReturns:\n    List[List[str]]: A list of all possible palindromic substrings of the given string. \n\"\"\""}
{"prompt": "def clone(self):\n    temp_variables = {i: self.variables[i] for i in self.variables}\n    return Monomial(temp_variables, Monomial._rationalize_if_possible(self.coeff)).clean()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCreate a clone of the Monomial with the same variables and coefficients. If the coefficient is an integer, it will be converted to a rational number. The cloned Monomial will then be cleaned up."}
{"prompt": "def search(self, data):\n    return self.recur_search(self.root, data)\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nRecursively search for a given data in the tree.\n\nParameters:\n    self (Tree): The tree object.\n    data: The data to search for.\n\nReturns:\n    The node containing the data, or None if not found."}
{"prompt": "def dfs(node, dic):\n    for neighbor in node.neighbors:\n        if neighbor not in dic:\n            neighbor_copy = neighbor.shallow_copy()\n            dic[neighbor] = neighbor_copy\n            dic[node].add_neighbor(neighbor_copy)\n            dfs(neighbor, dic)\n        else:\n            dic[node].add_neighbor(dic[neighbor])\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function performs a depth-first search on a graph, given a starting node and a dictionary mapping existing nodes to copies. It recursively traverses the graph, adding copies of each node to the dictionary and connecting them to each other as neighbors."}
{"prompt": "def max_heap_sort(arr, simulation=False):\n    iteration = 0\n    if simulation:\n        print('iteration', iteration, ':', *arr)\n    for i in range(len(arr) - 1, 0, -1):\n        iteration = max_heapify(arr, i, simulation, iteration)\n    if simulation:\n        iteration = iteration + 1\n        print('iteration', iteration, ':', *arr)\n    return arr\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nmax_heap_sort(arr, simulation=False)\n\nSort an array using the max-heap sort algorithm.\n\nParameters:\narr (list): A list of integers to be sorted.\nsimulation (bool, optional): Set to True to print each iteration of the sorting process. Defaults to False.\n\nReturns:\nlist: The sorted list of integers.\n\"\"\""}
{"prompt": "def pattern_match(pattern, string):\n\n    def backtrack(pattern, string, dic):\n        if len(pattern) == 0 and len(string) > 0:\n            return False\n        if len(pattern) == len(string) == 0:\n            return True\n        for end in range(1, len(string) - len(pattern) + 2):\n            if pattern[0] not in dic and string[:end] not in dic.values():\n                dic[pattern[0]] = string[:end]\n                if backtrack(pattern[1:], string[end:], dic):\n                    return True\n                del dic[pattern[0]]\n            elif pattern[0] in dic and dic[pattern[0]] == string[:end]:\n                if backtrack(pattern[1:], string[end:], dic):\n                    return True\n        return False\n    return backtrack(pattern, string, {})\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function checks for a match between a given pattern and string. It uses backtracking to explore possible matches and return a boolean value indicating whether a match was found."}
{"prompt": "def __init__(self, frequency=0, sign=None, left=None, right=None):\n    self.frequency = frequency\n    self.sign = sign\n    self.left = left\n    self.right = right\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nInitialize a Node object.\n\nArgs:\n    frequency (int): The frequency of the node's character.\n    sign (str): The character this node represents.\n    left (Node): The node to the left of this node.\n    right (Node): The node to the right of this node.\n\"\"\""}
{"prompt": "def lowest_common_ancestor(root, p, q):\n    while root:\n        if p.val > root.val < q.val:\n            root = root.right\n        elif p.val < root.val > q.val:\n            root = root.left\n        else:\n            return root\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nFind the lowest common ancestor of two nodes in a binary search tree. \n\nParameters: \nroot (TreeNode): root of the binary search tree\np (TreeNode): node 1 \nq (TreeNode): node 2 \n\nReturns: \nTreeNode: the lowest common ancestor node of p and q"}
{"prompt": "def __init__(self):\n    self.word_dict = collections.defaultdict(list)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__() function initializes a defaultdict object with list as its default factory. The word_dict attribute of the object will be set to the initialized defaultdict object."}
{"prompt": "def delete_node(self, root, key):\n    if not root:\n        return None\n    if root.val == key:\n        if root.left:\n            left_right_most = root.left\n            while left_right_most.right:\n                left_right_most = left_right_most.right\n            left_right_most.right = root.right\n            return root.left\n        else:\n            return root.right\n    elif root.val > key:\n        root.left = self.deleteNode(root.left, key)\n    else:\n        root.right = self.deleteNode(root.right, key)\n    return root\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nDeletes a node with the given key from a binary search tree.\n\nParameters:\n    self (object): The current object.\n    root (BinarySearchTree): The root of the tree.\n    key (int): The value of the node to delete.\n\nReturns:\n    BinarySearchTree: The new root of the tree after deletion.\n\"\"\""}
{"prompt": "def put(self, key, value):\n    hash_ = self.hash(key)\n    node_ = self._table[hash_]\n    if node_ is self._empty:\n        self._table[hash_] = Node(key, value)\n    else:\n        while node_.next is not None:\n            if node_.key == key:\n                node_.value = value\n                return\n            node_ = node_.next\n        node_.next = Node(key, value)\n    self._len += 1\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes in a key and value as arguments and adds them to a hash table. If the key already exists, the value is updated. It returns nothing."}
{"prompt": "def is_sorted(arr):\n    i = 0\n    arr_len = len(arr)\n    while i + 1 < arr_len:\n        if arr[i] > arr[i + 1]:\n            return False\n        i += 1\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nis_sorted() takes an array as input and returns a boolean value. It checks to see if the array is in sorted order by comparing each element in the array with its immediate neighbor and returns False if the elements are out of order. Otherwise, it returns True."}
{"prompt": "@abstractmethod\ndef min_child(self, i):\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis is an abstract method for obtaining the minimum child of a node in a tree-like structure.\n\nParameters: \n    i (int): The node index to obtain the minimum child from.\n\nReturns: \n    The index of the minimum child of the given node."}
{"prompt": "def pigeonhole_sort(arr):\n    Max = max(arr)\n    Min = min(arr)\n    size = Max - Min + 1\n    holes = [0] * size\n    for i in arr:\n        holes[i - Min] += 1\n    i = 0\n    for count in range(size):\n        while holes[count] > 0:\n            holes[count] -= 1\n            arr[i] = count + Min\n            i += 1\n    return arr\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function uses the pigeonhole sort algorithm to sort an array. It takes in an array and returns the sorted array. The algorithm works by first finding the minimum and maximum values in the array, creating a \"holes\" list with the size of the difference between the min and max values, and then iterating through the array to increment the \"holes\" list at the right indices. Finally, it iterates through the \"holes\" list and assigns values to the array according to the \"holes\" list, returning the sorted array. \n\"\"\""}
{"prompt": "def next_greatest_letter(letters, target):\n    index = bisect.bisect(letters, target)\n    return letters[index % len(letters)]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturn the next greatest letter in a given list of letters relative to a given target letter. If the target letter is greater than or equal to the last letter in the list, the first letter in the list will be returned.\n\"\"\""}
{"prompt": "def copy_random_pointer_v1(head):\n    dic = dict()\n    m = n = head\n    while m:\n        dic[m] = RandomListNode(m.label)\n        m = m.next\n    while n:\n        dic[n].next = dic.get(n.next)\n        dic[n].random = dic.get(n.random)\n        n = n.next\n    return dic.get(head)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes a head node of a linked list with random pointers as an argument and creates a copy of the linked list with the same random pointers and returns the head node of the new list."}
{"prompt": "def powerset(iterable):\n    \"\"\"list(powerset([1,2,3])) --> [(), (1,), (2,), (3,), (1,2), (1,3), (2,3), (1,2,3)]\"\"\"\n    s = list(iterable)\n    return chain.from_iterable((combinations(s, r) for r in range(len(s) + 1)))\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function returns a chain object (lazy iterator) that produces the power set of the given iterable. The power set is the set of all subsets of a given set, including the empty set and the original set."}
{"prompt": "def bucket_sort(arr):\n    num_buckets = len(arr)\n    buckets = [[] for bucket in range(num_buckets)]\n    for value in arr:\n        index = value * num_buckets // (max(arr) + 1)\n        buckets[index].append(value)\n    sorted_list = []\n    for i in range(num_buckets):\n        sorted_list.extend(next_sort(buckets[i]))\n    return sorted_list\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function implements the bucket sort algorithm to sort a given list. The list is divided into buckets, and the elements within each bucket are sorted using an alternate sorting algorithm (next_sort). The buckets are then combined to form a sorted list."}
{"prompt": "def push(self, item):\n    temp_stack = OrderedStack()\n    if self.is_empty() or item > self.peek():\n        self.push_t(item)\n    else:\n        while item < self.peek() and (not self.is_empty()):\n            temp_stack.push_t(self.pop())\n        self.push_t(item)\n        while not temp_stack.is_empty():\n            self.push_t(temp_stack.pop())\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nPush an item onto the OrderedStack. If the item is larger than the top item in the stack, push the item to the top. If the item is smaller, push the top item onto a temporary stack, then push the item, then push the remaining items from the temporary stack.\n\"\"\""}
{"prompt": "def rotate_v2(array, k):\n    array = array[:]\n\n    def reverse(arr, a, b):\n        while a < b:\n            (arr[a], arr[b]) = (arr[b], arr[a])\n            a += 1\n            b -= 1\n    n = len(array)\n    k = k % n\n    reverse(array, 0, n - k - 1)\n    reverse(array, n - k, n - 1)\n    reverse(array, 0, n - 1)\n    return array\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nrotate_v2(array, k) takes an array and an integer k as inputs, and returns a new array with the elements of the original array rotated k places to the right."}
{"prompt": "def array_to_bst(nums):\n    if not nums:\n        return None\n    mid = len(nums) // 2\n    node = TreeNode(nums[mid])\n    node.left = array_to_bst(nums[:mid])\n    node.right = array_to_bst(nums[mid + 1:])\n    return node\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Convert a sorted array to a binary search tree.\n\nArgs:\n    nums (list): List of sorted integers.\n\nReturns:\n    TreeNode: Root node of binary search tree.\n\"\"\""}
{"prompt": "def strobogrammatic_in_range(low, high):\n    res = []\n    count = 0\n    low_len = len(low)\n    high_len = len(high)\n    for i in range(low_len, high_len + 1):\n        res.extend(helper2(i, i))\n    for perm in res:\n        if len(perm) == low_len and int(perm) < int(low):\n            continue\n        if len(perm) == high_len and int(perm) > int(high):\n            continue\n        count += 1\n    return count\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function finds the number of strobogrammatic numbers in a given range. It takes two strings, low and high, as parameters and returns an integer representing the count of strobogrammatic numbers in the given range."}
{"prompt": "def print_matrix(matrix, name):\n    print('{}:\\n['.format(name))\n    for row in matrix:\n        print('  {}'.format(row))\n    print(']\\n')\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nPrints the given matrix to the console with the given name.\n\nParameters:\n    matrix (list of lists): A matrix to be printed.\n    name (str): The name to be displayed above the matrix.\n\"\"\""}
{"prompt": "def is_empty(self):\n    return self._size == 0\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nReturn True if the size of the object is 0, False otherwise."}
{"prompt": "def __init__(self):\n    self.parents = {}\n    self.size = {}\n    self.count = 0\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__(self)\n\nInitialize the data structure for Union Find. \n\nParameters:\nself (UnionFind): The instance of the UnionFind class.\n\nAttributes:\nparents (dict): A dictionary mapping items to their parent.\nsize (dict): A dictionary mapping items to the size of its component.\ncount (int): The total number of components."}
{"prompt": "def update_heights(self, recursive=True):\n    if self.node:\n        if recursive:\n            if self.node.left:\n                self.node.left.update_heights()\n            if self.node.right:\n                self.node.right.update_heights()\n        self.height = 1 + max(self.node.left.height, self.node.right.height)\n    else:\n        self.height = -1\n##############\nEND_FUNC\n##############\n", "completion": "\n\nUpdate the heights of the current node and its descendants.\nIf recursive is set to True, update the heights of all descendants. The height of a node is equal to the maximum of the heights of its two subtrees plus one. The height of a leaf node is zero."}
{"prompt": "def print_linked_list(head):\n    string = ''\n    while head.next:\n        string += str(head.val) + ' -> '\n        head = head.next\n    string += str(head.val)\n    print(string)\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nPrint a linked list, given the head node, in the format \"val1 -> val2 -> val3 -> ... -> valn\"."}
{"prompt": "def __init__(self, freq):\n    self.arr = freq\n    self.n = len(freq)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function is a class constructor for a data structure that stores an array of frequencies (freq) and its length (n)."}
{"prompt": "def clone(self):\n    return Polynomial(list({m.clone() for m in self.all_monomials()}))\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nClone a Polynomial object.\n\nThis function creates a new Polynomial object that is a clone of the original. It does this by looping through all the Monomial objects in the original Polynomial, cloning each one, and adding them to a new Polynomial object."}
{"prompt": "def power(a: int, n: int, mod: int=None):\n    ans = 1\n    while n:\n        if n & 1:\n            ans = ans * a\n        a = a * a\n        if mod:\n            ans %= mod\n            a %= mod\n        n >>= 1\n    return ans\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"Computes a to the power of n, with an optional modulus.\n\nArgs:\n    a (int): The base.\n    n (int): The exponent.\n    mod (int, optional): A modulus. Defaults to None.\n\nReturns:\n    int: The result of a to the power of n, modulo mod if specified.\n\"\"\""}
{"prompt": "def recur_insert(self, root, data):\n    if root.data == data:\n        return False\n    elif data < root.data:\n        if root.left:\n            return self.recur_insert(root.left, data)\n        else:\n            root.left = Node(data)\n            return True\n    elif root.right:\n        return self.recur_insert(root.right, data)\n    else:\n        root.right = Node(data)\n        return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nRecursively insert a node into a binary search tree.\n\nInputs:\n- self: reference to the object\n- root: the root node of the binary search tree\n- data: the data to be inserted into the binary search tree\n\nReturns:\nTrue if the data was successfully inserted, False if it was already present."}
{"prompt": "def multiply(num1: 'str', num2: 'str') -> 'str':\n    interm = []\n    zero = ord('0')\n    i_pos = 1\n    for i in reversed(num1):\n        j_pos = 1\n        add = 0\n        for j in reversed(num2):\n            mult = (ord(i) - zero) * (ord(j) - zero) * j_pos * i_pos\n            j_pos *= 10\n            add += mult\n        i_pos *= 10\n        interm.append(add)\n    return str(sum(interm))\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes two strings representing numbers and returns a string representing the product of the two numbers. The multiplication is done by multiplying each digit in one number with each digit in the other number and adding up the products."}
{"prompt": "def unary(x):\n    return (x - 1) * '1' + '0'\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nThis function takes in a number 'x' and returns a string of length 'x' consisting of '1's followed by a '0'."}
{"prompt": "def set_bit(num, i):\n    return num | 1 << i\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function sets the bit at index i of the given number, num, to 1 and returns the modified number."}
{"prompt": "def __is_balanced_recursive(root):\n    return -1 != __get_depth(root)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function returns a boolean indicating whether a binary tree is balanced or not. It uses a recursive approach to determine the depth of the tree and returns False if the tree is not balanced."}
{"prompt": "def recur_search(self, root, data):\n    if root is None:\n        return False\n    if root.data == data:\n        return True\n    elif data > root.data:\n        return self.recur_search(root.right, data)\n    else:\n        return self.recur_search(root.left, data)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nRecursively search for a given data in a binary search tree.\n\nArgs:\n    root (Node): The root node of a binary search tree.\n    data (int): The data to be searched for in the tree.\n\nReturns:\n    bool: True if the data is found in the tree, False otherwise."}
{"prompt": "def backtrack(res, nums, stack, pos):\n    if pos == len(nums):\n        res.add(tuple(stack))\n    else:\n        stack.append(nums[pos])\n        backtrack(res, nums, stack, pos + 1)\n        stack.pop()\n        backtrack(res, nums, stack, pos + 1)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function performs a backtracking algorithm to find all possible permutations of a given list of numbers. It takes in a result set (\"res\"), list of numbers (\"nums\"), a stack, and a starting position (\"pos\"). It recursively adds each number from the list of numbers to the stack and calls backtrack with an incremented position. It then pops the number from the stack and continues the recursive call without adding the number to the stack. When the position is equal to the length of the list of numbers, the stack is added to the result set as a tuple."}
{"prompt": "def is_sorted(head):\n    if not head:\n        return True\n    current = head\n    while current.next:\n        if current.val > current.next.val:\n            return False\n        current = current.next\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\n'''\nThis function takes in a head of a linked list and checks if the list is sorted in ascending order. It returns True if the list is sorted and False otherwise."}
{"prompt": "def find_factorial(n):\n    fact = 1\n    while n != 0:\n        fact *= n\n        n -= 1\n    return fact\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"This function calculates the factorial of a given number.\nIt takes an integer 'n' as input and returns the factorial of the given number.\"\"\""}
{"prompt": "def __repr__(self):\n    return self.name\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis method returns the string representation of the object (the name attribute). It is used when the object is printed or converted to a string."}
{"prompt": "def close(self):\n    additional_bits = 8 - len(self.buffer)\n    if additional_bits != 8:\n        self.write_bits('0' * additional_bits)\n        self._save_information_about_additional_bits(additional_bits)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nClose the bit stream by writing any remaining bits and save any additional information needed to decode the stream.\n\"\"\""}
{"prompt": "def valid_solution_hashtable(board):\n    for i in range(len(board)):\n        dict_row = defaultdict(int)\n        dict_col = defaultdict(int)\n        for j in range(len(board[0])):\n            value_row = board[i][j]\n            value_col = board[j][i]\n            if not value_row or value_col == 0:\n                return False\n            if value_row in dict_row:\n                return False\n            else:\n                dict_row[value_row] += 1\n            if value_col in dict_col:\n                return False\n            else:\n                dict_col[value_col] += 1\n    for i in range(3):\n        for j in range(3):\n            grid_add = 0\n            for k in range(3):\n                for l in range(3):\n                    grid_add += board[i * 3 + k][j * 3 + l]\n            if grid_add != 45:\n                return False\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function checks if a given board is a valid solution to a sudoku puzzle. It uses a hashtable to check if each row and column contain each number 1-9 only once. It also checks if each 3x3 grid adds up to 45. Returns True if valid, False if not."}
{"prompt": "def _find_largest_and_delete_in_left_subtree(self, node: Node):\n    if node.is_leaf:\n        return node.keys.pop()\n    else:\n        ch_index = len(node.children) - 1\n        self._repair_tree(node, ch_index)\n        largest_key_in_subtree = self._find_largest_and_delete_in_left_subtree(node.children[len(node.children) - 1])\n        return largest_key_in_subtree\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function finds the largest key in the left subtree of the given node and deletes it. It recursively calls itself on the rightmost child of the given node. It then repairs the tree if necessary and returns the largest key in the left subtree."}
{"prompt": "def __init__(self, val=None):\n    self.val = val\n    self.next = None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__() is the constructor of the Node class. It initializes a new Node object with an optional parameter val to assign a value to the Node's val attribute and sets the Node's next attribute to None."}
{"prompt": "def enqueue(self, value):\n    node = QueueNode(value)\n    if self._front is None:\n        self._front = node\n        self._rear = node\n    else:\n        self._rear.next = node\n        self._rear = node\n    self._size += 1\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"Add a node with given value to the rear of the queue.\""}
{"prompt": "def longest_increasing_subsequence_optimized2(sequence):\n    length = len(sequence)\n    tree = [0] * (length << 2)\n    sorted_seq = sorted(((x, -i) for (i, x) in enumerate(sequence)))\n\n    def update(pos, left, right, target, vertex):\n        if left == right:\n            tree[pos] = vertex\n            return\n        mid = left + right >> 1\n        if target <= mid:\n            vertex(pos << 1, left, mid, target, vertex)\n        else:\n            vertex(pos << 1 | 1, mid + 1, right, target, vertex)\n        tree[pos] = max(tree[pos << 1], tree[pos << 1 | 1])\n\n    def get_max(pos, left, right, start, end):\n        if left > end or right < start:\n            return 0\n        if left >= start and right <= end:\n            return tree[pos]\n        mid = left + right >> 1\n        return max(get_max(pos << 1, left, mid, start, end), get_max(pos << 1 | 1, mid + 1, right, start, end))\n    ans = 0\n    for tup in sorted_seq:\n        i = -tup[1]\n        cur = get_max(1, 0, length - 1, 0, i - 1) + 1\n        ans = max(ans, cur)\n        update(1, 0, length - 1, i, cur)\n    return ans\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function finds the length of the longest increasing subsequence in a given sequence. It uses an optimized version of the segment tree data structure to efficiently search for the longest sequence."}
{"prompt": "def __repr__(self):\n    return '{}: {}'.format(self.data, self.priority)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturns a string representation of the data and priority for the object."}
{"prompt": "def __init__(self, variables: Dict[int, int], coeff: Union[int, float, Fraction, None]=None) -> None:\n    self.variables = dict()\n    if coeff is None:\n        if len(variables) == 0:\n            coeff = Fraction(0, 1)\n        else:\n            coeff = Fraction(1, 1)\n    elif coeff == 0:\n        self.coeff = Fraction(0, 1)\n        return\n    if len(variables) == 0:\n        self.coeff = Monomial._rationalize_if_possible(coeff)\n        return\n    for i in variables:\n        if variables[i] != 0:\n            self.variables[i] = variables[i]\n    self.coeff = Monomial._rationalize_if_possible(coeff)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__(self, variables: Dict[int, int], coeff: Union[int, float, Fraction, None]=None) -> None:\n    \"\"\"Initialize a Monomial object with a given coefficient and variables.\n\n    Args:\n        variables (Dict[int, int]): The variables of the monomial.\n        coeff (Union[int, float, Fraction, None]): The coefficient of the monomial. If None, the coefficient will be set to 1 or 0 depending on the variables.\n\n    Returns:\n        None\n    \"\"\""}
{"prompt": "def swap(i, j):\n    (arr[i], arr[j]) = (arr[j], arr[i])\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Swap two elements in an array by their indices.\"\"\""}
{"prompt": "def simplify_path(path):\n    skip = {'..', '.', ''}\n    stack = []\n    paths = path.split('/')\n    for tok in paths:\n        if tok == '..':\n            if stack:\n                stack.pop()\n        elif tok not in skip:\n            stack.append(tok)\n    return '/' + '/'.join(stack)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nSimplify a given file path by removing '..', '.', and empty strings from the path. Returns the simplified path. \n\"\"\""}
{"prompt": "def get_factors_iterative1(n):\n    (todo, res) = ([(n, 2, [])], [])\n    while todo:\n        (n, i, combi) = todo.pop()\n        while i * i <= n:\n            if n % i == 0:\n                res += (combi + [i, n // i],)\n                (todo.append((n // i, i, combi + [i])),)\n            i += 1\n    return res\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function returns a list of tuples, each containing all the prime factors of n. It uses an iterative approach to generate the result."}
{"prompt": "def __init__(self, val=None):\n    self.val = int(val)\n    self.next = None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__(self, val=None)\n\nConstructor to initialize a node object.\n\nArgs:\n    val (int, optional): Value of the node. Defaults to None.\n\nAttributes:\n    val (int): Value of the node.\n    next (Node, optional): Reference to the next node in the linked list. Defaults to None."}
{"prompt": "def plus_one_v2(digits):\n    n = len(digits)\n    for i in range(n - 1, -1, -1):\n        if digits[i] < 9:\n            digits[i] += 1\n            return digits\n        digits[i] = 0\n    digits.insert(0, 1)\n    return digits\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nplus_one_v2 takes in a list of digits and returns a list that is the number represented by the list plus 1. It does so by starting from the last digit in the list and incrementing it if it's less than 9, or setting it to 0 if it's 9 and moving on to the next digit. If all the digits are 9, it adds a 1 to the beginning of the list.\n\"\"\""}
{"prompt": "def common_prefix(s1, s2):\n    if not s1 or not s2:\n        return ''\n    k = 0\n    while s1[k] == s2[k]:\n        k = k + 1\n        if k >= len(s1) or k >= len(s2):\n            return s1[0:k]\n    return s1[0:k]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nFind the longest common prefix of two strings.\n\nArgs:\ns1 (str): First string.\ns2 (str): Second string.\n\nReturns:\nstr: The longest common prefix of the two strings. If either string is empty, an empty string is returned."}
{"prompt": "def transplant(self, node_u, node_v):\n    if node_u.parent is None:\n        self.root = node_v\n    elif node_u is node_u.parent.left:\n        node_u.parent.left = node_v\n    elif node_u is node_u.parent.right:\n        node_u.parent.right = node_v\n    if node_v:\n        node_v.parent = node_u.parent\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"Transplant node_u with node_v, updating the tree accordingly.\""}
{"prompt": "def join_with_slash(base, suffix):\n    base = base.rstrip('/')\n    suffix = suffix.lstrip('/').rstrip()\n    full_path = '{}/{}'.format(base, suffix)\n    return full_path\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"Join two strings with a slash. Strips any trailing slashes from base and leading/trailing slashes from suffix before joining them together.\""}
{"prompt": "def __sub__(self, other: Union[int, float, Fraction, Monomial]):\n    if isinstance(other, int) or isinstance(other, float) or isinstance(other, Fraction):\n        return self.__sub__(Monomial({}, Polynomial._rationalize_if_possible(other)))\n    elif isinstance(other, Monomial):\n        monos = {m.clone() for m in self.all_monomials()}\n        for _own_monos in monos:\n            if _own_monos.equal_upto_scalar(other):\n                scalar = _own_monos.coeff\n                monos -= {_own_monos}\n                temp_variables = {i: other.variables[i] for i in other.variables}\n                monos |= {Monomial(temp_variables, Polynomial._rationalize_if_possible(scalar - other.coeff))}\n                return Polynomial([z for z in monos])\n        to_insert = other.clone()\n        to_insert.coeff *= -1\n        monos |= {to_insert}\n        return Polynomial([z for z in monos])\n    elif isinstance(other, Polynomial):\n        p = Polynomial(list((z for z in {m.clone() for m in self.all_monomials()})))\n        for o in other.all_monomials():\n            p = p.__sub__(o.clone())\n        return p\n    else:\n        raise ValueError('Can only subtract int, float, Fraction, Monomials, or Polynomials from Polynomials.')\n        return\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function subtracts ints, floats, Fractions, Monomials, or Polynomials from Polynomials. It returns a new Polynomial object that represents the result."}
{"prompt": "def search_rotate(array, val):\n    (low, high) = (0, len(array) - 1)\n    while low <= high:\n        mid = (low + high) // 2\n        if val == array[mid]:\n            return mid\n        if array[low] <= array[mid]:\n            if array[low] <= val <= array[mid]:\n                high = mid - 1\n            else:\n                low = mid + 1\n        elif array[mid] <= val <= array[high]:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nsearch_rotate(array, val):\n    Search 'val' in a sorted and rotated array 'array'.\n    If 'val' is present, return its index; else return -1.\n    'array' may contain duplicates.\n\"\"\""}
{"prompt": "def palindromic_substrings_iter(s):\n    if not s:\n        yield []\n        return\n    for i in range(len(s), 0, -1):\n        sub = s[:i]\n        if sub == sub[::-1]:\n            for rest in palindromic_substrings_iter(s[i:]):\n                yield ([sub] + rest)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes a string as an argument and yields a list of all possible palindromic substrings within that string. The strings are yielded in descending order of length."}
{"prompt": "def convert_to_list(number: int) -> Node:\n    if number >= 0:\n        head = Node(0)\n        current = head\n        remainder = number % 10\n        quotient = number // 10\n        while quotient != 0:\n            current.next = Node(remainder)\n            current = current.next\n            remainder = quotient % 10\n            quotient //= 10\n        current.next = Node(remainder)\n        return head.next\n    else:\n        print('number must be positive!')\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes in a positive integer and returns a linked list containing the individual digits of the given number."}
{"prompt": "def main():\n    array = [30, 35, 15, 5, 10, 20, 25]\n    length = len(array)\n    (matrix, optimal_solution) = matrix_chain_order(array)\n    print('No. of Operation required: ' + str(matrix[1][length - 1]))\n    print_optimal_solution(optimal_solution, 1, length - 1)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function computes the number of operations required to multiply a given set of matrices using the Matrix Chain Multiplication (MCM) algorithm. It also prints the optimal solution for the matrices."}
{"prompt": "def __init__(self, val):\n    self.val = val\n    self.next = None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function is a constructor for a linked list node. It takes in a value (val) and initializes the linked list node with it. It also sets the next node to None."}
{"prompt": "def is_match(str_a, str_b):\n    (len_a, len_b) = (len(str_a) + 1, len(str_b) + 1)\n    matches = [[False] * len_b for _ in range(len_a)]\n    matches[0][0] = True\n    for (i, element) in enumerate(str_b[1:], 2):\n        matches[0][i] = matches[0][i - 2] and element == '*'\n    for (i, char_a) in enumerate(str_a, 1):\n        for (j, char_b) in enumerate(str_b, 1):\n            if char_b != '*':\n                matches[i][j] = matches[i - 1][j - 1] and char_b in (char_a, '.')\n            else:\n                matches[i][j] |= matches[i][j - 2]\n                if char_a == str_b[j - 2] or str_b[j - 2] == '.':\n                    matches[i][j] |= matches[i - 1][j]\n    return matches[-1][-1]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function checks whether two strings, str_a and str_b, match according to the rules of regular expressions. It returns a boolean value. \nA match is defined as any combination of characters (including the empty string) that satisfies the following rules:\n- '.' matches any character\n- '*' matches zero or more of the preceding character"}
{"prompt": "def __init__(self, val, is_red, parent=None, left=None, right=None):\n    self.val = val\n    self.parent = parent\n    self.left = left\n    self.right = right\n    self.color = is_red\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis is an initialization constructor for a Red-Black Tree node. It creates a new node with the given value, color, parent, left child and right child. \nval (int): Value of the node\nis_red (bool): Color of the node, True if red, False if black\nparent (node): Parent node of the current node\nleft (node): Left child node of the current node\nright (node): Right child node of the current node"}
{"prompt": "def find_nth_digit(n):\n    length = 1\n    count = 9\n    start = 1\n    while n > length * count:\n        n -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n    start += (n - 1) / length\n    s = str(start)\n    return int(s[(n - 1) % length])\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nfind_nth_digit(n):\n    Finds and returns the nth digit of a number.\n    Args:\n        n (int): The position of the digit to be found.\n    Returns:\n        int: The nth digit of a number.\n\"\"\""}
{"prompt": "def has_next(self):\n    return bool(self.stack)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function checks if the stack contains any elements and returns True if there are elements and False if there are not."}
{"prompt": "def alice_private_key(p):\n    return randint(1, p - 1)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function returns a random integer between 1 and p-1. It is used to generate a private key for Alice."}
{"prompt": "def find_primitive_root(n):\n    if n == 1:\n        return [0]\n    phi = euler_totient(n)\n    p_root_list = []\n    for i in range(1, n):\n        if math.gcd(i, n) != 1:\n            continue\n        order = find_order(i, n)\n        if order == phi:\n            p_root_list.append(i)\n    return p_root_list\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Finds the primitive root of a given number n.\n\nA primitive root of a positive integer n is an integer r such that the values of\nthe powers of r (modulo n) are all different from each other.\n\nArgs:\n    n (int): The number whose primitive root we want to find.\n\nReturns:\n    A list of the primitive roots of n.\n\"\"\""}
{"prompt": "def sort_diagonally(mat: List[List[int]]) -> List[List[int]]:\n    if len(mat) == 1 or len(mat[0]) == 1:\n        return mat\n    for i in range(len(mat) + len(mat[0]) - 1):\n        if i + 1 < len(mat):\n            h = []\n            row = len(mat) - (i + 1)\n            col = 0\n            while row < len(mat):\n                heappush(h, mat[row][col])\n                row += 1\n                col += 1\n            row = len(mat) - (i + 1)\n            col = 0\n            while h:\n                ele = heappop(h)\n                mat[row][col] = ele\n                row += 1\n                col += 1\n        else:\n            h = []\n            row = 0\n            col = i - (len(mat) - 1)\n            while col < len(mat[0]) and row < len(mat):\n                heappush(h, mat[row][col])\n                row += 1\n                col += 1\n            row = 0\n            col = i - (len(mat) - 1)\n            while h:\n                ele = heappop(h)\n                mat[row][col] = ele\n                row += 1\n                col += 1\n    return mat\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function sorts the elements of a given matrix diagonally from top left to bottom right using the heapsort algorithm."}
{"prompt": "def peek(self):\n    if self.is_empty():\n        raise IndexError('Queue is empty')\n    return self._array[self._front]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturn the element at the front of the queue without removing it from the queue. Raises an IndexError if the queue is empty."}
{"prompt": "def get_factors_iterative2(n):\n    (ans, stack, x) = ([], [], 2)\n    while True:\n        if x > n // x:\n            if not stack:\n                return ans\n            ans.append(stack + [n])\n            x = stack.pop()\n            n *= x\n            x += 1\n        elif n % x == 0:\n            stack.append(x)\n            n //= x\n        else:\n            x += 1\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function returns the factors of a given number 'n' as a list. It does so using an iterative approach, with the help of a stack.\n\"\"\""}
{"prompt": "def reverse_vowel(s):\n    vowels = 'AEIOUaeiou'\n    (i, j) = (0, len(s) - 1)\n    s = list(s)\n    while i < j:\n        while i < j and s[i] not in vowels:\n            i += 1\n        while i < j and s[j] not in vowels:\n            j -= 1\n        (s[i], s[j]) = (s[j], s[i])\n        (i, j) = (i + 1, j - 1)\n    return ''.join(s)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes a string 's' as an argument and reverses the order of vowels in it. It traverses the string from both ends and swaps the vowels until it reaches the middle. Finally, it returns the reversed string."}
{"prompt": "def _check_coprime(list_to_check: List[int]):\n    for (ind, num) in enumerate(list_to_check):\n        for num2 in list_to_check[ind + 1:]:\n            if gcd(num, num2) != 1:\n                return False\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nCheck if a list of numbers are coprime (mutually prime).\n\nArgs:\n    list_to_check (List[int]): The list of numbers to check.\n\nReturns:\n    bool: True if all numbers in the list are coprime, False otherwise."}
{"prompt": "def __init__(self, dict_graph):\n    self.graph = DirectedGraph(dict_graph)\n    self.index = 0\n    self.stack = []\n    for vertex in self.graph.nodes:\n        vertex.index = None\n    self.sccs = []\n    for vertex in self.graph.nodes:\n        if vertex.index is None:\n            self.strongconnect(vertex, self.sccs)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nInitializes an instance of the Kosaraju's Algorithm class, which uses the provided directed graph to find the strongly connected components in the graph.\n\"\"\""}
{"prompt": "def check_pangram(input_string):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    for ch in alphabet:\n        if ch not in input_string.lower():\n            return False\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\ncheck_pangram(input_string)\n\nReturns True if the given string is a pangram, False otherwise. A pangram is a sentence using every letter of the alphabet at least once. The input string is case insensitive."}
{"prompt": "def update(self, p, v):\n    p += self.size\n    self.tree[p] = v\n    while p > 1:\n        p = p // 2\n        self.tree[p] = self.fn(self.tree[p * 2], self.tree[p * 2 + 1])\n##############\nEND_FUNC\n##############\n", "completion": "\n\nUpdate the value at position p in the tree with the new value v. Updates the values of the tree from the bottom up to ensure that the fn applied to all parent nodes stays valid."}
{"prompt": "def reverse(root):\n    if root is None:\n        return\n    (root.left, root.right) = (root.right, root.left)\n    if root.left:\n        reverse(root.left)\n    if root.right:\n        reverse(root.right)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReverse the left and right nodes of a binary tree.\n\nParameters:\n    root (TreeNode): The root node of the tree.\n\nReturns:\n    None: The nodes of the tree are reversed in place.\n\"\"\""}
{"prompt": "@abstractmethod\ndef remove_min(self):\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Remove the smallest item from this heap and return it.\n\nRaises a ValueError if this heap is empty.\n\"\"\""}
{"prompt": "def print_linked_list(head):\n    string = ''\n    while head.next:\n        string += head.val + ' -> '\n        head = head.next\n    string += head.val\n    print(string)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nPrints out a linked list given the head node of the linked list. Output is a string of the linked list's values separated by arrows (->)."}
{"prompt": "def subs(self, substitutions: Union[int, float, Fraction, Dict[int, Union[int, float, Fraction]]]) -> Union[int, float, Fraction]:\n    if isinstance(substitutions, int) or isinstance(substitutions, float) or isinstance(substitutions, Fraction):\n        substitutions = {i: Polynomial._rationalize_if_possible(substitutions) for i in set(self.variables())}\n        return self.subs(substitutions)\n    elif not isinstance(substitutions, dict):\n        raise ValueError('The substitutions should be a dictionary.')\n    if not self.variables().issubset(set(substitutions.keys())):\n        raise ValueError(\"Some variables didn't receive their values.\")\n    ans = 0\n    for m in self.all_monomials():\n        ans += Polynomial._rationalize_if_possible(m.substitute(substitutions))\n    return Polynomial._rationalize_if_possible(ans)\n##############\nEND_FUNC\n##############\n", "completion": "\nThis function takes a dictionary, or an integer, float, or fraction, and substitutes any variables in the polynomial with the given values. It then returns the result as an integer, float, or fraction."}
{"prompt": "def valid_solution_set(board):\n    valid = set(range(1, 10))\n    for row in board:\n        if set(row) != valid:\n            return False\n    for col in [[row[i] for row in board] for i in range(9)]:\n        if set(col) != valid:\n            return False\n    for x in range(3):\n        for y in range(3):\n            if set(sum([row[x * 3:(x + 1) * 3] for row in board[y * 3:(y + 1) * 3]], [])) != valid:\n                return False\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes in a board and checks if it is a valid solution set. It checks the rows, columns, and 3x3 sub-squares of the board to make sure that each contains the numbers 1-9. If the board is a valid solution set, it returns True, otherwise it returns False."}
{"prompt": "def rotate_right(head, k):\n    if not head or not head.next:\n        return head\n    current = head\n    length = 1\n    while current.next:\n        current = current.next\n        length += 1\n    current.next = head\n    k = k % length\n    for i in range(length - k):\n        current = current.next\n    head = current.next\n    current.next = None\n    return head\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nRotate the given linked list to the right by k nodes.\n\nArgs:\n    head (ListNode): The head node of the linked list\n    k (int): The number of nodes to rotate right\n\nReturns:\n    ListNode: The head node of the rotated linked list\n\"\"\""}
{"prompt": "def dfs(res, nums, path):\n    if not nums:\n        res.append(path)\n    for i in range(len(nums)):\n        print(nums[:i] + nums[i + 1:])\n        dfs(res, nums[:i] + nums[i + 1:], path + [nums[i]])\n##############\nEND_FUNC\n##############\n", "completion": "\n\n'''\nThis function performs a depth-first search on a list of numbers. It takes in a list of results, a list of numbers, and a path. It adds the current path to the list of results if the list of numbers is empty. It then recursively calls itself with the list of numbers without the current number, and a path with the current number added to it.\n\nReturns a list of paths.\n'''"}
{"prompt": "def permute_iter(elements):\n    if len(elements) <= 1:\n        yield elements\n    else:\n        for perm in permute_iter(elements[1:]):\n            for i in range(len(elements)):\n                yield (perm[:i] + elements[0:1] + perm[i:])\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nGenerates all possible permutations of a given list of elements.\nYields the permutations one at a time as a generator. \n\"\"\""}
{"prompt": "def kruskal(vertex_count, edges, forest):\n    edges.sort(key=lambda edge: edge.weight)\n    mst = []\n    for edge in edges:\n        set_u = forest.find_set(edge.u)\n        set_v = forest.find_set(edge.v)\n        if set_u != set_v:\n            forest.merge_set(set_u, set_v)\n            mst.append(edge)\n            if len(mst) == vertex_count - 1:\n                break\n    return sum([edge.weight for edge in mst])\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nImplement Kruskal's algorithm for finding the minimum spanning tree of a graph.\n\nParameters: \nvertex_count (int): The total number of vertices in the graph. \nedges (list): A list of Edge objects representing the edges of the graph. \nforest (UnionFind): An instance of the UnionFind class to keep track of the connected components of the graph. \n\nReturns: \nint: The total weight of the minimum spanning tree. \n\"\"\""}
{"prompt": "def build_tree(self):\n    for i in range(self.size - 1, 0, -1):\n        self.tree[i] = self.fn(self.tree[i * 2], self.tree[i * 2 + 1])\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nBuilds a tree from the given list of elements of size 'size' according to the given function 'fn'. \nThe tree is constructed by starting from the last index in the list and going backwards, setting each index \nto the result of the given function applied to the elements at the child indices."}
{"prompt": "def dfs_util(self, source, visited):\n    visited[source] = True\n    for adjacent in self.graph[source]:\n        if not visited[adjacent]:\n            self.dfs_util(adjacent, visited)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\ndfs_util is a recursive utility function for Depth-First Search (DFS) algorithm. It takes in two parameters: a source vertex and a visited list. It marks the source vertex as visited and then recursively calls itself for all adjacent vertices of the source vertex, passing in the adjacent vertex and the visited list."}
{"prompt": "def second_stutter(stack):\n    q = collections.deque()\n    for i in range(len(stack)):\n        q.append(stack.pop())\n    for i in range(len(q)):\n        stack.append(q.pop())\n    for i in range(len(stack)):\n        q.append(stack.pop())\n    for i in range(len(q)):\n        val = q.pop()\n        stack.append(val)\n        stack.append(val)\n    return stack\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function takes a stack as an argument, reverses it, then returns a new stack that contains each element twice."}
{"prompt": "def get_maximum_value(items, capacity):\n    dp = [0] * (capacity + 1)\n    for item in items:\n        for cur_weight in reversed(range(item.weight, capacity + 1)):\n            dp[cur_weight] = max(dp[cur_weight], item.value + dp[cur_weight - item.weight])\n    return dp[capacity]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nget_maximum_value(items, capacity) -> int\n    Returns the maximum total value of a set of items with the given weight capacity.\n    items: a list of objects with \"value\" and \"weight\" attributes\n    capacity: the maximum weight capacity of the items\n\"\"\""}
{"prompt": "def merge_two_list(l1, l2):\n    ret = cur = Node(0)\n    while l1 and l2:\n        if l1.val < l2.val:\n            cur.next = l1\n            l1 = l1.next\n        else:\n            cur.next = l2\n            l2 = l2.next\n        cur = cur.next\n    cur.next = l1 or l2\n    return ret.next\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function merges two given linked lists (l1 and l2) into a single linked list. The merged linked list is returned. The nodes of the merged linked list are in ascending order based on the values of their nodes."}
{"prompt": "def domain_name_2(url):\n    return url.split('//')[-1].split('www.')[-1].split('.')[0]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes in a URL and returns the domain name of the URL without the top-level domain.\n\"\"\""}
{"prompt": "def __mul__(self, other: Union[int, float, Fraction]):\n    if isinstance(other, float) or isinstance(other, int) or isinstance(other, Fraction):\n        mono = {i: self.variables[i] for i in self.variables}\n        return Monomial(mono, Monomial._rationalize_if_possible(self.coeff * other)).clean()\n    if not isinstance(other, Monomial):\n        raise ValueError('Can only multiply monomials, ints, floats, or Fractions.')\n    else:\n        mono = {i: self.variables[i] for i in self.variables}\n        for i in other.variables:\n            if i in mono:\n                mono[i] += other.variables[i]\n            else:\n                mono[i] = other.variables[i]\n        temp = dict()\n        for k in mono:\n            if mono[k] != 0:\n                temp[k] = mono[k]\n        return Monomial(temp, Monomial._rationalize_if_possible(self.coeff * other.coeff)).clean()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nMulitply two Monomials together, or a Monomial and an int, float, or Fraction. Returns a Monomial with the combined variable powers and multiplied coefficients."}
{"prompt": "def __delitem__(self, key):\n    return self.del_(key)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nDelete the item associated with the given key from the dictionary."}
{"prompt": "def __init__(self, key=None, value=None, next=None):\n    self.key = key\n    self.value = value\n    self.next = next\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function is the constructor for the Node class. It takes three arguments, key, value, and next, all of which are set to None by default. The key and value are assigned to the Node instance and the next argument is assigned to the Node's next pointer."}
{"prompt": "def postorder(self, root):\n    if root:\n        self.postorder(root.left)\n        self.postorder(root.right)\n        print(str(root.data), end=' ')\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function performs a post-order traversal of a binary tree. It will print the data of each node in post-order sequence. The function takes in a root node as an argument."}
{"prompt": "def reverse_words(string):\n    arr = string.strip().split()\n    n = len(arr)\n    reverse(arr, 0, n - 1)\n    return ' '.join(arr)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes in a string and reverses the words in the string. It returns the resulting string with words in the reverse order."}
{"prompt": "def comb_sort(arr):\n\n    def swap(i, j):\n        (arr[i], arr[j]) = (arr[j], arr[i])\n    n = len(arr)\n    gap = n\n    shrink = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink)\n        if gap > 1:\n            sorted = False\n        else:\n            gap = 1\n            sorted = True\n        i = 0\n        while i + gap < n:\n            if arr[i] > arr[i + gap]:\n                swap(i, i + gap)\n                sorted = False\n            i = i + 1\n    return arr\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\ncomb_sort(arr) -> list\n\nUses the Comb Sort algorithm to sort a given list of items in-place and returns the sorted list.\n\nParameters:\n  arr (list): The list of items to sort. \n\nReturns:\n  list: The sorted list.\n\"\"\""}
{"prompt": "def inorder(self):\n    res = []\n    if not self.root:\n        return res\n    stack = []\n    root = self.root\n    while root or stack:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        res.append({'val': root.val, 'color': root.color})\n        root = root.right\n    return res\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nTraverse a given Red-Black Tree and return an array of node values in-order.\n\"\"\""}
{"prompt": "def __init__(self, value, weight):\n    self.value = value\n    self.weight = weight\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nInitialize a new object with a given value and weight.\n\nArgs:\n    value (int): The value of the object.\n    weight (int): The weight of the object.\n\"\"\""}
{"prompt": "def __str__(self) -> str:\n    if len(self.variables) == 0:\n        return str(self.coeff)\n    result = str(self.coeff)\n    result += '('\n    for i in self.variables:\n        temp = 'a_{}'.format(str(i))\n        if self.variables[i] > 1:\n            temp = '(' + temp + ')**{}'.format(self.variables[i])\n        elif self.variables[i] < 0:\n            temp = '(' + temp + ')**(-{})'.format(-self.variables[i])\n        elif self.variables[i] == 0:\n            continue\n        else:\n            temp = '(' + temp + ')'\n        result += temp\n    return result + ')'\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function returns a string representation of the coefficient and the variables of a given Polynomial object. The string includes the coefficient, parentheses around the variables, and an exponent if the variable has an exponent."}
{"prompt": "def add_node(self, node_name):\n    try:\n        return self.nodes[self.nodes.index(node_name)]\n    except ValueError:\n        node = Node(node_name)\n        self.nodes.append(node)\n        return node\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nadd_node(self, node_name):\n    '''\n    Adds a node to the graph and returns it if it does not already exist.\n    \n    Parameters:\n    self (Graph): The graph to add the node to\n    node_name (str): The name of the node to be added\n\n    Returns:\n    Node: The node that was added to the graph\n    '''"}
{"prompt": "def __init__(self):\n    pass\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis is the constructor for a class. It is called when an instance of the class is created, and is used to initialize the attributes of the class."}
{"prompt": "def is_power_of_two(n):\n    return n > 0 and (not n & n - 1)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nis_power_of_two(n)\n\nReturns True if n is a power of two (i.e. is a positive integer that is a product of two equal numbers). Otherwise, returns False."}
{"prompt": "def max_ones_index(arr):\n    n = len(arr)\n    max_count = 0\n    max_index = 0\n    prev_zero = -1\n    prev_prev_zero = -1\n    for curr in range(n):\n        if arr[curr] == 0:\n            if curr - prev_prev_zero > max_count:\n                max_count = curr - prev_prev_zero\n                max_index = prev_zero\n            prev_prev_zero = prev_zero\n            prev_zero = curr\n    if n - prev_prev_zero > max_count:\n        max_index = prev_zero\n    return max_index\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nmax_ones_index(arr) returns the index of the 0 in the given array that creates the longest subarray of 1s. \nIf there is more than one such index, it will return the index closest to the beginning of the array."}
{"prompt": "def is_palindrome_deque(s):\n    s = remove_punctuation(s)\n    deq = deque()\n    for char in s:\n        deq.appendleft(char)\n    equal = True\n    while len(deq) > 1 and equal:\n        first = deq.pop()\n        last = deq.popleft()\n        if first != last:\n            equal = False\n    return equal\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCheck if a string is a palindrome using a deque data structure.\n\nParameters:\ns (str): The string to check.\n\nReturns:\nbool: True if the string is a palindrome, False otherwise.\n\"\"\""}
{"prompt": "def dfs_traverse(graph, start):\n    (visited, stack) = (set(), [start])\n    while stack:\n        node = stack.pop()\n        if node not in visited:\n            visited.add(node)\n            for next_node in graph[node]:\n                if next_node not in visited:\n                    stack.append(next_node)\n    return visited\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\ndfs_traverse(graph, start) is a function for performing a depth-first search traversal of a graph, starting at a given node. It takes as parameters a graph (represented as an adjacency list) and a starting node. It returns a set of all nodes visited during the traversal."}
{"prompt": "def __str__(self):\n    result = ' '.join(map(str, self))\n    return 'Top-> ' + result\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function returns a string representation of an object, typically a list, in the form of 'Top-> [elements of object]'."}
{"prompt": "def __init__(self, vertex_count):\n    self.vertex_count = vertex_count\n    self.graph = [[0 for _ in range(vertex_count)] for _ in range(vertex_count)]\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\n\nThis function initializes a graph object with a given number of vertices. It creates an adjacency matrix with 0's for all entries to represent the graph."}
{"prompt": "def bfs_traverse(graph, start):\n    (visited, queue) = (set(), [start])\n    while queue:\n        node = queue.pop(0)\n        if node not in visited:\n            visited.add(node)\n            for next_node in graph[node]:\n                if next_node not in visited:\n                    queue.append(next_node)\n    return visited\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nTraverse a graph using Breadth-First Search.\n\nArgs:\n    graph (dict): A graph represented as adjacency lists.\n    start (int): The node from which to start the traversal.\n\nReturns:\n    A set of visited nodes.\n\"\"\""}
{"prompt": "def flatten_iter(iterable):\n    for element in iterable:\n        if not isinstance(element, str) and isinstance(element, Iterable):\n            yield from flatten_iter(element)\n        else:\n            yield element\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Flatten an iterable so that sub-iterables are returned as single elements.\n\nParameters:\n    iterable (iterable): Iterable to flatten.\n\nReturns:\n    generator: Generator object yielding flattened elements.\n\"\"\""}
{"prompt": "def copy_random_pointer_v2(head):\n    copy = defaultdict(lambda : RandomListNode(0))\n    copy[None] = None\n    node = head\n    while node:\n        copy[node].label = node.label\n        copy[node].next = copy[node.next]\n        copy[node].random = copy[node.random]\n        node = node.next\n    return copy[head]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCreate a new linked list node by copying the given linked list node, including its random pointer.\n\nInputs:\n    head (RandomListNode): a linked list node\n\nReturns:\n    copy (RandomListNode): a copy of the given linked list node, including its random pointer\n\"\"\""}
{"prompt": "def remove(self, val):\n    if val in self.idxs:\n        (idx, last) = (self.idxs[val], self.nums[-1])\n        (self.nums[idx], self.idxs[last]) = (last, idx)\n        self.nums.pop()\n        self.idxs.pop(val, 0)\n        return True\n    return False\n##############\nEND_FUNC\n##############\n", "completion": "\n\nremove(self, val)\n\nRemoves val from the set if it exists, and returns a boolean indicating whether it was removed successfully."}
{"prompt": "@staticmethod\ndef _rationalize_if_possible(num):\n    if isinstance(num, Rational):\n        res = Fraction(num, 1)\n        return Fraction(res.numerator, res.denominator)\n    else:\n        return num\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function takes in a number 'num' and checks if it is an instance of the Rational type. If it is, it will return a Fraction with the numerator and denominator properties of the Rational number. If not, it will return the number."}
{"prompt": "def hash(self, key):\n    return key % self.size\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"This function takes a key and returns the hashed value of the key modulo the size of the object.\"\"\""}
{"prompt": "def max_path_sum(root):\n    maximum = float('-inf')\n    helper(root, maximum)\n    return maximum\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function finds the maximum path sum of a binary tree.\nIt takes a root node as an argument and returns the maximum path sum as an integer. \nThe maximum path is defined as any path from root to any leaf node. \nThe path must go downwards (traveling only from parent nodes to child nodes).\nThe helper function updates the maximum path sum as it traverses each node. \n\"\"\""}
{"prompt": "def delete(self, node):\n    node_color = node.color\n    if node.left is None:\n        temp_node = node.right\n        self.transplant(node, node.right)\n    elif node.right is None:\n        temp_node = node.left\n        self.transplant(node, node.left)\n    else:\n        node_min = self.minimum(node.right)\n        node_color = node_min.color\n        temp_node = node_min.right\n        if node_min.parent is not node:\n            self.transplant(node_min, node_min.right)\n            node_min.right = node.right\n            node_min.right.parent = node_min\n        self.transplant(node, node_min)\n        node_min.left = node.left\n        node_min.left.parent = node_min\n        node_min.color = node.color\n    if node_color == 0:\n        self.delete_fixup(temp_node)\n##############\nEND_FUNC\n##############\n", "completion": "\n\ndelete(self, node):\n    \"\"\"Removes a node from the tree and fixes any violations of the red-black tree properties.\"\"\""}
{"prompt": "def find_order(a, n):\n    if (a == 1) & (n == 1):\n        return 1\n    if math.gcd(a, n) != 1:\n        print('a and n should be relative prime!')\n        return -1\n    for i in range(1, n):\n        if pow(a, i) % n == 1:\n            return i\n    return -1\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Find the order of a in n.\n\nArgs:\n    a (int): The number to find the order of.\n    n (int): The modulus\n\nReturns:\n    int: The order of a in n, or -1 if a and n are not relatively prime.\n\"\"\""}
{"prompt": "def dfs(grid, i, j):\n    if (i < 0 or i >= len(grid)) or (j < 0 or j >= len(grid[0])):\n        return\n    if grid[i][j] != 1:\n        return\n    grid[i][j] = 0\n    dfs(grid, i + 1, j)\n    dfs(grid, i - 1, j)\n    dfs(grid, i, j + 1)\n    dfs(grid, i, j - 1)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nRecursively traverse a grid, marking cells as visited and avoiding out of bounds and already-visited cells.\n\nParameters:\ngrid (list of lists): The grid of cells to traverse\ni (int): The current row index\nj (int): The current column index\n\nReturns:\nNone\n\"\"\""}
{"prompt": "def int_to_roman(num):\n    m = ['', 'M', 'MM', 'MMM']\n    c = ['', 'C', 'CC', 'CCC', 'CD', 'D', 'DC', 'DCC', 'DCCC', 'CM']\n    x = ['', 'X', 'XX', 'XXX', 'XL', 'L', 'LX', 'LXX', 'LXXX', 'XC']\n    i = ['', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX']\n    return m[num // 1000] + c[num % 1000 // 100] + x[num % 100 // 10] + i[num % 10]\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function takes an integer (num) as an argument and returns a Roman numeral representation of it."}
{"prompt": "def find_set(self, node):\n    if self.parent[node] != node:\n        self.parent[node] = self.find_set(self.parent[node])\n    return self.parent[node]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nFind the set representative of a node in a disjoint-set data structure. \nThis function uses path compression to reduce the search time of finding the set representative. \nIt uses recursion to traverse the tree of parent nodes of the given node to find the set representative. \nThe parent of the node is updated to the set representative to reduce the search time for future lookups. \n\"\"\""}
{"prompt": "def caesar_cipher(s, k):\n    result = ''\n    for char in s:\n        n = ord(char)\n        if 64 < n < 91:\n            n = (n - 65 + k) % 26 + 65\n        if 96 < n < 123:\n            n = (n - 97 + k) % 26 + 97\n        result = result + chr(n)\n    return result\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes a string (s) and an integer (k) as input and returns the string s with each character shifted by k places in the alphabet."}
{"prompt": "def domain_name_1(url):\n    full_domain_name = url.split('//')[-1]\n    actual_domain = full_domain_name.split('.')\n    if len(actual_domain) > 2:\n        return actual_domain[1]\n    return actual_domain[0]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes in a url as a parameter and returns the domain name (without the .com, .net, etc.) of the url."}
{"prompt": "def kth_to_last_eval(head, k):\n    if not isinstance(k, int) or not head.val:\n        return False\n    nexts = '.'.join(['next' for n in range(1, k + 1)])\n    seeker = str('.'.join(['head', nexts]))\n    while head:\n        if eval(seeker) is None:\n            return head\n        else:\n            head = head.next\n    return False\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturns the node that is kth to last element in a linked list given a head node. Returns False if k is not an int or head is empty."}
{"prompt": "def test_size(self):\n    self.assertEqual(11, self.tree.size())\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function tests that the size of the tree is equal to 11."}
{"prompt": "def same_closure_default(a, b):\n    return a == b\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes two arguments, 'a' and 'b', and returns True if they are equal, and False if they are not."}
{"prompt": "def is_strobogrammatic2(num: str):\n    return num == num[::-1].replace('6', '#').replace('9', '6').replace('#', '9')\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nChecks whether a given number is strobogrammatic, i.e. the number reads the same upside down.\n\nParameters:\nnum (str): The number to check.\n\nReturns:\nbool: True if the number is strobogrammatic, False otherwise."}
{"prompt": "def __init__(self):\n    self.items = []\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__(self) is a constructor method for a class that initializes the items attribute as an empty list."}
{"prompt": "def recur_depth_sum(root, n):\n    if root is None:\n        return 0\n    elif root.left is None and root.right is None:\n        return root.data * n\n    else:\n        return n * root.data + recur_depth_sum(root.left, n + 1) + recur_depth_sum(root.right, n + 1)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"Calculates the sum of all nodes at each depth in a binary tree, recursively. Takes in the root node of the tree and the current depth as parameters.\""}
{"prompt": "def update_bit(self, bit_tree, i, v):\n    i += 1\n    while i <= self.n:\n        bit_tree[i] += v\n        i += i & -i\n##############\nEND_FUNC\n##############\n", "completion": "\n\nUpdate the value at position i in a bit-tree with value v.\n\nThis function updates the value at position i in a bit-tree (an array of binary trees) with a given value v. It starts by incrementing the position i by 1 and then, while iterating through the array, it adds v to the value at each position and increments it by the bitwise AND of the current position and its negation."}
{"prompt": "def josephus(int_list, skip):\n    skip = skip - 1\n    idx = 0\n    len_list = len(int_list)\n    while len_list > 0:\n        idx = (skip + idx) % len_list\n        yield int_list.pop(idx)\n        len_list -= 1\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function yields elements from the list int_list in a special order based on the skip argument. It works by iteratively removing elements from the list and then yielding them."}
{"prompt": "def height(root):\n    if root is None:\n        return 0\n    else:\n        return 1 + max(height(root.left), height(root.right))\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nThis function calculates the height of a given root node in a binary tree. It returns 0 if the root is None, and returns 1 plus the maximum of the left and right subtree heights otherwise."}
{"prompt": "def full_path(file):\n    return os.path.abspath(os.path.expanduser(file))\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"Return the absolute path of the given file, expanding any tilde (~) as necessary.\""}
{"prompt": "def main():\n    (m, n) = map(int, input('Enter two positive integers: ').split())\n    count_paths(m, n)\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nCalculate the number of paths from the top left corner to the bottom right corner in a mxn matrix.\n\nInput: Two positive integers m, n representing the size of the matrix.\n\nOutput: The number of paths from the top left corner to the bottom right corner."}
{"prompt": "def next_state(chain, current_state):\n    next_state_map = chain.get(current_state)\n    return __choose_state(next_state_map)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes in a Markov chain and a current state, and returns the next state in the chain. It does this by retrieving the map of the next state from the chain and choosing a state from that map."}
{"prompt": "def distance(x, y):\n    assert len(x) == len(y), 'The vector must have same length'\n    result = ()\n    sum = 0\n    for i in range(len(x)):\n        result += (x[i] - y[i],)\n    for component in result:\n        sum += component ** 2\n    return math.sqrt(sum)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nCalculates the Euclidean distance between 2 vectors of equal length. Takes in 2 vectors (x and y) as parameters and returns the Euclidean distance between them. Asserts that the vectors have the same length."}
{"prompt": "def prims_minimum_spanning(graph_used):\n    vis = []\n    heap = [[0, 1]]\n    prim = set()\n    mincost = 0\n    while len(heap) > 0:\n        (cost, node) = heapq.heappop(heap)\n        if node in vis:\n            continue\n        mincost += cost\n        prim.add(node)\n        vis.append(node)\n        for (distance, adjacent) in graph_used[node]:\n            if adjacent not in vis:\n                heapq.heappush(heap, [distance, adjacent])\n    return mincost\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function finds the minimum cost spanning tree of a graph using Prim's algorithm. It takes in a graph as an argument and returns the minimum cost of the spanning tree."}
{"prompt": "def backtrack(result, word, pos, count, cur):\n    if pos == len(word):\n        if count > 0:\n            cur += str(count)\n        result.append(cur)\n        return\n    if count > 0:\n        backtrack(result, word, pos + 1, 0, cur + str(count) + word[pos])\n    else:\n        backtrack(result, word, pos + 1, 0, cur + word[pos])\n    backtrack(result, word, pos + 1, count + 1, cur)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nCompress a given string by counting the consecutive repeating characters and output the compressed string. \nThe function takes in a word as a string, a position index (pos), a count, and a current string (cur). It recursively builds the output list with the compressed version of the given string."}
{"prompt": "def has_path_sum3(root, sum):\n    if root is None:\n        return False\n    queue = [(root, sum - root.val)]\n    while queue:\n        (node, val) = queue.pop(0)\n        if node.left is None and node.right is None:\n            if val == 0:\n                return True\n        if node.left is not None:\n            queue.append((node.left, val - node.left.val))\n        if node.right is not None:\n            queue.append((node.right, val - node.right.val))\n    return False\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturns True if there is a path from the root to a leaf such that the sum of all the node values of that path equals the given sum, and False otherwise. \nroot: the root node of a binary tree \nsum: an integer value\n\"\"\""}
{"prompt": "def word_break(word, word_dict):\n    dp_array = [False] * (len(word) + 1)\n    dp_array[0] = True\n    for i in range(1, len(word) + 1):\n        for j in range(0, i):\n            if dp_array[j] and word[j:i] in word_dict:\n                dp_array[i] = True\n                break\n    return dp_array[-1]\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function uses Dynamic Programming to determine whether a given word can be broken down into valid words from a given dictionary. It returns a boolean value, True if the word can be broken down, False otherwise."}
{"prompt": "def count_flips_to_convert(a, b):\n    diff = a ^ b\n    count = 0\n    while diff:\n        diff &= diff - 1\n        count += 1\n    return count\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function counts the number of bit flips (i.e. XOR operations) needed to convert one integer (a) to another (b). It takes two integers a and b as arguments and returns an integer count representing the number of bit flips."}
{"prompt": "def find_path(graph, start, end, path=[]):\n    path = path + [start]\n    if start == end:\n        return path\n    if not start in graph:\n        return None\n    for node in graph[start]:\n        if node not in path:\n            newpath = find_path(graph, node, end, path)\n            return newpath\n    return None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nFinds a path in a graph from a start node to an end node.\n\nParameters:\ngraph (dict): A graph represented as a dictionary.\nstart (any): The starting node.\nend (any): The ending node.\npath (list): An optional path argument (defaults to empty list).\n\nReturns:\nlist: A list of the nodes in the path from start to end, or None if no path exists. \n\"\"\""}
{"prompt": "def last_occurrence(array, query):\n    (low, high) = (0, len(array) - 1)\n    while low <= high:\n        mid = (high + low) // 2\n        if array[mid] == query and mid == len(array) - 1 or (array[mid] == query and array[mid + 1] > query):\n            return mid\n        if array[mid] <= query:\n            low = mid + 1\n        else:\n            high = mid - 1\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nFind the last occurrence of 'query' in a sorted array 'array' and return its index. Returns None if not found.\n\nParameters:\n    array (list): A sorted array of elements.\n    query (any): The element to be found in the array.\n\nReturns:\n    int: The index of the last occurrence of 'query' in 'array'. None if not found.\n\"\"\""}
{"prompt": "def predecessor(root, node):\n    pred = None\n    while root:\n        if node.val > root.val:\n            pred = root\n            root = root.right\n        else:\n            root = root.left\n    return pred\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nFinds the predecessor of a node within a given binary search tree.\n\nParameters: \nroot (Node): The root node of the binary search tree.\nnode (Node): The node for which to find the predecessor.\n\nReturns: \npred (Node): The predecessor node of the given node."}
{"prompt": "def is_valid_coordinates_regular_expression(coordinates):\n    return bool(re.match('-?(\\\\d|[1-8]\\\\d|90)\\\\.?\\\\d*, -?(\\\\d|[1-9]\\\\d|1[0-7]\\\\d|180)\\\\.?\\\\d*$', coordinates))\n##############\nEND_FUNC\n##############\n", "completion": "\n\nCheck if a string is a valid coordinate (latitude and longitude) using regular expression. Returns a boolean."}
{"prompt": "def longest_non_repeat_v2(string):\n    if string is None:\n        return 0\n    (start, max_len) = (0, 0)\n    used_char = {}\n    for (index, char) in enumerate(string):\n        if char in used_char and start <= used_char[char]:\n            start = used_char[char] + 1\n        else:\n            max_len = max(max_len, index - start + 1)\n        used_char[char] = index\n    return max_len\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturns the longest substring of the given string that does not contain any repeated characters.\nIf the given string is None, returns 0. \n\"\"\""}
{"prompt": "def add_bitwise_operator(x, y):\n    while y:\n        carry = x & y\n        x = x ^ y\n        y = carry << 1\n    return x\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function performs a bitwise addition between two given numbers, x and y. It utilizes a while loop to continually shift the carry until there is no value left in y. It returns the sum of x and y as the result."}
{"prompt": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    (left, right) = (merge_sort(arr[:mid]), merge_sort(arr[mid:]))\n    return merge(left, right, arr.copy())\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nmerge_sort(arr)\n\nSort the given array 'arr' using the Merge Sort algorithm.\n\nReturns a sorted array.\n\"\"\""}
{"prompt": "def n_sum(n, nums, target, **kv):\n\n    def sum_closure_default(a, b):\n        return a + b\n\n    def compare_closure_default(num, target):\n        if num < target:\n            return -1\n        elif num > target:\n            return 1\n        else:\n            return 0\n\n    def same_closure_default(a, b):\n        return a == b\n\n    def n_sum(n, nums, target):\n        if n == 2:\n            results = two_sum(nums, target)\n        else:\n            results = []\n            prev_num = None\n            for (index, num) in enumerate(nums):\n                if prev_num is not None and same_closure(prev_num, num):\n                    continue\n                prev_num = num\n                n_minus1_results = n_sum(n - 1, nums[index + 1:], target - num)\n                n_minus1_results = append_elem_to_each_list(num, n_minus1_results)\n                results += n_minus1_results\n        return union(results)\n\n    def two_sum(nums, target):\n        nums.sort()\n        lt = 0\n        rt = len(nums) - 1\n        results = []\n        while lt < rt:\n            sum_ = sum_closure(nums[lt], nums[rt])\n            flag = compare_closure(sum_, target)\n            if flag == -1:\n                lt += 1\n            elif flag == 1:\n                rt -= 1\n            else:\n                results.append(sorted([nums[lt], nums[rt]]))\n                lt += 1\n                rt -= 1\n                while lt < len(nums) and same_closure(nums[lt - 1], nums[lt]):\n                    lt += 1\n                while 0 <= rt and same_closure(nums[rt], nums[rt + 1]):\n                    rt -= 1\n        return results\n\n    def append_elem_to_each_list(elem, container):\n        results = []\n        for elems in container:\n            elems.append(elem)\n            results.append(sorted(elems))\n        return results\n\n    def union(duplicate_results):\n        results = []\n        if len(duplicate_results) != 0:\n            duplicate_results.sort()\n            results.append(duplicate_results[0])\n            for result in duplicate_results[1:]:\n                if results[-1] != result:\n                    results.append(result)\n        return results\n    sum_closure = kv.get('sum_closure', sum_closure_default)\n    same_closure = kv.get('same_closure', same_closure_default)\n    compare_closure = kv.get('compare_closure', compare_closure_default)\n    nums.sort()\n    return n_sum(n, nums, target)\n##############\nEND_FUNC\n##############\n", "completion": "\nFind the N-sum of a given list of numbers and a given target.\n\nParameters:\nn (int): The number of elements in the sum.\nnums (list): The list of numbers.\ntarget (int): The target sum.\nsum_closure (function (optional)): A function to sum two elements.\nsame_closure (function (optional)): A function to compare two elements for equality.\ncompare_closure (function (optional)): A function to compare two elements.\n\nReturns:\nlist: A list containing all possible N-sums of the given list of numbers that add up to the target sum."}
{"prompt": "def find_difference(s, t):\n    ret = 0\n    for ch in s + t:\n        ret = ret ^ ord(ch)\n    return chr(ret)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nFinds the difference between two strings.\n\nParameters:\n    s (str): First string to compare.\n    t (str): Second string to compare.\n\nReturns:\n    chr: The character that is different between s and t."}
{"prompt": "def alice_public_key(a_pr_k, a, p):\n    return pow(a, a_pr_k) % p\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCalculate Alice's public key given her private key, base 'a' and modulus 'p'.\n\nReturns:\n    The public key of Alice.\n\"\"\""}
{"prompt": "def num_empty(root):\n    if root is None:\n        return 1\n    elif root.left is None and root.right:\n        return 1 + num_empty(root.right)\n    elif root.right is None and root.left:\n        return 1 + num_empty(root.left)\n    else:\n        return num_empty(root.left) + num_empty(root.right)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"This function returns the number of empty nodes in a Binary Tree. It takes in a root node of the Binary Tree as an argument.\""}
{"prompt": "def maximum(self, node):\n    temp_node = node\n    while temp_node.right is not None:\n        temp_node = temp_node.right\n    return temp_node\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nFinds and returns the maximum node in a given binary search tree.\n\nParameters:\nself (instance): Instance of the BinarySearchTree class.\nnode (Node): Root node of the tree.\n\nReturns:\ntemp_node (Node): Maximum node in the given tree.\n\"\"\""}
{"prompt": "def merge(left, right, merged):\n    (left_cursor, right_cursor) = (0, 0)\n    while left_cursor < len(left) and right_cursor < len(right):\n        if left[left_cursor] <= right[right_cursor]:\n            merged[left_cursor + right_cursor] = left[left_cursor]\n            left_cursor += 1\n        else:\n            merged[left_cursor + right_cursor] = right[right_cursor]\n            right_cursor += 1\n    for left_cursor in range(left_cursor, len(left)):\n        merged[left_cursor + right_cursor] = left[left_cursor]\n    for right_cursor in range(right_cursor, len(right)):\n        merged[left_cursor + right_cursor] = right[right_cursor]\n    return merged\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nMerge two sorted lists into one.\n\nParameters: \nleft (list): The left list to be merged.\nright (list): The right list to be merged.\nmerged (list): The merged list.\n\nReturns:\nmerged (list): The merged list.\n\"\"\""}
{"prompt": "def size(self):\n    return self.recur_size(self.root)\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nReturns the number of elements in the tree."}
{"prompt": "def update(pos, left, right, target, vertex):\n    if left == right:\n        tree[pos] = vertex\n        return\n    mid = left + right >> 1\n    if target <= mid:\n        update(pos << 1, left, mid, target, vertex)\n    else:\n        update(pos << 1 | 1, mid + 1, right, target, vertex)\n    tree[pos] = max_seq(tree[pos << 1], tree[pos << 1 | 1])\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nUpdate the segment tree with a new vertex at the given target.\n\nParameters:\npos (int): Current position in the segment tree.\nleft (int): Left boundary of the range represented by the current node.\nright (int): Right boundary of the range represented by the current node.\ntarget (int): Target position of the vertex in the range.\nvertex (int): Value of the vertex that needs to be updated in the segment tree.\n\"\"\""}
{"prompt": "def backtrack(res, nums, stack, pos):\n    if pos == len(nums):\n        res.append(list(stack))\n    else:\n        stack.append(nums[pos])\n        backtrack(res, nums, stack, pos + 1)\n        stack.pop()\n        backtrack(res, nums, stack, pos + 1)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function recursively builds all possible permutations of a given list of numbers (nums) and stores them in a list (res). The stack parameter is a list used to store the current permutation, and the pos parameter keeps track of the current index in nums."}
{"prompt": "def __sub__(self, other: Union[int, float, Fraction]):\n    if isinstance(other, int) or isinstance(other, float) or isinstance(other, Fraction):\n        mono = {i: self.variables[i] for i in self.variables if self.variables[i] != 0}\n        if len(mono) != 0:\n            raise ValueError('Can only subtract like monomials.')\n        other_term = Monomial(mono, Monomial._rationalize_if_possible(other))\n        return self.__sub__(other_term)\n    if not isinstance(other, Monomial):\n        raise ValueError('Can only subtract monomials')\n    return self.__add__(other.__mul__(Fraction(-1, 1)))\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function subtracts two monomials from each other. If the monomials are not the same, a ValueError is raised. If the other monomial is an integer, float, or Fraction, it is rationalized before being subtracted."}
{"prompt": "def valid_solution(board):\n    correct = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    for row in board:\n        if sorted(row) != correct:\n            return False\n    for column in zip(*board):\n        if sorted(column) != correct:\n            return False\n    for i in range(3):\n        for j in range(3):\n            region = []\n            for line in board[i * 3:(i + 1) * 3]:\n                region += line[j * 3:(j + 1) * 3]\n            if sorted(region) != correct:\n                return False\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nvalid_solution(board) checks if the given board (a 2D 9x9 array) is a valid Sudoku solution. It returns True if the board is valid and False otherwise."}
{"prompt": "def decode_string(s):\n    stack = []\n    cur_num = 0\n    cur_string = ''\n    for c in s:\n        if c == '[':\n            stack.append((cur_string, cur_num))\n            cur_string = ''\n            cur_num = 0\n        elif c == ']':\n            (prev_string, num) = stack.pop()\n            cur_string = prev_string + num * cur_string\n        elif c.isdigit():\n            cur_num = cur_num * 10 + int(c)\n        else:\n            cur_string += c\n    return cur_string\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nDecodes a given string by repeating substrings based on the number preceding them.\n\nInput:\ns (str): The string to decode.\n\nOutput:\n(str): The decoded string.\n\"\"\""}
{"prompt": "def has_alternative_bit_fast(n):\n    mask1 = int('aaaaaaaa', 16)\n    mask2 = int('55555555', 16)\n    return mask1 == n + (n ^ mask1) or mask2 == n + (n ^ mask2)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nChecks if a given number has an alternative bit set.\n\nThis is a fast implementation of checking if a given number has an alternative bit set.\nIt uses bitwise operations to check if the number has either all the even bits set or all the odd bits set.\n\nArgs:\n    n (int): The number to check.\n\nReturns:\n    bool: True if the number has an alternative bit set; False otherwise."}
{"prompt": "def remove_punctuation(s):\n    return ''.join((i.lower() for i in s if i in ascii_letters))\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes a string 's' as input and returns a new string with all punctuation removed and all letters lowercased."}
{"prompt": "def expand_clique(candidates, nays):\n    nonlocal compsub\n    if not candidates and (not nays):\n        nonlocal solutions\n        solutions.append(compsub.copy())\n    else:\n        for selected in candidates.copy():\n            candidates.remove(selected)\n            candidates_temp = get_connected(selected, candidates)\n            nays_temp = get_connected(selected, nays)\n            compsub.append(selected)\n            expand_clique(candidates_temp, nays_temp)\n            nays.add(compsub.pop())\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nRecursively expands a clique from a list of candidates and nays.\n\nThe clique is constructed from the candidates list and added to the compsub list. The candidates list is then filtered for connected candidates, which are then passed to the next recursive call, along with the nays list. The nays list is also filtered for connected elements.\nWhen the candidates list and nays list are both empty, the current clique is added to the solutions list.\n\"\"\""}
{"prompt": "def test_search(self):\n    self.assertTrue(self.tree.search(24))\n    self.assertFalse(self.tree.search(50))\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nTest that a value is contained within a tree. Asserts that the search for the value 24 returns True and the search for the value 50 returns False."}
{"prompt": "def rotate(mat):\n    if not mat:\n        return mat\n    mat.reverse()\n    for i in range(len(mat)):\n        for j in range(i):\n            (mat[i][j], mat[j][i]) = (mat[j][i], mat[i][j])\n    return mat\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nRotates the given matrix 90 degrees clockwise.\n\nParameters:\nmat (list): A list of lists representing the matrix.\n\nReturns:\nlist: The matrix rotated 90 degrees clockwise. If the matrix is empty, the original matrix is returned.\n\"\"\""}
{"prompt": "def add_word(self, word):\n    if word:\n        self.word_dict[len(word)].append(word)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nAdd a word to the word dictionary.\n\nParameters:\nself (object): The object instance.\nword (str): The word to add.\n\nReturns:\nNone. The word is added to the word dictionary."}
{"prompt": "def __getitem__(self, index):\n    if index < 0:\n        return self.end + index\n    return self.start + index\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function returns the index of the start or end of the list, depending on whether the index is positive or negative."}
{"prompt": "def __len__(self):\n    return self.end - self.start\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturn the length of the object by subtracting the start value from the end value."}
{"prompt": "def __init__(self, file):\n    self.file = file\n    self.buffer = []\n    self.is_last_byte = False\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function initializes a new instance of the class. It takes a file argument and sets the file attribute to the input file. It also creates an empty buffer and sets the is_last_byte attribute to False."}
{"prompt": "def __init__(self):\n    self.keys = []\n    self.children = []\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"This function is the constructor for a new object. It initializes the object's two attributes, keys and children, as empty lists.\"\"\""}
{"prompt": "@abstractmethod\ndef enqueue(self, value):\n    pass\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis is an abstract method for adding a value to a queue. It does not contain any implementation details."}
{"prompt": "def prime_check(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    j = 5\n    while j * j <= n:\n        if n % j == 0 or n % (j + 2) == 0:\n            return False\n        j += 6\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nprime_check(n)\n\nChecks if the given number 'n' is a prime number.\nReturns a boolean value depending on the result of the check.\n\"\"\""}
{"prompt": "def longest_common_prefix_v2(strs):\n    if not strs:\n        return ''\n    for i in range(len(strs[0])):\n        for string in strs[1:]:\n            if i == len(string) or string[i] != strs[0][i]:\n                return strs[0][0:i]\n    return strs[0]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturn the longest common prefix of a list of strings.\nIf the list is empty, return an empty string.\n\"\"\""}
{"prompt": "def is_valid_sudoku(self, board):\n    seen = []\n    for (i, row) in enumerate(board):\n        for (j, c) in enumerate(row):\n            if c != '.':\n                seen += [(c, j), (i, c), (i / 3, j / 3, c)]\n    return len(seen) == len(set(seen))\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCheck if a 9x9 Sudoku board is valid. The board is represented by a 2D list of characters, where the character '.' represents an empty cell.\n\nParameters:\n    board (list): 2D list of characters representing the board\n\nReturns:\n    bool: True if the board is valid, False otherwise.\n\"\"\""}
{"prompt": "def recursive(s):\n    l = len(s)\n    if l < 2:\n        return s\n    return recursive(s[l // 2:]) + recursive(s[:l // 2])\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function recursively reverses a string.\n\nParameters:\ns (str): The string to be reversed.\n\nReturns:\nstr: The reversed string."}
{"prompt": "def lcs(s1, s2, i, j):\n    if i == 0 or j == 0:\n        return 0\n    elif s1[i - 1] == s2[j - 1]:\n        return 1 + lcs(s1, s2, i - 1, j - 1)\n    else:\n        return max(lcs(s1, s2, i - 1, j), lcs(s1, s2, i, j - 1))\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function finds the length of the longest common subsequence (LCS) between two strings (s1 and s2). \nIt takes four parameters: s1, s2 (the strings to compare), i and j (the index of the characters in the strings). \nIt returns either 0 (if either i or j is 0) or the length of the LCS (if s1[i - 1] == s2[j - 1]). \nOtherwise, it returns the maximum of lcs(s1, s2, i - 1, j) and lcs(s1, s2, i, j - 1)."}
{"prompt": "def __delitem__(self, key):\n    return self.del_(key)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nDelete an item from the dictionary.\n\n\"\"\"Delete an item from the dictionary given a key.\"\"\""}
{"prompt": "def reverse_list_recursive(head):\n    if head is None or head.next is None:\n        return head\n    p = head.next\n    head.next = None\n    revrest = reverse_list_recursive(p)\n    p.next = head\n    return revrest\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nThis function takes a linked list and reverses the order of the nodes recursively. It returns the head of the reversed linked list."}
{"prompt": "def __init__(self, val, left=None, right=None):\n    self.val = val\n    self.left = left\n    self.right = right\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nInitialize a Binary Tree Node with given value and optional left/right child nodes.\n\nParameters:\nval (any): The value of the Binary Tree Node.\nleft (Binary Tree Node, optional): The left child node. Defaults to None.\nright (Binary Tree Node, optional): The right child node. Defaults to None.\n\"\"\""}
{"prompt": "def query(self, L, R):\n    return self.__query(0, 0, len(self.arr) - 1, L, R)\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nquery(self, L, R):\n    \"\"\"Returns the sum of arr[L:R+1] inclusive of L and R.\n\n    Parameters:\n        self (object): the object instance\n        L (int): the leftmost index to include in the query\n        R (int): the rightmost index to include in the query\n\n    Returns:\n        int: the sum of arr[L:R+1]\n    \"\"\""}
{"prompt": "def bellman_ford(graph, source):\n    weight = {}\n    pre_node = {}\n    initialize_single_source(graph, source, weight, pre_node)\n    for _ in range(1, len(graph)):\n        for node in graph:\n            for adjacent in graph[node]:\n                if weight[adjacent] > weight[node] + graph[node][adjacent]:\n                    weight[adjacent] = weight[node] + graph[node][adjacent]\n                    pre_node[adjacent] = node\n    for node in graph:\n        for adjacent in graph[node]:\n            if weight[adjacent] > weight[node] + graph[node][adjacent]:\n                return False\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function implements the Bellman-Ford algorithm to determine the shortest paths from a given source node to all other nodes in a graph. It takes a graph and a source node as parameters, and returns True if there are no negative-weight cycles in the graph, and False if there are."}
{"prompt": "def print_tree(root):\n    if root is not None:\n        print(root.val)\n        print_tree(root.left)\n        print_tree(root.right)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nPrints the value of a given tree in pre-order traversal.\n\nParameters:\nroot (TreeNode): The root node of the tree\n\nReturns:\nNone\n\"\"\""}
{"prompt": "def bracket(words, symbols):\n    root = TreeNode()\n    for s in symbols:\n        t = root\n        for char in s:\n            if char not in t.c:\n                t.c[char] = TreeNode()\n            t = t.c[char]\n        t.sym = s\n    result = dict()\n    for word in words:\n        i = 0\n        symlist = list()\n        while i < len(word):\n            (j, t) = (i, root)\n            while j < len(word) and word[j] in t.c:\n                t = t.c[word[j]]\n                if t.sym is not None:\n                    symlist.append((j + 1 - len(t.sym), j + 1, t.sym))\n                j += 1\n            i += 1\n        if len(symlist) > 0:\n            sym = reduce(lambda x, y: x if x[1] - x[0] >= y[1] - y[0] else y, symlist)\n            result[word] = '{}[{}]{}'.format(word[:sym[0]], sym[2], word[sym[1]:])\n    return tuple((word if word not in result else result[word] for word in words))\n##############\nEND_FUNC\n##############\n", "completion": "\nThis function takes in a set of words and symbols, and returns a tuple of words that have been bracketed with the longest possible symbol. For each word in the set, it checks if the symbol matches any of the given symbols, and if so, it brackets the longest matching portion of the word with the symbol."}
{"prompt": "def is_isomorphic(s, t):\n    if len(s) != len(t):\n        return False\n    dict = {}\n    set_value = set()\n    for i in range(len(s)):\n        if s[i] not in dict:\n            if t[i] in set_value:\n                return False\n            dict[s[i]] = t[i]\n            set_value.add(t[i])\n        elif dict[s[i]] != t[i]:\n            return False\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nChecks if two strings are isomorphic, i.e. they contain the same characters in the same frequency but in different order.\n\nParameters:\ns (str): The first string.\nt (str): The second string.\n\nReturns:\nbool: True if strings are isomorphic, False otherwise.\n\"\"\""}
{"prompt": "def two_sum1(numbers, target):\n    dic = {}\n    for (i, num) in enumerate(numbers):\n        if target - num in dic:\n            return [dic[target - num] + 1, i + 1]\n        dic[num] = i\n    return None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\ntwo_sum1(numbers, target):\n    Find two indices in numbers list whose sum equals to target.\n    Args:\n        numbers (list): List of numbers to search for two elements whose sum equals to target\n        target (int): Target sum\n    Returns:\n        list: A list of two indices whose elements in numbers list sum up to target. None if not found.\n\"\"\""}
{"prompt": "def load_tree(self) -> Node:\n    node_stack = deque()\n    queue_leaves = deque()\n    root = Node()\n    current_node = root\n    is_end_of_tree = False\n    while not is_end_of_tree:\n        current_bit = self.get_bit()\n        if current_bit == '0':\n            current_node.left = Node()\n            current_node.right = Node()\n            node_stack.append(current_node.right)\n            current_node = current_node.left\n        else:\n            queue_leaves.append(current_node)\n            if node_stack:\n                current_node = node_stack.pop()\n            else:\n                is_end_of_tree = True\n    self._fill_tree(queue_leaves)\n    return root\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function loads a tree from a given bit sequence, where a '0' indicates a node with children and a '1' indicates a leaf node. It builds the tree using a stack and queue to track the nodes. It then fills the tree with the leaf nodes and returns the root node."}
{"prompt": "@staticmethod\ndef print_intervals(intervals):\n    res = []\n    for i in intervals:\n        res.append(repr(i))\n    print(''.join(res))\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nPrints the given list of intervals.\n\nArguments:\n    intervals (list): A list of intervals to be printed."}
{"prompt": "def kth_to_last_dict(head, k):\n    if not (head and k > -1):\n        return False\n    d = dict()\n    count = 0\n    while head:\n        d[count] = head\n        head = head.next\n        count += 1\n    return len(d) - k in d and d[len(d) - k]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturns the kth node from the end in a linked list.\n\nArgs:\n    head: A node in a linked list.\n    k: The kth node to be returned from the end.\n\nReturns:\n    The kth node from the end in a linked list if k is valid, False otherwise.\n\"\"\""}
{"prompt": "def rotate_alt(string, k):\n    k = k % len(string)\n    return string[k:] + string[:k]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nRotate a given string by k characters.\n\nParameters:\n    string (str): The string to rotate.\n    k (int): The number of characters to rotate by.\n\nReturns:\n    str: The rotated string."}
{"prompt": "def random_vector():\n    import random\n    vector = [0 for _ in range(vector_length)]\n    for i in random.sample(range(vector_length), nozero_counut):\n        vector[i] = random.random()\n    return vector\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nGenerates a random vector of length vector_length with nozero_count elements randomly assigned a random float value between 0 and 1 inclusive."}
{"prompt": "def min_cost(cost):\n    length = len(cost)\n    dist = [INF] * length\n    dist[0] = 0\n    for i in range(length):\n        for j in range(i + 1, length):\n            dist[j] = min(dist[j], dist[i] + cost[i][j])\n    return dist[length - 1]\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nThis function finds the minimum cost of a given path. It takes in a cost matrix as a parameter and uses dynamic programming to calculate the minimum cost from the starting node to the ending node. It returns the minimum cost."}
{"prompt": "def _check_every_number_in_bitsum(bitsum, sum_signs):\n    for val in bitsum:\n        if val != 0 and val != sum_signs:\n            return False\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCheck if every number in the bitsum list is either 0 or the sum_signs.\n\nReturns:\n    bool: True if every number in the bitsum list is either 0 or the sum_signs, False otherwise.\n\"\"\""}
{"prompt": "def binary_search(job, start_index):\n    left = 0\n    right = start_index - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if job[mid].finish <= job[start_index].start:\n            if job[mid + 1].finish <= job[start_index].start:\n                left = mid + 1\n            else:\n                return mid\n        else:\n            right = mid - 1\n    return -1\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function performs a binary search to find the index of the job with the highest finish time that is lower than or equal to the start time of the job at the specified start index. The search is conducted over the range of jobs from 0 to start_index - 1. If a job is found that meets this criteria, its index is returned; otherwise, -1 is returned."}
{"prompt": "def recursive_binomial_coefficient(n, k):\n    if k > n:\n        raise ValueError('Invalid Inputs, ensure that n >= k')\n    if k == 0 or n == k:\n        return 1\n    if k > n / 2:\n        return recursive_binomial_coefficient(n, n - k)\n    return int(n / k * recursive_binomial_coefficient(n - 1, k - 1))\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCalculates the binomial coefficient of two integers n and k using recursion. Raises a ValueError if n is less than k. \n\nParameters: \nn (int): The first integer.\nk (int): The second integer. \n\nReturns:\nint: The binomial coefficient of n and k. \n\"\"\""}
{"prompt": "def recursive_get_factors(n):\n\n    def factor(n, i, combi, combis):\n        while i * i <= n:\n            if n % i == 0:\n                (combis.append(combi + [i, n // i]),)\n                factor(n // i, i, combi + [i], combis)\n            i += 1\n        return combis\n    return factor(n, 2, [], [])\n##############\nEND_FUNC\n##############\n", "completion": "\nThis function recursively calculates all the factors of a given number n, and returns a list of lists containing the factor combinations."}
{"prompt": "def trimmean(arr, per):\n    ratio = per / 200\n    cal_sum = 0\n    arr.sort()\n    neg_val = int(len(arr) * ratio)\n    arr = arr[neg_val:len(arr) - neg_val]\n    for i in arr:\n        cal_sum += i\n    return cal_sum / len(arr)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"Calculate the trimmed mean of a given array by removing a given percentage of values from both ends of the array and take the average of the remaining values\""}
{"prompt": "@staticmethod\ndef _get_char_frequency(file) -> dict:\n    is_end_of_file = False\n    signs_frequency = defaultdict(lambda : 0)\n    while not is_end_of_file:\n        prev_pos = file.tell()\n        sign = file.read(1)\n        curr_pos = file.tell()\n        if prev_pos == curr_pos:\n            is_end_of_file = True\n        else:\n            signs_frequency[int.from_bytes(sign, 'big')] += 1\n    return signs_frequency\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function reads a file, one byte at a time, and stores the frequency of each byte in a dictionary. The function returns a dictionary containing the byte values as keys, and their frequency as values."}
{"prompt": "def __len__(self):\n    return self._len\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturn the length of the object."}
{"prompt": "def get(self, key):\n    initial_hash = hash_ = self.hash(key)\n    while True:\n        if self._keys[hash_] is self._empty:\n            return None\n        elif self._keys[hash_] == key:\n            return self._values[hash_]\n        hash_ = self._rehash(hash_)\n        if initial_hash == hash_:\n            return None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Retrieve a value associated with the given key from the hash table, or return None if the key does not exist.\"\"\""}
{"prompt": "def __test():\n    rset = RandomizedSet()\n    ground_truth = set()\n    n = 64\n    for i in range(n):\n        rset.insert(i)\n        ground_truth.add(i)\n    for i in random.sample(range(n), n // 2):\n        rset.remove(i)\n        ground_truth.remove(i)\n    print(len(ground_truth), len(rset.elements), len(rset.index_map))\n    for i in ground_truth:\n        assert i == rset.elements[rset.index_map[i]]\n    for i in range(n):\n        print(rset.random_element(), end=' ')\n    print()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function tests the RandomizedSet class by inserting a series of integers and then randomly removing half of them and ensuring that the RandomizedSet is behaving correctly. It prints out the lengths of the set and its associated elements and index map, followed by a random element from the set."}
{"prompt": "def in_order_traverse(self):\n    result = []\n    if not self.node:\n        return result\n    result.extend(self.node.left.in_order_traverse())\n    result.append(self.node.key)\n    result.extend(self.node.right.in_order_traverse())\n    return result\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nTraverse a binary tree in order and return the nodes in an array.\n\nArgs:\n    self (Tree): The Tree object being traversed.\n\nReturns:\n    list: An array containing the values of each node in the tree, in order."}
{"prompt": "def __init__(self, value):\n    self.value = value\n    self.next = None\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\n__init__(self, value) is a constructor for a node class object. It takes in a value parameter and assigns it to the self.value attribute. It also assigns None to the self.next attribute."}
{"prompt": "def longest_increasing_subsequence(sequence):\n    length = len(sequence)\n    counts = [1 for _ in range(length)]\n    for i in range(1, length):\n        for j in range(0, i):\n            if sequence[i] > sequence[j]:\n                counts[i] = max(counts[i], counts[j] + 1)\n                print(counts)\n    return max(counts)\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nThis function finds the longest increasing subsequence in a given sequence. It takes a sequence as the input and returns the length of the longest increasing subsequence as an integer."}
{"prompt": "def identity(n: int) -> list:\n    I = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        I[i][i] = 1\n    return I\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function creates and returns an identity matrix of size n. An identity matrix is a square matrix with 1s along the main diagonal and 0s everywhere else."}
{"prompt": "def summarize_ranges(array):\n    res = []\n    if len(array) == 1:\n        return [str(array[0])]\n    i = 0\n    while i < len(array):\n        num = array[i]\n        while i + 1 < len(array) and array[i + 1] - array[i] == 1:\n            i += 1\n        if array[i] != num:\n            res.append((num, array[i]))\n        else:\n            res.append((num, num))\n        i += 1\n    return res\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function takes in an array and returns an array of tuples summarizing any ranges of numbers found in the input array. Each tuple contains the first and last numbers of the range. If only one number is found in the array, it is returned as a string."}
{"prompt": "@abstractmethod\ndef __iter__(self):\n    pass\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis is an abstract method that defines an iterator for the class. It must be overridden in a subclass in order to be used."}
{"prompt": "def dfs_util(self, source, target):\n    self.closure[source][target] = 1\n    for adjacent in self.graph[target]:\n        if self.closure[source][adjacent] == 0:\n            self.dfs_util(source, adjacent)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function is a utility function used to traverse a graph using depth-first search. It marks the edges (source, target) as visited in the closure matrix and then recursively calls itself on each adjacent node of the target node."}
{"prompt": "def __init__(self, capacity=10):\n    super().__init__()\n    self._array = [None] * capacity\n    self._front = 0\n    self._rear = 0\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__(self, capacity=10) initializes a new Queue instance with a given capacity. The instance has an array of None values with the given capacity, a front pointer, and a rear pointer."}
{"prompt": "def find_shortest_path(graph, start, end, path=[]):\n    path = path + [start]\n    if start == end:\n        return path\n    if start not in graph:\n        return None\n    shortest = None\n    for node in graph[start]:\n        if node not in path:\n            newpath = find_shortest_path(graph, node, end, path)\n            if newpath:\n                if not shortest or len(newpath) < len(shortest):\n                    shortest = newpath\n    return shortest\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Finds the shortest path between two nodes in a graph.\n\nArgs:\n    graph (dict): Graph represented as an adjacency list.\n    start (str): Starting node.\n    end (str): Ending node.\n    path (list): Current path being explored.\n\nReturns:\n    list: Shortest path between start and end nodes.\n\"\"\""}
{"prompt": "def inorder(self, root):\n    if root:\n        self.inorder(root.left)\n        print(str(root.data), end=' ')\n        self.inorder(root.right)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function prints the data of a binary tree in-order (left, root, right). It takes in the root of the binary tree as an argument."}
{"prompt": "def next(self):\n    node = self.stack.pop()\n    tmp = node\n    if tmp.right:\n        tmp = tmp.right\n        while tmp:\n            self.stack.append(tmp)\n            tmp = tmp.left\n    return node.val\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturn the next element in an inorder traversal of a binary tree. \n\nPop the last node from the stack, store it in a temporary variable. If the node has a right child, push the right child onto the stack and all its left children onto the stack. Finally, return the value of the node."}
{"prompt": "def insert_key(self, key):\n    if len(self.root.keys) >= self.max_number_of_keys:\n        new_root = Node()\n        new_root.children.append(self.root)\n        self.root = new_root\n        self._split_child(new_root, 0)\n        self._insert_to_nonfull_node(self.root, key)\n    else:\n        self._insert_to_nonfull_node(self.root, key)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nInserts a key into the tree. If the root node is full, a new root node is created. The key is then inserted into the non-full node.\n\"\"\""}
{"prompt": "def update_bit(num, i, bit):\n    mask = ~(1 << i)\n    return num & mask | bit << i\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nUpdate the bit at index i in the given number num with the given bit value (0 or 1).\nReturns the new number with the updated bit.\n\"\"\""}
{"prompt": "def generate_abbreviations(word):\n\n    def backtrack(result, word, pos, count, cur):\n        if pos == len(word):\n            if count > 0:\n                cur += str(count)\n            result.append(cur)\n            return\n        if count > 0:\n            backtrack(result, word, pos + 1, 0, cur + str(count) + word[pos])\n        else:\n            backtrack(result, word, pos + 1, 0, cur + word[pos])\n        backtrack(result, word, pos + 1, count + 1, cur)\n    result = []\n    backtrack(result, word, 0, 0, '')\n    return result\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nGenerate all possible abbreviations for the given word.\n\nArgs:\n    word (str): The word to generate abbreviations for.\n\nReturns:\n    list[str]: A list of all possible abbreviations for the given word.\n\"\"\""}
{"prompt": "def __iter__(self):\n    probe = self._front\n    while True:\n        if probe == self._rear:\n            return\n        yield self._array[probe]\n        probe += 1\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Iterate over the elements of the queue, starting from the front. Yields each element in turn.\"\"\""}
{"prompt": "def linear_search(array, query):\n    for (i, value) in enumerate(array):\n        if value == query:\n            return i\n    return -1\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nSearches for a query element in an array and returns its index if found. If not found, returns -1.\n\nParameters: \narray (list): list of elements to be searched \nquery (any): element to be searched \n\nReturns: \nint: index of the query element if found, -1 otherwise."}
{"prompt": "def print_linked_list(head):\n    string = ''\n    while head.next:\n        string += head.val + ' -> '\n        head = head.next\n    string += head.val\n    print(string)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nPrints out a linked list given the head of the list.\nThe output is in the format \"val1 -> val2 -> val3 -> ... -> valN\""}
{"prompt": "def is_anagram(s, t):\n    maps = {}\n    mapt = {}\n    for i in s:\n        maps[i] = maps.get(i, 0) + 1\n    for i in t:\n        mapt[i] = mapt.get(i, 0) + 1\n    return maps == mapt\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nis_anagram(s, t) -> bool\n\nChecks if the two strings s and t are anagrams of each other.\nReturns True if they are anagrams, False otherwise. \n\"\"\""}
{"prompt": "def size(self):\n    return len(self.items)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturn the size of the list stored in the 'items' attribute of the current instance."}
{"prompt": "def count_ones_recur(n):\n    if not n:\n        return 0\n    return 1 + count_ones_recur(n & n - 1)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nRecursively count the number of ones in the binary representation of a given number.\n\nParameters:\nn (int): The number to count the number of ones from.\n\nReturns:\nint: The number of ones in the binary representation of n."}
{"prompt": "def garage(initial, final):\n    initial = initial[:]\n    seq = []\n    steps = 0\n    while initial != final:\n        zero = initial.index(0)\n        if zero != final.index(0):\n            car_to_move = final[zero]\n            pos = initial.index(car_to_move)\n            (initial[zero], initial[pos]) = (initial[pos], initial[zero])\n        else:\n            for i in range(len(initial)):\n                if initial[i] != final[i]:\n                    (initial[zero], initial[i]) = (initial[i], initial[zero])\n                    break\n        seq.append(initial[:])\n        steps += 1\n    return (steps, seq)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes in two arguments: an initial list and a final list, both of which represent a garage with cars in a certain order. It then finds the steps it takes to arrange the cars in the garage from the initial list to the final list and returns a tuple containing the number of steps and the sequence of steps."}
{"prompt": "def add_neighbor(self, node):\n    self.neighbors.append(node)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nAdd a node to the list of neighbors for the current node.\n\nParameters:\n    self (object): The current node object.\n    node (object): The node object to be added to the list of neighbors.\n\nReturns:\n    None\n\"\"\""}
{"prompt": "def helper(p, q):\n    if p is None and q is None:\n        return True\n    if p is not None or q is not None or q.val != p.val:\n        return False\n    return helper(p.left, q.right) and helper(p.right, q.left)\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nThis function checks if two binary trees are symmetric. It takes two parameters p and q, which represent the root nodes for the two binary trees. It returns True if the binary trees are mirror images of each other, False otherwise."}
{"prompt": "def construct_candidates(constructed_sofar):\n    array = A\n    if 1 == len(constructed_sofar):\n        array = B\n    elif 2 == len(constructed_sofar):\n        array = C\n    return array\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"This function takes in an array of elements and returns a different array based on the length of the input array. If the array has a length of 1, it returns array B, if the array has a length of 2, it returns array C, and otherwise it returns array A.\"\"\""}
{"prompt": "def main():\n    (node_count, edge_count) = map(int, input('Enter the Number of Nodes and Edges \\n').split(' '))\n    adjacency = [[] for _ in range(node_count + 1)]\n    for _ in range(edge_count):\n        print(\"Enter the edge's Nodes in form of `source target`\\n\")\n        (source, target) = map(int, input().split(' '))\n        adjacency[source].append(target)\n        adjacency[target].append(source)\n    print('Total number of Connected Components are : ', count_components(adjacency, node_count))\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nmain():\n    Input the Number of Nodes and Edges.\n    Enter the edge's Nodes in form of `source target`.\n    Output the total number of Connected Components."}
{"prompt": "def gen_prime(k, seed=None):\n\n    def is_prime(num):\n        if num == 2:\n            return True\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    random.seed(seed)\n    while True:\n        key = random.randrange(int(2 ** (k - 1)), int(2 ** k))\n        if is_prime(key):\n            return key\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\ngen_prime(k, seed=None):\n    Generates a prime number with k bits using a random seed if given.\n    Parameters:\n    k (int): number of bits\n    seed (int, optional): random seed\n    Returns:\n    int: prime number\n\"\"\""}
{"prompt": "def __init__(self, label):\n    self.label = label\n    self.neighbors = []\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__(self, label)\n\nInitialize a node with a label and an empty list of neighbors. \n\nParameters:\n    label (object): The label of the node.\n\nAttributes:\n    label (object): The label of the node.\n    neighbors (list): A list of neighboring nodes.\n\"\"\""}
{"prompt": "def decode_rle(input):\n    decode_str = ''\n    count = ''\n    for ch in input:\n        if not ch.isdigit():\n            decode_str += ch * int(count)\n            count = ''\n        else:\n            count += ch\n    return decode_str\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\ndecode_rle(input) takes an input string in Run-Length Encoding (RLE) format and decodes it into a string. RLE is a form of data compression where a string of repeated characters is shortened to a character and a number indicating the number of consecutive occurrences of that character. The function returns the decoded string."}
{"prompt": "@abstractmethod\ndef perc_up(self, i):\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"This method updates the percolation grid.\n\nParameters:\ni (int): The row index of the grid to be updated.\n\nReturns:\nNone\n\"\"\""}
{"prompt": "def get_number_of_additional_bits_in_the_last_byte(self) -> int:\n    bin_num = self.get_bit() + self.get_bit() + self.get_bit()\n    return int(bin_num, 2)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"Returns the number of additional bits in the last byte as an integer\""}
{"prompt": "def __init__(self, root):\n    self.stack = []\n    while root:\n        self.stack.append(root)\n        root = root.left\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function initializes a stack with the root node and all its left descendents."}
{"prompt": "def __init__(self, size):\n    self.queue = deque(maxlen=size)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function initializes a deque object with a maximum size. The deque object is assigned to the attribute 'queue' of the class instance."}
{"prompt": "def construct_tree_util(pre: list, post: list, low: int, high: int, size: int):\n    global pre_index\n    if pre_index == -1:\n        pre_index = 0\n    if pre_index >= size or low > high:\n        return None\n    root = TreeNode(pre[pre_index])\n    pre_index += 1\n    if low == high or pre_index >= size:\n        return root\n    i = low\n    while i <= high:\n        if pre[pre_index] == post[i]:\n            break\n        i += 1\n    if i <= high:\n        root.left = construct_tree_util(pre, post, low, i, size)\n        root.right = construct_tree_util(pre, post, i + 1, high, size)\n    return root\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nConstructs a binary tree given preorder and postorder traversal of the tree. \n\nParameters:\n    pre (list): Preorder traversal of the binary tree.\n    post (list): Postorder traversal of the binary tree.\n    low (int): Lower index of the traversal.\n    high (int): Upper index of the traversal.\n    size (int): Size of the traversal.\n\nReturns:\n    TreeNode: The root of the constructed binary tree.\n\"\"\""}
{"prompt": "def license_number(key, k):\n    (res, alnum) = ([], [])\n    for char in key:\n        if char != '-':\n            alnum.append(char)\n    for (i, char) in enumerate(reversed(alnum)):\n        res.append(char)\n        if (i + 1) % k == 0 and i != len(alnum) - 1:\n            res.append('-')\n    return ''.join(res[::-1])\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nlicense_number(key, k)\n\nReturns a string with the characters in key separated by '-' every k characters, starting from the end. \nkey: a string of characters \nk: an integer denoting the number of characters to be skipped\n\"\"\""}
{"prompt": "def ford_fulkerson(capacity, source, sink):\n    vertices = len(capacity)\n    ret = 0\n    flow = [[0] * vertices for _ in range(vertices)]\n    while True:\n        visit = [False for _ in range(vertices)]\n        tmp = dfs(capacity, flow, visit, vertices, source, sink)\n        if tmp:\n            ret += tmp\n        else:\n            break\n    return ret\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function implements the Ford-Fulkerson algorithm to determine the maximum flow within a network. \nIt takes three arguments: capacity, source, and sink. Capacity is a 2D matrix of the capacities of each edge within the network. Source is the source vertex, and sink is the sink vertex. It returns the maximum flow possible."}
{"prompt": "def n_sum(n, nums, target):\n    if n == 2:\n        results = two_sum(nums, target)\n    else:\n        results = []\n        prev_num = None\n        for (index, num) in enumerate(nums):\n            if prev_num is not None and same_closure(prev_num, num):\n                continue\n            prev_num = num\n            n_minus1_results = n_sum(n - 1, nums[index + 1:], target - num)\n            n_minus1_results = append_elem_to_each_list(num, n_minus1_results)\n            results += n_minus1_results\n    return union(results)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes in three parameters: an integer n, a list of numbers nums, and a target integer. It returns a list of combinations of n numbers from nums that sum up to the target, with no repeated combinations."}
{"prompt": "def factor(n, i, combi, combis):\n    while i * i <= n:\n        if n % i == 0:\n            (combis.append(combi + [i, n // i]),)\n            factor(n // i, i, combi + [i], combis)\n        i += 1\n    return combis\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\n\nThis function finds all combinations of factors of a given number 'n'. It takes four parameters: 'n' (the number to factor), 'i' (the number to test for divisibility, initially set to 2), 'combi' (list of previously found factors) and 'combis' (list of all possible combinations of factors). It returns a list of all possible combinations of factors for the given number 'n'."}
{"prompt": "def __init__(self, monomials: Iterable[Union[int, float, Fraction, Monomial]]) -> None:\n    self.monomials = set()\n    for m in monomials:\n        if any(map(lambda x: isinstance(m, x), [int, float, Fraction])):\n            self.monomials |= {Monomial({}, m)}\n        elif isinstance(m, Monomial):\n            self.monomials |= {m}\n        else:\n            raise ValueError('Iterable should have monomials, int, float, or Fraction.')\n    self.monomials -= {Monomial({}, 0)}\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__(self, monomials: Iterable[Union[int, float, Fraction, Monomial]]) -> None\n\nCreates a Polynomial object from an iterable of monomials. Monomials can be given as int, float, Fraction, or Monomial objects. If any other types are given, a ValueError will be raised. This function also removes any zero-value monomials."}
{"prompt": "def sum_closure_default(a, b):\n    return a + b\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes two arguments, 'a' and 'b', and returns the sum of the two arguments."}
{"prompt": "def has_path_sum2(root, sum):\n    if root is None:\n        return False\n    stack = [(root, root.val)]\n    while stack:\n        (node, val) = stack.pop()\n        if node.left is None and node.right is None:\n            if val == sum:\n                return True\n        if node.left is not None:\n            stack.append((node.left, val + node.left.val))\n        if node.right is not None:\n            stack.append((node.right, val + node.right.val))\n    return False\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCheck if a given binary tree has a path from root to leaf such that the sum of all the node values in the path equals a given sum.\n\nParameters:\n    root (TreeNode): The root of the binary tree to be checked.\n    sum (int): The sum to be checked.\n\nReturns:\n    bool: True if the tree has a path from root to leaf such that the sum of all the node values in the path equals the given sum, False otherwise.\n\"\"\""}
{"prompt": "def quick_sort_recur(arr, first, last, iteration, simulation):\n    if first < last:\n        pos = partition(arr, first, last)\n        if simulation:\n            iteration = iteration + 1\n            print('iteration', iteration, ':', *arr)\n        (_, iteration) = quick_sort_recur(arr, first, pos - 1, iteration, simulation)\n        (_, iteration) = quick_sort_recur(arr, pos + 1, last, iteration, simulation)\n    return (arr, iteration)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function performs a recursive quick sort on an array of elements. It takes in an array, the first and last indices, an iteration counter, and a simulation flag as parameters. If the first index is smaller than the last, the function will partition the array and recursively sort the two halves. If the simulation flag is true, the current iteration will be printed. The function returns the sorted array and the iteration counter."}
{"prompt": "def cocktail_shaker_sort(arr):\n\n    def swap(i, j):\n        (arr[i], arr[j]) = (arr[j], arr[i])\n    n = len(arr)\n    swapped = True\n    while swapped:\n        swapped = False\n        for i in range(1, n):\n            if arr[i - 1] > arr[i]:\n                swap(i - 1, i)\n                swapped = True\n        if swapped == False:\n            return arr\n        swapped = False\n        for i in range(n - 1, 0, -1):\n            if arr[i - 1] > arr[i]:\n                swap(i - 1, i)\n                swapped = True\n    return arr\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function implements the Cocktail Shaker Sort algorithm, which is an improvement on the Bubble Sort algorithm. It sorts an array of elements by swapping elements that are out of order. The function takes an array as an argument and returns a sorted array."}
{"prompt": "def jump_search(arr, target):\n    length = len(arr)\n    block_size = int(math.sqrt(length))\n    block_prev = 0\n    block = block_size\n    if arr[length - 1] < target:\n        return -1\n    while block <= length and arr[block - 1] < target:\n        block_prev = block\n        block += block_size\n    while arr[block_prev] < target:\n        block_prev += 1\n        if block_prev == min(block, length):\n            return -1\n    if arr[block_prev] == target:\n        return block_prev\n    return -1\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function performs a Jump Search on an array to find a target element. It returns the index of the target element if it is present in the array, otherwise, it returns -1."}
{"prompt": "def is_palindrome_dict(head):\n    if not head or not head.next:\n        return True\n    d = {}\n    pos = 0\n    while head:\n        if head.val in d.keys():\n            d[head.val].append(pos)\n        else:\n            d[head.val] = [pos]\n        head = head.next\n        pos += 1\n    checksum = pos - 1\n    middle = 0\n    for v in d.values():\n        if len(v) % 2 != 0:\n            middle += 1\n        else:\n            step = 0\n            for i in range(0, len(v)):\n                if v[i] + v[len(v) - 1 - step] != checksum:\n                    return False\n                step += 1\n        if middle > 1:\n            return False\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nChecks if a linked list is a palindrome using a dictionary.\n\nParameters:\nhead (Linked List): The head node of the linked list.\n\nReturns:\nboolean: True if the linked list is a palindrome, False otherwise."}
{"prompt": "def add_edge(self, node_name_from, node_name_to):\n    try:\n        node_from = self.nodes[self.nodes.index(node_name_from)]\n        node_to = self.nodes[self.nodes.index(node_name_to)]\n        self.edges.append(DirectedEdge(node_from, node_to))\n    except ValueError:\n        pass\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nadd_edge(self, node_name_from, node_name_to)\n\nAdd a directed edge from node_name_from to node_name_to to the graph.\nIf either node_name_from or node_name_to are not present in the graph, no edge will be added."}
{"prompt": "def is_strongly_connected(self):\n    if self.dfs():\n        reversed_graph = self.reverse_graph()\n        if reversed_graph.dfs():\n            return True\n    return False\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function checks if a given graph is strongly connected. It performs a depth-first search on the graph and checks if the reversed graph passes a depth-first search as well. If both tests pass, the graph is considered strongly connected and the function returns True, otherwise it returns False."}
{"prompt": "def __init__(self):\n    super().__init__()\n    self.head = None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function is used to initialize a linked list object and set the head of the linked list to None."}
{"prompt": "def is_palindrome_stack(head):\n    if not head or not head.next:\n        return True\n    slow = fast = cur = head\n    while fast and fast.next:\n        (fast, slow) = (fast.next.next, slow.next)\n    stack = [slow.val]\n    while slow.next:\n        slow = slow.next\n        stack.append(slow.val)\n    while stack:\n        if stack.pop() != cur.val:\n            return False\n        cur = cur.next\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCheck if a linked list is a palindrome using a stack.\n\nParams:\nhead (Node): first node in the list\n\nReturns:\nBoolean: True if the list is a palindrome, False otherwise.\n\"\"\""}
{"prompt": "def _fill_tree(self, leaves_queue):\n    leaves_queue.reverse()\n    while leaves_queue:\n        node = leaves_queue.pop()\n        s = int(self.get_byte(), 2)\n        node.sign = s\n##############\nEND_FUNC\n##############\n", "completion": "\n\nFill the tree with a given queue of leaves. The sign of the node is determined by the next byte in the encoded file."}
{"prompt": "def __init__(self, x):\n    self.val = x\n    self.left = None\n    self.right = None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"This is the initializer for a Binary Tree Node object. It takes an integer x and sets the node's value to x, sets the left child to None, and sets the right child to None.\""}
{"prompt": "def transitive_closure(self):\n    for i in range(self.vertex_count):\n        self.dfs_util(i, i)\n    return self.closure\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nThis function calculates the transitive closure of a graph. It does this by looping through each vertex and running a dfs_util on it. It returns the closure of the graph."}
{"prompt": "def comp(p, q):\n    if p is None and q is None:\n        return True\n    if p is not None and q is not None:\n        return p.val == q.val and comp(p.left, q.left) and comp(p.right, q.right)\n    return False\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCompare two given binary trees and return True if they are the same structure and have the same values, False otherwise. \nInputs p and q are the root nodes of the two trees. \n\"\"\""}
{"prompt": "def elias_generic(lencoding, x):\n    if x == 0:\n        return '0'\n    first_part = 1 + int(log2(x))\n    a = x - 2 ** int(log2(x))\n    k = int(log2(x))\n    return lencoding(first_part) + binary(a, k)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function encodes a given non-negative integer x into a given length encoding lencoding. It returns a string of characters representing the encoded integer."}
{"prompt": "def longest_palindrome(s):\n    if len(s) < 2:\n        return s\n    n_str = '#' + '#'.join(s) + '#'\n    p = [0] * len(n_str)\n    (mx, loc) = (0, 0)\n    (index, maxlen) = (0, 0)\n    for i in range(len(n_str)):\n        if i < mx and 2 * loc - i < len(n_str):\n            p[i] = min(mx - i, p[2 * loc - i])\n        else:\n            p[i] = 1\n        while p[i] + i < len(n_str) and i - p[i] >= 0 and (n_str[i - p[i]] == n_str[i + p[i]]):\n            p[i] += 1\n        if i + p[i] > mx:\n            mx = i + p[i]\n            loc = i\n        if p[i] > maxlen:\n            index = i\n            maxlen = p[i]\n    s = n_str[index - p[index] + 1:index + p[index]]\n    return s.replace('#', '')\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nlongest_palindrome(s)\n\nReturns the longest palindrome in a given string s. If s is empty, returns an empty string. \nOtherwise, returns the longest palindrome in s.\n\"\"\""}
{"prompt": "def dinic_bfs(capacity, flow, level, source, sink):\n    vertices = len(capacity)\n    queue = Queue()\n    queue.put(source)\n    level[source] = 0\n    while queue.qsize():\n        front = queue.get()\n        for nxt in range(vertices):\n            if level[nxt] == -1 and flow[front][nxt] < capacity[front][nxt]:\n                level[nxt] = level[front] + 1\n                queue.put(nxt)\n    return level[sink] != -1\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function performs a breadth-first search on a flow network, given the capacity and flow of each edge, the levels of each vertex, and the source and sink. The function returns a boolean indicating whether the sink has been reached."}
{"prompt": "def recur(n, r):\n    if n == r or r == 0:\n        return 1\n    if (n, r) not in memo:\n        memo[n, r] = recur(n - 1, r - 1) + recur(n - 1, r)\n    return memo[n, r]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"This function recursively calculates the number of combinations of size r that can be chosen from a set of size n. It uses memoization to improve efficiency by storing previously calculated values in a dictionary.\"\"\""}
{"prompt": "def rotate(s, k):\n    long_string = s * (k // len(s) + 2)\n    if k <= len(s):\n        return long_string[k:k + len(s)]\n    else:\n        return long_string[k - len(s):k]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nRotates a string 's' by 'k' characters. Returns a new string that is a rotation of the original string by 'k' characters."}
{"prompt": "def over(constructed_sofar):\n    sum = 0\n    (to_stop, reached_target) = (False, False)\n    for elem in constructed_sofar:\n        sum += elem\n    if sum >= target or len(constructed_sofar) >= 3:\n        to_stop = True\n        if sum == target and 3 == len(constructed_sofar):\n            reached_target = True\n    return (to_stop, reached_target)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nover() takes in a list of numbers (constructed_sofar) and returns a tuple containing two boolean values. The first boolean value (to_stop) is True if the sum of the numbers in the list is greater than or equal to the target, or if the list is at least 3 elements long. The second boolean value (reached_target) is True if the sum of the numbers in the list is equal to the target, and the list is exactly 3 elements long.\n\"\"\""}
{"prompt": "def get_sum(self, bit_tree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += bit_tree[i]\n        i -= i & -i\n    return s\n##############\nEND_FUNC\n##############\n", "completion": "\n\nCalculate the cumulative sum of all the elements up to the index i in the given bit_tree."}
{"prompt": "def get_random(self):\n    idx = random.randint(0, len(self.nums) - 1)\n    return self.nums[idx]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturn a random element from the given list of numbers."}
{"prompt": "def search_rotate_recur(array, low, high, val):\n    if low >= high:\n        return -1\n    mid = (low + high) // 2\n    if val == array[mid]:\n        return mid\n    if array[low] <= array[mid]:\n        if array[low] <= val <= array[mid]:\n            return search_rotate_recur(array, low, mid - 1, val)\n        return search_rotate_recur(array, mid + 1, high, val)\n    if array[mid] <= val <= array[high]:\n        return search_rotate_recur(array, mid + 1, high, val)\n    return search_rotate_recur(array, low, mid - 1, val)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nRecursively searches a rotated sorted array for a given value.\n\nParameters:\n    array (list): A rotated sorted array.\n    low (int): The index of the lower bound of the array.\n    high (int): The index of the higher bound of the array.\n    val (int): The value to be searched for.\n\nReturns:\n    int: The index of the value if found, otherwise -1.\n\"\"\""}
{"prompt": "def __init__(self, data, priority):\n    self.data = data\n    self.priority = priority\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"Initialize a new Node with the given data and priority values.\""}
{"prompt": "def __init__(self, size=10):\n    super().__init__()\n    self._array = [None] * size\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__(self, size=10) initializes a new instance of the class, setting the self._array attribute to a list of None elements with a size of 10 by default."}
{"prompt": "def is_palindrome_two_pointer(s):\n    s = remove_punctuation(s)\n    for i in range(0, len(s) // 2):\n        if s[i] != s[len(s) - i - 1]:\n            return False\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes a string 's' as input and checks if the string is a palindrome or not. It first removes the punctuation from the string and then uses two pointers to compare the characters from both ends of the string. If the characters don't match, then it returns False, else it returns True."}
{"prompt": "def iterating_markov_chain(chain, state):\n    while True:\n        state = next_state(chain, state)\n        yield state\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"This function takes a Markov chain and a starting state as arguments. It iterates through the chain until it reaches a terminal state, yielding the state at each step.\"\"\""}
{"prompt": "def check_bipartite(adj_list):\n    vertices = len(adj_list)\n    set_type = [-1 for v in range(vertices)]\n    set_type[0] = 0\n    queue = [0]\n    while queue:\n        current = queue.pop(0)\n        if adj_list[current][current]:\n            return False\n        for adjacent in range(vertices):\n            if adj_list[current][adjacent]:\n                if set_type[adjacent] == set_type[current]:\n                    return False\n                if set_type[adjacent] == -1:\n                    set_type[adjacent] = 1 - set_type[current]\n                    queue.append(adjacent)\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\ncheck_bipartite(adj_list)\n\nCheck if a given graph is bipartite or not.\n\nParameters:\n    adj_list (list of lists): Representation of a graph in the form of adjacency list.\n\nReturns:\n    Boolean: True if the given graph is bipartite, else False.\n\"\"\""}
{"prompt": "def dinic_dfs(capacity, flow, level, idx, sink, work, current_flow=1 << 63):\n    if idx == sink:\n        return current_flow\n    vertices = len(capacity)\n    while work[idx] < vertices:\n        nxt = work[idx]\n        if level[nxt] == level[idx] + 1 and flow[idx][nxt] < capacity[idx][nxt]:\n            available_flow = min(current_flow, capacity[idx][nxt] - flow[idx][nxt])\n            tmp = dinic_dfs(capacity, flow, level, nxt, sink, work, available_flow)\n            if tmp > 0:\n                flow[idx][nxt] += tmp\n                flow[nxt][idx] -= tmp\n                return tmp\n        work[idx] += 1\n    return 0\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function uses the Dinic Algorithm to recursively search for an augmenting path in a flow network with respect to the given capacity, flow, level and source/sink indices. It returns the maximum possible flow along the path or 0 if no path exists."}
{"prompt": "def all_variables(self) -> Set:\n    return set(sorted(self.variables.keys()))\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturn a set of all the variable names in the `self.variables` dictionary, sorted alphabetically."}
{"prompt": "def test():\n    a1 = Node('A')\n    a2 = Node('A')\n    b = Node('B')\n    c1 = Node('C')\n    d = Node('D')\n    c2 = Node('C')\n    f = Node('F')\n    g = Node('G')\n    a1.next = a2\n    a2.next = b\n    b.next = c1\n    c1.next = d\n    d.next = c2\n    c2.next = f\n    f.next = g\n    print_linked_list(a1)\n    kth = kth_to_last_eval(a1, 4)\n    try:\n        assert kth.val == 'D'\n    except AssertionError as e:\n        e.args += ('Expecting D, got %s' % kth.val,)\n        raise\n    kth = kth_to_last_dict(a1, 4)\n    try:\n        assert kth.val == 'D'\n    except AssertionError as e:\n        e.args += ('Expecting D, got %s' % kth.val,)\n        raise\n    kth = kth_to_last(a1, 4)\n    try:\n        assert kth.val == 'D'\n    except AssertionError as e:\n        e.args += ('Expecting D, got %s' % kth.val,)\n        raise\n    print('all passed.')\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\ntest():\n    Create a linked list with the given nodes, print the linked list and then evaluate kth_to_last_eval(), kth_to_last_dict() and kth_to_last() using 4 as the k value. Assert that the node returned is 'D'. Print \"all passed.\" if all assertions are successful. \n\"\"\""}
{"prompt": "def min_height(root):\n    if root is None:\n        return 0\n    height = 0\n    level = [root]\n    while level:\n        height += 1\n        new_level = []\n        for node in level:\n            if node.left is None and node.right is None:\n                return height\n            if node.left is not None:\n                new_level.append(node.left)\n            if node.right is not None:\n                new_level.append(node.right)\n        level = new_level\n    return height\n##############\nEND_FUNC\n##############\n", "completion": "\n\nFind the minimum height of a binary tree given its root node."}
{"prompt": "def preorder_rec(root, res=None):\n    if root is None:\n        return []\n    if res is None:\n        res = []\n    res.append(root.val)\n    preorder_rec(root.left, res)\n    preorder_rec(root.right, res)\n    return res\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function performs a recursive preorder traversal of a binary tree, appending each node's value to a given result list. It takes the root node of a binary tree and an optional result list as arguments, and returns the result list containing all values in preorder traversal order."}
{"prompt": "def build(square):\n    if len(square) == n:\n        squares.append(square)\n        return\n    prefix = ''\n    for k in range(len(square)):\n        prefix += square[k][len(square)]\n    for word in fulls[prefix]:\n        build(square + [word])\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function builds a list of all possible words from a given set of letters. It takes an incomplete square(list of words) as an argument and appends all possible words that can be formed from the list of words. The function recursively checks all combinations of letters and words to form a complete square."}
{"prompt": "def knuth_morris_pratt(text: Sequence, pattern: Sequence) -> List[int]:\n    n = len(text)\n    m = len(pattern)\n    pi = [0 for i in range(m)]\n    i = 0\n    j = 0\n    for i in range(1, m):\n        while j and pattern[i] != pattern[j]:\n            j = pi[j - 1]\n        if pattern[i] == pattern[j]:\n            j += 1\n            pi[i] = j\n    j = 0\n    ret = []\n    for i in range(n):\n        while j and text[i] != pattern[j]:\n            j = pi[j - 1]\n        if text[i] == pattern[j]:\n            j += 1\n            if j == m:\n                ret.append(i - m + 1)\n                j = pi[j - 1]\n    return ret\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function implements the Knuth-Morris-Pratt algorithm to find all occurrences of a pattern in a text. It takes two sequences (text and pattern) as parameters and returns a list of indices of the starting indices of the pattern in the text."}
{"prompt": "def print_tree(root):\n    while root:\n        print(root.val)\n        root = root.right\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nPrints the values of each node in a given binary tree, starting from the root node and moving right.\n\nParameters:\nroot (Node): The root node of the binary tree.\n\"\"\""}
{"prompt": "def bob_shared_key(a_pu_k, b_pr_k, p):\n    return pow(a_pu_k, b_pr_k) % p\n##############\nEND_FUNC\n##############\n", "completion": "\n\nCalculate and return the shared key between two users, Bob and Alice, using their public and private keys and a prime number."}
{"prompt": "def missing_ranges(arr, lo, hi):\n    res = []\n    start = lo\n    for n in arr:\n        if n == start:\n            start += 1\n        elif n > start:\n            res.append((start, n - 1))\n            start = n + 1\n    if start <= hi:\n        res.append((start, hi))\n    return res\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nmissing_ranges(arr, lo, hi)\n\nReturns the missing ranges within an array given the lower and upper bounds.\n\nParams:\narr (array): an array of integers\nlo (int): the lower bound\nhi (int): the higher bound\n\nReturns:\nres (list): a list of tuples containing the missing ranges within the given range (lo, hi)\n\"\"\""}
{"prompt": "def __str__(self):\n    return '<ch: {0}: {1}>'.format(self.sign, self.frequency)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturns a string representation of the object in the format '<ch: sign: frequency>' where 'sign' is the sign of the object and 'frequency' is the frequency of the object."}
{"prompt": "def pythonic(s):\n    r = list(reversed(s))\n    return ''.join(r)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes a string 's' as argument and reverses it using the reversed() built-in function, then returns a string with the characters in reversed order."}
{"prompt": "def test_next_bigger(self):\n    self.assertEqual(next_bigger(38276), 38627)\n    self.assertEqual(next_bigger(12345), 12354)\n    self.assertEqual(next_bigger(1528452), 1528524)\n    self.assertEqual(next_bigger(138654), 143568)\n    self.assertEqual(next_bigger(54321), -1)\n    self.assertEqual(next_bigger(999), -1)\n    self.assertEqual(next_bigger(5), -1)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nTest the next_bigger() function. This function takes a positive integer and returns the next bigger number formed from the same digits. If no bigger number can be formed, -1 is returned. \n\"\"\""}
{"prompt": "def __init__(self, arr, function):\n    self.segment = [0 for x in range(3 * len(arr) + 3)]\n    self.arr = arr\n    self.fn = function\n    self.make_tree(0, 0, len(arr) - 1)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__(self, arr, function)\n    Initialize a SegmentTree with the given array and function.\n    \n    Parameters:\n    self (SegmentTree): The SegmentTree object.\n    arr (list): The array of elements to segment.\n    function (function): The function to apply to the segment.\n\"\"\""}
{"prompt": "def cholesky_decomposition(A):\n    n = len(A)\n    for ai in A:\n        if len(ai) != n:\n            return None\n    V = [[0.0] * n for _ in range(n)]\n    for j in range(n):\n        sum_diagonal_element = 0\n        for k in range(j):\n            sum_diagonal_element = sum_diagonal_element + math.pow(V[j][k], 2)\n        sum_diagonal_element = A[j][j] - sum_diagonal_element\n        if sum_diagonal_element <= 0:\n            return None\n        V[j][j] = math.pow(sum_diagonal_element, 0.5)\n        for i in range(j + 1, n):\n            sum_other_element = 0\n            for k in range(j):\n                sum_other_element += V[i][k] * V[j][k]\n            V[i][j] = (A[i][j] - sum_other_element) / V[j][j]\n    return V\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function performs the Cholesky decomposition of a given matrix A. It returns the Cholesky matrix V if it is possible to decompose A, or None if it is not."}
{"prompt": "def permute_unique(nums):\n    perms = [[]]\n    for n in nums:\n        new_perms = []\n        for l in perms:\n            for i in range(len(l) + 1):\n                new_perms.append(l[:i] + [n] + l[i:])\n                if i < len(l) and l[i] == n:\n                    break\n        perms = new_perms\n    return perms\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes a list of numbers as input and returns all unique permutations of the numbers. It does this by looping through the numbers, adding them to each permutation already created while checking if the number is already present in the permutation to ensure no duplicates."}
{"prompt": "def inorder(root):\n    res = []\n    if not root:\n        return res\n    stack = []\n    while root or stack:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        res.append(root.val)\n        root = root.right\n    return res\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nTraverse a binary tree in-order (left, root, right).\nInput: root (TreeNode) - The root of the binary tree\nOutput: res (List[int]) - A list of values in in-order traversal of the binary tree\n\"\"\""}
{"prompt": "def combination(n, r):\n    if n == r or r == 0:\n        return 1\n    return combination(n - 1, r - 1) + combination(n - 1, r)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function calculates the number of combinations of size 'r' from a set of size 'n'. It uses a recursive approach to calculate the number of combinations. The result is returned when either n is equal to r or r is equal to 0."}
{"prompt": "def postorder(root):\n    res_temp = []\n    res = []\n    if not root:\n        return res\n    stack = []\n    stack.append(root)\n    while stack:\n        root = stack.pop()\n        res_temp.append(root.val)\n        if root.left:\n            stack.append(root.left)\n        if root.right:\n            stack.append(root.right)\n    while res_temp:\n        res.append(res_temp.pop())\n    return res\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nTraverse a binary tree in postorder and return a list of node values.\n\nParameters:\nroot (TreeNode): The root node of the binary tree.\n\nReturns:\nlist: A list of node values in postorder.\n\"\"\""}
{"prompt": "def __gt__(self, obj):\n    return self.name > self.get_name(obj)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nCompare two objects by their name to determine which one is greater."}
{"prompt": "def edmonds_karp(capacity, source, sink):\n    vertices = len(capacity)\n    ret = 0\n    flow = [[0] * vertices for _ in range(vertices)]\n    while True:\n        tmp = 0\n        queue = Queue()\n        visit = [False for _ in range(vertices)]\n        par = [-1 for _ in range(vertices)]\n        visit[source] = True\n        queue.put((source, 1 << 63))\n        while queue.qsize():\n            front = queue.get()\n            (idx, current_flow) = front\n            if idx == sink:\n                tmp = current_flow\n                break\n            for nxt in range(vertices):\n                if not visit[nxt] and flow[idx][nxt] < capacity[idx][nxt]:\n                    visit[nxt] = True\n                    par[nxt] = idx\n                    queue.put((nxt, min(current_flow, capacity[idx][nxt] - flow[idx][nxt])))\n        if par[sink] == -1:\n            break\n        ret += tmp\n        parent = par[sink]\n        idx = sink\n        while parent != -1:\n            flow[parent][idx] += tmp\n            flow[idx][parent] -= tmp\n            idx = parent\n            parent = par[parent]\n    return ret\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function implements the Edmonds-Karp algorithm for finding the maximum flow in a flow network. It takes a capacity matrix, source and sink vertices as inputs and returns the maximum flow as output."}
{"prompt": "def exchange_sort(arr):\n    arr_len = len(arr)\n    for i in range(arr_len - 1):\n        for j in range(i + 1, arr_len):\n            if arr[i] > arr[j]:\n                (arr[i], arr[j]) = (arr[j], arr[i])\n    return arr\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes in an array and sorts it using the exchange sort method. It returns the sorted array."}
{"prompt": "def bitonic_sort(arr, reverse=False):\n\n    def compare(arr, reverse):\n        n = len(arr) // 2\n        for i in range(n):\n            if reverse != (arr[i] > arr[i + n]):\n                (arr[i], arr[i + n]) = (arr[i + n], arr[i])\n        return arr\n\n    def bitonic_merge(arr, reverse):\n        n = len(arr)\n        if n <= 1:\n            return arr\n        arr = compare(arr, reverse)\n        left = bitonic_merge(arr[:n // 2], reverse)\n        right = bitonic_merge(arr[n // 2:], reverse)\n        return left + right\n    n = len(arr)\n    if n <= 1:\n        return arr\n    if not (n and (not n & n - 1)):\n        raise ValueError('the size of input should be power of two')\n    left = bitonic_sort(arr[:n // 2], True)\n    right = bitonic_sort(arr[n // 2:], False)\n    arr = bitonic_merge(left + right, reverse)\n    return arr\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function implements the bitonic sort algorithm. It takes an array of numbers and an optional boolean argument 'reverse'. It will sort the array in either ascending or descending order depending on the value of 'reverse'. It works by recursively dividing the array into two halves and then merging the two halves in a bitonic manner."}
{"prompt": "def unite(self, element1, element2):\n    (root1, root2) = (self.root(element1), self.root(element2))\n    if root1 == root2:\n        return\n    if self.size[root1] > self.size[root2]:\n        (root1, root2) = (root2, root1)\n    self.parents[root1] = root2\n    self.size[root2] += self.size[root1]\n    self.count -= 1\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Unite two elements in a union-find structure.\n\nArgs:\n    element1 (object): Element 1 to unite.\n    element2 (object): Element 2 to unite.\n\nReturns:\n    None\n\"\"\""}
{"prompt": "def plus_one_v1(digits):\n    digits[-1] = digits[-1] + 1\n    res = []\n    ten = 0\n    i = len(digits) - 1\n    while i >= 0 or ten == 1:\n        summ = 0\n        if i >= 0:\n            summ += digits[i]\n        if ten:\n            summ += 1\n        res.append(summ % 10)\n        ten = summ // 10\n        i -= 1\n    return res[::-1]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nplus_one_v1(digits) takes in a list of digits as an argument and adds one to the last digit of the list. It then returns a list of digits with the last digit incremented by one, and any additional digits that were carried over from the addition. \n\"\"\""}
{"prompt": "def bob_public_key(b_pr_k, a, p):\n    return pow(a, b_pr_k) % p\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCalculate Bob's public key given Bob's private key, Alice's public key, and a prime number. Returns an integer.\n\"\"\""}
{"prompt": "def __init__(self):\n    self._size = 0\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__(self) initializes a new instance of the class with the size attribute set to 0."}
{"prompt": "def search_range(nums, target):\n    low = 0\n    high = len(nums) - 1\n    while low <= high:\n        mid = low + (high - low) // 2\n        if target < nums[mid]:\n            high = mid - 1\n        elif target > nums[mid]:\n            low = mid + 1\n        else:\n            break\n    for j in range(len(nums) - 1, -1, -1):\n        if nums[j] == target:\n            return [mid, j]\n    return [-1, -1]\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nThis function takes in a list of numbers and a target number, and searches for the target in the list. It returns the range of indices for the target if found, or [-1, -1] if not found."}
{"prompt": "def append_elem_to_each_list(elem, container):\n    results = []\n    for elems in container:\n        elems.append(elem)\n        results.append(sorted(elems))\n    return results\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes an element and a container of lists as arguments and appends the element to each list in the container. It then returns a list of sorted lists where the element has been appended. \n\"\"\""}
{"prompt": "def two_sum(nums, target):\n    nums.sort()\n    lt = 0\n    rt = len(nums) - 1\n    results = []\n    while lt < rt:\n        sum_ = sum_closure(nums[lt], nums[rt])\n        flag = compare_closure(sum_, target)\n        if flag == -1:\n            lt += 1\n        elif flag == 1:\n            rt -= 1\n        else:\n            results.append(sorted([nums[lt], nums[rt]]))\n            lt += 1\n            rt -= 1\n            while lt < len(nums) and same_closure(nums[lt - 1], nums[lt]):\n                lt += 1\n            while 0 <= rt and same_closure(nums[rt], nums[rt + 1]):\n                rt -= 1\n    return results\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\ntwo_sum(nums, target)\n\nGiven a list of numbers `nums` and a target number `target`, returns all pairs of numbers from `nums` that add up to `target`. The results will be sorted and duplicates will be removed. \n\"\"\""}
{"prompt": "def dfs(res, root, cur):\n    if root.left is None and root.right is None:\n        res.append(cur)\n    if root.left:\n        dfs(res, root.left, cur + '->' + str(root.left.val))\n    if root.right:\n        dfs(res, root.right, cur + '->' + str(root.right.val))\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function performs a depth-first search on a binary tree to find all paths from the root node to the leaf nodes. It takes the results array, root node, and current path as parameters, and appends the current path to the results array if the root node is a leaf node. If the root node has a left child, it recursively calls itself on the left child with the current path appended with the left child's value. If the root node has a right child, it recursively calls itself on the right child with the current path appended with the right child's value. \n\"\"\""}
{"prompt": "def __init__(self, text, size_word):\n    self.text = text\n    self.hash = 0\n    self.size_word = size_word\n    for i in range(0, size_word):\n        self.hash += (ord(self.text[i]) - ord('a') + 1) * 26 ** (size_word - i - 1)\n    self.window_start = 0\n    self.window_end = size_word\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function initializes a RollingHash object with the provided text and size_word. It calculates the hash value of the first size_word characters of the text. It also sets the window_start and window_end variables to the position of the first and last characters of the text."}
{"prompt": "def search(self, word):\n    if not word:\n        return False\n    if '.' not in word:\n        return word in self.word_dict[len(word)]\n    for v in self.word_dict[len(word)]:\n        for (i, ch) in enumerate(word):\n            if ch != v[i] and ch != '.':\n                break\n        else:\n            return True\n    return False\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function searches for a given word in a dictionary. It takes a word as an argument and returns True if the word is present in the dictionary, False otherwise. If the word contains a period ('.'), then it will match any character in the corresponding position in the word."}
{"prompt": "def dfs(root, sum, ls, res):\n    if root.left is None and root.right is None and (root.val == sum):\n        ls.append(root.val)\n        res.append(ls)\n    if root.left is not None:\n        dfs(root.left, sum - root.val, ls + [root.val], res)\n    if root.right is not None:\n        dfs(root.right, sum - root.val, ls + [root.val], res)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function performs a depth-first search to find all paths from the root node to a leaf node that sum up to a given value. It takes in a root node, a sum, a list of path values, and a list of result paths as parameters. It checks if the current root node is a leaf node and if the sum of its value and the values in the path list equal the given sum. If so, it appends the root node's value to the path list and adds the list to the result list. If the current root node has a left child, the function is called recursively with the left child, the updated sum, and the updated path list as arguments. The same is done for the right child if it exists.\n\n\"\"\""}
{"prompt": "def add_word(self, word):\n    cur = self.root\n    for letter in word:\n        if letter not in cur.children:\n            cur.children[letter] = TrieNode(letter)\n        cur = cur.children[letter]\n    cur.is_terminal = True\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function adds a word to a Trie data structure. It takes in the Trie object (self) and a word (word) as parameters. The function iterates through each letter of the word and adds it to the Trie object's children if it doesn't already exist. After looping through each letter, it sets the node's is_terminal property to True, indicating that it is the end of a valid word."}
{"prompt": "def get_bit(self, buff_limit=8):\n    if self._load_byte(buff_limit):\n        bit = self.buffer.pop(0)\n        return bit\n    else:\n        return -1\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function returns a bit from the buffer, with a limit of 8, or -1 if the buffer is empty."}
{"prompt": "def cycle_sort(arr):\n    len_arr = len(arr)\n    for cur in range(len_arr - 1):\n        item = arr[cur]\n        index = cur\n        for i in range(cur + 1, len_arr):\n            if arr[i] < item:\n                index += 1\n        if index == cur:\n            continue\n        while item == arr[index]:\n            index += 1\n        (arr[index], item) = (item, arr[index])\n        while index != cur:\n            index = cur\n            for i in range(cur + 1, len_arr):\n                if arr[i] < item:\n                    index += 1\n            while item == arr[index]:\n                index += 1\n            (arr[index], item) = (item, arr[index])\n    return arr\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\ncycle_sort(arr) -> arr\n\nSort the given array 'arr' in-place using Cycle Sort algorithm. \n\"\"\""}
{"prompt": "def add_operators(num, target):\n\n    def dfs(res, path, num, target, pos, prev, multed):\n        if pos == len(num):\n            if target == prev:\n                res.append(path)\n            return\n        for i in range(pos, len(num)):\n            if i != pos and num[pos] == '0':\n                break\n            cur = int(num[pos:i + 1])\n            if pos == 0:\n                dfs(res, path + str(cur), num, target, i + 1, cur, cur)\n            else:\n                dfs(res, path + '+' + str(cur), num, target, i + 1, prev + cur, cur)\n                dfs(res, path + '-' + str(cur), num, target, i + 1, prev - cur, -cur)\n                dfs(res, path + '*' + str(cur), num, target, i + 1, prev - multed + multed * cur, multed * cur)\n    res = []\n    if not num:\n        return res\n    dfs(res, '', num, target, 0, 0, 0)\n    return res\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function adds operators (+, -, *) to a given number, and returns all possible expressions that evaluate to a given target."}
{"prompt": "def _load_byte(self, buff_limit=8) -> bool:\n    if len(self.buffer) <= buff_limit:\n        byte = self.file.read(1)\n        if not byte:\n            return False\n        i = int.from_bytes(byte, 'big')\n        self.buffer.extend(list('{0:08b}'.format(i)))\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function reads a single byte from the file, converts it to an integer, and appends its binary representation to the buffer. The buff_limit argument controls the maximum number of bytes to read. It returns False if the byte is empty, or True otherwise."}
{"prompt": "def two_sum(array, target):\n    dic = {}\n    for (i, num) in enumerate(array):\n        if num in dic:\n            return (dic[num], i)\n        else:\n            dic[target - num] = i\n    return None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\ntwo_sum(array, target):\n    Finds indices of two numbers in an array that add up to a given target.\n    \n    Parameters:\n    array (list): a list of numbers\n    target (int): the sum of two numbers in the array\n    \n    Returns:\n    tuple: a tuple of the indices of two numbers in the array that add up to the target, or None if no such numbers exist\n\"\"\""}
{"prompt": "def _traverse_tree(self, node: Node):\n    if node.is_leaf:\n        print(node.keys, end=' ')\n    else:\n        for (i, key) in enumerate(node.keys):\n            self._traverse_tree(node.children[i])\n            print(key, end=' ')\n        self._traverse_tree(node.children[-1])\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nRecursively traverse a B-tree node and its children, printing the keys in order.\n\nArgs:\n    node (Node): The node to traverse.\n\nReturns:\n    None\n\"\"\""}
{"prompt": "def _split_child(self, parent: Node, child_index: int):\n    new_right_child = Node()\n    half_max = self.max_number_of_keys // 2\n    child = parent.children[child_index]\n    middle_key = child.keys[half_max]\n    new_right_child.keys = child.keys[half_max + 1:]\n    child.keys = child.keys[:half_max]\n    if not child.is_leaf:\n        new_right_child.children = child.children[half_max + 1:]\n        child.children = child.children[:half_max + 1]\n    parent.keys.insert(child_index, middle_key)\n    parent.children.insert(child_index + 1, new_right_child)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function splits a child node of a parent node within a B-Tree. It takes in two arguments, the parent node and an int for the index of the child to be split. The function then sets the new right child to a new node and sets the middle key to the index of the original child node. It then resets the keys and children of the child node so that the original is the left and the new right is the right. Lastly, it inserts the middle key into the parent's keys and the new right node into the parent's children."}
{"prompt": "def __init__(self):\n    super().__init__(self.MIN_SIZE)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function is the initializer for an object, and is called when the object is instantiated. It calls the superclass's initializer with the specified MIN_SIZE argument."}
{"prompt": "def __init__(self, val, left=None, right=None):\n    self.val = val\n    self.left = left\n    self.right = right\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nConstructor for a binary tree node with a given value, optional left and right child nodes.\nParameters: \n    val (any): value of the node\n    left (BinaryTreeNode): left child node\n    right (BinaryTreeNode): right child node\n\"\"\""}
{"prompt": "def __init__(self):\n    self.elements = []\n    self.index_map = {}\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis is the constructor for the class. It initializes the elements and index_map variables. The elements variable contains an empty list while the index_map variable contains an empty dictionary."}
{"prompt": "def ladder_length(begin_word, end_word, word_list):\n    if len(begin_word) != len(end_word):\n        return -1\n    if begin_word == end_word:\n        return 0\n    if sum((c1 != c2 for (c1, c2) in zip(begin_word, end_word))) == 1:\n        return 1\n    begin_set = set()\n    end_set = set()\n    begin_set.add(begin_word)\n    end_set.add(end_word)\n    result = 2\n    while begin_set and end_set:\n        if len(begin_set) > len(end_set):\n            (begin_set, end_set) = (end_set, begin_set)\n        next_begin_set = set()\n        for word in begin_set:\n            for ladder_word in word_range(word):\n                if ladder_word in end_set:\n                    return result\n                if ladder_word in word_list:\n                    next_begin_set.add(ladder_word)\n                    word_list.remove(ladder_word)\n        begin_set = next_begin_set\n        result += 1\n    return -1\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function finds the length of the shortest transformation sequence from begin_word to end_word using only words from the word_list. It returns -1 if there is no such transformation."}
{"prompt": "def __init__(self):\n    self.children = collections.defaultdict(TrieNode)\n    self.is_word = False\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__(self)\n    Initialize a new TrieNode.\n    Args:\n        self: The node to initialize.\n    Attributes:\n        children (dict): A mapping of each character in the alphabet to the TrieNode that represents this character's substring.\n        is_word (bool): A boolean indicating whether this node represents a complete word in the trie. Defaults to False.\n\"\"\""}
{"prompt": "def __init__(self, val, left=None, right=None):\n    self.val = val\n    self.left = left\n    self.right = right\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nInitialize a node in a binary tree with a given value, and optional left and right nodes.\n\"\"\""}
{"prompt": "def dfs(rooms, i, j, depth):\n    if (i < 0 or i >= len(rooms)) or (j < 0 or j >= len(rooms[0])):\n        return\n    if rooms[i][j] < depth:\n        return\n    rooms[i][j] = depth\n    dfs(rooms, i + 1, j, depth + 1)\n    dfs(rooms, i - 1, j, depth + 1)\n    dfs(rooms, i, j + 1, depth + 1)\n    dfs(rooms, i, j - 1, depth + 1)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function performs a Depth-First Search on a 2D array/list of rooms, starting from the given indices (i, j) and traversing in a given depth. It updates the values of the rooms array/list with the given depth value."}
{"prompt": "def is_sorted(stack):\n    storage_stack = []\n    for i in range(len(stack)):\n        if len(stack) == 0:\n            break\n        first_val = stack.pop()\n        if len(stack) == 0:\n            break\n        second_val = stack.pop()\n        if first_val < second_val:\n            return False\n        storage_stack.append(first_val)\n        stack.append(second_val)\n    for i in range(len(storage_stack)):\n        stack.append(storage_stack.pop())\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nChecks if a stack is sorted in ascending order.\n\nParameters:\nstack (list): The stack to be checked.\n\nReturns:\nbool: True if the stack is sorted, False otherwise.\n\"\"\""}
{"prompt": "def top_sort_recursive(graph):\n    (order, enter, state) = ([], set(graph), {})\n\n    def dfs(node):\n        state[node] = GRAY\n        for k in graph.get(node, ()):\n            sk = state.get(k, None)\n            if sk == GRAY:\n                raise ValueError('cycle')\n            if sk == BLACK:\n                continue\n            enter.discard(k)\n            dfs(k)\n        order.append(node)\n        state[node] = BLACK\n    while enter:\n        dfs(enter.pop())\n    return order\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function performs a topological sort on a graph using a recursive depth-first search. It takes in a graph and returns a list of nodes in topological order."}
{"prompt": "def is_one_edit(s, t):\n    if len(s) > len(t):\n        return is_one_edit(t, s)\n    if len(t) - len(s) > 1 or t == s:\n        return False\n    for i in range(len(s)):\n        if s[i] != t[i]:\n            return s[i + 1:] == t[i + 1:] or s[i:] == t[i + 1:]\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nChecks whether the difference between two strings is one edit.\n\nParameters:\ns (str): The first string to compare.\nt (str): The second string to compare.\n\nReturns:\nbool: True if the difference between two strings is one edit, False otherwise."}
{"prompt": "def search_insert(array, val):\n    low = 0\n    high = len(array) - 1\n    while low <= high:\n        mid = low + (high - low) // 2\n        if val > array[mid]:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return low\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nsearch_insert(array, val) searches for the position of 'val' in a given sorted array 'array'. It returns the index at which 'val' should be inserted to maintain the order of the array."}
{"prompt": "def move_window(self):\n    if self.window_end <= len(self.text) - 1:\n        self.hash -= (ord(self.text[self.window_start]) - ord('a') + 1) * 26 ** (self.size_word - 1)\n        self.hash *= 26\n        self.hash += ord(self.text[self.window_end]) - ord('a') + 1\n        self.window_start += 1\n        self.window_end += 1\n##############\nEND_FUNC\n##############\n", "completion": "\n\nMove the sliding window of a given size across the text. Calculates the new hash value by removing the first letter of the previous window, multiplying by 26, and adding the new last letter. Updates the window_start and window_end variables."}
{"prompt": "def gen_strobogrammatic(n):\n    return helper(n, n)\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nhelper(n, m) returns a list of all strobogrammatic numbers that are of length m with n digits. A strobogrammatic number is a number that when rotated 180 degrees, looks the same when read left to right."}
{"prompt": "def ultra_pythonic(s):\n    return s[::-1]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes a string 's' and returns the reversed version of it."}
{"prompt": "def __init__(self, items=None, priorities=None):\n    self.priority_queue_list = []\n    if items is None:\n        return\n    if priorities is None:\n        priorities = itertools.repeat(None)\n    for (item, priority) in zip(items, priorities):\n        self.push(item, priority=priority)\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nThis function is the initializer for the PriorityQueue class. It initializes the list for the priority queue, and then if items is not None, it pushes each item from the items list along with its associated priority from the priorities list into the priority queue. If priorities is None, the priority is set to None by default."}
{"prompt": "def find_keyboard_row(words):\n    keyboard = [set('qwertyuiop'), set('asdfghjkl'), set('zxcvbnm')]\n    result = []\n    for word in words:\n        for key in keyboard:\n            if set(word.lower()).issubset(key):\n                result.append(word)\n    return result\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Finds the words from a given list that can be typed using a single row on the keyboard.\n\nParameters:\nwords (list): List of words to check.\n\nReturns:\nlist: List of words that can be typed using a single row on the keyboard.\n\"\"\""}
{"prompt": "def next_greatest_letter_v2(letters, target):\n    for index in letters:\n        if index > target:\n            return index\n    return letters[0]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes in a list of letters and a target letter, and returns the next greatest letter in the list after the target letter. If the target letter is the greatest letter in the list, the first letter in the list will be returned."}
{"prompt": "def first_stutter(stack):\n    storage_stack = []\n    for i in range(len(stack)):\n        storage_stack.append(stack.pop())\n    for i in range(len(storage_stack)):\n        val = storage_stack.pop()\n        stack.append(val)\n        stack.append(val)\n    return stack\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes in a stack and creates a storage stack. It will then pop off each element in the stack and append it to the storage stack. Once all elements have been popped, it will pop off each element from the storage stack, append it back to the original stack and then append it again. This will double each element in the stack and return the new stack."}
{"prompt": "@staticmethod\ndef _decode_and_write_signs_to_file(file, reader: HuffmanReader, tree: Node, additional_bits: int):\n    tree_finder = TreeFinder(tree)\n    is_end_of_file = False\n    while not is_end_of_file:\n        bit = reader.get_bit()\n        if bit != -1:\n            while not tree_finder.find(bit):\n                bit = reader.get_bit(0)\n            file.write(bytes([tree_finder.found]))\n        else:\n            is_end_of_file = True\n            last_byte = reader.buffer\n            last_byte = last_byte[:-additional_bits]\n            for bit in last_byte:\n                if tree_finder.find(bit):\n                    file.write(bytes([tree_finder.found]))\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function decodes and writes Huffman signs from a given Huffman tree to a file. It uses a TreeFinder to find the corresponding sign for each bit, and adds the sign to the file. At the end of the file, additional bits are removed from the HuffmanReader's buffer."}
{"prompt": "def clean(self):\n    temp_variables = {i: self.variables[i] for i in self.variables if self.variables[i] != 0}\n    return Monomial(temp_variables, Monomial._rationalize_if_possible(self.coeff))\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nClean this Monomial object of any zero-valued variables. Returns a Monomial object with the cleaned values."}
{"prompt": "def wiggle_sort(nums):\n    for i in range(len(nums)):\n        if (i % 2 == 1) == (nums[i - 1] > nums[i]):\n            (nums[i - 1], nums[i]) = (nums[i], nums[i - 1])\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function sorts a given list of numbers in a wiggle pattern. \nIt iterates through the list and swaps adjacent elements if they are not in the correct order according to the wiggle pattern. \n\"\"\""}
{"prompt": "def permute(elements):\n    if len(elements) <= 1:\n        return [elements]\n    else:\n        tmp = []\n        for perm in permute(elements[1:]):\n            for i in range(len(elements)):\n                tmp.append(perm[:i] + elements[0:1] + perm[i:])\n        return tmp\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes in a list of elements and returns all of the possible permutations of those elements. The list of permutations is returned as a list of lists."}
{"prompt": "def __init__(self, x):\n    self.val = x\n    self.next = None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function is the constructor for a Node object. It takes in one argument, x, and sets the value of the node to x and the next node to None."}
{"prompt": "def build_graph(formula):\n    graph = {}\n    for clause in formula:\n        for (lit, _) in clause:\n            for neg in [False, True]:\n                graph[lit, neg] = []\n    for ((a_lit, a_neg), (b_lit, b_neg)) in formula:\n        add_edge(graph, (a_lit, a_neg), (b_lit, not b_neg))\n        add_edge(graph, (b_lit, b_neg), (a_lit, not a_neg))\n    return graph\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nBuilds a graph from a given formula.\n\nParameters:\nformula - A list of clauses in conjunctive normal form. Each clause is a list of (literal, boolean) tuples.\n\nReturns:\ngraph - A dictionary representing a graph in which each literal is a node and each clause forms an edge between the nodes."}
{"prompt": "def find(self, key) -> bool:\n    current_node = self.root\n    while True:\n        i = len(current_node.keys) - 1\n        while i >= 0 and current_node.keys[i] > key:\n            i -= 1\n        if i >= 0 and current_node.keys[i] == key:\n            return True\n        if current_node.is_leaf:\n            return False\n        current_node = current_node.children[i + 1]\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nCheck if a given key exists in a B+ tree.\n\nReturns:\n    bool: True if the key exists, False otherwise."}
{"prompt": "def get_longest_non_repeat_v1(string):\n    if string is None:\n        return (0, '')\n    sub_string = ''\n    dict = {}\n    max_length = 0\n    j = 0\n    for i in range(len(string)):\n        if string[i] in dict:\n            j = max(dict[string[i]], j)\n        dict[string[i]] = i + 1\n        if i - j + 1 > max_length:\n            max_length = i - j + 1\n            sub_string = string[j:i + 1]\n    return (max_length, sub_string)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturns the longest non-repeating substring in a given string.\n\nParameters:\n    string (str): The string to be evaluated.\n\nReturns:\n    (int, str): A tuple containing the length of the longest non-repeating substring and the substring itself.\n    If the given string is None, a tuple of (0, '') is returned.\n\"\"\""}
{"prompt": "def get_histogram(input_list: list) -> dict:\n    histogram = {}\n    for i in input_list:\n        histogram[i] = histogram.get(i, 0) + 1\n    return histogram\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes a list as an input and returns a dictionary containing the number of times each element appears in the list."}
{"prompt": "def generate_parenthesis_v2(n):\n\n    def add_pair(res, s, left, right):\n        if left == 0 and right == 0:\n            res.append(s)\n        if left > 0:\n            add_pair(res, s + '(', left - 1, right)\n        if right > 0 and left < right:\n            add_pair(res, s + ')', left, right - 1)\n    res = []\n    add_pair(res, '', n, n)\n    return res\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function generates all possible valid combinations of n pairs of parentheses. It uses a recursive approach to generate the combinations by adding a '(' or ')' to the current string and then calling the function again with the updated number of left and right parentheses."}
{"prompt": "def __init__(self, val=None):\n    self.val = val\n    self.next = None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__() is a constructor for a Node object. It takes an optional parameter val which is the value stored in the Node. It also sets the next attribute to None."}
{"prompt": "def factorial(n, mod=None):\n    if not (isinstance(n, int) and n >= 0):\n        raise ValueError(\"'n' must be a non-negative integer.\")\n    if mod is not None and (not (isinstance(mod, int) and mod > 0)):\n        raise ValueError(\"'mod' must be a positive integer\")\n    result = 1\n    if n == 0:\n        return 1\n    for i in range(2, n + 1):\n        result *= i\n        if mod:\n            result %= mod\n    return result\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Computes the factorial of a non-negative integer 'n', optionally taking a positive integer 'mod' for modular factorials.\"\"\""}
{"prompt": "def inorder_rec(root, res=None):\n    if root is None:\n        return []\n    if res is None:\n        res = []\n    inorder_rec(root.left, res)\n    res.append(root.val)\n    inorder_rec(root.right, res)\n    return res\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"Recursively traverse a binary tree inorder and return a list of values in the tree\""}
{"prompt": "def has_next(self):\n    if self.queue:\n        return True\n    return False\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturns a boolean indicating whether there is an item in the queue."}
{"prompt": "def __init__(self, vertices):\n    self.vertex_count = vertices\n    self.graph = {}\n    self.closure = [[0 for j in range(vertices)] for i in range(vertices)]\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\n__init__(self, vertices) - Initializes the graph object with a given number of vertices, creates a graph dictionary and an adjacency matrix of zeroes.\nParameters:\nself (object) - The graph object\nvertices (int) - The number of vertices in the graph"}
{"prompt": "def insertion_sort(arr, simulation=False):\n    iteration = 0\n    if simulation:\n        print('iteration', iteration, ':', *arr)\n    for i in range(len(arr)):\n        cursor = arr[i]\n        pos = i\n        while pos > 0 and arr[pos - 1] > cursor:\n            arr[pos] = arr[pos - 1]\n            pos = pos - 1\n        arr[pos] = cursor\n        if simulation:\n            iteration = iteration + 1\n            print('iteration', iteration, ':', *arr)\n    return arr\n##############\nEND_FUNC\n##############\n", "completion": "\n\nInsertion sort a given array. If simulation is set to True, print the current iteration of the array. Returns the sorted array."}
{"prompt": "def root(self, element):\n    while element != self.parents[element]:\n        self.parents[element] = self.parents[self.parents[element]]\n        element = self.parents[element]\n    return element\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function finds the root element of a union-find structure. It takes in an element and uses a path-compression technique to find the root element of the union-find structure, then returns the root element."}
{"prompt": "def delete_nth_naive(array, n):\n    ans = []\n    for num in array:\n        if ans.count(num) < n:\n            ans.append(num)\n    return ans\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nThis function takes an array of numbers and an integer n as arguments and returns an array with all elements that occur less than n times in the original array. It uses a naive approach to iterate through the array and count the occurrences of each element."}
{"prompt": "def multiply(self, a, b):\n    if a is None or b is None:\n        return None\n    (m, n, l) = (len(a), len(b[0]), len(b[0]))\n    if len(b) != n:\n        raise Exception(\"A's column number must be equal to B's row number.\")\n    c = [[0 for _ in range(l)] for _ in range(m)]\n    for (i, row) in enumerate(a):\n        for (k, eleA) in enumerate(row):\n            if eleA:\n                for (j, eleB) in enumerate(b[k]):\n                    if eleB:\n                        c[i][j] += eleA * eleB\n    return c\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function multiplies two matrices together. It takes three arguments: `self`, `a`, and `b`. If either `a` or `b` is None, the function will return None. Otherwise, it will check if `a` and `b` have compatible dimensions, and then it will multiply them together, returning the result."}
{"prompt": "def binary_tree_paths(root):\n    res = []\n    if root is None:\n        return res\n    dfs(res, root, str(root.val))\n    return res\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes in a binary tree root node as an argument and returns a list of all paths from the root node to its leaf nodes as strings. It uses depth-first search to traverse the tree and generate the paths."}
{"prompt": "def __query(self, i, L, R, l, r):\n    if l > R or r < L or L > R or (l > r):\n        return None\n    if L >= l and R <= r:\n        return self.segment[i]\n    val1 = self.__query(2 * i + 1, L, int((L + R) / 2), l, r)\n    val2 = self.__query(2 * i + 2, int((L + R + 2) / 2), R, l, r)\n    print(L, R, ' returned ', val1, val2)\n    if val1 != None:\n        if val2 != None:\n            return self.fn(val1, val2)\n        return val1\n    return val2\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function returns the result of an operation on a range of elements in a segment tree. \nInputs: \n    self: the segment tree object\n    i: the index of the segment tree node\n    L: the left boundary of the range represented by the node\n    R: the right boundary of the range represented by the node\n    l: the left boundary of the query range\n    r: the right boundary of the query range\nOutputs: \n    the result of the operation on the query range, or None if the query range does not overlap with the range represented by the node\n\"\"\""}
{"prompt": "def get(self, key):\n    hash_ = self.hash(key)\n    node_ = self._table[hash_]\n    while node_ is not self._empty:\n        if node_.key == key:\n            return node_.value\n        node_ = node_.next\n    return None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nRetrieves a value associated with the given key from this hash table.\n\nParameters:\n    self (HashTable): The hash table object.\n    key: The key of the value to retrieve.\n\nReturns:\n    The value associated with the given key, or None if no such value exists."}
{"prompt": "def __init__(self, letter, is_terminal=False):\n    self.children = dict()\n    self.letter = letter\n    self.is_terminal = is_terminal\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nInitialize a TrieNode with a given letter and is_terminal flag.\n\nParameters:\nletter (str): The letter for this TrieNode.\nis_terminal (bool, optional): Flag to indicate if this node is a terminal node. Defaults to False.\n\"\"\""}
{"prompt": "def maze_search(maze):\n    (BLOCKED, ALLOWED) = (0, 1)\n    (UNVISITED, VISITED) = (0, 1)\n    (initial_x, initial_y) = (0, 0)\n    if maze[initial_x][initial_y] == BLOCKED:\n        return -1\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    (height, width) = (len(maze), len(maze[0]))\n    (target_x, target_y) = (height - 1, width - 1)\n    queue = deque([(initial_x, initial_y, 0)])\n    is_visited = [[UNVISITED for w in range(width)] for h in range(height)]\n    is_visited[initial_x][initial_y] = VISITED\n    while queue:\n        (x, y, steps) = queue.popleft()\n        if x == target_x and y == target_y:\n            return steps\n        for (dx, dy) in directions:\n            new_x = x + dx\n            new_y = y + dy\n            if not (0 <= new_x < height and 0 <= new_y < width):\n                continue\n            if maze[new_x][new_y] == ALLOWED and is_visited[new_x][new_y] == UNVISITED:\n                queue.append((new_x, new_y, steps + 1))\n                is_visited[new_x][new_y] = VISITED\n    return -1\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function performs a search on a maze to find the shortest path between the starting point and the target point. It takes in a 2D array representing the maze, where 0 represents a blocked cell and 1 represents an allowed cell, and returns the number of steps required to reach the target point, or -1 if no such path is found. \n\"\"\""}
{"prompt": "def starts_with(self, prefix):\n    current = self.root\n    for letter in prefix:\n        current = current.children.get(letter)\n        if current is None:\n            return False\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes two arguments, self and prefix. It traverses the tree, starting from the root node, looking for a prefix in the tree. If the prefix is found, it returns True, otherwise it returns False."}
{"prompt": "def elias_gamma(x):\n    return elias_generic(unary, x)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nelias_gamma() encodes an integer x using the Elias Gamma code, which is a self-delimiting code based on unary encoding. It returns the encoded integer as a string of bits."}
{"prompt": "def is_rotated_v1(s1, s2):\n    if len(s1) != len(s2):\n        return False\n    if len(s1) == 0:\n        return True\n    for c in range(len(s1)):\n        if all((s1[(c + i) % len(s1)] == s2[i] for i in range(len(s1)))):\n            return True\n    return False\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nChecks if s2 is a rotated version of s1.\n\nParameters:\ns1 (str): The original string\ns2 (str): The string to check if it is a rotated version of s1\n\nReturns:\nbool: True if s2 is a rotated version of s1, False otherwise.\n\"\"\""}
{"prompt": "def find_order(a, n):\n    if (a == 1) & (n == 1):\n        return 1\n    if math.gcd(a, n) != 1:\n        print('a and n should be relative prime!')\n        return -1\n    for i in range(1, n):\n        if pow(a, i) % n == 1:\n            return i\n    return -1\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nFinds the order of a modulo n.\n\nGiven a number a and a modulo n, this function will return the smallest positive integer k such that a^k mod n is equal to 1. If a and n are not relatively prime, it will return -1.\n\nParameters: \na (int): The number to find the order of.\nn (int): The modulo.\n\nReturns:\nint: The smallest positive integer k such that a^k mod n is equal to 1, or -1 if a and n are not relatively prime.\n\"\"\""}
{"prompt": "def simplify_path_v1(path):\n    return os.path.abspath(path)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function takes a path and returns the canonical (absolute) path. The canonical path is the absolute path with all symbolic links and relative paths resolved."}
{"prompt": "def __init__(self):\n    self.root = None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__() is a constructor for the class which initializes the root attribute to None."}
{"prompt": "def get_skyline(lrh):\n    (skyline, live) = ([], [])\n    (i, n) = (0, len(lrh))\n    while i < n or live:\n        if not live or (i < n and lrh[i][0] <= -live[0][1]):\n            x = lrh[i][0]\n            while i < n and lrh[i][0] == x:\n                heapq.heappush(live, (-lrh[i][2], -lrh[i][1]))\n                i += 1\n        else:\n            x = -live[0][1]\n            while live and -live[0][1] <= x:\n                heapq.heappop(live)\n        height = len(live) and -live[0][0]\n        if not skyline or height != skyline[-1][1]:\n            skyline += ([x, height],)\n    return skyline\n##############\nEND_FUNC\n##############\n", "completion": "\n\nget_skyline(lrh):\n    \"\"\"\n    Returns a list of pairs [x, y] representing the skyline. \n    lrh is a list of triples of (left, right, height) representing buildings.\n    \"\"\""}
{"prompt": "def max_heapify(arr, end, simulation, iteration):\n    last_parent = (end - 1) // 2\n    for parent in range(last_parent, -1, -1):\n        current_parent = parent\n        while current_parent <= last_parent:\n            child = 2 * current_parent + 1\n            if child + 1 <= end and arr[child] < arr[child + 1]:\n                child = child + 1\n            if arr[child] > arr[current_parent]:\n                (arr[current_parent], arr[child]) = (arr[child], arr[current_parent])\n                current_parent = child\n                if simulation:\n                    iteration = iteration + 1\n                    print('iteration', iteration, ':', *arr)\n            else:\n                break\n    (arr[0], arr[end]) = (arr[end], arr[0])\n    return iteration\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nmax_heapify(arr, end, simulation, iteration):\n    Reorder the elements in the array 'arr' to make a max heap.\n    The max heap is a complete binary tree in which each node is larger than its two children.\n    All the elements in arr[0:end] are part of the max heap.\n    If simulation is True, print the array after each iteration.\n    Return the number of iterations.\n\"\"\""}
{"prompt": "def alice_shared_key(b_pu_k, a_pr_k, p):\n    return pow(b_pu_k, a_pr_k) % p\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"Returns Alice's shared key by using Bob's public key, Alice's private key, and a prime number.\""}
{"prompt": "def add_edge(self, source, target):\n    self.graph[source].append(target)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nAdds an edge between the given source and target vertices in the graph.\n\"\"\""}
{"prompt": "def nearest_neighbor(x, tSet):\n    assert isinstance(x, tuple) and isinstance(tSet, dict)\n    current_key = ()\n    min_d = float('inf')\n    for key in tSet:\n        d = distance(x, key)\n        if d < min_d:\n            min_d = d\n            current_key = key\n    return tSet[current_key]\n##############\nEND_FUNC\n##############\n", "completion": "\n\nFinds the value in tSet whose key is closest to x, according to a distance function. x and the keys of tSet must be tuples."}
{"prompt": "def traverse_tree(self):\n    self._traverse_tree(self.root)\n    print()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nTraverse the tree beginning at the root node, printing each node's value in order."}
{"prompt": "def postorder_rec(root, res=None):\n    if root is None:\n        return []\n    if res is None:\n        res = []\n    postorder_rec(root.left, res)\n    postorder_rec(root.right, res)\n    res.append(root.val)\n    return res\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function takes in a binary tree root node and an optional result list as parameters and performs a postorder traversal of the tree, adding each node's value to the result list. It returns the result list containing the postorder traversal of the binary tree."}
{"prompt": "@abstractmethod\ndef peek(self):\n    pass\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"This is an abstract method that will return the item at the top of the stack without removing it.\"\"\""}
{"prompt": "def anagram(s1, s2):\n    c1 = [0] * 26\n    c2 = [0] * 26\n    for c in s1:\n        pos = ord(c) - ord('a')\n        c1[pos] = c1[pos] + 1\n    for c in s2:\n        pos = ord(c) - ord('a')\n        c2[pos] = c2[pos] + 1\n    return c1 == c2\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCheck if two strings are anagrams of each other.\n\nParameters:\ns1 (str): first string to compare\ns2 (str): second string to compare\n\nReturns:\nbool: True if s1 is an anagram of s2, False otherwise\n\"\"\""}
{"prompt": "def ternary_search(left, right, key, arr):\n    while right >= left:\n        mid1 = left + (right - left) // 3\n        mid2 = right - (right - left) // 3\n        if key == arr[mid1]:\n            return mid1\n        if key == mid2:\n            return mid2\n        if key < arr[mid1]:\n            right = mid1 - 1\n        elif key > arr[mid2]:\n            left = mid2 + 1\n        else:\n            left = mid1 + 1\n            right = mid2 - 1\n    return -1\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function implements ternary search to find the given key in a given sorted array. It returns the index of the key if found, otherwise -1. \n\nParameters: \nleft (int): The left index of the array to begin the search. \nright (int): The right index of the array to end the search. \nkey (int): The key to be searched for. \narr (list): The sorted array to search in. \n\nReturns: \nint: The index of the key if found, otherwise -1. \n\"\"\""}
{"prompt": "def combination_memo(n, r):\n    memo = {}\n\n    def recur(n, r):\n        if n == r or r == 0:\n            return 1\n        if (n, r) not in memo:\n            memo[n, r] = recur(n - 1, r - 1) + recur(n - 1, r)\n        return memo[n, r]\n    return recur(n, r)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function computes the number of combinations of size r that can be made from a set of size n. It utilizes memoization to increase efficiency by avoiding redundant calculations and storing the results in a dictionary."}
{"prompt": "def climb_stairs(steps):\n    arr = [1, 1]\n    for _ in range(1, steps):\n        arr.append(arr[-1] + arr[-2])\n    return arr[-1]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nclimb_stairs(steps) takes in an integer value steps and returns the number of distinct ways in which a person can climb a staircase of given number of steps."}
{"prompt": "def find_words(board, words):\n\n    def backtrack(board, i, j, trie, pre, used, result):\n        if '#' in trie:\n            result.add(pre)\n        if i < 0 or i >= len(board) or j < 0 or (j >= len(board[0])):\n            return\n        if not used[i][j] and board[i][j] in trie:\n            used[i][j] = True\n            backtrack(board, i + 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n            backtrack(board, i, j + 1, trie[board[i][j]], pre + board[i][j], used, result)\n            backtrack(board, i - 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n            backtrack(board, i, j - 1, trie[board[i][j]], pre + board[i][j], used, result)\n            used[i][j] = False\n    trie = {}\n    for word in words:\n        curr_trie = trie\n        for char in word:\n            if char not in curr_trie:\n                curr_trie[char] = {}\n            curr_trie = curr_trie[char]\n        curr_trie['#'] = '#'\n    result = set()\n    used = [[False] * len(board[0]) for _ in range(len(board))]\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            backtrack(board, i, j, trie, '', used, result)\n    return list(result)\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nfind_words(board, words) is a function that takes in a 2D array of characters, 'board', and a list of words, 'words', and finds all words in 'words' that can be formed in the 'board'. It returns the list of found words."}
{"prompt": "def write_char(self, char):\n    self.write_int(ord(char))\n##############\nEND_FUNC\n##############\n", "completion": "\n\nWrite the given character to the stream, encoding it as an integer (its ASCII value)."}
{"prompt": "def __eq__(self, other):\n    if self.start == other.start and self.end == other.end:\n        return True\n    return False\n##############\nEND_FUNC\n##############\n", "completion": "\n\nCompares two objects and returns a boolean value (True or False) depending on whether their start and end values are equal."}
{"prompt": "def can_attend_meetings(intervals):\n    intervals = sorted(intervals, key=lambda x: x.start)\n    for i in range(1, len(intervals)):\n        if intervals[i].start < intervals[i - 1].end:\n            return False\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\nThis function takes in a list of Meeting intervals and determines if a person can attend all of the meetings. It returns True if the person can attend all meetings, False otherwise."}
{"prompt": "def iterative(s):\n    r = list(s)\n    (i, j) = (0, len(s) - 1)\n    while i < j:\n        (r[i], r[j]) = (r[j], r[i])\n        i += 1\n        j -= 1\n    return ''.join(r)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes a string as input, and returns a string with the characters reversed. It uses an iterative approach to reverse the characters by swapping them from both ends and incrementing/decrementing the indices accordingly."}
{"prompt": "def dot_product(iv_list1, iv_list2):\n    product = 0\n    p1 = len(iv_list1) - 1\n    p2 = len(iv_list2) - 1\n    while p1 >= 0 and p2 >= 0:\n        (i1, v1) = iv_list1[p1]\n        (i2, v2) = iv_list2[p2]\n        if i1 < i2:\n            p1 -= 1\n        elif i2 < i1:\n            p2 -= 1\n        else:\n            product += v1 * v2\n            p1 -= 1\n            p2 -= 1\n    return product\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCalculate the dot product of two vectors represented as index-value lists.\n\nArgs:\n    iv_list1 (list): First vector represented as an index-value list.\n    iv_list2 (list): Second vector represented as an index-value list.\n\nReturns:\n    int: The dot product of the two vectors.\n\"\"\""}
{"prompt": "def preorder(root):\n    res = []\n    if not root:\n        return res\n    stack = []\n    stack.append(root)\n    while stack:\n        root = stack.pop()\n        res.append(root.val)\n        if root.right:\n            stack.append(root.right)\n        if root.left:\n            stack.append(root.left)\n    return res\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nThis function takes in a root node and returns a list of preorder traversal of its nodes' values. It uses a stack to store the nodes that need to be processed."}
{"prompt": "def put(self, key, value):\n    initial_hash = hash_ = self.hash(key)\n    while True:\n        if self._keys[hash_] is self._empty or self._keys[hash_] is self._deleted:\n            self._keys[hash_] = key\n            self._values[hash_] = value\n            self._len += 1\n            return\n        elif self._keys[hash_] == key:\n            self._keys[hash_] = key\n            self._values[hash_] = value\n            return\n        hash_ = self._rehash(hash_)\n        if initial_hash == hash_:\n            raise ValueError('Table is full')\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nput(): Inserts a key-value pair into the hash table. \nRaises ValueError if the hash table is full.\nParameters: \n  self (required): The hash table object. \n  key (required): The key to insert. \n  value (required): The value to insert. \nReturns: None.\n\"\"\""}
{"prompt": "def remove_min(self):\n    ret = self.heap[1]\n    self.heap[1] = self.heap[self.current_size]\n    self.current_size = self.current_size - 1\n    self.heap.pop()\n    self.perc_down(1)\n    return ret\n##############\nEND_FUNC\n##############\n", "completion": "\n\nRemoves the minimum element from the heap and reorganizes the remaining elements to maintain heap order. Returns the minimum element."}
{"prompt": "def __add__(self, other: Union[int, float, Fraction, Monomial]):\n    if isinstance(other, int) or isinstance(other, float) or isinstance(other, Fraction):\n        return self.__add__(Monomial({}, Polynomial._rationalize_if_possible(other)))\n    elif isinstance(other, Monomial):\n        monos = {m.clone() for m in self.monomials}\n        for _own_monos in monos:\n            if _own_monos.equal_upto_scalar(other):\n                scalar = _own_monos.coeff\n                monos -= {_own_monos}\n                temp_variables = {i: other.variables[i] for i in other.variables}\n                monos |= {Monomial(temp_variables, Polynomial._rationalize_if_possible(scalar + other.coeff))}\n                return Polynomial([z for z in monos])\n        monos |= {other.clone()}\n        return Polynomial([z for z in monos])\n    elif isinstance(other, Polynomial):\n        temp = list((z for z in {m.clone() for m in self.all_monomials()}))\n        p = Polynomial(temp)\n        for o in other.all_monomials():\n            p = p.__add__(o.clone())\n        return p\n    else:\n        raise ValueError('Can only add int, float, Fraction, Monomials, or Polynomials to Polynomials.')\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function adds a given int, float, Fraction, Monomial, or Polynomial to a Polynomial object. It returns a Polynomial object that is the sum of the two."}
{"prompt": "def perc_up(self, i):\n    while i // 2 > 0:\n        if self.heap[i] < self.heap[i // 2]:\n            (self.heap[i], self.heap[i // 2]) = (self.heap[i // 2], self.heap[i])\n        i = i // 2\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"Move a node up the heap to its proper position according to the heap property\""}
{"prompt": "def __resize(self):\n    (keys, values) = (self._keys, self._values)\n    self.size *= 2\n    self._len = 0\n    self._keys = [self._empty] * self.size\n    self._values = [self._empty] * self.size\n    for (key, value) in zip(keys, values):\n        if key is not self._empty and key is not self._deleted:\n            self.put(key, value)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"Resizes the hash table when the load factor is high to ensure efficient use of space and time complexity\""}
{"prompt": "def strip_url_params1(url, params_to_strip=None):\n    if not params_to_strip:\n        params_to_strip = []\n    if url:\n        result = ''\n        tokens = url.split('?')\n        domain = tokens[0]\n        query_string = tokens[-1]\n        result += domain\n        if len(tokens) > 1:\n            result += '?'\n        if not query_string:\n            return url\n        else:\n            key_value_string = []\n            string = ''\n            for char in query_string:\n                if char.isdigit():\n                    key_value_string.append(string + char)\n                    string = ''\n                else:\n                    string += char\n            dict = defaultdict(int)\n            for i in key_value_string:\n                _token = i.split('=')\n                if _token[0]:\n                    length = len(_token[0])\n                    if length == 1:\n                        if _token and (not _token[0] in dict):\n                            if params_to_strip:\n                                if _token[0] != params_to_strip[0]:\n                                    dict[_token[0]] = _token[1]\n                                    result = result + _token[0] + '=' + _token[1]\n                            elif not _token[0] in dict:\n                                dict[_token[0]] = _token[1]\n                                result = result + _token[0] + '=' + _token[1]\n                    else:\n                        check = _token[0]\n                        letter = check[1]\n                        if _token and (not letter in dict):\n                            if params_to_strip:\n                                if letter != params_to_strip[0]:\n                                    dict[letter] = _token[1]\n                                    result = result + _token[0] + '=' + _token[1]\n                            elif not letter in dict:\n                                dict[letter] = _token[1]\n                                result = result + _token[0] + '=' + _token[1]\n    return result\n##############\nEND_FUNC\n##############\n", "completion": "\n\nstrip_url_params1(url, params_to_strip=None)\n\nThis function takes a URL string and an optional list of parameter names to strip from the URL. It returns a new URL string with the specified parameters removed."}
{"prompt": "def is_bst(root):\n    stack = []\n    pre = None\n    while root or stack:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if pre and root.val <= pre.val:\n            return False\n        pre = root\n        root = root.right\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function checks if a given binary tree is a valid binary search tree (BST). It uses an in-order traversal to traverse the nodes of the tree and returns False if any of the nodes are found to violate the BST property (i.e. if any left node is greater than the right node)."}
{"prompt": "def possible_values(self):\n    a = '123456789'\n    (d, val) = ({}, {})\n    for i in range(self.row):\n        for j in range(self.col):\n            ele = self.board[i][j]\n            if ele != '.':\n                d['r', i] = d.get(('r', i), []) + [ele]\n                d['c', j] = d.get(('c', j), []) + [ele]\n                d[i // 3, j // 3] = d.get((i // 3, j // 3), []) + [ele]\n            else:\n                val[i, j] = []\n    for (i, j) in val.keys():\n        inval = d.get(('r', i), []) + d.get(('c', j), []) + d.get((i / 3, j / 3), [])\n        val[i, j] = [n for n in a if n not in inval]\n    return val\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function returns a dictionary containing all possible values of a given Sudoku board. The key of the dictionary is a tuple containing the row and column index of the cell, and the value is a list of all possible values for that cell."}
{"prompt": "def merge_k_lists(lists):\n    dummy = ListNode(None)\n    curr = dummy\n    q = PriorityQueue()\n    for node in lists:\n        if node:\n            q.put((node.val, node))\n    while not q.empty():\n        curr.next = q.get()[1]\n        curr = curr.next\n        if curr.next:\n            q.put((curr.next.val, curr.next))\n    return dummy.next\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nMerge k sorted linked lists and return it as one sorted list.\n\nParameters:\n- lists (ListNode): list of ListNode objects representing linked lists\n\nReturns:\n- ListNode: head of the merged list\n\"\"\""}
{"prompt": "def __str__(self) -> str:\n    return ' + '.join((str(m) for m in self.all_monomials() if m.coeff != Fraction(0, 1)))\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturns a string representation of the expression in the form of a summation of all monomials in the expression."}
{"prompt": "def __eq__(self, other):\n    return self.frequency == other.frequency\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nCompares two objects for equality based on their frequency.\nReturns True if their frequencies are equal, False otherwise."}
{"prompt": "def one_sparse(array):\n    sum_signs = 0\n    bitsum = [0] * 32\n    sum_values = 0\n    for (val, sign) in array:\n        if sign == '+':\n            sum_signs += 1\n            sum_values += val\n        else:\n            sum_signs -= 1\n            sum_values -= val\n        _get_bit_sum(bitsum, val, sign)\n    if sum_signs > 0 and _check_every_number_in_bitsum(bitsum, sum_signs):\n        return int(sum_values / sum_signs)\n    else:\n        return None\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function takes in an array of tuples containing a value and a sign. It then sums up the values and signs and checks to see if all the values with a \"+\" sign are greater than or equal to the total number of \"+\" signs. If so, it returns the average, otherwise it returns None."}
{"prompt": "def euler_totient(n):\n    result = n\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            while n % i == 0:\n                n //= i\n            result -= result // i\n    if n > 1:\n        result -= result // n\n    return result\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCalculate Euler's totient function of n.\n\nEuler's totient function, also known as Euler's phi function, is an arithmetic function that counts the positive integers up to a given integer n that are relatively prime to n.\n\nParameters\n    n (int): The number to calculate the totient of.\n\nReturns\n    int: The Euler's totient function of n.\n\"\"\""}
{"prompt": "def test():\n    a = Node('3')\n    b = Node('5')\n    c = Node('8')\n    d = Node('5')\n    e = Node('10')\n    f = Node('2')\n    g = Node('1')\n    a.next = b\n    b.next = c\n    c.next = d\n    d.next = e\n    e.next = f\n    f.next = g\n    print_linked_list(a)\n    partition(a, 5)\n    print_linked_list(a)\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"This function creates a linked list of nodes, prints the linked list, then partitions the linked list around the value of '5' and prints the new partitioned linked list.\"\"\""}
{"prompt": "def solve_sat(formula):\n    graph = build_graph(formula)\n    vertex_scc = scc(graph)\n    for (var, _) in graph:\n        if vertex_scc[var, False] == vertex_scc[var, True]:\n            return None\n    comp_repr = {}\n    for vertex in graph:\n        if not vertex_scc[vertex] in comp_repr:\n            comp_repr[vertex_scc[vertex]] = vertex\n    comp_value = {}\n    components = sorted(vertex_scc.values())\n    for comp in components:\n        if comp not in comp_value:\n            comp_value[comp] = False\n            (lit, neg) = comp_repr[comp]\n            comp_value[vertex_scc[lit, not neg]] = True\n    value = {var: comp_value[vertex_scc[var, False]] for (var, _) in graph}\n    return value\n##############\nEND_FUNC\n##############\n", "completion": "\n\nSolve SAT: Given a formula in the form of a graph, the function finds the assignments of True and False to the variables that make the formula true. If no such assignment exists, it returns None."}
{"prompt": "def max_common_sub_string(s1, s2):\n    s2dic = {s2[i]: i for i in range(len(s2))}\n    maxr = 0\n    subs = ''\n    i = 0\n    while i < len(s1):\n        if s1[i] in s2dic:\n            j = s2dic[s1[i]]\n            k = i\n            while j < len(s2) and k < len(s1) and (s1[k] == s2[j]):\n                k += 1\n                j += 1\n            if k - i > maxr:\n                maxr = k - i\n                subs = s1[i:k]\n            i = k\n        else:\n            i += 1\n    return subs\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function finds the longest common substring between two strings, s1 and s2. It returns the longest common substring as a string. \n\"\"\""}
{"prompt": "def find_primitive_root(n):\n    if n == 1:\n        return [0]\n    phi = euler_totient(n)\n    p_root_list = []\n    ' It will return every primitive roots of n. '\n    for i in range(1, n):\n        if math.gcd(i, n) == 1:\n            order = find_order(i, n)\n            if order == phi:\n                p_root_list.append(i)\n    return p_root_list\n##############\nEND_FUNC\n##############\n", "completion": "\nReturns a list of all primitive roots of n. Primitive roots are numbers less than n such that the order of the number modulo n is equal to the totient of n."}
{"prompt": "def __ge__(self, obj):\n    return self.name >= self.get_name(obj)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nCompares the name of \"self\" with the name of \"obj\" and returns a boolean value."}
{"prompt": "def distance(point, origin=(0, 0)):\n    return (point[0] - origin[0]) ** 2 + (point[1] - origin[1]) ** 2\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nCalculate the squared distance between a point and an origin.\n\nArgs:\n    point (tuple): A length-two tuple containing the x and y coordinates of the point.\n    origin (tuple): A length-two tuple containing the x and y coordinates of the origin. Defaults to (0, 0).\n\nReturns:\n    float: The squared distance between the point and the origin."}
{"prompt": "def __init__(self, load_dict={}):\n    self.nodes = []\n    self.edges = []\n    self.adjacency_list = {}\n    if load_dict and isinstance(load_dict, dict):\n        for vertex in load_dict:\n            node_from = self.add_node(vertex)\n            self.adjacency_list[node_from] = []\n            for neighbor in load_dict[vertex]:\n                node_to = self.add_node(neighbor)\n                self.adjacency_list[node_from].append(node_to)\n                self.add_edge(vertex, neighbor)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function initializes a Graph object. It takes an optional load_dict argument which is a dictionary of nodes and edges.  If the load_dict argument is supplied, the Graph will be populated with the nodes and edges from the dictionary. \n\"\"\""}
{"prompt": "def cycle_index_sym_helper(n: int, memo: Dict[int, Polynomial]) -> Polynomial:\n    if n in memo:\n        return memo[n]\n    ans = Polynomial([Monomial({}, Fraction(0, 1))])\n    for t in range(1, n + 1):\n        ans = ans.__add__(Polynomial([Monomial({t: 1}, Fraction(1, 1))]) * cycle_index_sym_helper(n - t, memo))\n    ans *= Fraction(1, n)\n    memo[n] = ans\n    return memo[n]\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function calculates the cycle index polynomial of a symmetric group of order `n`. It uses memoization to store the results of previously-calculated polynomials and returns the polynomial stored in the memo dictionary with the given `n`."}
{"prompt": "def closest_value(root, target):\n    a = root.val\n    kid = root.left if target < a else root.right\n    if not kid:\n        return a\n    b = closest_value(kid, target)\n    return min((a, b), key=lambda x: abs(target - x))\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nclosest_value(root, target) finds the closest value in a binary search tree to the given target value.\nIt returns the closest value in the BST to the given target value.\n\nIt takes two parameters:\nroot: the root node of the BST\ntarget: the target value to find the closest value for\n\"\"\""}
{"prompt": "def dfs_traverse_recursive(graph, start, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    for next_node in graph[start]:\n        if next_node not in visited:\n            dfs_traverse_recursive(graph, next_node, visited)\n    return visited\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function performs a depth-first search (DFS) on a graph, traversing all nodes from the given start node. It takes in a graph (represented as a dictionary), a start node, and an optional visited set to track visited nodes. It adds the start node to the visited set and then iterates through all connected nodes, recursively running the DFS on each node that has not yet been visited. Finally, it returns the visited set.\n\"\"\""}
{"prompt": "def array_sum_combinations(A, B, C, target):\n\n    def over(constructed_sofar):\n        sum = 0\n        (to_stop, reached_target) = (False, False)\n        for elem in constructed_sofar:\n            sum += elem\n        if sum >= target or len(constructed_sofar) >= 3:\n            to_stop = True\n            if sum == target and 3 == len(constructed_sofar):\n                reached_target = True\n        return (to_stop, reached_target)\n\n    def construct_candidates(constructed_sofar):\n        array = A\n        if 1 == len(constructed_sofar):\n            array = B\n        elif 2 == len(constructed_sofar):\n            array = C\n        return array\n\n    def backtrack(constructed_sofar=[], res=[]):\n        (to_stop, reached_target) = over(constructed_sofar)\n        if to_stop:\n            if reached_target:\n                res.append(constructed_sofar)\n            return\n        candidates = construct_candidates(constructed_sofar)\n        for candidate in candidates:\n            constructed_sofar.append(candidate)\n            backtrack(constructed_sofar[:], res)\n            constructed_sofar.pop()\n    res = []\n    backtrack([], res)\n    return res\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function takes four arguments: three arrays A, B, and C, as well as a target number. It returns an array of combinations of elements from the three arrays that sum to the target number."}
{"prompt": "def __init__(self):\n    self.current_size = 0\n    self.heap = [0]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function is used to initialize a heap data structure. It sets the size of the heap to 0 and creates a list containing one element (0) which is used as the base of the heap."}
{"prompt": "def max_subarray(array):\n    max_so_far = max_now = array[0]\n    for i in range(1, len(array)):\n        max_now = max(array[i], max_now + array[i])\n        max_so_far = max(max_so_far, max_now)\n    return max_so_far\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nFinds the contiguous subarray within an array (containing at least one number) which has the largest sum.\n\nParameters:\n    array (list of ints): The array to search through.\n\nReturns:\n    int: The sum of the largest contiguous subarray.\n\"\"\""}
{"prompt": "def has_path_sum(root, sum):\n    if root is None:\n        return False\n    if root.left is None and root.right is None and (root.val == sum):\n        return True\n    sum -= root.val\n    return has_path_sum(root.left, sum) or has_path_sum(root.right, sum)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCheck if the given binary tree has a path with the given sum.\n\nArgs:\n    root (TreeNode): The root node of the binary tree.\n    sum (int): The sum to check for in the binary tree.\n\nReturns:\n    bool: Whether or not a path with the given sum exists in the binary tree.\n\"\"\""}
{"prompt": "def bin_tree_to_list(root):\n    if not root:\n        return root\n    root = bin_tree_to_list_util(root)\n    while root.left:\n        root = root.left\n    return root\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes the root node of a binary tree and converts it into a doubly linked list. It returns the head of the linked list."}
{"prompt": "def kth_smallest(self, root, k):\n    count = []\n    self.helper(root, count)\n    return count[k - 1]\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nThis function returns the kth smallest element in a binary search tree. It traverses the tree in an inorder manner and stores the elements in an array. The kth smallest element is then returned from the array."}
{"prompt": "def max_product(nums):\n    lmin = lmax = gmax = nums[0]\n    for num in nums:\n        t_1 = num * lmax\n        t_2 = num * lmin\n        lmax = max(max(t_1, t_2), num)\n        lmin = min(min(t_1, t_2), num)\n        gmax = max(gmax, lmax)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function finds the maximum product of any subarray in the given array of numbers. It runs through the array and updates the local max and local min and then compares it to the global max to keep track of the greatest product."}
{"prompt": "def __init__(self):\n    self.c = dict()\n    self.sym = None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__(self)\n\nInitialize a new instance of the class.\n\nParameters:\n    self: The instance of the class.\n\nAttributes:\n    c (dict): The dictionary to store the data.\n    sym (None): The symbol to be used."}
{"prompt": "def num_decodings2(enc_mes):\n    if not enc_mes or enc_mes.startswith('0'):\n        return 0\n    stack = [1, 1]\n    for i in range(1, len(enc_mes)):\n        if enc_mes[i] == '0':\n            if enc_mes[i - 1] == '0' or enc_mes[i - 1] > '2':\n                return 0\n            stack.append(stack[-2])\n        elif 9 < int(enc_mes[i - 1:i + 1]) < 27:\n            stack.append(stack[-2] + stack[-1])\n        else:\n            stack.append(stack[-1])\n    return stack[-1]\n##############\nEND_FUNC\n##############\n", "completion": "\n\nnum_decodings2(enc_mes) takes an encoded message as an argument and returns the number of possible decodings of the message. It returns 0 if the encoded message is empty or starts with '0'."}
{"prompt": "def helper(n, length):\n    if n == 0:\n        return ['']\n    if n == 1:\n        return ['1', '0', '8']\n    middles = helper(n - 2, length)\n    result = []\n    for middle in middles:\n        if n != length:\n            result.append('0' + middle + '0')\n        result.append('8' + middle + '8')\n        result.append('1' + middle + '1')\n        result.append('9' + middle + '6')\n        result.append('6' + middle + '9')\n    return result\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function returns a list of all possible combinations of the numbers 1, 8, 0, 9 and 6 given a length and starting number."}
{"prompt": "def add_edge(self, source, target):\n    self.graph[source].append(target)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nAdds an edge between two nodes in a graph.\n\nArgs:\n    self (object): The object being operated on.\n    source (int): The source node.\n    target (int): The target node.\n\nReturns:\n    None\n\"\"\""}
{"prompt": "def push(self, value):\n    self._top += 1\n    if self._top == len(self._array):\n        self._expand()\n    self._array[self._top] = value\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nPush a value onto the top of the stack. If the stack is full, expand it to double its size."}
{"prompt": "def first_switch_pairs(stack):\n    storage_stack = []\n    for i in range(len(stack)):\n        storage_stack.append(stack.pop())\n    for i in range(len(storage_stack)):\n        if len(storage_stack) == 0:\n            break\n        first = storage_stack.pop()\n        if len(storage_stack) == 0:\n            stack.append(first)\n            break\n        second = storage_stack.pop()\n        stack.append(second)\n        stack.append(first)\n    return stack\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Switches the first two items in a stack.\n\nArgs:\n    stack (list): The stack to switch the first two items of.\n\nReturns:\n    list: The stack with the first two items switched.\n\"\"\""}
{"prompt": "def subsets_v2(nums):\n    res = [[]]\n    for num in sorted(nums):\n        res += [item + [num] for item in res]\n    return res\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nThis function takes a list of numbers as an argument and returns a list of all possible subsets of the given list. Each subset is stored as a list within the outer list."}
{"prompt": "def union(duplicate_results):\n    results = []\n    if len(duplicate_results) != 0:\n        duplicate_results.sort()\n        results.append(duplicate_results[0])\n        for result in duplicate_results[1:]:\n            if results[-1] != result:\n                results.append(result)\n    return results\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nunion(duplicate_results)\n\nReturns a list containing the unique elements of duplicate_results, sorted in ascending order. \nduplicate_results must be a list of elements that are able to be sorted. \n\"\"\""}
{"prompt": "def path_sum(root, sum):\n    if root is None:\n        return []\n    res = []\n    dfs(root, sum, [], res)\n    return res\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function finds all the paths in a binary tree that sum up to a given sum.\nThe function takes in the root of a binary tree and the target sum as parameters, and returns a list of all paths that sum up to the target sum."}
{"prompt": "def sum_dig_pow(low, high):\n    result = []\n    for number in range(low, high + 1):\n        exponent = 1\n        summation = 0\n        number_as_string = str(number)\n        tokens = list(map(int, number_as_string))\n        for k in tokens:\n            summation = summation + k ** exponent\n            exponent += 1\n        if summation == number:\n            result.append(number)\n    return result\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nsum_dig_pow(low, high) returns a list of all the numbers between low and high (inclusive) \nwhose digits raised to the consecutive powers sum to the number itself. For example, 89 \n= 8^1 + 9^2 is such a number. \n\"\"\""}
{"prompt": "def dequeue(self):\n    if self.is_empty():\n        raise IndexError('Queue is empty')\n    value = self._front.value\n    if self._front is self._rear:\n        self._front = None\n        self._rear = None\n    else:\n        self._front = self._front.next\n    self._size -= 1\n    return value\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"Removes and returns the item at the front of the queue. Raises an IndexError if the queue is empty.\"\"\""}
{"prompt": "def perc_down(self, i):\n    while 2 * i < self.current_size:\n        min_child = self.min_child(i)\n        if self.heap[min_child] < self.heap[i]:\n            (self.heap[min_child], self.heap[i]) = (self.heap[i], self.heap[min_child])\n        i = min_child\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"Performs percolate down on the heap to maintain the min-heap property\""}
{"prompt": "def write_bits(self, bits):\n    self.saved_bits += len(bits)\n    self.buffer += bits\n    while len(self.buffer) >= 8:\n        i = int(self.buffer[:8], 2)\n        self.file.write(bytes([i]))\n        self.buffer = self.buffer[8:]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Write bits to a file.\n\nThis function takes in a string of bits and appends it to the existing 'buffer' string. \nOnce the length of the combined bits reaches 8, it will convert it to an integer and write it to the file. \nThe number of bits written is then stored in the 'saved_bits' variable, and the buffer is reset.\n\"\"\""}
{"prompt": "def decrypt(data, d, n):\n    return pow(int(data), int(d), int(n))\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nDecrypts data using the provided d and n exponent and modulus parameters.\n\nParameters:\ndata (int): data to be decrypted\nd (int): exponent parameter\nn (int): modulus parameter\n\nReturns:\ndecrypted data (int)\n\"\"\""}
{"prompt": "def find_missing_number(nums):\n    missing = 0\n    for (i, num) in enumerate(nums):\n        missing ^= num\n        missing ^= i + 1\n    return missing\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes in a list of numbers and finds the missing number in the sequence. It uses a bitwise XOR operator to compare the numbers in the list with the numbers in the sequence to find the missing number."}
{"prompt": "def subsets(nums):\n    n = len(nums)\n    total = 1 << n\n    res = set()\n    for i in range(total):\n        subset = tuple((num for (j, num) in enumerate(nums) if i & 1 << j))\n        res.add(subset)\n    return res\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes in a list of numbers and returns a set of all subsets of those numbers.\n\"\"\""}
{"prompt": "def stoogesort(arr, l, h):\n    if l >= h:\n        return\n    if arr[l] > arr[h]:\n        t = arr[l]\n        arr[l] = arr[h]\n        arr[h] = t\n    if h - l + 1 > 2:\n        t = int((h - l + 1) / 3)\n        stoogesort(arr, l, h - t)\n        stoogesort(arr, l + t, h)\n        stoogesort(arr, l, h - t)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nSort an array using Stooge Sort.\n\nParameters:\n    arr (list): The array to be sorted\n    l (int): The leftmost index of the array\n    h (int): The rightmost index of the array\n\nReturns:\n    None\n\"\"\""}
{"prompt": "@staticmethod\ndef _rationalize_if_possible(num):\n    if isinstance(num, Rational):\n        res = Fraction(num, 1)\n        return Fraction(res.numerator, res.denominator)\n    else:\n        return num\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function checks if the given number is an instance of Rational type. If it is, it converts the Rational instance to a Fraction and returns the Fraction with numerator and denominator. If the number is not an instance of Rational, it simply returns the number."}
{"prompt": "def test_depth_sum(self):\n    self.assertEqual(253, depth_sum(self.tree.root, 4))\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nTest that the total sum of all nodes in a given binary tree is equal to the expected sum. \nParameters: \nself (object): The object reference.\nself.tree.root (TreeNode): The root node of the given binary tree.\n4 (int): The maximum depth of the tree.\n\"\"\""}
{"prompt": "def update_balances(self, recursive=True):\n    if self.node:\n        if recursive:\n            if self.node.left:\n                self.node.left.update_balances()\n            if self.node.right:\n                self.node.right.update_balances()\n        self.balance = self.node.left.height - self.node.right.height\n    else:\n        self.balance = 0\n##############\nEND_FUNC\n##############\n", "completion": "\nUpdate the balance of the node and the nodes in its subtree."}
{"prompt": "def re_balance(self):\n    self.update_heights(recursive=False)\n    self.update_balances(False)\n    while self.balance < -1 or self.balance > 1:\n        if self.balance > 1:\n            if self.node.left.balance < 0:\n                self.node.left.rotate_left()\n                self.update_heights()\n                self.update_balances()\n            self.rotate_right()\n            self.update_heights()\n            self.update_balances()\n        if self.balance < -1:\n            if self.node.right.balance > 0:\n                self.node.right.rotate_right()\n                self.update_heights()\n                self.update_balances()\n            self.rotate_left()\n            self.update_heights()\n            self.update_balances()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nRe-balance the tree by rotating left or right and updating the heights and balances."}
{"prompt": "def counting_sort(arr):\n    m = min(arr)\n    different = 0\n    if m < 0:\n        different = -m\n        for i in range(len(arr)):\n            arr[i] += -m\n    k = max(arr)\n    temp_arr = [0] * (k + 1)\n    for i in range(0, len(arr)):\n        temp_arr[arr[i]] = temp_arr[arr[i]] + 1\n    for i in range(1, k + 1):\n        temp_arr[i] = temp_arr[i] + temp_arr[i - 1]\n    result_arr = arr.copy()\n    for i in range(len(arr) - 1, -1, -1):\n        result_arr[temp_arr[arr[i]] - 1] = arr[i] - different\n        temp_arr[arr[i]] = temp_arr[arr[i]] - 1\n    return result_arr\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nImplements the Counting Sort algorithm to sort a given array of integers.\n\nParameters:\narr (list): The array of integers to be sorted.\n\nReturns:\nlist: The sorted array.\n\"\"\""}
{"prompt": "def __repr__(self):\n    return '<ch: {0}: {1}>'.format(self.sign, self.frequency)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function returns a string representation of an object instance. It takes two inputs: self.sign and self.frequency, and returns a string in the format '<ch: {sign}: {frequency}>'."}
{"prompt": "def push(self, value):\n    node = StackNode(value)\n    node.next = self.head\n    self.head = node\n    self._top += 1\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\npush() adds a new StackNode with the given value at the top of the stack."}
{"prompt": "def delete_node(node):\n    if node is None or node.next is None:\n        raise ValueError\n    node.val = node.next.val\n    node.next = node.next.next\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nDelete the given node in a singly linked list.\n\nRaises a ValueError if the node is None or if the node is the last node in the list."}
{"prompt": "def pop(self):\n    if self.is_empty():\n        raise IndexError('Stack is empty')\n    return self.items.pop()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"pop(self) - Removes and returns the last item in the stack. Raises IndexError if stack is empty.\"\"\""}
{"prompt": "def search(self, word):\n    current = self.root\n    for letter in word:\n        current = current.children.get(letter)\n        if current is None:\n            return False\n    return current.is_word\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function searches for a given word in a trie data structure. It takes in a word as argument and returns a boolean value indicating whether the word exists in the trie or not."}
{"prompt": "def crout_matrix_decomposition(A):\n    n = len(A)\n    L = [[0.0] * n for i in range(n)]\n    U = [[0.0] * n for i in range(n)]\n    for j in range(n):\n        U[j][j] = 1.0\n        for i in range(j, n):\n            alpha = float(A[i][j])\n            for k in range(j):\n                alpha -= L[i][k] * U[k][j]\n            L[i][j] = float(alpha)\n        for i in range(j + 1, n):\n            tempU = float(A[j][i])\n            for k in range(j):\n                tempU -= float(L[j][k] * U[k][i])\n            if int(L[j][j]) == 0:\n                L[j][j] = float(0.1 ** 40)\n            U[j][i] = float(tempU / L[j][j])\n    return (L, U)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function performs Crout matrix decomposition on a given matrix A. It returns two matrices, L (the lower triangular matrix) and U (the upper triangular matrix)."}
{"prompt": "def match_symbol_1(words, symbols):\n    res = []\n    symbols = sorted(symbols, key=lambda _: len(_), reverse=True)\n    for word in words:\n        for symbol in symbols:\n            word_replaced = ''\n            if word.find(symbol) != -1:\n                word_replaced = word.replace(symbol, '[' + symbol + ']')\n                res.append(word_replaced)\n                break\n        if word_replaced == '':\n            res.append(word)\n    return res\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes in two parameters, a list of words and a list of symbols, and returns a list of words with the symbols replaced by brackets around the symbol. Symbols are replaced in order of longest to shortest. If a word does not contain a symbol, it is added to the result list as is. \n\"\"\""}
{"prompt": "def remove_min(stack):\n    storage_stack = []\n    if len(stack) == 0:\n        return stack\n    min = stack.pop()\n    stack.append(min)\n    for i in range(len(stack)):\n        val = stack.pop()\n        if val <= min:\n            min = val\n        storage_stack.append(val)\n    for i in range(len(storage_stack)):\n        val = storage_stack.pop()\n        if val != min:\n            stack.append(val)\n    return stack\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nremove_min(stack) - Removes the minimum value from the given stack and returns the modified stack. If the stack is empty, the original stack is returned."}
{"prompt": "def __init__(self, x):\n    self.val = x\n    self.left = None\n    self.right = None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__() is a constructor for a Binary Tree Node object. It takes in an argument 'x', and assigns it to the value of the node (self.val). It also assigns the left and right nodes of the given node to None."}
{"prompt": "def pop(self):\n    if self.is_empty():\n        raise IndexError('Stack is empty')\n    value = self.head.value\n    self.head = self.head.next\n    self._top -= 1\n    return value\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Removes the top item from the stack and returns it. Raises an IndexError if the stack is empty.\"\"\""}
{"prompt": "def int_to_bytes_little_endian(num):\n    bytestr = []\n    while num > 0:\n        bytestr.append(num & 255)\n        num >>= 8\n    return bytes(bytestr)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nConvert an integer to a bytes object in little endian byte order.\n\nParameters:\nnum (int): The integer to convert to a bytes object.\n\nReturns:\nbytes: A bytes object representing the integer in little endian byte order.\n\"\"\""}
{"prompt": "def valid_witness(a):\n    x = pow(int(a), int(d), int(n))\n    if x == 1 or x == n - 1:\n        return False\n    for _ in range(r - 1):\n        x = pow(int(x), int(2), int(n))\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes an integer a as an input and checks if it is a valid witness for primality testing. It returns True if a is a valid witness, False otherwise."}
{"prompt": "def pacific_atlantic(matrix):\n    n = len(matrix)\n    if not n:\n        return []\n    m = len(matrix[0])\n    if not m:\n        return []\n    res = []\n    atlantic = [[False for _ in range(n)] for _ in range(m)]\n    pacific = [[False for _ in range(n)] for _ in range(m)]\n    for i in range(n):\n        dfs(pacific, matrix, float('-inf'), i, 0)\n        dfs(atlantic, matrix, float('-inf'), i, m - 1)\n    for i in range(m):\n        dfs(pacific, matrix, float('-inf'), 0, i)\n        dfs(atlantic, matrix, float('-inf'), n - 1, i)\n    for i in range(n):\n        for j in range(m):\n            if pacific[i][j] and atlantic[i][j]:\n                res.append([i, j])\n    return res\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function takes a matrix of numbers as an input and returns a list of coordinates where the values in the matrix are able to flow to both the Atlantic and Pacific oceans. It uses a Depth-first Search algorithm to determine which cells are able to reach the two oceans."}
{"prompt": "def find_k_factor(length, k_factor):\n    mat = [[[0 for i in range(4)] for j in range((length - 1) // 3 + 2)] for k in range(length + 1)]\n    if 3 * k_factor + 1 > length:\n        return 0\n    mat[1][0][0] = 1\n    mat[1][0][1] = 0\n    mat[1][0][2] = 0\n    mat[1][0][3] = 25\n    for i in range(2, length + 1):\n        for j in range((length - 1) // 3 + 2):\n            if j == 0:\n                mat[i][j][0] = mat[i - 1][j][0] + mat[i - 1][j][1] + mat[i - 1][j][3]\n                mat[i][j][1] = mat[i - 1][j][0]\n                mat[i][j][2] = mat[i - 1][j][1]\n                mat[i][j][3] = mat[i - 1][j][0] * 24 + mat[i - 1][j][1] * 24 + mat[i - 1][j][2] * 25 + mat[i - 1][j][3] * 25\n            elif 3 * j + 1 < i:\n                mat[i][j][0] = mat[i - 1][j][0] + mat[i - 1][j][1] + mat[i - 1][j][3] + mat[i - 1][j - 1][2]\n                mat[i][j][1] = mat[i - 1][j][0]\n                mat[i][j][2] = mat[i - 1][j][1]\n                mat[i][j][3] = mat[i - 1][j][0] * 24 + mat[i - 1][j][1] * 24 + mat[i - 1][j][2] * 25 + mat[i - 1][j][3] * 25\n            elif 3 * j + 1 == i:\n                mat[i][j][0] = 1\n                mat[i][j][1] = 0\n                mat[i][j][2] = 0\n                mat[i][j][3] = 0\n            else:\n                mat[i][j][0] = 0\n                mat[i][j][1] = 0\n                mat[i][j][2] = 0\n                mat[i][j][3] = 0\n    return sum(mat[length][k_factor])\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function finds the number of possible sequences of length 'length' and k_factor occurrences of a number greater than 3. It returns the sum of all possible sequences."}
{"prompt": "@property\ndef is_leaf(self):\n    return len(self.children) == 0\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis property returns a boolean indicating whether the given node has any children or not."}
{"prompt": "def make_tree(self, i, l, r):\n    if l == r:\n        self.segment[i] = self.arr[l]\n    elif l < r:\n        self.make_tree(2 * i + 1, l, int((l + r) / 2))\n        self.make_tree(2 * i + 2, int((l + r) / 2) + 1, r)\n        self.segment[i] = self.fn(self.segment[2 * i + 1], self.segment[2 * i + 2])\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function creates a segment tree from an array of values. It takes the index of the current node (i), the left index of the array (l), and the right index of the array (r) as parameters. If l is equal to r, it sets the value of the current node to the value of the array at index l. If l is less than r, it recursively calls itself on the left and right nodes, setting the value of the current node to the result of calling the function given as a parameter (fn) on the left and right nodes."}
{"prompt": "def rotate_right(self):\n    new_root = self.node.left.node\n    new_left_sub = new_root.right.node\n    old_root = self.node\n    self.node = new_root\n    old_root.left.node = new_left_sub\n    new_root.right.node = old_root\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Rotate the node to the right, i.e. the left child of the current node becomes the parent node, and the current node becomes the right child of the new parent node.\"\"\""}
{"prompt": "def peek(self):\n    if self.is_empty():\n        raise IndexError('Queue is empty')\n    return self._front.value\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturn the value of the item at the front of the queue without removing it from the queue. Raise an IndexError if the queue is empty."}
{"prompt": "def subarray_with_max_product(arr):\n    length = len(arr)\n    product_so_far = max_product_end = 1\n    max_start_i = 0\n    so_far_start_i = so_far_end_i = 0\n    all_negative_flag = True\n    for i in range(length):\n        max_product_end *= arr[i]\n        if arr[i] > 0:\n            all_negative_flag = False\n        if max_product_end <= 0:\n            max_product_end = arr[i]\n            max_start_i = i\n        if product_so_far <= max_product_end:\n            product_so_far = max_product_end\n            so_far_end_i = i\n            so_far_start_i = max_start_i\n    if all_negative_flag:\n        print(f'max_product_so_far: {reduce(lambda x, y: x * y, arr)}, {arr}')\n    else:\n        print(f'max_product_so_far: {product_so_far},{arr[so_far_start_i:so_far_end_i + 1]}')\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function finds the subarray with the maximum product in an array. It prints the maximum product along with the subarray with the maximum product. If all elements in the array are negative, then it prints the product of all elements along with the array."}
{"prompt": "def __init__(self, val=None):\n    self.val = val\n    self.next = None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function is a constructor for a linked list node. It takes an optional argument val and assigns it to the node's value. It also initializes the node's next pointer to None."}
{"prompt": "def __truediv__(self, other: Union[int, float, Fraction, Monomial]):\n    if isinstance(other, int) or isinstance(other, float) or isinstance(other, Fraction):\n        return self.__truediv__(Monomial({}, other))\n    elif isinstance(other, Monomial):\n        poly_temp = reduce(lambda acc, val: acc + val, map(lambda x: x / other, [z for z in self.all_monomials()]), Polynomial([Monomial({}, 0)]))\n        return poly_temp\n    elif isinstance(other, Polynomial):\n        if Monomial({}, 0) in other.all_monomials():\n            if len(other.all_monomials()) == 2:\n                temp_set = {x for x in other.all_monomials() if x != Monomial({}, 0)}\n                only = temp_set.pop()\n                return self.__truediv__(only)\n        elif len(other.all_monomials()) == 1:\n            temp_set = {x for x in other.all_monomials()}\n            only = temp_set.pop()\n            return self.__truediv__(only)\n    raise ValueError('Can only divide a polynomial by an int, float, Fraction, or a Monomial.')\n    return\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function divides a Polynomial by another Polynomial, Fraction, int, or Monomial. Raises a ValueError if the argument is not one of these types."}
{"prompt": "def __init__(self, val, left=None, right=None):\n    self.val = val\n    self.left = left\n    self.right = right\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function is the constructor for a binary tree node. It takes in a value, and two optional parameters, left and right, which represent the left and right children of the node respectively. It sets the value of the node to the input value, and the left and right children to the corresponding parameters."}
{"prompt": "def add(self, element):\n    self.parents[element] = element\n    self.size[element] = 1\n    self.count += 1\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nadd() adds an element to the parents dictionary, sets the size of the element to 1, and increments the count of elements by 1."}
{"prompt": "def valid_one(self, n, kee, update):\n    self.board[kee[0]][kee[1]] = n\n    del self.val[kee]\n    (i, j) = kee\n    for ind in self.val.keys():\n        if n in self.val[ind]:\n            if ind[0] == i or ind[1] == j or (ind[0] / 3, ind[1] / 3) == (i / 3, j / 3):\n                update[ind] = n\n                self.val[ind].remove(n)\n                if len(self.val[ind]) == 0:\n                    return False\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function validates one number in a sudoku board. It takes in self (the sudoku board), n (the number to be validated), kee (the position of the number in the board), and update (a list of all positions with the number removed). It will then check the row, column, and box of the position of the number for other positions with the number, and remove the number from those other positions. It will return False if there are no valid numbers for a position."}
{"prompt": "def misras_gries(array, k=2):\n    keys = {}\n    for i in array:\n        val = str(i)\n        if val in keys:\n            keys[val] = keys[val] + 1\n        elif len(keys) < k - 1:\n            keys[val] = 1\n        else:\n            for key in list(keys):\n                keys[key] = keys[key] - 1\n                if keys[key] == 0:\n                    del keys[key]\n    suspects = keys.keys()\n    frequencies = {}\n    for suspect in suspects:\n        freq = _count_frequency(array, int(suspect))\n        if freq >= len(array) / k:\n            frequencies[suspect] = freq\n    return frequencies if len(frequencies) > 0 else None\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nThis function uses the Misra-Gries algorithm to find suspects in an array of elements. \nIt takes an array and an optional k parameter (defaults to 2). It will iterate through the array and add each element to a keys dictionary, and if the length of the dictionary is more than k-1, it will delete the oldest element in the dictionary. It will then check the frequency of each suspect element in the array and return a dictionary of elements with frequency greater than or equal to len(array)/k. If no such element exists, it will return None."}
{"prompt": "def dfs(self, source, target):\n    visited = [False] * self.vertex_count\n    self.dfsutil(visited, source, target)\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\ndfsutil():\n    Helper function for Depth First Search algorithm.\n    This function is used to recursively traverse the graph,\n    starting from the given source node, and check if the\n    target node can be reached.\n    \n    Parameters:\n    visited (list): List of visited nodes.\n    source (int): Source node.\n    target (int): Target node.\n    \n    Returns:\n    None."}
{"prompt": "def roman_to_int(s: 'str') -> 'int':\n    number = 0\n    roman = {'M': 1000, 'D': 500, 'C': 100, 'L': 50, 'X': 10, 'V': 5, 'I': 1}\n    for i in range(len(s) - 1):\n        if roman[s[i]] < roman[s[i + 1]]:\n            number -= roman[s[i]]\n        else:\n            number += roman[s[i]]\n    return number + roman[s[-1]]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes a Roman numeral string as an argument and returns an integer value. It uses a dictionary to map Roman numerals to their corresponding integer values and adds or subtracts each Roman numeral value within the string to calculate the total integer."}
{"prompt": "def cycle_product_for_two_polynomials(p1: Polynomial, p2: Polynomial, q: Union[float, int, Fraction]) -> Union[float, int, Fraction]:\n    ans = Fraction(0, 1)\n    for m1 in p1.monomials:\n        for m2 in p2.monomials:\n            ans += cycle_product(m1, m2).substitute(q)\n    return ans\n##############\nEND_FUNC\n##############\n", "completion": "\n\nCalculates the cycle product of two polynomials, p1 and p2, with respect to a given substitution q. Returns a float, int, or Fraction."}
{"prompt": "def main():\n    mat = [[2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20]]\n    key = 13\n    print(mat)\n    search_in_a_sorted_matrix(mat, len(mat), len(mat[0]), key)\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\ndef search_in_a_sorted_matrix(mat, m, n, key):\n    \"\"\"\n    Searches for key in a sorted matrix.\n    Args:\n        mat (list): A 2D list of integers.\n        m (int): Number of rows in matrix.\n        n (int): Number of columns in matrix.\n        key (int): The element to be searched.\n    Returns:\n        bool: True if key is present, False otherwise.\n    \"\"\"\n    pass"}
{"prompt": "def __init__(self):\n    self.node = None\n    self.height = -1\n    self.balance = 0\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__() is a constructor method for creating a new node in a tree. It initializes the node to None, sets the height of the node to -1, and sets the balance of the node to 0."}
{"prompt": "def binary_gap_improved(N):\n    last = None\n    ans = 0\n    index = 0\n    while N != 0:\n        tes = N & 1\n        if tes:\n            if last is not None:\n                ans = max(ans, index - last + 1)\n            else:\n                last = index\n        else:\n            last = index + 1\n        index = index + 1\n        N = N >> 1\n    return ans\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function takes in a given number N and returns the longest binary gap (the number of zeros between two ones) in the binary representation of N. The binary gap is calculated by iterating through the binary representation of N, keeping track of the last index of a one and the current index, and comparing the difference between the two indices. The maximum difference is then returned as the binary gap."}
{"prompt": "def hash(self, key):\n    return hash(key) % self.size\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturn the hash value of the given key modulo the size of the hash table."}
{"prompt": "def rotate_left(self):\n    new_root = self.node.right.node\n    new_left_sub = new_root.left.node\n    old_root = self.node\n    self.node = new_root\n    old_root.right.node = new_left_sub\n    new_root.left.node = old_root\n##############\nEND_FUNC\n##############\n", "completion": "\n\nRotates the tree one node to the left. The new root of the tree is the old root's right child, and the old root becomes the left child of the new root."}
{"prompt": "def delete_reoccurring_characters(string):\n    seen_characters = set()\n    output_string = ''\n    for char in string:\n        if char not in seen_characters:\n            seen_characters.add(char)\n            output_string += char\n    return output_string\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes a string as input and removes any reoccurring characters, returning the modified string."}
{"prompt": "def __lt__(self, other):\n    return self.frequency < other.frequency\n##############\nEND_FUNC\n##############\n", "completion": "\n\nCompare two objects based on their frequency attribute. Returns True if self has a lower frequency than other, False otherwise."}
{"prompt": "def reverse_graph(self):\n    reverse_graph = Graph(self.vertex_count)\n    for (source, adjacent) in self.graph.items():\n        for target in adjacent:\n            reverse_graph.add_edge(target, source)\n    return reverse_graph\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCreate a new Graph object with the same vertex count as the current Graph object and reverse the edges of the current Graph object.\n\nReturns:\n    Graph: A new Graph object with the edges of the current Graph reversed."}
{"prompt": "def insert_mult_bits(num, bits, len, i):\n    mask = num >> i\n    mask = mask << len | bits\n    mask = mask << i\n    right = (1 << i) - 1 & num\n    return right | mask\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nInserts a sequence of bits into a number.\n\nParameters:\nnum (int): The number to insert the bits into.\nbits (int): The bits to insert.\nlen (int): The length of the bits to insert.\ni (int): The index of the number to start inserting the bits.\n\nReturns:\nint: The number with the inserted bits.\n\"\"\""}
{"prompt": "def kth_to_last(head, k):\n    if not (head or k > -1):\n        return False\n    p1 = head\n    p2 = head\n    for i in range(1, k + 1):\n        if p1 is None:\n            raise IndexError\n        p1 = p1.next\n    while p1:\n        p1 = p1.next\n        p2 = p2.next\n    return p2\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nFind the kth to last element in a linked list.\n\nParameters:\nhead (Node): The head of the linked list.\nk (int): The kth element from the end of the list.\n\nReturns:\nNode: The kth to last element of the linked list.\nRaises:\nIndexError: If k is greater than the length of the list."}
{"prompt": "def merge_k_lists(lists):\n    dummy = node = ListNode(0)\n    list_h = [(n.val, n) for n in lists if n]\n    heapify(list_h)\n    while list_h:\n        (_, n_val) = list_h[0]\n        if n_val.next is None:\n            heappop(list_h)\n        else:\n            heapreplace(list_h, (n_val.next.val, n_val.next))\n        node.next = n_val\n        node = node.next\n    return dummy.next\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nMerge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.\n\nInput: \nlists: list of sorted linked lists\n\nOutput: \nreturn: single sorted linked list\n\nComplexity: \nTime: O(NlogK) where N is the total number of nodes and K is the number of linked lists.\nSpace: O(K)"}
{"prompt": "def _insert_to_nonfull_node(self, node: Node, key):\n    i = len(node.keys) - 1\n    while i >= 0 and node.keys[i] >= key:\n        i -= 1\n    if node.is_leaf:\n        node.keys.insert(i + 1, key)\n    else:\n        if len(node.children[i + 1].keys) >= self.max_number_of_keys:\n            self._split_child(node, i + 1)\n            if node.keys[i + 1] < key:\n                i += 1\n        self._insert_to_nonfull_node(node.children[i + 1], key)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n_insert_to_nonfull_node(self, node: Node, key):\n    \"\"\"Inserts a key into a non-full node.\n\n    Parameters\n    ----------\n    self : object\n        The object instance.\n    node : Node\n        The node to insert the key into.\n    key : object\n        The key to insert.\n    \"\"\""}
{"prompt": "def DFA(transitions, start, final, string):\n    num = len(string)\n    num_final = len(final)\n    cur = start\n    for i in range(num):\n        if transitions[cur][string[i]] is None:\n            return False\n        else:\n            cur = transitions[cur][string[i]]\n    for i in range(num_final):\n        if cur == final[i]:\n            return True\n    return False\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nThis function checks whether a string is accepted by a given Deterministic Finite Automaton (DFA). It takes in four arguments: \n- transitions: A dictionary representing the transition function of the DFA.\n- start: The starting state of the DFA.\n- final: A list of final states of the DFA.\n- string: The input string to be tested.\n\nIt returns a boolean value indicating whether the string is accepted or not."}
{"prompt": "def prime_check(num):\n    if num <= 1:\n        return False\n    if num == 2 or num == 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    j = 5\n    while j * j <= num:\n        if num % j == 0 or num % (j + 2) == 0:\n            return False\n        j += 6\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nprime_check(num) takes in a number and returns a boolean value. It returns True if the number is prime and False if the number is not prime."}
{"prompt": "def save_tree(self, tree):\n    signs = []\n    tree_code = ''\n\n    def get_code_tree(T):\n        nonlocal tree_code\n        if T.sign is not None:\n            signs.append(T.sign)\n        if T.left:\n            tree_code += '0'\n            get_code_tree(T.left)\n        if T.right:\n            tree_code += '1'\n            get_code_tree(T.right)\n    get_code_tree(tree)\n    self.write_bits(tree_code + '1')\n    for int_sign in signs:\n        self.write_int(int_sign)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nsave_tree(self, tree):\n    \"\"\"Compress a given tree by writing its bits and signs to a file.\n\n    Args:\n        self (object): the instance of the class\n        tree (object): an object representing the tree\n    \"\"\""}
{"prompt": "def diffie_hellman_key_exchange(a, p, option=None):\n    if option is not None:\n        option = 1\n    if prime_check(p) is False:\n        print(f'{p} is not a prime number')\n        return False\n    try:\n        p_root_list = find_primitive_root(p)\n        p_root_list.index(a)\n    except ValueError:\n        print(f'{a} is not a primitive root of {p}')\n        return False\n    a_pr_k = alice_private_key(p)\n    a_pu_k = alice_public_key(a_pr_k, a, p)\n    b_pr_k = bob_private_key(p)\n    b_pu_k = bob_public_key(b_pr_k, a, p)\n    if option == 1:\n        print(f\"Alice's private key: {a_pr_k}\")\n        print(f\"Alice's public key: {a_pu_k}\")\n        print(f\"Bob's private key: {b_pr_k}\")\n        print(f\"Bob's public key: {b_pu_k}\")\n    a_sh_k = alice_shared_key(b_pu_k, a_pr_k, p)\n    b_sh_k = bob_shared_key(a_pu_k, b_pr_k, p)\n    print(f'Shared key calculated by Alice = {a_sh_k}')\n    print(f'Shared key calculated by Bob = {b_sh_k}')\n    return a_sh_k == b_sh_k\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function implements the Diffie-Hellman key exchange algorithm. It takes in three arguments, a (primitive root of p), p (prime number) and an optional argument 'option' (defaulted to None). It checks if p is a prime number and a is a primitive root of p, then generates private and public keys for Alice and Bob. Finally, it calculates the shared key for Alice and Bob and returns True if both shared keys are equal."}
{"prompt": "def count_ones_iter(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCounts the number of 1 bits in the binary representation of a number.\n\nParameters:\n    n (int): The number to count 1 bits of.\n\nReturns:\n    int: The number of 1 bits in the binary representation of n."}
{"prompt": "def _expand(self):\n    self._array += [None] * len(self._array)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function expands the internal array of an instance of the class it belongs to by adding None values to the end of the array."}
{"prompt": "def get_longest_non_repeat_v2(string):\n    if string is None:\n        return (0, '')\n    sub_string = ''\n    (start, max_len) = (0, 0)\n    used_char = {}\n    for (index, char) in enumerate(string):\n        if char in used_char and start <= used_char[char]:\n            start = used_char[char] + 1\n        elif index - start + 1 > max_len:\n            max_len = index - start + 1\n            sub_string = string[start:index + 1]\n        used_char[char] = index\n    return (max_len, sub_string)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function returns a tuple containing the length of the longest non-repeating substring of a given string, as well as the substring itself. If the given string is None, (0, '') is returned. \n\"\"\""}
{"prompt": "def is_reachable(self, source, target):\n    self.has_path = False\n    self.dfs(source, target)\n    return self.has_path\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"Checks if the target is reachable from the source using depth-first search.\""}
{"prompt": "def solve(self):\n    if len(self.val) == 0:\n        return True\n    kee = min(self.val.keys(), key=lambda x: len(self.val[x]))\n    nums = self.val[kee]\n    for n in nums:\n        update = {kee: self.val[kee]}\n        if self.valid_one(n, kee, update):\n            if self.solve():\n                return True\n        self.undo(kee, update)\n    return False\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nSolve the sudoku puzzle by finding a valid number for each cell.\n\nThis function recursively iterates through the puzzle, checking if a valid number can be found for each cell. If it finds a valid number, it calls itself to check the next cell, and if all cells have valid numbers, it returns True. If it cannot find a valid number for the current cell, it undoes any changes it made and returns False."}
{"prompt": "def __repr__(self):\n    return '<id_node: {0}>'.format(self.keys)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function returns a representation of an id_node object as a string. The string consists of the '<id_node: ' prefix followed by the keys of the object."}
{"prompt": "def longest_non_repeat_v1(string):\n    if string is None:\n        return 0\n    dict = {}\n    max_length = 0\n    j = 0\n    for i in range(len(string)):\n        if string[i] in dict:\n            j = max(dict[string[i]], j)\n        dict[string[i]] = i + 1\n        max_length = max(max_length, i - j + 1)\n    return max_length\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nFinds the length of the longest substring without repeating characters in a given string.\n\nParameters:\nstring (str): The string to be evaluated.\n\nReturns:\nint: The length of the longest substring without repeating characters. Returns 0 if string is None.\n\"\"\""}
{"prompt": "def inverse(self):\n    mono = {i: self.variables[i] for i in self.variables if self.variables[i] != 0}\n    for i in mono:\n        mono[i] *= -1\n    if self.coeff == 0:\n        raise ValueError('Coefficient must not be 0.')\n    return Monomial(mono, Monomial._rationalize_if_possible(1 / self.coeff)).clean()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCalculate the inverse of the monomial and return the result as a new Monomial object.\nRaises ValueError if the coefficient of the monomial is 0."}
{"prompt": "def elias_delta(x):\n    return elias_generic(elias_gamma, x)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function uses the elias_gamma function to encode an integer x and returns the resulting encoded string."}
{"prompt": "def remove_key(self, key):\n    self._remove_key(self.root, key)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Remove the given key from the tree.\n\nArgs:\n    key (any): The key to be removed from the tree.\n\nReturns:\n    None\n\"\"\""}
{"prompt": "def construct(self):\n    bit_tree = [0] * (self.n + 1)\n    for i in range(self.n):\n        self.update_bit(bit_tree, i, self.arr[i])\n    return bit_tree\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"Function to construct a Binary Indexed Tree (BIT) from a given array of size 'n'. Creates an array of size 'n+1' with initial values of 0 and updates the values in the BIT using the given array.\""}
{"prompt": "def extended_gcd(num1, num2):\n    (old_s, s) = (1, 0)\n    (old_t, t) = (0, 1)\n    (old_r, r) = (num1, num2)\n    while r != 0:\n        quotient = old_r / r\n        (old_r, r) = (r, old_r - quotient * r)\n        (old_s, s) = (s, old_s - quotient * s)\n        (old_t, t) = (t, old_t - quotient * t)\n    return (old_s, old_t, old_r)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function uses the extended Euclidean algorithm to compute the greatest common divisor of two numbers. It returns a tuple containing the coefficients of the linear combination of the two numbers that yield their gcd.\n\"\"\""}
{"prompt": "def swap(i, j):\n    (arr[i], arr[j]) = (arr[j], arr[i])\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nSwap the elements at indices i and j in the array arr."}
{"prompt": "def swap_pairs(head):\n    if not head:\n        return head\n    start = Node(0)\n    start.next = head\n    current = start\n    while current.next and current.next.next:\n        first = current.next\n        second = current.next.next\n        first.next = second.next\n        current.next = second\n        current.next.next = first\n        current = current.next.next\n    return start.next\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nSwap pairs of nodes in a linked list.\n\nArgs:\n    head (Node): The head of the linked list.\n\nReturns:\n    Node: The head of the linked list with nodes swapped.\n\"\"\""}
{"prompt": "def test_add_two_numbers(self):\n    number1 = Node(2)\n    number1.next = Node(4)\n    number1.next.next = Node(3)\n    number2 = Node(5)\n    number2.next = Node(6)\n    number2.next.next = Node(4)\n    result = convert_to_str(add_two_numbers(number1, number2))\n    self.assertEqual('708', result)\n    number3 = Node(1)\n    number3.next = Node(1)\n    number3.next.next = Node(9)\n    number4 = Node(1)\n    number4.next = Node(0)\n    number4.next.next = Node(1)\n    result = convert_to_str(add_two_numbers(number3, number4))\n    self.assertEqual('2101', result)\n    number5 = Node(1)\n    number6 = Node(0)\n    result = convert_to_str(add_two_numbers(number5, number6))\n    self.assertEqual('1', result)\n    number7 = Node(9)\n    number7.next = Node(1)\n    number7.next.next = Node(1)\n    number8 = Node(1)\n    number8.next = Node(0)\n    number8.next.next = Node(1)\n    result = convert_to_str(add_two_numbers(number7, number8))\n    self.assertEqual('022', result)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function tests the add_two_numbers function using different test cases. It compares the output of the add_two_numbers function to the expected output and asserts if they are equal."}
{"prompt": "def next(self, val):\n    self.queue.append(val)\n    return sum(self.queue) / len(self.queue)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"Calculate and return the average of the values in the queue, after adding the given value to the queue\""}
{"prompt": "def __init__(self, board, row, col):\n    self.board = board\n    self.row = row\n    self.col = col\n    self.val = self.possible_values()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function initializes a cell instance for a Sudoku board. It takes in the entire board, the row and column of the cell, and assigns possible values to the cell based on the board."}
{"prompt": "def strip_url_params2(url, param_to_strip=[]):\n    if '?' not in url:\n        return url\n    queries = url.split('?')[1].split('&')\n    queries_obj = [query[0] for query in queries]\n    for i in range(len(queries_obj) - 1, 0, -1):\n        if queries_obj[i] in param_to_strip or queries_obj[i] in queries_obj[0:i]:\n            queries.pop(i)\n    return url.split('?')[0] + '?' + '&'.join(queries)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nstrip_url_params2(url, param_to_strip=[]):\n    Removes duplicate query parameters and parameters specified in the params_to_strip list from the given URL.\n    Parameters: \n        url (str): The url to strip the parameters from.\n        param_to_strip (list): A list of query parameters to strip from the url. \n    Returns:\n        str: The URL with the specified parameters removed. \n\"\"\""}
{"prompt": "def gnome_sort(arr):\n    n = len(arr)\n    index = 0\n    while index < n:\n        if index == 0 or arr[index] >= arr[index - 1]:\n            index = index + 1\n        else:\n            (arr[index], arr[index - 1]) = (arr[index - 1], arr[index])\n            index = index - 1\n    return arr\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nGnome Sort is a sorting algorithm which is based on the comparison of the elements. It works by iterating the array from left to right and swapping the elements until the array is sorted.\n\nInput: arr - an array of elements to be sorted\n\nOutput: sorted array\n\"\"\""}
{"prompt": "def query(self, l, r):\n    (l, r) = (l + self.size, r + self.size)\n    res = None\n    while l <= r:\n        if l % 2 == 1:\n            res = self.tree[l] if res is None else self.fn(res, self.tree[l])\n        if r % 2 == 0:\n            res = self.tree[r] if res is None else self.fn(res, self.tree[r])\n        (l, r) = ((l + 1) // 2, (r - 1) // 2)\n    return res\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function performs a range query on a segment tree. It takes two parameters, l and r, which represent the left and right bounds of the range, respectively. It returns the result of applying the fn function on the range given."}
{"prompt": "def multiply(matA: list, matB: list) -> list:\n    n = len(matA)\n    matC = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                matC[i][j] += matA[i][k] * matB[k][j]\n    return matC\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nMultiply two matrices of the same size.\n\nParams:\nmatA (list): a two-dimensional matrix of size n \nmatB (list): a two-dimensional matrix of size n\n\nReturns:\nmatC (list): a two-dimensional matrix of size n, which is the product of matA and matB\n\"\"\""}
{"prompt": "def helper_topdown(nums, target):\n    if DP[target] != -1:\n        return DP[target]\n    res = 0\n    for num in nums:\n        if target >= num:\n            res += helper_topdown(nums, target - num)\n    DP[target] = res\n    return res\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nhelper_topdown() takes in two parameters: nums (a list of integers) and target (an integer). It returns the number of possible combinations of the numbers in nums that add up to the target. It uses dynamic programming to store and retrieve the number of combinations for each target value."}
{"prompt": "def optimal_set_cover(universe, subsets, costs):\n    pset = powerset(subsets.keys())\n    best_set = None\n    best_cost = float('inf')\n    for subset in pset:\n        covered = set()\n        cost = 0\n        for s in subset:\n            covered.update(subsets[s])\n            cost += costs[s]\n        if len(covered) == len(universe) and cost < best_cost:\n            best_set = subset\n            best_cost = cost\n    return best_set\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function finds the optimal set cover of a given universe using a powerset of subsets and their associated costs. It returns the best set with the lowest cost."}
{"prompt": "def is_symmetric_iterative(root):\n    if root is None:\n        return True\n    stack = [[root.left, root.right]]\n    while stack:\n        (left, right) = stack.pop()\n        if left is None and right is None:\n            continue\n        if left is None or right is None:\n            return False\n        if left.val == right.val:\n            stack.append([left.left, right.right])\n            stack.append([left.right, right.left])\n        else:\n            return False\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function checks if a binary tree is symmetric. It uses an iterative approach to traverse the tree. It takes in the root node of the tree and returns a boolean value. If the tree is symmetric, it returns True, else it returns False."}
{"prompt": "def __init__(self, tree):\n    self.root = tree\n    self.current_node = tree\n    self.found = None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__(self, tree)\n\nInitializes a TreeWalker object with a given tree.\n\nParameters:\ntree (object): The root node of the tree to be traversed.\n\nAttributes:\nroot (object): The root node of the tree to be traversed.\ncurrent_node (object): The current node being traversed.\nfound (object): An additional attribute to store the result of a search operation.\n\"\"\""}
{"prompt": "def get_factors(n):\n\n    def factor(n, i, combi, res):\n        while i * i <= n:\n            if n % i == 0:\n                res += (combi + [i, int(n / i)],)\n                factor(n / i, i, combi + [i], res)\n            i += 1\n        return res\n    return factor(n, 2, [], [])\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function returns all the possible combinations of factors of a given number. It takes in an integer as an argument and returns a list of combinations of factors of that number as a tuple."}
{"prompt": "def __contains__(self, item):\n    if self.start >= item >= self.end:\n        return True\n    return False\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCheck if an item is within the range of the given start and end values.\n\nReturns:\n    True if the item is within the range of the start and end values. False if not."}
{"prompt": "def rotate_counterclockwise(matrix):\n    new = []\n    for row in matrix:\n        for (i, elem) in enumerate(reversed(row)):\n            try:\n                new[i].append(elem)\n            except IndexError:\n                new.insert(i, [])\n                new[i].append(elem)\n    return new\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nRotates the given matrix counterclockwise and returns the resulting matrix.\n\"\"\""}
{"prompt": "def is_valid_coordinates_0(coordinates):\n    for char in coordinates:\n        if not (char.isdigit() or char in ['-', '.', ',', ' ']):\n            return False\n    l = coordinates.split(', ')\n    if len(l) != 2:\n        return False\n    try:\n        latitude = float(l[0])\n        longitude = float(l[1])\n    except:\n        return False\n    return -90 <= latitude <= 90 and -180 <= longitude <= 180\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nChecks if given coordinates are valid coordinates.\n\nParameters:\n    coordinates (str): A string representing coordinates in the form of 'latitude, longitude'.\n\nReturns:\n    bool: True if the coordinates are valid and False if not.\n\"\"\""}
{"prompt": "def __str__(self):\n    resp = ''\n    for i in range(self.row):\n        for j in range(self.col):\n            resp += ' {0} '.format(self.board[i][j])\n        resp += '\\n'\n    return resp\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function prints out the contents of a board object as a string. It iterates through each row and column in the board, and appends each element as a string to the response string. The response string is then returned."}
{"prompt": "def __init__(self, size=11):\n    self.size = size\n    self._len = 0\n    self._keys = [self._empty] * size\n    self._values = [self._empty] * size\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\n__init__(self, size=11) initializes a hash table with the given size. It sets the length of the hash table to 0, and creates two lists of the same size to store the keys and values. The default size is 11."}
{"prompt": "def is_empty(self):\n    return self.items == []\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturn True if the list is empty, False otherwise."}
{"prompt": "def helper(root, maximum):\n    if root is None:\n        return 0\n    left = helper(root.left, maximum)\n    right = helper(root.right, maximum)\n    maximum = max(maximum, left + right + root.val)\n    return root.val + maximum\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\n\nHelper function to find the maximum sum of a path in a binary tree.\n\nParameters:\nroot (Node): The root node of the binary tree.\nmaximum (int): The current maximum sum of the path.\n\nReturns:\nint: The new maximum sum of the path."}
{"prompt": "def __init__(self):\n    self._top = -1\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function is a constructor for a class. It initializes the instance variable \"_top\" to -1."}
{"prompt": "def count_islands(grid):\n    row = len(grid)\n    col = len(grid[0])\n    num_islands = 0\n    visited = [[0] * col for i in range(row)]\n    directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n    queue = []\n    for i in range(row):\n        for (j, num) in enumerate(grid[i]):\n            if num == 1 and visited[i][j] != 1:\n                visited[i][j] = 1\n                queue.append((i, j))\n                while queue:\n                    (x, y) = queue.pop(0)\n                    for k in range(len(directions)):\n                        nx_x = x + directions[k][0]\n                        nx_y = y + directions[k][1]\n                        if nx_x >= 0 and nx_y >= 0 and (nx_x < row) and (nx_y < col):\n                            if visited[nx_x][nx_y] != 1 and grid[nx_x][nx_y] == 1:\n                                queue.append((nx_x, nx_y))\n                                visited[nx_x][nx_y] = 1\n                num_islands += 1\n    return num_islands\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes a grid of 0s and 1s (representing land and water) and finds the number of islands in the grid. The function uses a BFS approach to traverse the grid and count the number of islands. \n\"\"\""}
{"prompt": "def get_primes(n):\n    if n <= 0:\n        raise ValueError(\"'n' must be a positive integer.\")\n    sieve_size = n // 2 - 1 if n % 2 == 0 else n // 2\n    sieve = [True for _ in range(sieve_size)]\n    primes = []\n    if n >= 2:\n        primes.append(2)\n    for i in range(sieve_size):\n        if sieve[i]:\n            value_at_i = i * 2 + 3\n            primes.append(value_at_i)\n            for j in range(i, sieve_size, value_at_i):\n                sieve[j] = False\n    return primes\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nget_primes(n) returns a list of prime numbers up to the given positive integer 'n'. Raises ValueError if 'n' is 0 or negative."}
{"prompt": "def selection_sort(arr, simulation=False):\n    iteration = 0\n    if simulation:\n        print('iteration', iteration, ':', *arr)\n    for i in range(len(arr)):\n        minimum = i\n        for j in range(i + 1, len(arr)):\n            if arr[j] < arr[minimum]:\n                minimum = j\n        (arr[minimum], arr[i]) = (arr[i], arr[minimum])\n        if simulation:\n            iteration = iteration + 1\n            print('iteration', iteration, ':', *arr)\n    return arr\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nselection_sort(arr, simulation=False) -> sorted array\n\nSorts an array 'arr' using selection sort. If the optional argument 'simulation' is set to True, it prints out the iterations of the sorting process.\n\"\"\""}
{"prompt": "def quick_sort(arr, simulation=False):\n    iteration = 0\n    if simulation:\n        print('iteration', iteration, ':', *arr)\n    (arr, _) = quick_sort_recur(arr, 0, len(arr) - 1, iteration, simulation)\n    return arr\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function implements the quick sort algorithm. It takes an array 'arr' as input and an optional boolean parameter 'simulation' to indicate whether the sorting process should be printed. It then calls the quick_sort_recur function to recursively sort the array and returns the sorted array."}
{"prompt": "def test_convert_to_str(self):\n    number1 = Node(2)\n    number1.next = Node(4)\n    number1.next.next = Node(3)\n    self.assertEqual('243', convert_to_str(number1))\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"Convert a linked list of numbers to a string representation of the numbers.\"\"\""}
{"prompt": "def bin_tree_to_list_util(root):\n    if not root:\n        return root\n    if root.left:\n        left = bin_tree_to_list_util(root.left)\n        while left.right:\n            left = left.right\n        left.right = root\n        root.left = left\n    if root.right:\n        right = bin_tree_to_list_util(root.right)\n        while right.left:\n            right = right.left\n        right.left = root\n        root.right = right\n    return root\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function converts a binary tree to a doubly linked list. It recursively traverses through the tree and sets the left and right pointers to the previous and next nodes respectively. It returns the root of the doubly linked list."}
{"prompt": "def add_pair(res, s, left, right):\n    if left == 0 and right == 0:\n        res.append(s)\n        return\n    if right > 0:\n        add_pair(res, s + ')', left, right - 1)\n    if left > 0:\n        add_pair(res, s + '(', left - 1, right + 1)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function adds a pair of parentheses to a given string 's'. The parameters 'left' and 'right' represent the number of left/right parentheses left to be added. The results are appended to the list 'res'."}
{"prompt": "def __init__(self, val=0):\n    self.val = val\n    self.left = None\n    self.right = None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__(self, val=0) is a constructor method for creating a new Binary Tree Node object. \nIt initializes the node with the given value and sets the left and right child of the node to None."}
{"prompt": "def add_two_numbers(left: Node, right: Node) -> Node:\n    head = Node(0)\n    current = head\n    sum = 0\n    while left or right:\n        print('adding: ', left.val, right.val)\n        sum //= 10\n        if left:\n            sum += left.val\n            left = left.next\n        if right:\n            sum += right.val\n            right = right.next\n        current.next = Node(sum % 10)\n        current = current.next\n    if sum // 10 == 1:\n        current.next = Node(1)\n    return head.next\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes two linked list nodes as inputs and returns a linked list node. It iterates through the two given linked list nodes, adds their values together, and returns a new linked list node with the sum of the two inputs. The new linked list node contains the sum of each pair of values from the two given linked list nodes."}
{"prompt": "def __test_simple():\n    print(dot_product(vector_to_index_value_list([1.0, 2.0, 3.0]), vector_to_index_value_list([0.0, 2.0, 2.0])))\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"Calculates the dot product of two vectors represented as a list of index-value pairs and prints the result.\"\"\""}
{"prompt": "def interpolation_search(array: List[int], search_key: int) -> int:\n    high = len(array) - 1\n    low = 0\n    while low <= high and array[low] <= search_key <= array[high]:\n        pos = low + int((search_key - array[low]) * (high - low) / (array[high] - array[low]))\n        if array[pos] == search_key:\n            return pos\n        if array[pos] < search_key:\n            low = pos + 1\n        else:\n            high = pos - 1\n    return -1\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\ninterpolation_search(array, search_key) -> int\n\nSearches for 'search_key' in a sorted array 'array' using interpolation search algorithm.\nReturns the index of the search_key in the array if found, otherwise returns -1.\n\"\"\""}
{"prompt": "def __iter__(self):\n    probe = self.head\n    while True:\n        if probe is None:\n            return\n        yield probe.value\n        probe = probe.next\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__iter__(self)\n\nReturns an iterator object used to iterate over the elements of the linked list. \nYields the value of each element in the linked list, starting from the head, until reaching a None element."}
{"prompt": "def is_palindrome(head):\n    if not head:\n        return True\n    (fast, slow) = (head.next, head)\n    while fast and fast.next:\n        fast = fast.next.next\n        slow = slow.next\n    second = slow.next\n    slow.next = None\n    node = None\n    while second:\n        nxt = second.next\n        second.next = node\n        node = second\n        second = nxt\n    while node:\n        if node.val != head.val:\n            return False\n        node = node.next\n        head = head.next\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes in a head node of a linked list and returns whether the linked list is a palindrome. A palindrome is a sequence of characters that reads the same backward and forward. \n\"\"\""}
{"prompt": "def modular_inverse(a: int, m: int) -> int:\n    (s, _, g) = extended_gcd(a, m)\n    if g != 1:\n        raise ValueError('a and m must be coprime')\n    return s % m\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCalculates the modular inverse of a given number 'a' modulo 'm'. Raises a 'ValueError' if 'a' and 'm' are not coprime.\n\"\"\""}
{"prompt": "def is_valid_coordinates_1(coordinates):\n    try:\n        (lat, lng) = [abs(float(c)) for c in coordinates.split(',') if 'e' not in c]\n    except ValueError:\n        return False\n    return lat <= 90 and lng <= 180\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nChecks if a string is a valid set of coordinates.\n\nParameters:\n    coordinates (str): A string representing a set of coordinates.\n\nReturns:\n    bool: Whether or not the coordinates are valid."}
{"prompt": "def test_height(self):\n    self.assertEqual(4, height(self.tree.root))\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function tests whether the given tree's root node has a height of 4."}
{"prompt": "def __le__(self, obj):\n    return self.name <= self.get_name(obj)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nCompare two objects based on their names. Returns True if the name of the object is less than or equal to the name of the other object, False otherwise."}
{"prompt": "def kth_smallest(root, k):\n    stack = []\n    while root or stack:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        k -= 1\n        if k == 0:\n            break\n        root = root.right\n    return root.val\n##############\nEND_FUNC\n##############\n", "completion": "\nThis function finds the kth smallest element in a given binary search tree. It uses an inorder traversal of the tree, keeping track of the current element's index in the traversal. When the index reaches k, the function returns the value of the current element."}
{"prompt": "def find_missing_number2(nums):\n    num_sum = sum(nums)\n    n = len(nums)\n    total_sum = n * (n + 1) // 2\n    missing = total_sum - num_sum\n    return missing\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes in a list of numbers and returns the missing number in the sequence. It does this by calculating the total sum of all numbers in the sequence, subtracting the sum of the numbers in the list from it, and returning the difference."}
{"prompt": "def shortest_distance(grid):\n    if not grid or not grid[0]:\n        return -1\n    matrix = [[[0, 0] for i in range(len(grid[0]))] for j in range(len(grid))]\n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                bfs(grid, matrix, i, j, count)\n                count += 1\n    res = float('inf')\n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            if matrix[i][j][1] == count:\n                res = min(res, matrix[i][j][0])\n    return res if res != float('inf') else -1\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function finds the shortest distance between all the 1s in a given grid. It uses Breadth First Search (BFS) to traverse the grid and keep track of the minimum distance from one 1 to another. It returns -1 if there are no 1s in the grid or if the distance is infinite."}
{"prompt": "def __init__(self, arr, function):\n    self.tree = [None for _ in range(len(arr))] + arr\n    self.size = len(arr)\n    self.fn = function\n    self.build_tree()\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\n__init__(self, arr, function)\n    Initialize a new Segment Tree object with an array of values (arr)\n    and a function (function) that will be used to combine the values.\n    The tree will be built to reflect the array and the function.\n\"\"\""}
{"prompt": "def __eq__(self, other) -> bool:\n    if isinstance(other, int) or isinstance(other, float) or isinstance(other, Fraction):\n        other_poly = Polynomial([Monomial({}, other)])\n        return self.__eq__(other_poly)\n    elif isinstance(other, Monomial):\n        return self.__eq__(Polynomial([other]))\n    elif isinstance(other, Polynomial):\n        return self.all_monomials() == other.all_monomials()\n    else:\n        raise ValueError('Can only compare a polynomial with an int, float, Fraction, Monomial, or another Polynomial.')\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"Compares a Polynomial with an int, float, Fraction, Monomial, or another Polynomial and returns a boolean indicating if they are equal.\""}
{"prompt": "def top_sort(graph):\n    (order, enter, state) = ([], set(graph), {})\n\n    def is_ready(node):\n        lst = graph.get(node, ())\n        if len(lst) == 0:\n            return True\n        for k in lst:\n            sk = state.get(k, None)\n            if sk == GRAY:\n                raise ValueError('cycle')\n            if sk != BLACK:\n                return False\n        return True\n    while enter:\n        node = enter.pop()\n        stack = []\n        while True:\n            state[node] = GRAY\n            stack.append(node)\n            for k in graph.get(node, ()):\n                sk = state.get(k, None)\n                if sk == GRAY:\n                    raise ValueError('cycle')\n                if sk == BLACK:\n                    continue\n                enter.discard(k)\n                stack.append(k)\n            while stack and is_ready(stack[-1]):\n                node = stack.pop()\n                order.append(node)\n                state[node] = BLACK\n            if len(stack) == 0:\n                break\n            node = stack.pop()\n    return order\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function performs topological sorting on a given graph. It takes a graph as its argument and returns a list of nodes in the graph in topological order. It raises a ValueError if it finds a cycle in the graph."}
{"prompt": "def subsets_unique(nums):\n\n    def backtrack(res, nums, stack, pos):\n        if pos == len(nums):\n            res.add(tuple(stack))\n        else:\n            stack.append(nums[pos])\n            backtrack(res, nums, stack, pos + 1)\n            stack.pop()\n            backtrack(res, nums, stack, pos + 1)\n    res = set()\n    backtrack(res, nums, [], 0)\n    return list(res)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function finds all unique subsets of an array of numbers. It uses a backtracking algorithm to generate the subsets and add them to a set. The function then returns a list of all the unique subsets."}
{"prompt": "def reverse(array, i, j):\n    while i < j:\n        (array[i], array[j]) = (array[j], array[i])\n        i += 1\n        j -= 1\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReverse the elements in an array between the given indices (i, j).\n\nParameters:\narray (list): The array to reverse.\ni (int): The start index of the range to be reversed.\nj (int): The end index of the range to be reversed.\n\nReturns:\nNone\n\"\"\""}
{"prompt": "def num_islands(grid):\n    count = 0\n    for i in range(len(grid)):\n        for (j, col) in enumerate(grid[i]):\n            if col == 1:\n                dfs(grid, i, j)\n                count += 1\n    return count\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nThis function counts the number of islands in a given grid of numerical values. It uses Depth-First Search (DFS) to traverse the grid and identify which cells contain an island. It returns the total number of islands found."}
{"prompt": "def convert_to_str(l: Node) -> str:\n    result = ''\n    while l:\n        result += str(l.val)\n        l = l.next\n    return result\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nconvert_to_str() takes a Node object l as an argument and returns a string made up of the values of each node in the linked list."}
{"prompt": "def modinv(a, m):\n    b = 1\n    while not a * b % m == 1:\n        b += 1\n    return b\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nmodinv(a, m)\n\nCalculate the modular inverse of a modulo m.\n\nParameters:\n    a (int): The number to calculate the modular inverse for.\n    m (int): The modulus.\n\nReturns:\n    int: The modular inverse of a modulo m.\n\"\"\""}
{"prompt": "def setUp(self):\n    self.tree = bst()\n    self.tree.insert(9)\n    self.tree.insert(6)\n    self.tree.insert(12)\n    self.tree.insert(3)\n    self.tree.insert(8)\n    self.tree.insert(10)\n    self.tree.insert(15)\n    self.tree.insert(7)\n    self.tree.insert(18)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"Set up a binary search tree with 9, 6, 12, 3, 8, 10, 15, 7, and 18 as initial values.\""}
{"prompt": "def __init__(self, start=0, end=0):\n    self.start = start\n    self.end = end\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nInitialize a new instance of the class with start and end values.\n\nArgs:\n    start (int): Start value of the instance.\n    end (int): End value of the instance."}
{"prompt": "def min_heapify(arr, start, simulation, iteration):\n    end = len(arr) - 1\n    last_parent = (end - start - 1) // 2\n    for parent in range(last_parent, -1, -1):\n        current_parent = parent\n        while current_parent <= last_parent:\n            child = 2 * current_parent + 1\n            if child + 1 <= end - start and arr[child + start] > arr[child + 1 + start]:\n                child = child + 1\n            if arr[child + start] < arr[current_parent + start]:\n                (arr[current_parent + start], arr[child + start]) = (arr[child + start], arr[current_parent + start])\n                current_parent = child\n                if simulation:\n                    iteration = iteration + 1\n                    print('iteration', iteration, ':', *arr)\n            else:\n                break\n    return iteration\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function rearranges items in an array to form a min-heap. It takes in an array as `arr`, a starting index as `start`, a boolean `simulation` value to determine if this function will be run as a simulation, and an `iteration` value. It returns an updated `iteration` value. If the `simulation` value is `True`, each iteration is printed."}
{"prompt": "def merge_intervals(intervals):\n    if intervals is None:\n        return None\n    intervals.sort(key=lambda i: i[0])\n    out = [intervals.pop(0)]\n    for i in intervals:\n        if out[-1][-1] >= i[0]:\n            out[-1][-1] = max(out[-1][-1], i[-1])\n        else:\n            out.append(i)\n    return out\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes in a list of intervals (represented as tuples of two integers) and merges any overlapping intervals. It returns a list of the merged intervals."}
{"prompt": "def is_palindrome_reverse(s):\n    s = remove_punctuation(s)\n    if s == string_reverse(s):\n        return True\n    return False\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"Checks if a string is a palindrome by reversing it and comparing it to the original. Punctuation is removed first.\""}
{"prompt": "def find_next_square(sq):\n    root = sq ** 0.5\n    if root.is_integer():\n        return (root + 1) ** 2\n    return -1\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nfind_next_square(sq)\n\nReturns the next square if sq is a perfect square, -1 otherwise.\nsq: int, a perfect square number\n\"\"\""}
{"prompt": "def add_edge(self, source, target):\n    if source in self.graph:\n        self.graph[source].append(target)\n    else:\n        self.graph[source] = [target]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function adds an edge between a source and target node in a graph. If the source node already exists in the graph, the target node is appended to the list of nodes connected to it. Otherwise, the source node is added to the graph with the target node connected to it."}
{"prompt": "def deserialize(data):\n\n    def build_tree():\n        val = next(vals)\n        if val == '#':\n            return None\n        node = TreeNode(int(val))\n        node.left = build_tree()\n        node.right = build_tree()\n        return node\n    vals = iter(data.split())\n    return build_tree()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\ndeserialize(data) takes in a serialized tree data and returns the corresponding binary tree. The serialized data is a preorder traversal of the tree, where '#' is used to denote the absence of a child node."}
{"prompt": "def __setitem__(self, key, value):\n    self.put(key, value)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nSet the value at the given key in the dictionary. If the key does not exist, a new entry is created."}
{"prompt": "def hailstone(n):\n    sequence = [n]\n    while n > 1:\n        if n % 2 != 0:\n            n = 3 * n + 1\n        else:\n            n = int(n / 2)\n        sequence.append(n)\n    return sequence\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes an integer as input and produces a list of integers that are the result of the Hailstone sequence. The sequence starts with the input number and continues until it reaches 1. If the number is even, it is divided by 2, and if it is odd, it is multiplied by 3 and then 1 is added.\n\n\"\"\""}
{"prompt": "def __floordiv__(self, other: Union[int, float, Fraction]):\n    return self.__truediv__(other)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nFloordivide self by other and return the result.\n\nArgs:\n    other (Union[int, float, Fraction]): The number to divide self by.\n\nReturns:\n    The result of the floor division.\n\"\"\""}
{"prompt": "def __eq__(self, obj):\n    if isinstance(obj, DirectedEdge):\n        return obj.source == self.source and obj.target == self.target\n    return False\n##############\nEND_FUNC\n##############\n", "completion": "\n\nCompare two DirectedEdge objects for equality.\nReturns True if the source and target of the two objects are equal, False otherwise."}
{"prompt": "def power_recur(a: int, n: int, mod: int=None):\n    if n == 0:\n        ans = 1\n    elif n == 1:\n        ans = a\n    else:\n        ans = power_recur(a, n // 2, mod)\n        ans = ans * ans\n        if n % 2:\n            ans = ans * a\n    if mod:\n        ans %= mod\n    return ans\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nComputes a raised to the power of n (a^n) recursively, and optionally modulo mod. \nIf mod is not specified, the result will not be modulo anything.\n\"\"\""}
{"prompt": "def _save_information_about_additional_bits(self, additional_bits: int):\n    self.file.seek(0)\n    first_byte_raw = self.file.read(1)\n    self.file.seek(0)\n    first_byte = '{0:08b}'.format(int.from_bytes(first_byte_raw, 'big'))\n    first_byte = first_byte[3:]\n    first_byte = '{0:03b}'.format(additional_bits) + first_byte\n    self.write_bits(first_byte)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Save information about additional bits to the file.\n\nParameters\n----------\nadditional_bits : int\n    Number of additional bits.\n\n\"\"\""}
{"prompt": "def get_determinant(m):\n    if len(m) == 2:\n        return m[0][0] * m[1][1] - m[0][1] * m[1][0]\n    else:\n        sign = 1\n        det = 0\n        for i in range(len(m)):\n            det += sign * m[0][i] * get_determinant(get_minor(m, 0, i))\n            sign *= -1\n        return det\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCalculate the determinant of a given matrix.\n\nParameters:\nm (list): The matrix to calculate the determinant of.\n\nReturns:\nint: The determinant of the given matrix.\n\"\"\""}
{"prompt": "def pow2_factor(num):\n    power = 0\n    while num % 2 == 0:\n        num /= 2\n        power += 1\n    return (power, num)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\npow2_factor(num) takes a number as an argument and returns a tuple containing the power of two and the number after dividing it by two as many times as possible."}
{"prompt": "def __init__(self):\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__() is the initializer method for a class. It is called when an instance of the class is created and sets up the attributes of the instance."}
{"prompt": "def plus_one_v3(num_arr):\n    for idx in reversed(list(enumerate(num_arr))):\n        num_arr[idx[0]] = (num_arr[idx[0]] + 1) % 10\n        if num_arr[idx[0]]:\n            return num_arr\n    return [1] + num_arr\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"plus_one_v3\" takes in an array of numbers and increases the number by one. It will loop through the array in reverse, adding one to each number and setting it to its remainder when divided by 10. If the number is not 0, it will return the array. If the number is 0, it will return an array with a 1 added to the front."}
{"prompt": "def matrix_chain_order(array):\n    n = len(array)\n    matrix = [[0 for x in range(n)] for x in range(n)]\n    sol = [[0 for x in range(n)] for x in range(n)]\n    for chain_length in range(2, n):\n        for a in range(1, n - chain_length + 1):\n            b = a + chain_length - 1\n            matrix[a][b] = INF\n            for c in range(a, b):\n                cost = matrix[a][c] + matrix[c + 1][b] + array[a - 1] * array[c] * array[b]\n                if cost < matrix[a][b]:\n                    matrix[a][b] = cost\n                    sol[a][b] = c\n    return (matrix, sol)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes in an array as an argument and implements the matrix chain order algorithm. It returns a tuple containing a matrix and a solution matrix. The matrix contains the costs of the optimal solutions for each subproblem and the solution matrix contains the optimal solution for each subproblem."}
{"prompt": "def test_convert_to_list(self):\n    result = convert_to_str(convert_to_list(112))\n    self.assertEqual('211', result)\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nTest that the convert_to_list() function correctly converts an int to a list and back to the original int."}
{"prompt": "def get_connected(vertex, old_set):\n    new_set = set()\n    for neighbor in edges[str(vertex)]:\n        if neighbor in old_set:\n            new_set.add(neighbor)\n    return new_set\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function returns a set of all the neighbors of a given vertex (vertex) in a graph (edges) that are in a given set of vertices (old_set)."}
{"prompt": "def letter_combinations(digits):\n    if digits == '':\n        return []\n    kmaps = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n    ans = ['']\n    for num in digits:\n        tmp = []\n        for an in ans:\n            for char in kmaps[num]:\n                tmp.append(an + char)\n        ans = tmp\n    return ans\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes a string of digits as an argument and returns a list of all possible letter combinations that the digits could represent."}
{"prompt": "def __init__(self, start, finish, profit):\n    self.start = start\n    self.finish = finish\n    self.profit = profit\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function is used to initialize a new instance of an object. It takes three parameters: start, finish, and profit, and assigns them to the new instance of the object."}
{"prompt": "def repeat_string(A, B):\n    count = 1\n    tmp = A\n    max_count = len(B) / len(A) + 1\n    while not B in tmp:\n        tmp = tmp + A\n        if count > max_count:\n            count = -1\n            break\n        count = count + 1\n    return count\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function returns the number of times a given string A must be repeated in order to form the string B. If A cannot be repeated enough times to form B, the return value is -1."}
{"prompt": "def bottom_left_invert(matrix):\n    new = []\n    for row in reversed(matrix):\n        for (i, elem) in enumerate(reversed(row)):\n            try:\n                new[i].append(elem)\n            except IndexError:\n                new.insert(i, [])\n                new[i].append(elem)\n    return new\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nbottom_left_invert(matrix)\n\nReverses and inverts the order of a given matrix.\nFor a given matrix, returns a new matrix with the elements in the bottom left corner of the original matrix first, in reverse order.\n\nArgs:\n    matrix (list): A list of lists containing numerical values\n\nReturns:\n    new (list): A new matrix with the elements from the bottom left corner of the original matrix first, in reverse order\n\"\"\""}
{"prompt": "def euler_totient(n):\n    result = n\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            while n % i == 0:\n                n //= i\n            result -= result // i\n    if n > 1:\n        result -= result // n\n    return result\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function computes the Euler totient of a given number. The Euler totient of a number is the number of integers from 1 to n that are relatively prime to n."}
{"prompt": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    while gap > 0:\n        y_index = gap\n        while y_index < len(arr):\n            y = arr[y_index]\n            x_index = y_index - gap\n            while x_index >= 0 and y < arr[x_index]:\n                arr[x_index + gap] = arr[x_index]\n                x_index = x_index - gap\n            arr[x_index + gap] = y\n            y_index = y_index + 1\n        gap = gap // 2\n    return arr\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nSort an array of elements using Shell Sort algorithm.\n\nParameters:\narr (list): List of elements to be sorted.\n\nReturns:\nlist: Sorted list of elements.\n\"\"\""}
{"prompt": "def right_rotate(self, node):\n    left_node = node.left\n    if left_node is None:\n        return\n    else:\n        node.left = left_node.right\n        if left_node.right is not None:\n            left_node.right.parent = node\n        left_node.parent = node.parent\n        if node.parent is None:\n            self.root = left_node\n        elif node is node.parent.left:\n            node.parent.left = left_node\n        else:\n            node.parent.right = left_node\n        left_node.right = node\n        node.parent = left_node\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function performs a right rotation on a given node in a binary search tree. It updates the node and its parent's left/right references in order to preserve the order of the tree."}
{"prompt": "@abstractmethod\ndef peek(self):\n    pass\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\npeek() is an abstract method whose purpose is to be overridden by a subclass. It does not have any implementation."}
{"prompt": "def __gt__(self, other):\n    return self.frequency > other.frequency\n##############\nEND_FUNC\n##############\n", "completion": "\n\nCompare two objects based on frequency attribute: return True if the frequency of the first object is greater than the frequency of the second object, False otherwise."}
{"prompt": "def egg_drop(n, k):\n    egg_floor = [[0 for _ in range(k + 1)] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        egg_floor[i][1] = 1\n        egg_floor[i][0] = 0\n    for j in range(1, k + 1):\n        egg_floor[1][j] = j\n    for i in range(2, n + 1):\n        for j in range(2, k + 1):\n            egg_floor[i][j] = INT_MAX\n            for x in range(1, j + 1):\n                res = 1 + max(egg_floor[i - 1][x - 1], egg_floor[i][j - x])\n                if res < egg_floor[i][j]:\n                    egg_floor[i][j] = res\n    return egg_floor[n][k]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\negg_drop is a function that takes two parameters: n and k. The function implements a dynamic programming approach to solve the Egg Dropping Puzzle. It returns the minimum number of attempts required to find the critical floor given n eggs and k floors."}
{"prompt": "def __repr__(self):\n    return 'PriorityQueue({!r})'.format(self.priority_queue_list)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturn a string representation of the PriorityQueue object."}
{"prompt": "def cycle_product(m1: Monomial, m2: Monomial) -> Monomial:\n    assert isinstance(m1, Monomial) and isinstance(m2, Monomial)\n    A = m1.variables\n    B = m2.variables\n    result_variables = dict()\n    for i in A:\n        for j in B:\n            k = lcm(i, j)\n            g = i * j // k\n            if k in result_variables:\n                result_variables[k] += A[i] * B[j] * g\n            else:\n                result_variables[k] = A[i] * B[j] * g\n    return Monomial(result_variables, Fraction(m1.coeff * m2.coeff, 1))\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function takes two Monomial objects, m1 and m2, as arguments and returns a new Monomial object. It calculates the product of the two input Monomials and gives a Monomial object with the variables and their coefficients as a result. The coefficients are calculated using the least common multiple of the variables in the two Monomials."}
{"prompt": "def __init__(self, size):\n    self.parent = [None] * size\n    self.size = [1] * size\n    for i in range(size):\n        self.parent[i] = i\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function initializes a union-find data structure, which can be used to track when nodes are connected in a network. It takes in a size parameter, which represents the number of elements in the network, and initializes an array of parents and sizes for each node. The parent of each node is set to itself, and the size of each node is set to 1."}
{"prompt": "def test_3x4(self):\n    grid1 = [['0', 'E', '0', '0'], ['E', '0', 'W', 'E'], ['0', 'E', '0', '0']]\n    self.assertEqual(3, max_killed_enemies(grid1))\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"This function tests that the maximum number of enemies killed by a single bomb in the given grid is 3.\"\"\""}
{"prompt": "def is_same_tree(tree_p, tree_q):\n    if tree_p is None and tree_q is None:\n        return True\n    if tree_p is not None and tree_q is not None and (tree_p.val == tree_q.val):\n        return is_same_tree(tree_p.left, tree_q.left) and is_same_tree(tree_p.right, tree_q.right)\n    return False\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"Determine if two binary trees are the same. Returns true if they are, false if they are not.\""}
{"prompt": "def planting_trees(trees, length, width):\n    trees = [0] + trees\n    n_pairs = int(len(trees) / 2)\n    space_between_pairs = length / (n_pairs - 1)\n    target_locations = [location * space_between_pairs for location in range(n_pairs)]\n    cmatrix = [[0 for _ in range(n_pairs + 1)] for _ in range(n_pairs + 1)]\n    for r_i in range(1, n_pairs + 1):\n        cmatrix[r_i][0] = cmatrix[r_i - 1][0] + sqrt(width + abs(trees[r_i] - target_locations[r_i - 1]) ** 2)\n    for l_i in range(1, n_pairs + 1):\n        cmatrix[0][l_i] = cmatrix[0][l_i - 1] + abs(trees[l_i] - target_locations[l_i - 1])\n    for r_i in range(1, n_pairs + 1):\n        for l_i in range(1, n_pairs + 1):\n            cmatrix[r_i][l_i] = min(cmatrix[r_i - 1][l_i] + sqrt(width + (trees[l_i + r_i] - target_locations[r_i - 1]) ** 2), cmatrix[r_i][l_i - 1] + abs(trees[l_i + r_i] - target_locations[l_i - 1]))\n    return cmatrix[n_pairs][n_pairs]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"Calculates the minimum amount of energy required to plant a given sequence of trees in a given rectangular area of length and width\""}
{"prompt": "def binary_gap(N):\n    last = None\n    ans = 0\n    index = 0\n    while N != 0:\n        if N & 1:\n            if last is not None:\n                ans = max(ans, index - last)\n            last = index\n        index = index + 1\n        N = N >> 1\n    return ans\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nbinary_gap(N)\n\nReturns the longest binary gap of the binary representation of the given number N. A binary gap is the maximum number of consecutive 0s in between two 1s in the binary representation of a number."}
{"prompt": "@abstractmethod\ndef insert(self, val):\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Insert a new value into the data structure.\n\nArgs:\n    val (any): The value to be inserted.\n\nReturns:\n    None\n\"\"\""}
{"prompt": "def merge_two_list_recur(l1, l2):\n    if not l1 or not l2:\n        return l1 or l2\n    if l1.val < l2.val:\n        l1.next = merge_two_list_recur(l1.next, l2)\n        return l1\n    else:\n        l2.next = merge_two_list_recur(l1, l2.next)\n        return l2\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nmerge_two_list_recur() is a recursive function that merges two sorted linked lists, l1 and l2, into a single sorted linked list. It compares the values of the nodes of each list and returns the list with the lower value. It then recursively calls itself to continue merging the lists until all nodes have been added."}
{"prompt": "def is_prime(num):\n    if num == 2:\n        return True\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nChecks if a number is prime or not.\n\nParameters: \nnum (int): The number to be checked.\n\nReturns: \nbool: True if the number is prime, False if not."}
{"prompt": "def backtrack(board, i, j, trie, pre, used, result):\n    if '#' in trie:\n        result.add(pre)\n    if i < 0 or i >= len(board) or j < 0 or (j >= len(board[0])):\n        return\n    if not used[i][j] and board[i][j] in trie:\n        used[i][j] = True\n        backtrack(board, i + 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n        backtrack(board, i, j + 1, trie[board[i][j]], pre + board[i][j], used, result)\n        backtrack(board, i - 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n        backtrack(board, i, j - 1, trie[board[i][j]], pre + board[i][j], used, result)\n        used[i][j] = False\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function is used to backtrack through a board of letters to search for words that can be formed using a given trie. It takes in a board of letters, a trie, a current prefix, a matrix of used letter positions, and a result set of found words. It recursively backtracks through the board in all four directions and adds any words found to the result set."}
{"prompt": "def lcm(a, b):\n    return abs(a) * abs(b) / gcd(a, b)\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nCalculates the Least Common Multiple (LCM) of two given numbers. LCM is the smallest number that can be divided by both numbers without a remainder."}
{"prompt": "def multiply(multiplicand: list, multiplier: list) -> list:\n    (multiplicand_row, multiplicand_col) = (len(multiplicand), len(multiplicand[0]))\n    (multiplier_row, multiplier_col) = (len(multiplier), len(multiplier[0]))\n    if multiplicand_col != multiplier_row:\n        raise Exception('Multiplicand matrix not compatible with Multiplier matrix.')\n    result = [[0] * multiplier_col for i in range(multiplicand_row)]\n    for i in range(multiplicand_row):\n        for j in range(multiplier_col):\n            for k in range(len(multiplier)):\n                result[i][j] += multiplicand[i][k] * multiplier[k][j]\n    return result\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes two matrices as input, multiplicand and multiplier, multiplies them and returns the resulting matrix. The function will check if the two matrices are compatible for multiplication and will raise an exception if they are not."}
{"prompt": "def remove(self, old_one):\n    if not old_one in self.index_map:\n        return\n    index = self.index_map[old_one]\n    last = self.elements.pop()\n    self.index_map.pop(old_one)\n    if index == len(self.elements):\n        return\n    self.elements[index] = last\n    self.index_map[last] = index\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nRemove an element from the Set.\nParameters:\n    old_one (any): The element to remove from the Set.\n\"\"\""}
{"prompt": "def min_depth(self, root):\n    if root is None:\n        return 0\n    if root.left is not None or root.right is not None:\n        return max(self.minDepth(root.left), self.minDepth(root.right)) + 1\n    return min(self.minDepth(root.left), self.minDepth(root.right)) + 1\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturns the minimum depth of a given binary tree. The minimum depth is the number of nodes along the shortest path from the root node to the nearest leaf node. \n\"\"\""}
{"prompt": "def window_text(self):\n    return self.text[self.window_start:self.window_end]\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"Return the text within the window start and end indices.\"\"\""}
{"prompt": "def longest_common_prefix_v1(strs):\n    if not strs:\n        return ''\n    result = strs[0]\n    for i in range(len(strs)):\n        result = common_prefix(result, strs[i])\n    return result\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturns the longest common prefix (string) of the given list of strings. If the list is empty, an empty string is returned."}
{"prompt": "def first_is_consecutive(stack):\n    storage_stack = []\n    for i in range(len(stack)):\n        first_value = stack.pop()\n        if len(stack) == 0:\n            return True\n        second_value = stack.pop()\n        if first_value - second_value != 1:\n            return False\n        stack.append(second_value)\n        storage_stack.append(first_value)\n    for i in range(len(storage_stack)):\n        stack.append(storage_stack.pop())\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCheck if the values in a stack are consecutive numbers in descending order.\n\nParameters: \nstack (list): The stack to check.\n\nReturns:\nbool: True if the values in the stack are consecutive numbers in descending order, False otherwise.\n\"\"\""}
{"prompt": "def get_minor(m, row, col):\n    minors = []\n    for i in range(len(m)):\n        if i != row:\n            new_row = m[i][:col]\n            new_row.extend(m[i][col + 1:])\n            minors.append(new_row)\n    return minors\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nget_minor(m, row, col) -> list of lists\n\nReturns a list of lists representing the minor matrix of the given matrix m, \nexcluding the row and column specified by row and col parameters.\n\nArgs:\n    m (list of lists): matrix to calculate the minor matrix of\n    row (int): row index to exclude from the minor matrix\n    col (int): column index to exclude from the minor matrix\n\nReturns:\n    list of lists: the minor matrix of the given matrix m, excluding the row and column specified by row and col parameters.\n\"\"\""}
{"prompt": "def max_sliding_window(nums, k):\n    if not nums:\n        return nums\n    queue = collections.deque()\n    res = []\n    for num in nums:\n        if len(queue) < k:\n            queue.append(num)\n        else:\n            res.append(max(queue))\n            queue.popleft()\n            queue.append(num)\n    res.append(max(queue))\n    return res\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes an array of numbers and an integer k as input and returns an array containing the maximum of each sliding window of size k."}
{"prompt": "def pancake_sort(arr):\n    len_arr = len(arr)\n    if len_arr <= 1:\n        return arr\n    for cur in range(len(arr), 1, -1):\n        index_max = arr.index(max(arr[0:cur]))\n        if index_max + 1 != cur:\n            if index_max != 0:\n                arr[:index_max + 1] = reversed(arr[:index_max + 1])\n            arr[:cur] = reversed(arr[:cur])\n    return arr\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function implements the Pancake Sorting Algorithm. \nIt takes an array of integers as an argument and returns a sorted array. \nThe algorithm iterates over the array from the end to the beginning, \nfinding the maximum element, reversing the array up to that element, \nand then reversing the whole array. \nThis is done until the array is sorted in ascending order. \n\"\"\""}
{"prompt": "def level_order(root):\n    ans = []\n    if not root:\n        return ans\n    level = [root]\n    while level:\n        current = []\n        new_level = []\n        for node in level:\n            current.append(node.val)\n            if node.left:\n                new_level.append(node.left)\n            if node.right:\n                new_level.append(node.right)\n        level = new_level\n        ans.append(current)\n    return ans\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nTraverse a binary tree in level order, returning a list of values.\n\nArgs:\n    root (Node): The root node of the tree.\n\nReturns:\n    list: A list of values from the tree, in level order.\n\"\"\""}
{"prompt": "def __choose_state(state_map):\n    choice = random.random()\n    probability_reached = 0\n    for (state, probability) in state_map.items():\n        probability_reached += probability\n        if probability_reached > choice:\n            return state\n    return None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function randomly selects a state based on its probability from a given state map. It takes in a mapping of states to probabilities, and returns a randomly chosen state, or None if no state is chosen."}
{"prompt": "def __ne__(self, obj):\n    return self.name != self.get_name(obj)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturns True if the name of the current object is not equal to the name of the object passed in as an argument."}
{"prompt": "def search_in_a_sorted_matrix(mat, m, n, key):\n    (i, j) = (m - 1, 0)\n    while i >= 0 and j < n:\n        if key == mat[i][j]:\n            print('Key %s found at row- %s column- %s' % (key, i + 1, j + 1))\n            return\n        if key < mat[i][j]:\n            i -= 1\n        else:\n            j += 1\n    print('Key %s not found' % key)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function searchs for a given value (key) in a given sorted matrix of size m x n. It returns the row and column number of the key if found. Otherwise, it prints the key is not found. \n\"\"\""}
{"prompt": "def bubble_sort(arr, simulation=False):\n\n    def swap(i, j):\n        (arr[i], arr[j]) = (arr[j], arr[i])\n    n = len(arr)\n    swapped = True\n    iteration = 0\n    if simulation:\n        print('iteration', iteration, ':', *arr)\n    x = -1\n    while swapped:\n        swapped = False\n        x = x + 1\n        for i in range(1, n - x):\n            if arr[i - 1] > arr[i]:\n                swap(i - 1, i)\n                swapped = True\n                if simulation:\n                    iteration = iteration + 1\n                    print('iteration', iteration, ':', *arr)\n    return arr\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nbubble_sort(arr, simulation=False) -> sorts the array 'arr' using the Bubble Sort algorithm, optionally printing each step of the algorithm.\n\nParameters:\narr (list): array to be sorted.\nsimulation (bool, optional): flag to determine if each step of the algorithm should be printed. Default is False.\n\nReturns:\nlist: sorted array.\n\"\"\""}
{"prompt": "def __repr__(self):\n    return f'({self.source} -> {self.target})'\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturn a string representing the object. The string shows an arrow connecting the source and target objects."}
{"prompt": "@staticmethod\ndef _go_through_tree_and_create_codes(tree: Node, code: str, dict_codes: dict):\n    if tree.sign is not None:\n        dict_codes[tree.sign] = code\n    if tree.left:\n        HuffmanCoding._go_through_tree_and_create_codes(tree.left, code + '0', dict_codes)\n    if tree.right:\n        HuffmanCoding._go_through_tree_and_create_codes(tree.right, code + '1', dict_codes)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nRecursively traverse through a Huffman tree, assigning binary codes to each of the symbols within the tree and adding them to a dictionary.\n\nParameters:\n    tree (Node): The Huffman tree to traverse.\n    code (str): The cumulative binary code.\n    dict_codes (dict): The dictionary to store the codes in.\n\"\"\""}
{"prompt": "def __eq__(self, obj):\n    return self.name == self.get_name(obj)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nCompares the name of the current object with the name of a given object. Returns True if the names are equal, False otherwise."}
{"prompt": "def combination_sum(candidates, target):\n\n    def dfs(nums, target, index, path, res):\n        if target < 0:\n            return\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(index, len(nums)):\n            dfs(nums, target - nums[i], i, path + [nums[i]], res)\n    res = []\n    candidates.sort()\n    dfs(candidates, target, 0, [], res)\n    return res\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nThis function finds all combinations of candidates that add up to the target number. It implements a depth-first search (dfs) algorithm to traverse the entire search space and identify all valid combinations. \n\nInputs: \ncandidates: a list of numbers\ntarget: the desired sum of the combination \n\nOutputs: a list of lists which contain all the valid combinations \n\"\"\""}
{"prompt": "def rabin_karp(word, text):\n    if word == '' or text == '':\n        return None\n    if len(word) > len(text):\n        return None\n    rolling_hash = RollingHash(text, len(word))\n    word_hash = RollingHash(word, len(word))\n    for i in range(len(text) - len(word) + 1):\n        if rolling_hash.hash == word_hash.hash:\n            if rolling_hash.window_text() == word:\n                return i\n        rolling_hash.move_window()\n    return None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function implements the Rabin-Karp substring search algorithm. It takes two strings, 'word' and 'text', as parameters and returns the first index of 'word' in 'text' if it exists; otherwise, it returns None."}
{"prompt": "def insert_one_bit(num, bit, i):\n    mask = num >> i\n    mask = mask << 1 | bit\n    mask = mask << i\n    right = (1 << i) - 1 & num\n    return right | mask\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nInsert one bit into a given number num at index i.\n\nParameters:\nnum (int): The number to insert a bit into.\nbit (int): The bit to insert (0 or 1).\ni (int): The index at which to insert the bit.\n\nReturns:\nint: The number with the bit inserted."}
{"prompt": "@staticmethod\ndef decode_file(file_in_name, file_out_name):\n    with open(file_in_name, 'rb') as file_in, open(file_out_name, 'wb') as file_out:\n        reader = HuffmanReader(file_in)\n        additional_bits = reader.get_number_of_additional_bits_in_the_last_byte()\n        tree = reader.load_tree()\n        HuffmanCoding._decode_and_write_signs_to_file(file_out, reader, tree, additional_bits)\n    print('File decoded.')\n##############\nEND_FUNC\n##############\n", "completion": "\n\nDecodes a file encoded with Huffman coding algorithm and writes the decoded content to a new file. Prints a message when finished."}
{"prompt": "def remove_dups(head):\n    hashset = set()\n    prev = Node()\n    while head:\n        if head.val in hashset:\n            prev.next = head.next\n        else:\n            hashset.add(head.val)\n            prev = head\n        head = head.next\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function removes duplicate nodes in a linked list. It takes in the head node of the list and uses a set to keep track of the already visited nodes. It iterates over the list and removes duplicate nodes."}
{"prompt": "def fib_iter(n):\n    assert n >= 0, 'n must be positive integer'\n    fib_1 = 0\n    fib_2 = 1\n    res = 0\n    if n <= 1:\n        return n\n    for _ in range(n - 1):\n        res = fib_1 + fib_2\n        fib_1 = fib_2\n        fib_2 = res\n    return res\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Computes the n-th Fibonacci number using iteration.\n \nParameters:\n    n (int): number for which to compute the Fibonacci number\n \nReturns:\n    int: n-th Fibonacci number\n \nRaises:\n    AssertionError: if n is not a positive integer\n\"\"\""}
{"prompt": "def get_matrix_of_minors(m):\n    matrix_of_minors = [[0 for i in range(len(m))] for j in range(len(m))]\n    for row in range(len(m)):\n        for col in range(len(m[0])):\n            if (row + col) % 2 == 0:\n                sign = 1\n            else:\n                sign = -1\n            matrix_of_minors[row][col] = sign * get_determinant(get_minor(m, row, col))\n    return matrix_of_minors\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function returns a matrix of minors of a given matrix \"m\". It assigns the minors of each element in the matrix its corresponding sign (positive or negative) based on their row and column index, and then calculates their determinant."}
{"prompt": "def dfs_transposed(vertex, graph, order, visited):\n    visited[vertex] = True\n    for adjacent in graph[vertex]:\n        if not visited[adjacent]:\n            dfs_transposed(adjacent, graph, order, visited)\n    order.append(vertex)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function performs a depth-first search on a graph, starting from a given vertex, and filling the 'order' list with the vertices in reverse topological order. The 'visited' set is used to keep track of which vertices have already been visited."}
{"prompt": "def _rotate_left(self, parent_node: Node, child_index: int):\n    new_child_key = parent_node.keys[child_index]\n    new_parent_key = parent_node.children[child_index + 1].keys.pop(0)\n    parent_node.children[child_index].keys.append(new_child_key)\n    parent_node.keys[child_index] = new_parent_key\n    if not parent_node.children[child_index + 1].is_leaf:\n        ownerless_child = parent_node.children[child_index + 1].children.pop(0)\n        parent_node.children[child_index].children.append(ownerless_child)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function rotates left a node in a B-Tree by moving a key from the parent node to the left child. Additionally, if the right child is not a leaf, it also moves the leftmost child of the right child to the left child."}
{"prompt": "def __len__(self):\n    return self._size\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturns the number of elements in the container."}
{"prompt": "def count_left_node(root):\n    if root is None:\n        return 0\n    elif root.left is None:\n        return count_left_node(root.right)\n    else:\n        return 1 + count_left_node(root.left) + count_left_node(root.right)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nRecursively count the number of left nodes in a binary tree.\n\nParameters:\n    root (Node): The root of the binary tree.\n\nReturns:\n    int: The number of left nodes in the binary tree.\n\"\"\""}
{"prompt": "def next_greatest_letter_v1(letters, target):\n    if letters[0] > target:\n        return letters[0]\n    if letters[len(letters) - 1] <= target:\n        return letters[0]\n    (left, right) = (0, len(letters) - 1)\n    while left <= right:\n        mid = left + (right - left) // 2\n        if letters[mid] > target:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return letters[left]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturn the next greatest letter in the list of letters after the target letter.\n\nParameters:\n    letters (list): A list of letters\n    target (char): The target letter\n\nReturns:\n    char: The next greatest letter in the list after the target letter\n\"\"\""}
{"prompt": "def path_sum2(root, s):\n    if root is None:\n        return []\n    res = []\n    stack = [(root, [root.val])]\n    while stack:\n        (node, ls) = stack.pop()\n        if node.left is None and node.right is None and (sum(ls) == s):\n            res.append(ls)\n        if node.left is not None:\n            stack.append((node.left, ls + [node.left.val]))\n        if node.right is not None:\n            stack.append((node.right, ls + [node.right.val]))\n    return res\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes in a binary tree root and a sum (s) and returns a list of all paths that have a sum equal to the given sum (s). Each path must start from the root and end at a leaf node."}
{"prompt": "def _remove_from_nonleaf_node(self, node: Node, key_index: int):\n    key = node.keys[key_index]\n    left_subtree = node.children[key_index]\n    if len(left_subtree.keys) > self.min_numbers_of_keys:\n        largest_key = self._find_largest_and_delete_in_left_subtree(left_subtree)\n    elif len(node.children[key_index + 1].keys) > self.min_numbers_of_keys:\n        largest_key = self._find_largest_and_delete_in_right_subtree(node.children[key_index + 1])\n    else:\n        self._merge(node, key_index, key_index + 1)\n        return self._remove_key(node, key)\n    node.keys[key_index] = largest_key\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n_remove_from_nonleaf_node(self, node: Node, key_index: int)\n    Remove a key from a non-leaf node. \n    Parameters: \n        self (object): the BTree object \n        node (Node): the Node object to remove the key from \n        key_index (int): the index of the key to remove \n    Returns: \n        None \n\"\"\""}
{"prompt": "def split(path):\n    parts = []\n    split_part = path.rpartition('/')\n    parts.append(split_part[0])\n    parts.append(split_part[2])\n    return parts\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Split a path into two parts: the directory and the filename.\n\nParameters:\n    path (str): The path to be split.\n\nReturns:\n    parts (list): A list containing two elements, the directory and the filename.\n\"\"\""}
{"prompt": "def dijkstra(self, src):\n    dist = [float('inf')] * self.vertex_count\n    dist[src] = 0\n    min_dist_set = [False] * self.vertex_count\n    for _ in range(self.vertex_count):\n        source = self.min_distance(dist, min_dist_set)\n        min_dist_set[source] = True\n        for target in range(self.vertex_count):\n            if self.graph[source][target] <= 0 or min_dist_set[target]:\n                continue\n            if dist[target] > dist[source] + self.graph[source][target]:\n                dist[target] = dist[source] + self.graph[source][target]\n    return dist\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function implements Dijkstra's Algorithm to find the shortest path between a given source vertex and all other vertices in a graph. It takes in the graph and a source vertex as inputs and returns an array of the shortest distances from the source vertex to all other vertices."}
{"prompt": "def compare_closure_default(num, target):\n    if num < target:\n        return -1\n    elif num > target:\n        return 1\n    else:\n        return 0\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\n\ncompare_closure_default(num, target) takes two numbers, num and target, and returns -1 if num is less than target, 1 if num is greater than target, and 0 if num is equal to target."}
{"prompt": "def push(self, item, priority=None):\n    priority = item if priority is None else priority\n    node = PriorityQueueNode(item, priority)\n    for (index, current) in enumerate(self.priority_queue_list):\n        if current.priority < node.priority:\n            self.priority_queue_list.insert(index, node)\n            return\n    self.priority_queue_list.append(node)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function pushes an item to the priority queue with the given priority, or the item's value if no priority is given. The item is then inserted into the priority queue list at the index where the current node's priority is less than the new node's priority. If no such index is found, the item is appended to the end of the list."}
{"prompt": "def bytes_big_endian_to_int(bytestr):\n    num = 0\n    for b in bytestr:\n        num <<= 8\n        num += b\n    return num\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nConvert a big-endian byte string to an integer.\n\nArgs:\n    bytestr (bytes): The byte string to convert.\n\nReturns:\n    int: The converted integer.\n\"\"\""}
{"prompt": "def __add__(self, other: Union[int, float, Fraction]):\n    if isinstance(other, int) or isinstance(other, float) or isinstance(other, Fraction):\n        return self.__add__(Monomial({}, Monomial._rationalize_if_possible(other)))\n    if not isinstance(other, Monomial):\n        raise ValueError('Can only add monomials, ints, floats, or Fractions.')\n    if self.variables == other.variables:\n        mono = {i: self.variables[i] for i in self.variables}\n        return Monomial(mono, Monomial._rationalize_if_possible(self.coeff + other.coeff)).clean()\n    raise ValueError(f\"Cannot add {str(other)} to {self.__str__()} because they don't have same variables.\")\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function adds a Monomial, int, float, or Fraction to another Monomial. It raises a ValueError if the Monomials don't have the same variables or if the passed argument is not a Monomial, int, float, or Fraction. It returns a cleaned Monomial of the sum of the coefficients of the two Monomials."}
{"prompt": "def __init__(self, source, target, weight):\n    self.source = source\n    self.target = target\n    self.weight = weight\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__(self, source, target, weight) initializes a new instance of the object with the given source, target, and weight values."}
{"prompt": "def print_hosoya(height):\n    for i in range(height):\n        for j in range(i + 1):\n            print(hosoya(i, j), end=' ')\n        print('\\n', end='')\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nPrints a Hosoya triangle of a given height. A Hosoya triangle is a right-angled triangle where each entry is the Hosoya number, which is calculated by the formula (i*(i + 1))/2 + j.\n\nParameters:\nheight (int): The height of the Hosoya triangle to be printed.\n\"\"\""}
{"prompt": "def edit_distance(word_a, word_b):\n    (length_a, length_b) = (len(word_a) + 1, len(word_b) + 1)\n    edit = [[0 for _ in range(length_b)] for _ in range(length_a)]\n    for i in range(1, length_a):\n        edit[i][0] = i\n    for j in range(1, length_b):\n        edit[0][j] = j\n    for i in range(1, length_a):\n        for j in range(1, length_b):\n            cost = 0 if word_a[i - 1] == word_b[j - 1] else 1\n            edit[i][j] = min(edit[i - 1][j] + 1, edit[i][j - 1] + 1, edit[i - 1][j - 1] + cost)\n    return edit[-1][-1]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function computes the Levenshtein edit distance between two words. It takes two strings, word_a and word_b, and returns the edit distance between them. It uses a dynamic programming approach to calculate the edit cost between the two words."}
{"prompt": "def k_closest(points, k, origin=(0, 0)):\n    heap = [(-distance(p, origin), p) for p in points[:k]]\n    heapify(heap)\n    '\\n    For every point p in points[k:],\\n    check if p is smaller than the root of the max heap;\\n    if it is, add p to heap and remove root. Reheapify.\\n    '\n    for point in points[k:]:\n        dist = distance(point, origin)\n        heappushpop(heap, (-dist, point))\n        'Same as:\\n            if d < -heap[0][0]:\\n                heappush(heap, (-d,p))\\n                heappop(heap)\\n\\n        Note: heappushpop is more efficient than separate push and pop calls.\\n        Each heappushpop call takes O(logk) time.\\n        '\n    return [point for (nd, point) in heap]\n##############\nEND_FUNC\n##############\n", "completion": "\nThis function finds the k closest points to a given origin from a list of points. It takes three arguments, points (a list of points), k (an integer) and origin (an optional tuple of coordinates). It uses a max heap to store the k closest points and then checks each point in points[k:] to see if it is closer than the root of the heap, replacing the root with this point if it is. It returns a list of the k closest points."}
{"prompt": "def print_tree(root):\n    if root is not None:\n        print(root.val)\n        print_tree(root.left)\n        print_tree(root.right)\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nPrints the tree rooted at 'root' in pre-order. 'root' is an instance of a TreeNode class."}
{"prompt": "def single_number3(nums):\n    ab = 0\n    for n in nums:\n        ab ^= n\n    right_most = ab & -ab\n    (a, b) = (0, 0)\n    for n in nums:\n        if n & right_most:\n            a ^= n\n        else:\n            b ^= n\n    return [a, b]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nFind the two numbers that only appear once in a given array of numbers where every other number appears twice.\n\nReturns a list with two numbers that appear once, in no particular order. \n\"\"\""}
{"prompt": "def find_order(a, n):\n    if (a == 1) & (n == 1):\n        return 1\n    if math.gcd(a, n) != 1:\n        print('a and n should be relative prime!')\n        return -1\n    for i in range(1, n):\n        if pow(a, i) % n == 1:\n            return i\n    return -1\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nfind_order(a, n) takes two integers a and n as inputs, and returns an integer. It returns the smallest positive integer i such that a^i mod n = 1, provided that a and n are relatively prime. If a and n are not relatively prime, it prints a message and returns -1."}
{"prompt": "def __len__(self):\n    return self._top + 1\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nReturns the number of elements currently stored in the stack, which is equal to the value of the top index plus one."}
{"prompt": "def is_strobogrammatic(num):\n    comb = '00 11 88 69 96'\n    i = 0\n    j = len(num) - 1\n    while i <= j:\n        if comb.find(num[i] + num[j]) == -1:\n            return False\n        i += 1\n        j -= 1\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nis_strobogrammatic(num) checks if the given number is strobogrammatic.\nA strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).\n\nThis function takes in a number as a string, checks if the number is strobogrammatic, and returns a boolean value."}
{"prompt": "def __init__(self):\n    self.depth = 0\n    self.Node = None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function initializes a class object with attributes depth and Node, both set to 0."}
{"prompt": "def max_profit_naive(prices):\n    max_so_far = 0\n    for i in range(0, len(prices) - 1):\n        for j in range(i + 1, len(prices)):\n            max_so_far = max(max_so_far, prices[j] - prices[i])\n    return max_so_far\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCalculate the maximum profit from a list of stock prices using a naive approach.\n\nParameters:\nprices (list): A list of stock prices.\n\nReturns:\nint: The maximum profit from the given list of stock prices.\n\"\"\""}
{"prompt": "def put(self, key, value):\n    rv = super().put(key, value)\n    if len(self) >= self.size * 2 / 3:\n        self.__resize()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nPut a (key, value) pair into the hash table. If the size of the hash table exceeds two-thirds of its capacity, the table will be resized. \n\"\"\""}
{"prompt": "def get_bit(num, i):\n    return num & 1 << i != 0\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nReturns whether bit at index i in num is set to 1."}
{"prompt": "def helper2(n, length):\n    if n == 0:\n        return ['']\n    if n == 1:\n        return ['0', '8', '1']\n    mids = helper(n - 2, length)\n    res = []\n    for mid in mids:\n        if n != length:\n            res.append('0' + mid + '0')\n        res.append('1' + mid + '1')\n        res.append('6' + mid + '9')\n        res.append('9' + mid + '6')\n        res.append('8' + mid + '8')\n    return res\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function takes two parameters: an integer \"n\" and a length \"length\". It returns a list of strings, where each string is composed of characters from the strings \"0\", \"1\", \"6\", \"9\", and \"8\". The strings are generated by combining a string of length \"n - 2\" with characters from the given strings. If \"n\" is 0, an empty string is returned. If \"n\" is 1, a list containing the strings \"0\", \"8\", and \"1\" is returned."}
{"prompt": "def col_kills(grid, i, j):\n    num = 0\n    len_col = len(grid)\n    while i < len_col and grid[i][j] != 'W':\n        if grid[i][j] == 'E':\n            num += 1\n        i += 1\n    return num\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function takes a grid of characters, an index 'i' and an index 'j', and returns the number of enemies ('E') in the same column as the given indices."}
{"prompt": "def swap_pair(num):\n    odd = (num & int('AAAAAAAA', 16)) >> 1\n    even = (num & int('55555555', 16)) << 1\n    return odd | even\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function swaps the even and odd bits in a number. It takes one argument, num, which is an integer, and returns an integer with the even and odd bits swapped."}
{"prompt": "def has_alternative_bit(n):\n    first_bit = 0\n    second_bit = 0\n    while n:\n        first_bit = n & 1\n        if n >> 1:\n            second_bit = n >> 1 & 1\n            if not first_bit ^ second_bit:\n                return False\n        else:\n            return True\n        n = n >> 1\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nChecks if a given number has an alternative bit pattern.\n\nReturns:\n    bool: True if the number has an alternative bit pattern, False otherwise."}
{"prompt": "def min_heap_sort(arr, simulation=False):\n    iteration = 0\n    if simulation:\n        print('iteration', iteration, ':', *arr)\n    for i in range(0, len(arr) - 1):\n        iteration = min_heapify(arr, i, simulation, iteration)\n    return arr\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"This function performs min-heap sort on a given array. If the 'simulation' parameter is set to True, it will print out a running log of the steps taken during the sort. It returns a sorted array.\"\"\""}
{"prompt": "def __iter__(self):\n    probe = self._top\n    while True:\n        if probe == -1:\n            return\n        yield self._array[probe]\n        probe -= 1\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"This function is used to iterate over the elements of a stack in a reverse order. It takes in the instance of the stack object as an argument and yields each element of the stack in reverse order.\"\"\""}
{"prompt": "@staticmethod\ndef _encode_and_write_signs_to_file(file, writer: HuffmanWriter, codes: dict):\n    sign = file.read(1)\n    while sign:\n        int_char = int.from_bytes(sign, 'big')\n        writer.write_bits(codes[int_char])\n        sign = file.read(1)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function reads a file one character at a time, encodes it from bytes to an integer, and then writes it to a file using the HuffmanWriter."}
{"prompt": "def num_perfect_squares(number):\n    if int(math.sqrt(number)) ** 2 == number:\n        return 1\n    while number > 0 and number % 4 == 0:\n        number /= 4\n    if number % 8 == 7:\n        return 4\n    for i in range(1, int(math.sqrt(number)) + 1):\n        if int(math.sqrt(number - i ** 2)) ** 2 == number - i ** 2:\n            return 2\n    return 3\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nnum_perfect_squares(number)\n\nReturns an integer, depending on how many perfect squares are within the given number:\n\n1 - If the number is a perfect square.\n2 - If the difference between the number and a perfect square is also a perfect square.\n3 - If the number is not a perfect square and there is no perfect square difference.\n4 - If the number is divisible by 8 and the remainder is 7."}
{"prompt": "def __test_time():\n    vector_length = 1024\n    vector_count = 1024\n    nozero_counut = 10\n\n    def random_vector():\n        import random\n        vector = [0 for _ in range(vector_length)]\n        for i in random.sample(range(vector_length), nozero_counut):\n            vector[i] = random.random()\n        return vector\n    vectors = [random_vector() for _ in range(vector_count)]\n    iv_lists = [vector_to_index_value_list(vector) for vector in vectors]\n    import time\n    time_start = time.time()\n    for i in range(vector_count):\n        for j in range(i):\n            dot_product(iv_lists[i], iv_lists[j])\n    time_end = time.time()\n    print(time_end - time_start, 'seconds')\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function tests the time of a dot product operation on a randomly generated list of vectors. It prints the total time taken to calculate the dot products.\n\"\"\""}
{"prompt": "def reverse_bits(n):\n    m = 0\n    i = 0\n    while i < 32:\n        m = (m << 1) + (n & 1)\n        n >>= 1\n        i += 1\n    return m\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes an integer n as input and returns an integer m containing the reverse of the bits of n. The function first sets m to 0, and then iterates 32 times, taking the last bit from n and adding it to m, before shifting n one bit to the right. At the end, m will contain the bits of n in reverse order."}
{"prompt": "def print_optimal_solution(optimal_solution, i, j):\n    if i == j:\n        print('A' + str(i), end=' ')\n    else:\n        print('(', end=' ')\n        print_optimal_solution(optimal_solution, i, optimal_solution[i][j])\n        print_optimal_solution(optimal_solution, optimal_solution[i][j] + 1, j)\n        print(')', end=' ')\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nPrints the optimal solution of a matrix chain multiplication problem.\n\nArgs:\n    optimal_solution (list): The optimal solution matrix.\n    i (int): The starting index.\n    j (int): The ending index.\n\"\"\""}
{"prompt": "def __init__(self, vertex_count):\n    self.vertex_count = vertex_count\n    self.graph = defaultdict(list)\n    self.has_path = False\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__(self, vertex_count):\n    \"\"\"Initializes a graph structure with the given number of vertices.\n\n    Args:\n        vertex_count (int): The number of vertices in the graph.\n    \n    Attributes:\n        vertex_count (int): The number of vertices in the graph.\n        graph (dict): The adjacency list of the graph.\n        has_path (bool): Boolean flag indicating if a path has been found.\n\"\"\""}
{"prompt": "def limit(arr, min_lim=None, max_lim=None):\n    if len(arr) == 0:\n        return arr\n    if min_lim is None:\n        min_lim = min(arr)\n    if max_lim is None:\n        max_lim = max(arr)\n    return list(filter(lambda x: min_lim <= x <= max_lim, arr))\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturns a list of elements from the given array that is within the bounds of the given minimum and maximum limit. If no minimum and maximum limit is specified, the minimum and maximum values of the given array will be used as the bounds. If the given array is empty, the empty array is returned. \n\"\"\""}
{"prompt": "@staticmethod\ndef _generate_codes(tree: Node) -> dict:\n    codes = dict()\n    HuffmanCoding._go_through_tree_and_create_codes(tree, '', codes)\n    return codes\n##############\nEND_FUNC\n##############\n", "completion": "\n\nGenerate codes from a Huffman tree.\n\nGiven a Huffman tree, process the tree and generate the codes associated to each character and store them in a dictionary. Returns the dictionary containing the codes."}
{"prompt": "def max_sliding_window(arr, k):\n    qi = collections.deque()\n    result = []\n    for (i, n) in enumerate(arr):\n        while qi and arr[qi[-1]] < n:\n            qi.pop()\n        qi.append(i)\n        if qi[0] == i - k:\n            qi.popleft()\n        if i >= k - 1:\n            result.append(arr[qi[0]])\n    return result\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturn a list containing the maximum value in each sliding window of size k across the given array.\n\nParameters:\narr (list): The array of values.\nk (int): The size of the sliding window.\n\nReturns:\nlist: A list containing the maximum value in each sliding window of size k across the given array.\n\"\"\""}
{"prompt": "def top_1(arr):\n    values = {}\n    result = []\n    f_val = 0\n    for i in arr:\n        if i in values:\n            values[i] += 1\n        else:\n            values[i] = 1\n    f_val = max(values.values())\n    for i in values.keys():\n        if values[i] == f_val:\n            result.append(i)\n        else:\n            continue\n    return result\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturns the elements with the highest frequency in an array.\n\nInput: \narr: array of elements\n\nOutput:\nresult: list of elements with the highest frequency in arr\n\"\"\""}
{"prompt": "def flatten(input_arr, output_arr=None):\n    if output_arr is None:\n        output_arr = []\n    for ele in input_arr:\n        if not isinstance(ele, str) and isinstance(ele, Iterable):\n            flatten(ele, output_arr)\n        else:\n            output_arr.append(ele)\n    return output_arr\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Flatten a nested iterable into a single list.\n\nParameters:\n    input_arr (iterable): A nested iterable to flatten. \n    output_arr (list, optional): An optional list to output the flattened iterable into.\n\nReturns:\n    list: A single list containing all elements from the input iterable.\n\"\"\""}
{"prompt": "def is_palindrome_stack(s):\n    stack = []\n    s = remove_punctuation(s)\n    for i in range(len(s) // 2, len(s)):\n        stack.append(s[i])\n    for i in range(0, len(s) // 2):\n        if s[i] != stack.pop():\n            return False\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nis_palindrome_stack() takes a string as an argument and returns a boolean indicating whether or not the string is a palindrome. It uses a stack data structure to determine if the string is a palindrome. It removes punctuation from the string before checking if it is a palindrome."}
{"prompt": "def find_deepest_left(root, is_left, depth, res):\n    if not root:\n        return\n    if is_left and depth > res.depth:\n        res.depth = depth\n        res.Node = root\n    find_deepest_left(root.left, True, depth + 1, res)\n    find_deepest_left(root.right, False, depth + 1, res)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function finds the deepest left node in a tree given the root node.\nIt takes in 4 parameters:\n- root: the root node of the tree\n- is_left: a boolean value indicating whether the root node is a left node\n- depth: an integer representing the current depth of the tree\n- res: a result object storing the deepest left node and its depth\n\"\"\""}
{"prompt": "def sort_colors(nums):\n    i = j = 0\n    for k in range(len(nums)):\n        v = nums[k]\n        nums[k] = 2\n        if v < 2:\n            nums[j] = 1\n            j += 1\n        if v == 0:\n            nums[i] = 0\n            i += 1\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nSort the numbers in nums in-place so that all 0s come first, followed by all 1s, followed by all 2s.\n\nParameters:\nnums (list): List of numbers to be sorted in-place.\n\nReturns:\nNone.\n\"\"\""}
{"prompt": "def encode_rle(input):\n    if not input:\n        return ''\n    encoded_str = ''\n    prev_ch = ''\n    count = 1\n    for ch in input:\n        if ch != prev_ch:\n            if prev_ch:\n                encoded_str += str(count) + prev_ch\n            count = 1\n            prev_ch = ch\n        else:\n            count += 1\n    else:\n        return encoded_str + (str(count) + prev_ch)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nEncode RLE encodes a string using Run Length Encoding (RLE). It takes in a string input and returns an encoded string using RLE technique. It keeps a count of the number of consecutive characters and returns the count and the character in the encoded string."}
{"prompt": "def bfs(grid, matrix, i, j, count):\n    q = [(i, j, 0)]\n    while q:\n        (i, j, step) = q.pop(0)\n        for (k, l) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n            if 0 <= k < len(grid) and 0 <= l < len(grid[0]) and (matrix[k][l][1] == count) and (grid[k][l] == 0):\n                matrix[k][l][0] += step + 1\n                matrix[k][l][1] = count + 1\n                q.append((k, l, step + 1))\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nThis function performs a breadth-first search (BFS) on a grid of cells with a given matrix. It takes four parameters: grid, matrix, i, and j, which indicate the current cell's coordinates and the current count, respectively. It returns an updated matrix, which contains the distance to the original cell and the number of the cell visited."}
{"prompt": "def next_sort(arr):\n    for i in range(1, len(arr)):\n        j = i - 1\n        key = arr[i]\n        while arr[j] > key and j >= 0:\n            arr[j + 1] = arr[j]\n            j = j - 1\n        arr[j + 1] = key\n    return arr\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nThis function takes an array 'arr' and sorts the elements in ascending order using an insertion sort algorithm. It returns the sorted array."}
{"prompt": "def equal_upto_scalar(self, other) -> bool:\n    if not isinstance(other, Monomial):\n        raise ValueError('Can only compare monomials.')\n    return other.variables == self.variables\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nChecks if two Monomial objects have the same variables and returns a boolean. Raises a ValueError if the comparison is attempted between a Monomial and a non-Monomial object."}
{"prompt": "def find(self, bit):\n    if bit == '0':\n        self.current_node = self.current_node.left\n    elif bit == '1':\n        self.current_node = self.current_node.right\n    else:\n        self._reset()\n        return True\n    if self.current_node.sign is not None:\n        self._reset(self.current_node.sign)\n        return True\n    else:\n        return False\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes in a bit ('0' or '1') and traverses the trie with it. If the bit is not valid ('0' or '1'), the current_node is reset to the root and True is returned. If the bit is valid, the current_node is moved to the left (if the bit is '0') or to the right (if the bit is '1'). If the current_node is a sign, the current_node is reset to the root and the sign is returned. Otherwise, False is returned."}
{"prompt": "def unique_array_sum_combinations(A, B, C, target):\n\n    def check_sum(n, *nums):\n        if sum((x for x in nums)) == n:\n            return (True, nums)\n        else:\n            return (False, nums)\n    pro = itertools.product(A, B, C)\n    func = partial(check_sum, target)\n    sums = list(itertools.starmap(func, pro))\n    res = set()\n    for s in sums:\n        if s[0] is True and s[1] not in res:\n            res.add(s[1])\n    return list(res)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function finds all the unique combinations of sums of elements of three given arrays that add up to a given target.\nIt takes in arrays A, B and C, and the target value as arguments. It returns a list of combinations of elements from A, B and C that sum up to the target value. \n\"\"\""}
{"prompt": "def delete_fixup(self, node):\n    while node is not self.root and node.color == 0:\n        if node is node.parent.left:\n            node_brother = node.parent.right\n            if node_brother.color == 1:\n                node_brother.color = 0\n                node.parent.color = 1\n                self.left_rotate(node.parent)\n                node_brother = node.parent.right\n            if (node_brother.left is None or node_brother.left.color == 0) and (node_brother.right is None or node_brother.right.color == 0):\n                node_brother.color = 1\n                node = node.parent\n            else:\n                if node_brother.right is None or node_brother.right.color == 0:\n                    node_brother.color = 1\n                    node_brother.left.color = 0\n                    self.right_rotate(node_brother)\n                    node_brother = node.parent.right\n                node_brother.color = node.parent.color\n                node.parent.color = 0\n                node_brother.right.color = 0\n                self.left_rotate(node.parent)\n                node = self.root\n        else:\n            node_brother = node.parent.left\n            if node_brother.color == 1:\n                node_brother.color = 0\n                node.parent.color = 1\n                self.left_rotate(node.parent)\n                node_brother = node.parent.right\n            if (node_brother.left is None or node_brother.left.color == 0) and (node_brother.right is None or node_brother.right.color == 0):\n                node_brother.color = 1\n                node = node.parent\n            else:\n                if node_brother.left is None or node_brother.left.color == 0:\n                    node_brother.color = 1\n                    node_brother.right.color = 0\n                    self.left_rotate(node_brother)\n                    node_brother = node.parent.left\n                node_brother.color = node.parent.color\n                node.parent.color = 0\n                node_brother.left.color = 0\n                self.right_rotate(node.parent)\n                node = self.root\n    node.color = 0\n##############\nEND_FUNC\n##############\n", "completion": "\n\ndelete_fixup() performs the necessary fix-up operations after a node is deleted from a red-black tree. It checks the node's parent and sibling and adjusts the tree accordingly to maintain the properties of a red-black tree."}
{"prompt": "def get_factors(n):\n    (todo, combis) = ([(n, 2, [])], [])\n    while todo:\n        (n, i, combi) = todo.pop()\n        while i * i <= n:\n            if n % i == 0:\n                combis.append(combi + [i, n // i])\n                todo.append((n // i, i, combi + [i]))\n            i += 1\n    return combis\n##############\nEND_FUNC\n##############\n", "completion": "\n\nCalculates all the factors of a given number, n, and returns them as a list of lists."}
{"prompt": "def clone_graph2(node):\n    if not node:\n        return None\n    node_copy = node.shallow_copy()\n    dic = {node: node_copy}\n    stack = [node]\n    while stack:\n        node = stack.pop()\n        for neighbor in node.neighbors:\n            if neighbor not in dic:\n                neighbor_copy = neighbor.shallow_copy()\n                dic[neighbor] = neighbor_copy\n                dic[node].add_neighbor(neighbor_copy)\n                stack.append(neighbor)\n            else:\n                dic[node].add_neighbor(dic[neighbor])\n    return node_copy\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function creates a shallow copy of a graph's node, and then creates a deep copy of the node's neighbors. It takes in a node and returns a shallow copy of the node."}
{"prompt": "def get_max(pos, left, right, start, end):\n    if left > end or right < start:\n        return 0\n    if left >= start and right <= end:\n        return tree[pos]\n    mid = left + right >> 1\n    return max_seq(get_max(pos << 1, left, mid, start, end), get_max(pos << 1 | 1, mid + 1, right, start, end))\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function finds the maximum element of a given range in a segment tree. It takes in five parameters: pos, left, right, start, and end. The pos parameter is the position of the root node of the segment tree. The left and right parameters are the left and right indices of the segment tree, respectively. The start and end parameters are the start and end indices of the range in which the maximum element is to be found. The function returns the maximum element of the given range."}
{"prompt": "def __init__(self, data):\n    self.data = data\n    self.left = None\n    self.right = None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__(self, data)\n    Constructor to initialize a node object.\n    :param self: The object pointer\n    :param data: The data to be stored in the node\n    :type self: Node\n    :type data: Any\n    :return: None\n\"\"\""}
{"prompt": "def __init__(self, vertex_count):\n    self.vertex_count = vertex_count\n    self.graph = defaultdict(list)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__(self, vertex_count)\n\nInitialize a graph object with the given vertex count.\n\nParameters:\nvertex_count (int): Number of vertices in the graph.\n\nReturns:\nNone\n\"\"\""}
{"prompt": "def num_digits(n):\n    n = abs(n)\n    if n == 0:\n        return 1\n    return int(math.log10(n)) + 1\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCalculate the number of digits in a non-negative integer.\n\nParameters:\nn (int): The non-negative integer to calculate the number of digits for.\n\nReturns:\nint: The number of digits in the input integer. \n\"\"\""}
{"prompt": "def __setitem__(self, key, value):\n    self.put(key, value)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nSet an item in the dictionary, given a key and a value."}
{"prompt": "def repeat_substring(s):\n    str = (s + s)[1:-1]\n    return s in str\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nChecks if a string s is a substring of a string formed by repeating s twice. Returns True if s is a substring, False otherwise."}
{"prompt": "def fib_list(n):\n    assert n >= 0, 'n must be a positive integer'\n    list_results = [0, 1]\n    for i in range(2, n + 1):\n        list_results.append(list_results[i - 1] + list_results[i - 2])\n    return list_results[n]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function generates the nth Fibonacci number given a positive integer n. It returns the Fibonacci number as a list. An assertion is used to ensure that the input is a positive integer."}
{"prompt": "def walls_and_gates(rooms):\n    for i in range(len(rooms)):\n        for j in range(len(rooms[0])):\n            if rooms[i][j] == 0:\n                dfs(rooms, i, j, 0)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function iterates through a 2D array of integers and uses depth-first search to update the value of each cell to its distance from the nearest gate (marked with a 0)."}
{"prompt": "def max_killed_enemies(grid):\n    if not grid:\n        return 0\n    (m, n) = (len(grid), len(grid[0]))\n    max_killed = 0\n    (row_e, col_e) = (0, [0] * n)\n    for i in range(m):\n        for j in range(n):\n            if j == 0 or grid[i][j - 1] == 'W':\n                row_e = row_kills(grid, i, j)\n            if i == 0 or grid[i - 1][j] == 'W':\n                col_e[j] = col_kills(grid, i, j)\n            if grid[i][j] == '0':\n                max_killed = max(max_killed, row_e + col_e[j])\n    return max_killed\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nmax_killed_enemies(grid)\n\nReturns the maximum number of killed enemies given a matrix of characters representing a battlefield. 'W' represents a wall, 'E' represents an enemy, and '0' represents an empty space."}
{"prompt": "def cosine_similarity(vec1, vec2):\n    if len(vec1) != len(vec2):\n        raise ValueError('The two vectors must be the same length. Got shape ' + str(len(vec1)) + ' and ' + str(len(vec2)))\n    norm_a = _l2_distance(vec1)\n    norm_b = _l2_distance(vec2)\n    similarity = 0.0\n    for (vec1_element, vec2_element) in zip(vec1, vec2):\n        similarity += vec1_element * vec2_element\n    similarity /= norm_a * norm_b\n    return similarity\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCalculates the cosine similarity between two vectors.\n\nParameters:\n    vec1 (list): Vector 1\n    vec2 (list): Vector 2\n\nReturns:\n    float: The cosine similarity between the two vectors\n\nRaises:\n    ValueError: If the two vectors are not the same length\n\"\"\""}
{"prompt": "def is_balanced(root):\n    return __is_balanced_recursive(root)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nRecursively check if a binary tree is balanced. A balanced binary tree is defined to be a tree such that the heights of the two subtrees of any node never differ by more than one. \n\nReturn True if the given binary tree is balanced, else return False."}
{"prompt": "def test_delete_node(self):\n    head = Node(1)\n    curr = head\n    for i in range(2, 6):\n        curr.next = Node(i)\n        curr = curr.next\n    node3 = head.next.next\n    delete_node(node3)\n    curr = head\n    self.assertEqual(1, curr.val)\n    curr = curr.next\n    self.assertEqual(2, curr.val)\n    curr = curr.next\n    self.assertEqual(4, curr.val)\n    curr = curr.next\n    self.assertEqual(5, curr.val)\n    tail = curr\n    self.assertIsNone(tail.next)\n    self.assertRaises(ValueError, delete_node, tail)\n    self.assertRaises(ValueError, delete_node, tail.next)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nTest the delete_node() function by creating a linked list, deleting a node from it, and then verifying the resulting list."}
{"prompt": "def get_cycle_index_sym(n: int) -> Polynomial:\n    if n < 0:\n        raise ValueError('n should be a non-negative integer.')\n    memo = {0: Polynomial([Monomial({}, Fraction(1, 1))]), 1: Polynomial([Monomial({1: 1}, Fraction(1, 1))]), 2: Polynomial([Monomial({1: 2}, Fraction(1, 2)), Monomial({2: 1}, Fraction(1, 2))]), 3: Polynomial([Monomial({1: 3}, Fraction(1, 6)), Monomial({1: 1, 2: 1}, Fraction(1, 2)), Monomial({3: 1}, Fraction(1, 3))]), 4: Polynomial([Monomial({1: 4}, Fraction(1, 24)), Monomial({2: 1, 1: 2}, Fraction(1, 4)), Monomial({3: 1, 1: 1}, Fraction(1, 3)), Monomial({2: 2}, Fraction(1, 8)), Monomial({4: 1}, Fraction(1, 4))])}\n    result = cycle_index_sym_helper(n, memo)\n    return result\n##############\nEND_FUNC\n##############\n", "completion": "\n\nget_cycle_index_sym(n: int) -> Polynomial:\n    \"\"\"\n    Calculates the cycle index symmetric polynomials for a given integer n.\n    Args:\n        n (int): The integer to calculate the symmetric polynomial for.\n    Returns:\n        Polynomial: The cycle index symmetric polynomial for the given integer n.\n    Raises:\n        ValueError: If n is a negative integer.\n    \"\"\""}
{"prompt": "def invert_matrix(m):\n    if not array_is_matrix(m):\n        print('Invalid matrix: array is not a matrix')\n        return [[-1]]\n    elif len(m) != len(m[0]):\n        print('Invalid matrix: matrix is not square')\n        return [[-2]]\n    elif len(m) < 2:\n        print('Invalid matrix: matrix is too small')\n        return [[-3]]\n    elif get_determinant(m) == 0:\n        print('Invalid matrix: matrix is square, but singular (determinant = 0)')\n        return [[-4]]\n    elif len(m) == 2:\n        multiplier = 1 / get_determinant(m)\n        inverted = [[multiplier] * len(m) for n in range(len(m))]\n        inverted[0][1] = inverted[0][1] * -1 * m[0][1]\n        inverted[1][0] = inverted[1][0] * -1 * m[1][0]\n        inverted[0][0] = multiplier * m[1][1]\n        inverted[1][1] = multiplier * m[0][0]\n        return inverted\n    else:\n        'some steps combined in helpers to reduce traversals'\n        m_of_minors = get_matrix_of_minors(m)\n        multiplier = fractions.Fraction(1, get_determinant(m))\n        inverted = transpose_and_multiply(m_of_minors, multiplier)\n        return inverted\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function inverts a given matrix. It returns the inverse of the matrix if it is square and non-singular, and it prints an error and returns a special matrix containing error codes if the matrix is not appropriate for inversion."}
{"prompt": "def __getitem__(self, key):\n    return self.get(key)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturn the value of the given key if present in the dictionary. If not, default to None."}
{"prompt": "def __getitem__(self, key):\n    return self.get(key)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nRetrieve an item from the mapping object associated with the given key."}
{"prompt": "def group_anagrams(strs):\n    d = {}\n    ans = []\n    k = 0\n    for str in strs:\n        sstr = ''.join(sorted(str))\n        if sstr not in d:\n            d[sstr] = k\n            k += 1\n            ans.append([])\n            ans[-1].append(str)\n        else:\n            ans[d[sstr]].append(str)\n    return ans\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"Group anagrams from an array of strings into a list of lists of anagrams.\n\nInputs:\n  strs: An array of strings\n\nOutputs:\n  ans: A list of lists of anagrams\""}
{"prompt": "def __hash__(self) -> int:\n    arr = []\n    for i in sorted(self.variables):\n        if self.variables[i] > 0:\n            for _ in range(self.variables[i]):\n                arr.append(i)\n    return hash(tuple(arr))\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Returns the hash value of a given set of variables, which is calculated by sorting the variables in ascending order and then creating a tuple from them.\"\"\""}
{"prompt": "def remove_range(head, start, end):\n    assert start <= end\n    if start == 0:\n        for i in range(0, end + 1):\n            if head != None:\n                head = head.next\n    else:\n        current = head\n        for i in range(0, start - 1):\n            current = current.next\n        for i in range(0, end - start + 1):\n            if current != None and current.next != None:\n                current.next = current.next.next\n    return head\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nRemove a range of nodes from a linked list.\n\nParameters:\nhead (ListNode): The head of the linked list.\nstart (int): The starting position of the range (inclusive).\nend (int): The ending position of the range (inclusive).\n\nReturns:\nListNode: The head of the linked list with the range of nodes removed.\n\"\"\""}
{"prompt": "def lca(root, p, q):\n    if root is None or root is p or root is q:\n        return root\n    left = lca(root.left, p, q)\n    right = lca(root.right, p, q)\n    if left is not None and right is not None:\n        return root\n    return left if left else right\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function returns the lowest common ancestor (LCA) of two nodes in a binary tree.\nIt traverses the tree recursively, first checking if the current root is either of the nodes (p or q).\nIf so, it returns the current root. Otherwise, it traverses its left and right subtrees to get the LCA of the two nodes.\nIf both the left and right subtrees have an LCA, the current root is the LCA.\nOtherwise, it returns the LCA from the subtree with an LCA.\n\"\"\""}
{"prompt": "def all_pairs_shortest_path(adjacency_matrix):\n    new_array = copy.deepcopy(adjacency_matrix)\n    size = len(new_array)\n    for k in range(size):\n        for i in range(size):\n            for j in range(size):\n                if new_array[i][j] > new_array[i][k] + new_array[k][j]:\n                    new_array[i][j] = new_array[i][k] + new_array[k][j]\n    return new_array\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nFinds the shortest paths between every pair of nodes in a graph given an adjacency matrix. Uses the Floyd-Warshall algorithm.\n\"\"\""}
{"prompt": "def max_contiguous_subsequence_sum(arr) -> int:\n    arr_size = len(arr)\n    if arr_size == 0:\n        return 0\n    max_till_now = arr[0]\n    curr_sub_sum = 0\n    for i in range(0, arr_size):\n        if curr_sub_sum + arr[i] < arr[i]:\n            curr_sub_sum = arr[i]\n        else:\n            curr_sub_sum += arr[i]\n        max_till_now = max(max_till_now, curr_sub_sum)\n    return max_till_now\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Returns the maximum sum of any contiguous sub-sequence of values in a given array of integers.\"\"\""}
{"prompt": "def bitonic_merge(arr, reverse):\n    n = len(arr)\n    if n <= 1:\n        return arr\n    arr = compare(arr, reverse)\n    left = bitonic_merge(arr[:n // 2], reverse)\n    right = bitonic_merge(arr[n // 2:], reverse)\n    return left + right\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"Merge two bitonic sequences into one bitonic sequence.\n\nParameters:\narr (list): The input sequence.\nreverse (bool): Specifies whether the order of the sequence is ascending (False) or descending (True).\n\nReturns:\nlist: The merged bitonic sequence.\""}
{"prompt": "def dfs(res, path, num, target, pos, prev, multed):\n    if pos == len(num):\n        if target == prev:\n            res.append(path)\n        return\n    for i in range(pos, len(num)):\n        if i != pos and num[pos] == '0':\n            break\n        cur = int(num[pos:i + 1])\n        if pos == 0:\n            dfs(res, path + str(cur), num, target, i + 1, cur, cur)\n        else:\n            dfs(res, path + '+' + str(cur), num, target, i + 1, prev + cur, cur)\n            dfs(res, path + '-' + str(cur), num, target, i + 1, prev - cur, -cur)\n            dfs(res, path + '*' + str(cur), num, target, i + 1, prev - multed + multed * cur, multed * cur)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function performs a depth-first search to find all possible expressions that evaluate to a given target number. The function takes in a result array, a path string, a string of numbers, a target number, a current position, a previous number, and a multiplied number. It then appends to the result array the expressions that evaluate to the target number."}
{"prompt": "def cut_rod(price):\n    n = len(price)\n    val = [0] * (n + 1)\n    for i in range(1, n + 1):\n        max_val = INT_MIN\n        for j in range(i):\n            max_val = max(max_val, price[j] + val[i - j - 1])\n        val[i] = max_val\n    return val[n]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes in an array of prices and returns the maximum total value of cutting up the rod. It uses a bottom-up approach and dynamic programming to solve the problem."}
{"prompt": "@staticmethod\ndef _create_tree(signs_frequency: dict) -> Node:\n    nodes = [Node(frequency=frequency, sign=char_int) for (char_int, frequency) in signs_frequency.items()]\n    heapq.heapify(nodes)\n    while len(nodes) > 1:\n        left = heapq.heappop(nodes)\n        right = heapq.heappop(nodes)\n        new_node = Node(frequency=left.frequency + right.frequency, left=left, right=right)\n        heapq.heappush(nodes, new_node)\n    return nodes[0]\n##############\nEND_FUNC\n##############\n", "completion": "\n\nCreate a Huffman tree from a dictionary of signs and their corresponding frequencies. Returns the root node of the tree."}
{"prompt": "def max_height(root):\n    if root is None:\n        return 0\n    height = 0\n    queue = [root]\n    while queue:\n        height += 1\n        level = []\n        while queue:\n            node = queue.pop(0)\n            if node.left is not None:\n                level.append(node.left)\n            if node.right is not None:\n                level.append(node.right)\n        queue = level\n    return height\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCalculates the maximum height of a given binary tree.\n\nParameters:\n    root (node): The root node of the binary tree.\n\nReturns:\n    int: The maximum height of the tree.\n\"\"\""}
{"prompt": "def length_longest_path(input):\n    (curr_len, max_len) = (0, 0)\n    stack = []\n    for s in input.split('\\n'):\n        print('---------')\n        print('<path>:', s)\n        depth = s.count('\\t')\n        print('depth: ', depth)\n        print('stack: ', stack)\n        print('curlen: ', curr_len)\n        while len(stack) > depth:\n            curr_len -= stack.pop()\n        stack.append(len(s.strip('\\t')) + 1)\n        curr_len += stack[-1]\n        print('stack: ', stack)\n        print('curlen: ', curr_len)\n        if '.' in s:\n            max_len = max(max_len, curr_len - 1)\n    return max_len\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function takes an input string in the form of a file path and determines the length of the longest absolute path to a file within the string. It returns an integer representing the length of the longest absolute path."}
{"prompt": "def strong_password(n, password):\n    count_error = 0\n    if any((i.isdigit() for i in password)) == False:\n        count_error = count_error + 1\n    if any((i.islower() for i in password)) == False:\n        count_error = count_error + 1\n    if any((i.isupper() for i in password)) == False:\n        count_error = count_error + 1\n    if any((i in '!@#$%^&*()-+' for i in password)) == False:\n        count_error = count_error + 1\n    return max(count_error, 6 - n)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function checks if a given password meets the requirements for a strong password. It is given a password and its length n, and it returns the number of errors needed to make the password strong."}
{"prompt": "def print_inorder(root: TreeNode, result=None):\n    if root is None:\n        return []\n    if result is None:\n        result = []\n    print_inorder(root.left, result)\n    result.append(root.val)\n    print_inorder(root.right, result)\n    return result\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function prints the elements of a binary tree in order. It takes a TreeNode (the root of the tree) and a result list (defaults to an empty list) as parameters. It recursively calls itself on the left and right branches of the tree, adding each node's value to the result list, and then returns the list when the tree has been fully traversed."}
{"prompt": "def as_list(self):\n    return list(self)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturn a list representation of the object."}
{"prompt": "def is_merge_recursive(s, part1, part2):\n    if not part1:\n        return s == part2\n    if not part2:\n        return s == part1\n    if not s:\n        return part1 + part2 == ''\n    if s[0] == part1[0] and is_merge_recursive(s[1:], part1[1:], part2):\n        return True\n    if s[0] == part2[0] and is_merge_recursive(s[1:], part1, part2[1:]):\n        return True\n    return False\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function recursively checks whether a given string (s) can be created by merging two other strings (part1 and part2). Returns True if s can be formed by merging part1 and part2, otherwise returns False."}
{"prompt": "def is_empty(self):\n    return self._top == -1\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturn a boolean indicating whether the stack has any items."}
{"prompt": "def strongconnect(self, vertex, sccs):\n    vertex.index = self.index\n    vertex.lowlink = self.index\n    self.index += 1\n    self.stack.append(vertex)\n    vertex.on_stack = True\n    for adjacent in self.graph.adjacency_list[vertex]:\n        if adjacent.index is None:\n            self.strongconnect(adjacent, sccs)\n            vertex.lowlink = min(vertex.lowlink, adjacent.lowlink)\n        elif adjacent.on_stack:\n            vertex.lowlink = min(vertex.lowlink, adjacent.index)\n    if vertex.lowlink == vertex.index:\n        scc = []\n        while True:\n            adjacent = self.stack.pop()\n            adjacent.on_stack = False\n            scc.append(adjacent)\n            if adjacent == vertex:\n                break\n        scc.sort()\n        sccs.append(scc)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function implements the strongly connected components (SCC) algorithm on a graph. It assigns a 'index' and 'lowlink' to each vertex and uses recursion to traverse the graph to identify the SCCs and append them to the 'sccs' list."}
{"prompt": "def clear_bit(num, i):\n    mask = ~(1 << i)\n    return num & mask\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function clears the bit at index `i` in the number `num`, and returns the resulting number. \nIt does this by using a bitmask that sets the value of the bit at index `i` to 0, and then using a bitwise AND operation to apply this mask to `num`."}
{"prompt": "def test_4x4(self):\n    grid1 = [['0', 'E', '0', 'E'], ['E', 'E', 'E', '0'], ['E', '0', 'W', 'E'], ['0', 'E', '0', '0']]\n    grid2 = [['0', '0', '0', 'E'], ['E', '0', '0', '0'], ['E', '0', 'W', 'E'], ['0', 'E', '0', '0']]\n    self.assertEqual(5, max_killed_enemies(grid1))\n    self.assertEqual(3, max_killed_enemies(grid2))\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"This function tests the max_killed_enemies function by comparing the expected output to the output of max_killed_enemies given two 4x4 grids of characters.\"\"\""}
{"prompt": "def binary(x, l=1):\n    fmt = '{0:0%db}' % l\n    return fmt.format(x)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"binary(x, l=1) takes an integer x and returns a binary representation of x as a string of length l\""}
{"prompt": "def first_occurrence(array, query):\n    (low, high) = (0, len(array) - 1)\n    while low <= high:\n        mid = (low + high) // 2\n        if low == high:\n            break\n        if array[mid] < query:\n            low = mid + 1\n        else:\n            high = mid\n    if array[low] == query:\n        return low\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturns the index of the first occurrence of the query in the given array, or None if the query is not present in the array. Uses binary search to find the index.\n\"\"\""}
{"prompt": "def dinic(capacity, source, sink):\n    vertices = len(capacity)\n    flow = [[0] * vertices for i in range(vertices)]\n    ret = 0\n    while True:\n        level = [-1 for i in range(vertices)]\n        work = [0 for i in range(vertices)]\n        if not dinic_bfs(capacity, flow, level, source, sink):\n            break\n        while True:\n            tmp = dinic_dfs(capacity, flow, level, source, sink, work)\n            if tmp > 0:\n                ret += tmp\n            else:\n                break\n    return ret\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function performs the Dinic's algorithm to determine the maximum flow through a graph.\nIt takes three parameters: capacity, source and sink. Capacity is a matrix representing the capacities of the edges. Source and sink are the start and end points of the graph.\nIt returns the maximum flow through the graph."}
{"prompt": "def size(self):\n    return len(self.priority_queue_list)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Returns the size of the priority queue list.\"\"\""}
{"prompt": "def schedule(job):\n    job = sorted(job, key=lambda j: j.finish)\n    length = len(job)\n    table = [0 for _ in range(length)]\n    table[0] = job[0].profit\n    for i in range(1, length):\n        incl_prof = job[i].profit\n        pos = binary_search(job, i)\n        if pos != -1:\n            incl_prof += table[pos]\n        table[i] = max(incl_prof, table[i - 1])\n    return table[length - 1]\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function takes in a job with a start and finish time and a profit associated with it. It sorts the jobs by their finish time and then uses a binary search to determine the maximum possible profit. The function returns the maximum possible profit."}
{"prompt": "def reconstruct_queue(people):\n    queue = []\n    people.sort(key=lambda x: (-x[0], x[1]))\n    for (h, k) in people:\n        queue.insert(k, [h, k])\n    return queue\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes in a list of people in the form [height, position] and returns a reconstructed queue of these people, sorted first by the height in descending order and then by the position in ascending order."}
{"prompt": "def two_sum(numbers, target):\n    for (i, number) in enumerate(numbers):\n        second_val = target - number\n        (low, high) = (i + 1, len(numbers) - 1)\n        while low <= high:\n            mid = low + (high - low) // 2\n            if second_val == numbers[mid]:\n                return [i + 1, mid + 1]\n            if second_val > numbers[mid]:\n                low = mid + 1\n            else:\n                high = mid - 1\n    return None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturns the indices of two elements in list of numbers that add up to target. If no such elements exist, None is returned. \n\"\"\""}
{"prompt": "def gcd_bit(a, b):\n    tza = trailing_zero(a)\n    tzb = trailing_zero(b)\n    a >>= tza\n    b >>= tzb\n    while b:\n        if a < b:\n            (a, b) = (b, a)\n        a -= b\n        a >>= trailing_zero(a)\n    return a << min(tza, tzb)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Calculates the greatest common divisor (gcd) of two non-negative integers using bitwise operations.\n\nParameters:\n    a (int): Non-negative integer.\n    b (int): Non-negative integer.\n\nReturns:\n    int: The greatest common divisor of a and b.\n\"\"\""}
{"prompt": "def clone_graph1(node):\n    if not node:\n        return None\n    node_copy = node.shallow_copy()\n    dic = {node: node_copy}\n    queue = collections.deque([node])\n    while queue:\n        node = queue.popleft()\n        for neighbor in node.neighbors:\n            if neighbor not in dic:\n                neighbor_copy = neighbor.shallow_copy()\n                dic[neighbor] = neighbor_copy\n                dic[node].add_neighbor(neighbor_copy)\n                queue.append(neighbor)\n            else:\n                dic[node].add_neighbor(dic[neighbor])\n    return node_copy\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nClone a graph by creating a shallow copy of each node and adding neighbors according to the original graph's connections. \nInput: node: the node that is the root of the graph. \nOutput: node_copy: the cloned graph. \n\"\"\""}
{"prompt": "def __init__(self, name):\n    self.name = name\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis is the constructor for a class. It initializes the class with a given name."}
{"prompt": "def rotate_v1(array, k):\n    array = array[:]\n    n = len(array)\n    for i in range(k):\n        temp = array[n - 1]\n        for j in range(n - 1, 0, -1):\n            array[j] = array[j - 1]\n        array[0] = temp\n    return array\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nRotate an array by k elements.\n\nParameters:\narray (list): The array to be rotated.\nk (int): The number of elements by which to rotate the array.\n\nReturns:\nlist: The rotated array."}
{"prompt": "def extended_gcd(a: int, b: int) -> [int, int, int]:\n    (old_s, s) = (1, 0)\n    (old_t, t) = (0, 1)\n    (old_r, r) = (a, b)\n    while r != 0:\n        quotient = old_r // r\n        (old_r, r) = (r, old_r - quotient * r)\n        (old_s, s) = (s, old_s - quotient * s)\n        (old_t, t) = (t, old_t - quotient * t)\n    return (old_s, old_t, old_r)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function uses the Extended Euclidean Algorithm to calculate the greatest common divisor of two integers 'a' and 'b', and returns a list containing the GCD, 's' and 't' such that 's*a + t*b = gcd(a,b)'."}
{"prompt": "def generate_key(k, seed=None):\n\n    def modinv(a, m):\n        b = 1\n        while not a * b % m == 1:\n            b += 1\n        return b\n\n    def gen_prime(k, seed=None):\n\n        def is_prime(num):\n            if num == 2:\n                return True\n            for i in range(2, int(num ** 0.5) + 1):\n                if num % i == 0:\n                    return False\n            return True\n        random.seed(seed)\n        while True:\n            key = random.randrange(int(2 ** (k - 1)), int(2 ** k))\n            if is_prime(key):\n                return key\n    p_size = k / 2\n    q_size = k - p_size\n    e = gen_prime(k, seed)\n    while True:\n        p = gen_prime(p_size, seed)\n        if p % e != 1:\n            break\n    while True:\n        q = gen_prime(q_size, seed)\n        if q % e != 1:\n            break\n    n = p * q\n    l = (p - 1) * (q - 1)\n    d = modinv(e, l)\n    return (int(n), int(e), int(d))\n##############\nEND_FUNC\n##############\n", "completion": "\n\ngenerate_key(k, seed=None)\n\n\"\"\"\nGenerates a new key with the given size k and random seed. \nReturns a tuple containing the generated modulus n, \npublic exponent e, and private exponent d. \n\"\"\""}
{"prompt": "@abstractmethod\ndef push(self, value):\n    pass\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\npush() is an abstract method that adds a value to the data structure. It takes in a value as an argument and does not return anything."}
{"prompt": "def find_path(maze):\n    cnt = dfs(maze, 0, 0, 0, -1)\n    return cnt\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nFinds the number of paths to the bottom right corner of a maze.\n\nParameters:\nmaze (2D array): a 2D array representing a maze\n\nReturns:\ncnt (int): the number of paths to the bottom right corner of the maze\n\"\"\""}
{"prompt": "def simplify_path_v2(path):\n    (stack, tokens) = ([], path.split('/'))\n    for token in tokens:\n        if token == '..' and stack:\n            stack.pop()\n        elif token != '..' and token != '.' and token:\n            stack.append(token)\n    return '/' + '/'.join(stack)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nSimplify a given file path into its shortest equivalent.\nGiven a string representing a file path, this function removes any redundant components and returns the simplified path. \nRedundant components include '.' (current directory) and '..' (parent directory). \nIf the given path is already the shortest possible, the same path is returned.\n\nArgs:\n    path (str): The file path to simplify.\n\nReturns:\n    str: The simplified path.\n\"\"\""}
{"prompt": "def longest_common_subsequence(s_1, s_2):\n    m = len(s_1)\n    n = len(s_2)\n    mat = [[0] * (n + 1) for i in range(m + 1)]\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0 or j == 0:\n                mat[i][j] = 0\n            elif s_1[i - 1] == s_2[j - 1]:\n                mat[i][j] = mat[i - 1][j - 1] + 1\n            else:\n                mat[i][j] = max(mat[i - 1][j], mat[i][j - 1])\n    return mat[m][n]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nComputes the length of the longest common subsequence between two strings s_1 and s_2 using dynamic programming.\n\"\"\""}
{"prompt": "def greedy_set_cover(universe, subsets, costs):\n    elements = set((e for s in subsets.keys() for e in subsets[s]))\n    if elements != universe:\n        return None\n    covered = set()\n    cover_sets = []\n    while covered != universe:\n        min_cost_elem_ratio = float('inf')\n        min_set = None\n        for (s, elements) in subsets.items():\n            new_elements = len(elements - covered)\n            if new_elements != 0:\n                cost_elem_ratio = costs[s] / new_elements\n                if cost_elem_ratio < min_cost_elem_ratio:\n                    min_cost_elem_ratio = cost_elem_ratio\n                    min_set = s\n        cover_sets.append(min_set)\n        covered |= subsets[min_set]\n    return cover_sets\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\ngreedy_set_cover(universe, subsets, costs)\n\nFinds a set cover of the universe (a set of subsets whose union contains all elements of the universe) \nusing a greedy algorithm.\n\nParameters:\n    universe (set): The set of elements to be covered.\n    subsets (dict): A dictionary mapping subsets to the elements they contain.\n    costs (dict): A dictionary mapping subsets to their costs.\n\nReturns:\n    list: A list of the subsets chosen for the set cover. \n    If no set cover exists, returns None. \n\"\"\""}
{"prompt": "def __init__(self):\n    self.nums = []\n    self.idxs = {}\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__(self)\n\nInitialize the data structure.\n\nCreates an empty list of numbers (self.nums) and an empty dictionary of indexes (self.idxs)."}
{"prompt": "def combination_sum_bottom_up(nums, target):\n    combs = [0] * (target + 1)\n    combs[0] = 1\n    for i in range(0, len(combs)):\n        for num in nums:\n            if i - num >= 0:\n                combs[i] += combs[i - num]\n    return combs[target]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\ncombination_sum_bottom_up(nums, target)\n\nCalculates the number of combinations for a target sum using a given set of numbers.\n\nInputs:\n    nums: A list of integers\n    target: An integer representing the target sum\n\nReturns:\n    An integer representing the number of combinations for the given target sum.\n\"\"\""}
{"prompt": "def recur_size(self, root):\n    if root is None:\n        return 0\n    else:\n        return 1 + self.recur_size(root.left) + self.recur_size(root.right)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCalculate the size of a binary tree using recursion.\n\nThis function takes a root node and recursively calculates the size of the binary tree by adding 1 for each node, plus the size of its left and right subtrees. If the root node is None, the size of the tree is 0."}
{"prompt": "def square_root(n, epsilon=0.001):\n    guess = n / 2\n    while abs(guess * guess - n) > epsilon:\n        guess = (guess + n / guess) / 2\n    return guess\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCalculates the square root of a given number using the Newton-Raphson method.\n\nParameters:\n    n (int): The number whose square root needs to be calculated.\n    epsilon (float): The maximum desired error in the calculated result (default 0.001).\n\nReturns:\n    float: The square root of n.\n\"\"\""}
{"prompt": "def rotate_clockwise(matrix):\n    new = []\n    for row in reversed(matrix):\n        for (i, elem) in enumerate(row):\n            try:\n                new[i].append(elem)\n            except IndexError:\n                new.insert(i, [])\n                new[i].append(elem)\n    return new\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nRotates a matrix clockwise by reversing each row and adding elements to a new list. Returns the rotated matrix."}
{"prompt": "def enqueue(self, value):\n    if self._rear == len(self._array):\n        self._expand()\n    self._array[self._rear] = value\n    self._rear += 1\n    self._size += 1\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nEnqueue a value to the rear of the queue. Resize the queue if necessary. Increase the size of the queue by one."}
{"prompt": "def update(pos, left, right, target, vertex):\n    if left == right:\n        tree[pos] = vertex\n        return\n    mid = left + right >> 1\n    if target <= mid:\n        vertex(pos << 1, left, mid, target, vertex)\n    else:\n        vertex(pos << 1 | 1, mid + 1, right, target, vertex)\n    tree[pos] = max(tree[pos << 1], tree[pos << 1 | 1])\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nUpdate a segment tree with a given target and vertex value. \n\nParameters:\npos (int): The current position in the segment tree.\nleft (int): The left bound of the tree.\nright (int): The right bound of the tree.\ntarget (int): The target to be updated.\nvertex (int): The vertex to be updated.\n\nReturns:\nNone\n\"\"\""}
{"prompt": "def factorial_recur(n, mod=None):\n    if not (isinstance(n, int) and n >= 0):\n        raise ValueError(\"'n' must be a non-negative integer.\")\n    if mod is not None and (not (isinstance(mod, int) and mod > 0)):\n        raise ValueError(\"'mod' must be a positive integer\")\n    if n == 0:\n        return 1\n    result = n * factorial(n - 1, mod)\n    if mod:\n        result %= mod\n    return result\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Computes the factorial of a non-negative integer 'n'. If a positive integer 'mod' is provided, the result is computed modulo 'mod'.\"\"\""}
{"prompt": "def __hash__(self):\n    return hash(self.name)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturn the hash value for the given object. The hash value is generated using the object's name."}
{"prompt": "def __eq__(self, other) -> bool:\n    return self.equal_upto_scalar(other) and self.coeff == other.coeff\n##############\nEND_FUNC\n##############\n", "completion": "\n\nCompares two objects to see if they are equal. Returns a boolean value indicating if the objects are equal."}
{"prompt": "def main():\n    formula = [(('x', False), ('y', False)), (('y', True), ('y', True)), (('a', False), ('b', False)), (('a', True), ('c', True)), (('c', False), ('b', True))]\n    result = solve_sat(formula)\n    for (variable, assign) in result.items():\n        print(f'{variable}:{assign}')\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function solves a given boolean satisfiability problem (SAT) and prints the assigned values for each variable in the given formula.\nThe formula is a list of tuples containing the variables and their assignment (True/False).\n\"\"\""}
{"prompt": "def bytes_little_endian_to_int(bytestr):\n    num = 0\n    e = 0\n    for b in bytestr:\n        num += b << e\n        e += 8\n    return num\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nConvert a byte string (in little-endian order) to an integer.\n\nParameters: \nbytestr (bytes): The byte string to convert.\n\nReturns: \nint: The corresponding integer.\n\"\"\""}
{"prompt": "def peek(self):\n    if self.is_empty():\n        raise IndexError('Stack is empty')\n    return self.head.value\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Returns the value at the top of the stack without removing it. Raises an IndexError if the stack is empty.\"\"\""}
{"prompt": "def fb(m):\n    r = (m % 3 == 0) * 'Fizz' + (m % 5 == 0) * 'Buzz'\n    return r if r != '' else m\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"This function takes in an integer m as an argument and returns 'Fizz' if the integer is divisible by 3, 'Buzz' if the integer is divisible by 5, and 'FizzBuzz' if the integer is divisible by both 3 and 5. If the integer is not divisible by either 3 or 5, the function returns the integer itself.\"\"\""}
{"prompt": "def second_switch_pairs(stack):\n    q = collections.deque()\n    for i in range(len(stack)):\n        q.append(stack.pop())\n    for i in range(len(q)):\n        stack.append(q.pop())\n    for i in range(len(stack)):\n        q.append(stack.pop())\n    for i in range(len(q)):\n        if len(q) == 0:\n            break\n        first = q.pop()\n        if len(q) == 0:\n            stack.append(first)\n            break\n        second = q.pop()\n        stack.append(second)\n        stack.append(first)\n    return stack\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nsecond_switch_pairs(stack) takes a stack (list) as an argument, and switches the pairs in the stack. \nIt first pops items from the stack and pushes them to a deque. Then it pops from the deque and pushes the items\nback to the stack. If there is an odd number of items, the last item will be appended to the stack. \nThe function then returns the stack with the pairs switched.\n\"\"\""}
{"prompt": "def encrypt(data, e, n):\n    return pow(int(data), int(e), int(n))\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nencrypt(data, e, n)\n\nDescription:\n    Encrypts data using the RSA encryption algorithm.\n\nParameters:\n    data: The data that needs to be encrypted.\n    e: The exponent used for encryption.\n    n: The modulus used for encryption.\n\nReturns:\n    The encrypted data."}
{"prompt": "def contain_string(haystack, needle):\n    if len(needle) == 0:\n        return 0\n    if len(needle) > len(haystack):\n        return -1\n    for i in range(len(haystack)):\n        if len(haystack) - i < len(needle):\n            return -1\n        if haystack[i:i + len(needle)] == needle:\n            return i\n    return -1\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function returns the index of the first occurrence of the string 'needle' in the string 'haystack'. If 'needle' is an empty string, the function will return 0. If 'needle' is longer than 'haystack' or is not present in 'haystack', the function will return -1."}
{"prompt": "def word_pattern(pattern, str):\n    dict = {}\n    set_value = set()\n    list_str = str.split()\n    if len(list_str) != len(pattern):\n        return False\n    for i in range(len(pattern)):\n        if pattern[i] not in dict:\n            if list_str[i] in set_value:\n                return False\n            dict[pattern[i]] = list_str[i]\n            set_value.add(list_str[i])\n        elif dict[pattern[i]] != list_str[i]:\n            return False\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nCheck if a given pattern and string are matching.\n\nParameters: \npattern (str): A string representing a pattern where each character is unique.\nstr (str): A string to check against the pattern.\n\nReturns: \nbool: True if str matches the pattern, False otherwise."}
{"prompt": "def _rotate_right(self, parent_node: Node, child_index: int):\n    parent_key = parent_node.keys[child_index - 1]\n    new_parent_key = parent_node.children[child_index - 1].keys.pop()\n    parent_node.children[child_index].keys.insert(0, parent_key)\n    parent_node.keys[child_index - 1] = new_parent_key\n    if not parent_node.children[child_index - 1].is_leaf:\n        ownerless_child = parent_node.children[child_index - 1].children.pop()\n        parent_node.children[child_index].children.insert(0, ownerless_child)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function rotates a node to the right. It removes the parent node's key in position child_index-1, moves the rightmost key of the left child of the parent node to the parent node, and if the left child is not a leaf, moves its rightmost child to the left child of the right child of the parent node. \n\"\"\""}
{"prompt": "def main():\n    for size in sys.stdin:\n        (vertex_count, edge_count) = map(int, size.split())\n        forest = DisjointSet(edge_count)\n        edges = [None] * edge_count\n        for i in range(edge_count):\n            (source, target, weight) = map(int, input().split())\n            source -= 1\n            target -= 1\n            edges[i] = Edge(source, target, weight)\n        print('MST weights sum:', kruskal(vertex_count, edges, forest))\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function implements Kruskal's algorithm to find the minimum spanning tree of a given graph. It takes in the number of vertices and edges, and a list of Edge objects, and uses a DisjointSet object to store the set of vertices. It prints the sum of the weights of the edges in the minimum spanning tree.\n\"\"\""}
{"prompt": "def num_trees(n):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i + 1):\n            dp[i] += dp[i - j] * dp[j - 1]\n    return dp[-1]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nnum_trees(n)\n\nReturn the number of unique binary search trees for a given 'n'.\nThis uses dynamic programming to calculate the result. \n\"\"\""}
{"prompt": "def _expand(self):\n    self._array += [None] * len(self._array)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Expands the size of the array by doubling its length.\"\"\""}
{"prompt": "def pop(self):\n    return self.priority_queue_list.pop().data\n##############\nEND_FUNC\n##############\n", "completion": "\n\nRemoves and returns the item with the highest priority from the priority queue."}
{"prompt": "@abstractmethod\ndef perc_down(self, i):\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"Perform the percolate down operation from a given node i in the heap.\n\nThis operation is done to maintain the heap property of the heap. This is done\nby comparing the value of the node with its children and if the value of the node\nis greater than its children, the node is swapped with the larger of its children. \nThis process is repeated until the heap property is satisfied.\n\"\"\""}
{"prompt": "def first_cyclic_node(head):\n    runner = walker = head\n    while runner and runner.next:\n        runner = runner.next.next\n        walker = walker.next\n        if runner is walker:\n            break\n    if runner is None or runner.next is None:\n        return None\n    walker = head\n    while runner is not walker:\n        (runner, walker) = (runner.next, walker.next)\n    return runner\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Find the first node in a cyclic linked list.\n\nGiven a head node of a linked list, this function finds the first node in the linked list which is part of a cycle.\n\nArgs:\n    head (Node): The head node of the linked list.\n\nReturns:\n    Node: The first node in the cycle, or None if the linked list is not cyclic.\n\"\"\""}
{"prompt": "def left_rotate(self, node):\n    right_node = node.right\n    if right_node is None:\n        return\n    else:\n        node.right = right_node.left\n        if right_node.left is not None:\n            right_node.left.parent = node\n        right_node.parent = node.parent\n        if node.parent is None:\n            self.root = right_node\n        elif node is node.parent.left:\n            node.parent.left = right_node\n        else:\n            node.parent.right = right_node\n        right_node.left = node\n        node.parent = right_node\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nLeft rotate a given node in a binary tree. \n\nArgs:\n    self (object): The object of the binary tree.\n    node (object): The node to be left rotated.\n\nReturns:\n    None\n\"\"\""}
{"prompt": "def search(self, word, node=None):\n    cur = node\n    if not cur:\n        cur = self.root\n    for (i, letter) in enumerate(word):\n        if letter == '.':\n            if i == len(word) - 1:\n                for child in cur.children.itervalues():\n                    if child.is_terminal:\n                        return True\n                return False\n            for child in cur.children.itervalues():\n                if self.search(word[i + 1:], child) == True:\n                    return True\n            return False\n        if letter not in cur.children:\n            return False\n        cur = cur.children[letter]\n    return cur.is_terminal\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function is used to search a given word in a Trie data structure. \nIt takes two arguments, self and word, with the optional argument node. \nIt returns True if the given word is present in the Trie, and False otherwise. \nIt also allows for wildcard searches with the '.' character."}
{"prompt": "def dfs(vertex, current_comp, vertex_scc, graph, visited):\n    visited[vertex] = True\n    vertex_scc[vertex] = current_comp\n    for adjacent in graph[vertex]:\n        if not visited[adjacent]:\n            dfs(adjacent, current_comp, vertex_scc, graph, visited)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nRecursively traverse a graph using depth-first search and assign each vertex to a strongly connected component.\n\nParameters:\nvertex (int): The current vertex to be explored.\ncurrent_comp (int): The current strongly connected component.\nvertex_scc (list): The list of vertices and their corresponding strongly connected components.\ngraph (dict): A dictionary representing the graph with adjacent vertices.\nvisited (list): A list of visited vertices.\n\"\"\""}
{"prompt": "def add_edge(graph, vertex_from, vertex_to):\n    if vertex_from not in graph:\n        graph[vertex_from] = []\n    graph[vertex_from].append(vertex_to)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nAdds an edge from vertex_from to vertex_to in the graph. If vertex_from does not exist in the graph, it will be added to the graph with an empty list as its value.\n\nParameters:\n    graph (dict): The graph to add the edge to.\n    vertex_from (any): The starting vertex of the edge.\n    vertex_to (any): The ending vertex of the edge.\n\nReturns:\n    None\n\"\"\""}
{"prompt": "def dfs(capacity, flow, visit, vertices, idx, sink, current_flow=1 << 63):\n    if idx == sink:\n        return current_flow\n    visit[idx] = True\n    for nxt in range(vertices):\n        if not visit[nxt] and flow[idx][nxt] < capacity[idx][nxt]:\n            available_flow = min(current_flow, capacity[idx][nxt] - flow[idx][nxt])\n            tmp = dfs(capacity, flow, visit, vertices, nxt, sink, available_flow)\n            if tmp:\n                flow[idx][nxt] += tmp\n                flow[nxt][idx] -= tmp\n                return tmp\n    return 0\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function implements the Depth-First Search algorithm to find the maximum flow from a given source to a given sink in a graph. It takes in 6 parameters: capacity, flow, visit, vertices, idx, and sink, and an optional parameter current_flow. It returns the maximum flow from the source to the sink, or 0 if there is no path from the source to the sink."}
{"prompt": "def minimum(self, node):\n    temp_node = node\n    while temp_node.left:\n        temp_node = temp_node.left\n    return temp_node\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"This function finds the minimum value in a binary tree, by traversing the left subtree until it finds the lowest node.\"\"\""}
{"prompt": "def min_child(self, i):\n    if 2 * i + 1 > self.current_size:\n        return 2 * i\n    if self.heap[2 * i] > self.heap[2 * i + 1]:\n        return 2 * i + 1\n    return 2 * i\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturns the index of the child node that has the minimum value for a given parent node index."}
{"prompt": "def __init__(self, file):\n    self.file = file\n    self.buffer = ''\n    self.saved_bits = 0\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__(self, file)\n\nInitialize a FileBitReader object with the given file object.\n\nArgs:\n    file: A file object opened in binary mode.\n    \nAttributes:\n    buffer (str): An empty string to hold the contents of the file.\n    saved_bits (int): An integer to store the number of saved bits.\n    file (file): The file object passed as an argument."}
{"prompt": "def krishnamurthy_number(n):\n    if n == 0:\n        return False\n    sum_of_digits = 0\n    temp = n\n    while temp != 0:\n        sum_of_digits += find_factorial(temp % 10)\n        temp //= 10\n    return sum_of_digits == n\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function checks if a given number is a Krishnamurthy Number or not. A Krishnamurthy Number is a number whose sum of the factorial of its digits is equal to the number itself.\n\nParameters:\nn (int): The number to check.\n\nReturns:\nbool: True if the number is a Krishnamurthy Number, False otherwise.\n\"\"\""}
{"prompt": "def binary_search_recur(array, low, high, val):\n    if low > high:\n        return -1\n    mid = (low + high) // 2\n    if val < array[mid]:\n        return binary_search_recur(array, low, mid - 1, val)\n    if val > array[mid]:\n        return binary_search_recur(array, mid + 1, high, val)\n    return mid\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nRecursively search for an element in a sorted array using binary search. \nInputs:\n array: A sorted array. \n low: The lower bound index of the array. \n high: The upper bound index of the array. \n val: The value to search for in the array. \n\nOutput:\n Returns the index of the element in the array if it is present, -1 otherwise. \n\"\"\""}
{"prompt": "def vector_to_index_value_list(vector):\n    return [(i, v) for (i, v) in enumerate(vector) if v != 0.0]\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturns a list of tuples, each tuple containing the index number and value of non-zero elements of the given vector."}
{"prompt": "def dfs(maze, i, j, depth, cnt):\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    row = len(maze)\n    col = len(maze[0])\n    if i == row - 1 and j == col - 1:\n        if cnt == -1:\n            cnt = depth\n        elif cnt > depth:\n            cnt = depth\n        return cnt\n    maze[i][j] = 0\n    for k in range(len(directions)):\n        nx_i = i + directions[k][0]\n        nx_j = j + directions[k][1]\n        if nx_i >= 0 and nx_i < row and (nx_j >= 0) and (nx_j < col):\n            if maze[nx_i][nx_j] == 1:\n                cnt = dfs(maze, nx_i, nx_j, depth + 1, cnt)\n    maze[i][j] = 1\n    return cnt\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function implements a Depth-First Search (DFS) algorithm on a maze and counts the number of steps taken to reach the end. It takes four parameters: maze (a 2-dimensional array representing the maze), i and j (integers representing the current row and column position in the maze), and depth (an integer representing the current depth in the DFS traversal). The function returns an integer representing the minimum number of steps taken to reach the end of the maze."}
{"prompt": "def partition(head, x):\n    left = None\n    right = None\n    prev = None\n    current = head\n    while current:\n        if int(current.val) >= x:\n            if not right:\n                right = current\n        elif not left:\n            left = current\n        else:\n            prev.next = current.next\n            left.next = current\n            left = current\n            left.next = right\n        if prev and prev.next is None:\n            break\n        prev = current\n        current = current.next\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\npartition() partitions a linked list around a given value x, such that all nodes less than x come before all nodes greater than or equal to x. \n\nThe left and right pointers are set to None initially, and the prev and current pointers are set to the head of the linked list. The function iterates through the linked list, and if the value of current is greater than or equal to x, the right pointer is set to the current node. If the value of current is less than x, the left pointer is set to current, and the current node is inserted between the left and right pointers. If the prev and current node are both None, the loop is broken. The prev and current pointers are then updated. \n\nThis function partitions the linked list around a given value x, so that all nodes less than x come before all nodes greater than or equal to x. \n\"\"\""}
{"prompt": "def delete_nth(array, n):\n    result = []\n    counts = collections.defaultdict(int)\n    for i in array:\n        if counts[i] < n:\n            result.append(i)\n            counts[i] += 1\n    return result\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\ndelete_nth(array, n)\n\nReturns an array with elements from the array 'array', with no element appearing more than 'n' times.\n\"\"\""}
{"prompt": "def two_sum2(numbers, target):\n    left = 0\n    right = len(numbers) - 1\n    while left < right:\n        current_sum = numbers[left] + numbers[right]\n        if current_sum == target:\n            return [left + 1, right + 1]\n        if current_sum > target:\n            right = right - 1\n        else:\n            left = left + 1\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\ntwo_sum2(numbers, target)\n\nGiven a list of numbers and target value, returns the indices of two numbers \nthat add up to the target. If no such indices exist, returns None. \n\"\"\""}
{"prompt": "def climb_stairs_optimized(steps):\n    a_steps = b_steps = 1\n    for _ in range(steps):\n        (a_steps, b_steps) = (b_steps, a_steps + b_steps)\n    return a_steps\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function finds the number of different ways you can climb a staircase with a given number of steps. It uses an optimized approach using dynamic programming to calculate the result in O(n) time complexity."}
{"prompt": "def __init__(self, x):\n    self.val = x\n    self.next = None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis is an initializer for a class. It takes in one argument, 'x', and assigns it to the instance variable 'val'. It also sets the instance variable 'next' to None."}
{"prompt": "def variables(self) -> Set:\n    res = set()\n    for i in self.all_monomials():\n        res |= {j for j in i.variables}\n    res = list(res)\n    return set(res)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function returns a set of all the variables in a set of monomials.\nIt takes a set of monomials as argument and returns a set of all the variables in the set."}
{"prompt": "def unique_morse(words):\n    unique_morse_word = []\n    for word in words:\n        morse_word = convert_morse_word(word)\n        if morse_word not in unique_morse_word:\n            unique_morse_word.append(morse_word)\n    return len(unique_morse_word)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes in a list of words as input and returns the number of unique morse code words in the list. It does this by looping through each word in the input list, converting it to morse code and then checking if the morse code word is already present in the list of unique morse code words. If the morse code word is not present in the list, it is added to the list. Finally, the length of the list of unique morse code words is returned."}
{"prompt": "def setUp(self):\n    self.tree = bst()\n    self.tree.insert(9)\n    self.tree.insert(6)\n    self.tree.insert(12)\n    self.tree.insert(3)\n    self.tree.insert(8)\n    self.tree.insert(10)\n    self.tree.insert(15)\n    self.tree.insert(7)\n    self.tree.insert(18)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nSet up a Binary Search Tree with initial values 9, 6, 12, 3, 8, 10, 15, 7, and 18."}
{"prompt": "@staticmethod\ndef merge(intervals):\n    out = []\n    for i in sorted(intervals, key=lambda i: i.start):\n        if out and i.start <= out[-1].end:\n            out[-1].end = max(out[-1].end, i.end)\n        else:\n            out += (i,)\n    return out\n##############\nEND_FUNC\n##############\n", "completion": "\n\nMerge overlapping intervals.\nGiven a list of intervals, merge all overlapping intervals. \nReturns a list of merged intervals."}
{"prompt": "def get_root(self):\n    return self.root\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function returns the root element of the current object."}
{"prompt": "def panagram(string):\n    letters = set(ascii_lowercase)\n    for c in string:\n        try:\n            letters.remove(c.lower())\n        except:\n            pass\n    return len(letters) == 0\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\npanagram(string)\n\nChecks if a string is a pangram (contains every letter of the alphabet once).\n\nParameters: \nstring (str): The string to check.\n\nReturns:\nbool: True if the string is a pangram, False otherwise."}
{"prompt": "def path_sum3(root, sum):\n    if root is None:\n        return []\n    res = []\n    queue = [(root, root.val, [root.val])]\n    while queue:\n        (node, val, ls) = queue.pop(0)\n        if node.left is None and node.right is None and (val == sum):\n            res.append(ls)\n        if node.left is not None:\n            queue.append((node.left, val + node.left.val, ls + [node.left.val]))\n        if node.right is not None:\n            queue.append((node.right, val + node.right.val, ls + [node.right.val]))\n    return res\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturns a list of all paths from root to leaf nodes in a binary tree whose node values sum up to the given sum.\n\nParameters:\n    root (TreeNode): The root node of the binary tree.\n    sum (int): The sum of the values of the nodes in the path.\n\nReturns:\n    list: List of paths from root to leaf nodes whose node values sum up to the given sum.\n\"\"\""}
{"prompt": "def __get_depth(root):\n    if root is None:\n        return 0\n    left = __get_depth(root.left)\n    right = __get_depth(root.right)\n    if abs(left - right) > 1 or -1 in [left, right]:\n        return -1\n    return 1 + max(left, right)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCalculates the depth of a binary tree, returning -1 if the tree is unbalanced.\n\nParameters:\nroot (Node): The root node of the binary tree.\n\nReturns:\nint: The depth of the binary tree, or -1 if the tree is unbalanced."}
{"prompt": "def matrix_exponentiation(mat: list, n: int) -> list:\n    if n == 0:\n        return identity(len(mat))\n    elif n % 2 == 1:\n        return multiply(matrix_exponentiation(mat, n - 1), mat)\n    else:\n        tmp = matrix_exponentiation(mat, n // 2)\n        return multiply(tmp, tmp)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"This function calculates the matrix to the power of n (mat^n). It takes in a matrix (mat) and an integer (n) as inputs and returns a matrix as output. It uses recursion to calculate the matrix exponentiation.\"\"\""}
{"prompt": "def bob_private_key(p):\n    return randint(1, p - 1)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function generates a random private key value for Bob, given a prime number p."}
{"prompt": "def make_sentence(str_piece, dictionaries):\n    global count\n    if len(str_piece) == 0:\n        return True\n    for i in range(0, len(str_piece)):\n        (prefix, suffix) = (str_piece[0:i], str_piece[i:])\n        if prefix in dictionaries:\n            if suffix in dictionaries or make_sentence(suffix, dictionaries):\n                count += 1\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nmake_sentence is a recursive function that checks whether a given string can be segmented into a list of valid words from a given dictionary. It takes a string and a dictionary as parameters, and returns True if the string can be segmented into a valid list of words. The global count variable is incremented each time the string is successfully segmented."}
{"prompt": "def setUp(self):\n    self.tree = bst()\n    self.tree.insert(9)\n    self.tree.insert(6)\n    self.tree.insert(12)\n    self.tree.insert(3)\n    self.tree.insert(8)\n    self.tree.insert(10)\n    self.tree.insert(15)\n    self.tree.insert(7)\n    self.tree.insert(18)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nSet up a binary search tree with the given values."}
{"prompt": "def insert(self, word):\n    current = self.root\n    for letter in word:\n        current = current.children[letter]\n    current.is_word = True\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nInsert a word into the trie data structure.\n\nArgs:\n    self (Trie): The Trie object\n    word (str): The word to be inserted into the Trie\n\nReturns:\n    None\n\"\"\""}
{"prompt": "def second_is_consecutive(stack):\n    q = collections.deque()\n    for i in range(len(stack)):\n        first_value = stack.pop()\n        if len(stack) == 0:\n            return True\n        second_value = stack.pop()\n        if first_value - second_value != 1:\n            return False\n        stack.append(second_value)\n        q.append(first_value)\n    for i in range(len(q)):\n        stack.append(q.pop())\n    for i in range(len(stack)):\n        q.append(stack.pop())\n    for i in range(len(q)):\n        stack.append(q.pop())\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes in a stack and checks if the two consecutive values are consecutive numbers. It returns True if they are, False if they are not."}
{"prompt": "def single_number2(nums):\n    (ones, twos) = (0, 0)\n    for i in range(len(nums)):\n        ones = (ones ^ nums[i]) & ~twos\n        twos = (twos ^ nums[i]) & ~ones\n    return ones\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes in an array of numbers and returns the single number in the array that appears only once. It does this by using a bitwise XOR operation to identify the single number."}
{"prompt": "def min_distance(word1, word2):\n    return len(word1) + len(word2) - 2 * lcs(word1, word2, len(word1), len(word2))\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function returns the minimum edit distance between two given words using the Longest Common Subsequence (LCS) algorithm. The edit distance is the minimum number of operations (insert, delete, replace) required to transform one word into the other."}
{"prompt": "def find_all_path(graph, start, end, path=[]):\n    path = path + [start]\n    if start == end:\n        return [path]\n    if not start in graph:\n        return []\n    paths = []\n    for node in graph[start]:\n        if node not in path:\n            newpaths = find_all_path(graph, node, end, path)\n            for newpath in newpaths:\n                paths.append(newpath)\n    return paths\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturns a list of all paths from start to end in a given graph.\n\nParameters:\ngraph (dict): A dictionary representing a graph.\nstart (any): The starting node of the path.\nend (any): The ending node of the path.\npath (list): The list of visited nodes (optional).\n\nReturns:\nlist: A list of all paths from start to end in the graph.\n\"\"\""}
{"prompt": "def strip_url_params3(url, strip=None):\n    if not strip:\n        strip = []\n    parse = urllib.parse.urlparse(url)\n    query = urllib.parse.parse_qs(parse.query)\n    query = {k: v[0] for (k, v) in query.items() if k not in strip}\n    query = urllib.parse.urlencode(query)\n    new = parse._replace(query=query)\n    return new.geturl()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Removes URL parameters from a URL.\n\nParameters:\nurl (str): URL string.\nstrip (list): List of URL parameters to be removed. Defaults to an empty list.\n\nReturns:\nstr: Modified URL string.\n\"\"\""}
{"prompt": "def is_in_cycle(graph, traversal_states, vertex):\n    if traversal_states[vertex] == TraversalState.GRAY:\n        return True\n    traversal_states[vertex] = TraversalState.GRAY\n    for neighbor in graph[vertex]:\n        if is_in_cycle(graph, traversal_states, neighbor):\n            return True\n    traversal_states[vertex] = TraversalState.BLACK\n    return False\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCheck if a vertex is part of a cycle in a graph.\n\nParameters:\ngraph (dict): A dictionary representing a graph, with the keys being the vertices and the values being a list of adjacent vertices.\ntraversal_states (dict): A dictionary representing the traversal state of each vertex, with the keys being the vertices and the values being one of TraversalState.GRAY, TraversalState.BLACK, or TraversalState.WHITE.\nvertex (any): The vertex to check if it is in a cycle.\n\nReturns:\nbool: True if the vertex is in a cycle, False otherwise.\n\"\"\""}
{"prompt": "def find_min_rotate(array):\n    low = 0\n    high = len(array) - 1\n    while low < high:\n        mid = (low + high) // 2\n        if array[mid] > array[high]:\n            low = mid + 1\n        else:\n            high = mid\n    return array[low]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nfind_min_rotate() finds the minimum element in a rotated sorted array.\n\nParameters:\n    array (list): A list of integers representing a rotated sorted array\n\nReturns:\n    int: The minimum element in the array\n\"\"\""}
{"prompt": "def _count_frequency(array, element):\n    return array.count(element)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n_count_frequency(array, element) takes an array and an element as input and returns the number of times the element appears in the array."}
{"prompt": "def __init__(self, x):\n    self.val = x\n    self.next = None\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function is a constructor for a linked list. It takes in an argument 'x', assigns it to the 'val' attribute, and sets the 'next' attribute to None."}
{"prompt": "def peek(self):\n    return self.items[len(self.items) - 1]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturn the last item in the list of items in the stack."}
{"prompt": "def setUp(self):\n    self.tree = BST()\n    self.tree.insert(10)\n    self.tree.insert(15)\n    self.tree.insert(6)\n    self.tree.insert(4)\n    self.tree.insert(9)\n    self.tree.insert(12)\n    self.tree.insert(24)\n    self.tree.insert(7)\n    self.tree.insert(20)\n    self.tree.insert(30)\n    self.tree.insert(18)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"Set up a BST with 10, 15, 6, 4, 9, 12, 24, 7, 20, 30, and 18 as its initial values.\""}
{"prompt": "def spiral_traversal(matrix):\n    res = []\n    if len(matrix) == 0:\n        return res\n    row_begin = 0\n    row_end = len(matrix) - 1\n    col_begin = 0\n    col_end = len(matrix[0]) - 1\n    while row_begin <= row_end and col_begin <= col_end:\n        for i in range(col_begin, col_end + 1):\n            res.append(matrix[row_begin][i])\n        row_begin += 1\n        for i in range(row_begin, row_end + 1):\n            res.append(matrix[i][col_end])\n        col_end -= 1\n        if row_begin <= row_end:\n            for i in range(col_end, col_begin - 1, -1):\n                res.append(matrix[row_end][i])\n        row_end -= 1\n        if col_begin <= col_end:\n            for i in range(row_end, row_begin - 1, -1):\n                res.append(matrix[i][col_begin])\n        col_begin += 1\n    return res\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nspiral_traversal takes in a matrix and returns a list of all the elements in the matrix in a spiral order."}
{"prompt": "def contains_cycle(graph):\n    traversal_states = {vertex: TraversalState.WHITE for vertex in graph}\n    for (vertex, state) in traversal_states.items():\n        if state == TraversalState.WHITE and is_in_cycle(graph, traversal_states, vertex):\n            return True\n    return False\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nChecks if the given graph contains a cycle or not.\n\nParameters:\ngraph (dict): A dictionary representing a graph. Keys represent vertices and values represent edges.\n\nReturns:\nbool: True if the graph contains a cycle, False otherwise."}
{"prompt": "@abstractmethod\ndef __iter__(self):\n    pass\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis is an abstract method that defines an iterator for the class. It must be overridden by subclasses."}
{"prompt": "def is_ready(node):\n    lst = graph.get(node, ())\n    if len(lst) == 0:\n        return True\n    for k in lst:\n        sk = state.get(k, None)\n        if sk == GRAY:\n            raise ValueError('cycle')\n        if sk != BLACK:\n            return False\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function checks if a node in a graph is ready. It checks if the node's length is 0, \nwhich indicates it has no dependencies, or if all of the node's dependencies have been visited.\nRaises a ValueError if a cycle is detected. Return True if the node is ready and False otherwise."}
{"prompt": "def write_int(self, num):\n    bin_int = '{0:08b}'.format(num)\n    self.write_bits(bin_int)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nWrites the given integer (num) to the stream, represented as 8-bit binary."}
{"prompt": "def remove_dups_wothout_set(head):\n    current = head\n    while current:\n        runner = current\n        while runner.next:\n            if runner.next.val == current.val:\n                runner.next = runner.next.next\n            else:\n                runner = runner.next\n        current = current.next\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nRemove duplicate nodes from a linked list without using a set.\n\nInputs:\nhead (Node): Head of linked list\n\nReturns:\nNone\n\"\"\""}
{"prompt": "def atbash(s):\n    translated = ''\n    for i in range(len(s)):\n        n = ord(s[i])\n        if s[i].isalpha():\n            if s[i].isupper():\n                x = n - ord('A')\n                translated += chr(ord('Z') - x)\n            if s[i].islower():\n                x = n - ord('a')\n                translated += chr(ord('z') - x)\n        else:\n            translated += s[i]\n    return translated\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\natbash(s) -> str\n\nReturns a string which is the result of the atbash cipher applied to the given string s. The atbash cipher is a simple substitution cipher which swaps the order of the letters in the alphabet."}
{"prompt": "def __init__(self, value):\n    self.value = value\n    self.next = None\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\n__init__() is the constructor for a basic linked list node.\nIt takes a single argument, 'value', which is the value of the node.\nIt sets the 'value' of the node to the argument passed and sets the 'next' of the node to None."}
{"prompt": "def scc(graph):\n    order = []\n    visited = {vertex: False for vertex in graph}\n    graph_transposed = {vertex: [] for vertex in graph}\n    for (source, neighbours) in graph.iteritems():\n        for target in neighbours:\n            add_edge(graph_transposed, target, source)\n    for vertex in graph:\n        if not visited[vertex]:\n            dfs_transposed(vertex, graph_transposed, order, visited)\n    visited = {vertex: False for vertex in graph}\n    vertex_scc = {}\n    current_comp = 0\n    for vertex in reversed(order):\n        if not visited[vertex]:\n            dfs(vertex, current_comp, vertex_scc, graph, visited)\n            current_comp += 1\n    return vertex_scc\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function takes in a graph and performs a depth-first search on its transpose, followed by a depth-first search on the original graph. It returns a dictionary containing the strongly connected components of the graph."}
{"prompt": "def __init__(self):\n    self.root = TrieNode('')\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__() is the constructor for the Trie class. It creates an instance of the Trie class and initializes the root of the Trie to an empty string."}
{"prompt": "def shallow_copy(self):\n    return UndirectedGraphNode(self.label)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCreate a shallow copy of the UndirectedGraphNode.\n\nReturns:\n    UndirectedGraphNode: A new UndirectedGraphNode with the same label as the original node. \n    The new node does not contain any edges."}
{"prompt": "def gcd(a, b):\n    a_int = isinstance(a, int)\n    b_int = isinstance(b, int)\n    a = abs(a)\n    b = abs(b)\n    if not (a_int or b_int):\n        raise ValueError('Input arguments are not integers')\n    if a == 0 or b == 0:\n        raise ValueError('One or more input arguments equals zero')\n    while b != 0:\n        (a, b) = (b, a % b)\n    return a\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Calculates the greatest common divisor of two integers.\n\nRaises a ValueError if either input is not an integer, or if one or both of the arguments equal zero.\n\nArgs:\n    a (int): The first integer.\n    b (int): The second integer.\n\nReturns:\n    int: The greatest common divisor of a and b.\n\"\"\""}
{"prompt": "def _find_largest_and_delete_in_right_subtree(self, node: Node):\n    if node.is_leaf:\n        return node.keys.pop(0)\n    else:\n        ch_index = 0\n        self._repair_tree(node, ch_index)\n        largest_key_in_subtree = self._find_largest_and_delete_in_right_subtree(node.children[0])\n        return largest_key_in_subtree\n##############\nEND_FUNC\n##############\n", "completion": "\n\nFinds and returns the largest key in a given node's right subtree, then deletes it from the tree."}
{"prompt": "def __bool__(self):\n    return self.name\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis method returns the name of the object if it is True, and False otherwise."}
{"prompt": "def __lt__(self, obj):\n    return self.name < self.get_name(obj)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function compares two objects and returns True if the name of the first object is less than the name of the second object."}
{"prompt": "def permute_recursive(nums):\n\n    def dfs(res, nums, path):\n        if not nums:\n            res.append(path)\n        for i in range(len(nums)):\n            print(nums[:i] + nums[i + 1:])\n            dfs(res, nums[:i] + nums[i + 1:], path + [nums[i]])\n    res = []\n    dfs(res, nums, [])\n    return res\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function generates all possible permutations of a list of numbers and returns them as a list. It does this recursively by appending a number to the path and removing it from the list of numbers for each iteration. "}
{"prompt": "def binary_search(array, query):\n    (low, high) = (0, len(array) - 1)\n    while low <= high:\n        mid = (high + low) // 2\n        val = array[mid]\n        if val == query:\n            return mid\n        if val < query:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nPerform a binary search on an array of items to find the index of a given query item. Returns the index of the query item if present in the array, otherwise returns None.\n\"\"\""}
{"prompt": "def count(coins, value):\n    dp_array = [1] + [0] * value\n    for coin in coins:\n        for i in range(coin, value + 1):\n            dp_array[i] += dp_array[i - coin]\n    return dp_array[value]\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nCounts the number of ways to make change for a given value using a set of coins.\n\nParameters:\n    coins (list): A list of coins to use for making change\n    value (int): The value for which to make change\n\nReturns:\n    int: The number of ways to make change for the given value using the given coins."}
{"prompt": "def decimal_to_binary_ip(ip):\n    values = ip.split('.')\n    binary_list = []\n    for val in values:\n        binary_list.append(decimal_to_binary_util(val))\n    return '.'.join(binary_list)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Convert an IP address in decimal form to binary form.\n\nThis function takes a decimal IP address as a string and returns a binary IP address as a string.\n\nArgs:\n    ip (str): An IP address in decimal form.\n\nReturns:\n    str: An IP address in binary form.\n\"\"\""}
{"prompt": "def __mul__(self, other: Union[int, float, Fraction, Monomial]):\n    if isinstance(other, int) or isinstance(other, float) or isinstance(other, Fraction):\n        result = Polynomial([])\n        monos = {m.clone() for m in self.all_monomials()}\n        for m in monos:\n            result = result.__add__(m.clone() * other)\n        return result\n    elif isinstance(other, Monomial):\n        result = Polynomial([])\n        monos = {m.clone() for m in self.all_monomials()}\n        for m in monos:\n            result = result.__add__(m.clone() * other)\n        return result\n    elif isinstance(other, Polynomial):\n        temp_self = {m.clone() for m in self.all_monomials()}\n        temp_other = {m.clone() for m in other.all_monomials()}\n        result = Polynomial([])\n        for i in temp_self:\n            for j in temp_other:\n                result = result.__add__(i * j)\n        return result\n    else:\n        raise ValueError('Can only multiple int, float, Fraction, Monomials, or Polynomials with Polynomials.')\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function multiplies two polynomials, or a polynomial and an int, float, Fraction, or Monomial together. It returns the result as a Polynomial object."}
{"prompt": "def move_zeros(array):\n    result = []\n    zeros = 0\n    for i in array:\n        if i == 0 and type(i) != bool:\n            zeros += 1\n        else:\n            result.append(i)\n    result.extend([0] * zeros)\n    return result\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nThis function takes an array as an argument and returns an array with all zeros moved to the end. Any zeros that are not of type bool are counted and added to the end of the array."}
{"prompt": "def is_merge_iterative(s, part1, part2):\n    tuple_list = [(s, part1, part2)]\n    while tuple_list:\n        (string, p1, p2) = tuple_list.pop()\n        if string:\n            if p1 and string[0] == p1[0]:\n                tuple_list.append((string[1:], p1[1:], p2))\n            if p2 and string[0] == p2[0]:\n                tuple_list.append((string[1:], p1, p2[1:]))\n        elif not p1 and (not p2):\n            return True\n    return False\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"Checks if a string can be formed by merging two parts of the string. Iterative approach.\""}
{"prompt": "@abstractmethod\ndef pop(self):\n    pass\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function is an abstract method that does nothing and has no docstring."}
{"prompt": "def text_justification(words, max_width):\n    ret = []\n    row_len = 0\n    row_words = []\n    index = 0\n    is_first_word = True\n    while index < len(words):\n        while row_len <= max_width and index < len(words):\n            if len(words[index]) > max_width:\n                raise ValueError('there exists word whose length is larger than max_width')\n            tmp = row_len\n            row_words.append(words[index])\n            tmp += len(words[index])\n            if not is_first_word:\n                tmp += 1\n            if tmp > max_width:\n                row_words.pop()\n                break\n            row_len = tmp\n            index += 1\n            is_first_word = False\n        row = ''\n        if index == len(words):\n            for word in row_words:\n                row += word + ' '\n            row = row[:-1]\n            row += ' ' * (max_width - len(row))\n        elif len(row_words) != 1:\n            space_num = max_width - row_len\n            space_num_of_each_interval = space_num // (len(row_words) - 1)\n            space_num_rest = space_num - space_num_of_each_interval * (len(row_words) - 1)\n            for j in range(len(row_words)):\n                row += row_words[j]\n                if j != len(row_words) - 1:\n                    row += ' ' * (1 + space_num_of_each_interval)\n                if space_num_rest > 0:\n                    row += ' '\n                    space_num_rest -= 1\n        else:\n            row += row_words[0]\n            row += ' ' * (max_width - len(row))\n        ret.append(row)\n        row_len = 0\n        row_words = []\n        is_first_word = True\n    return ret\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function takes a list of words and a maximum width as parameters and returns a list of text-justified strings, given the parameters. Each string in the returned list is no longer than the given maximum width."}
{"prompt": "def array_is_matrix(m):\n    if len(m) == 0:\n        return False\n    first_col = len(m[0])\n    for row in m:\n        if len(row) != first_col:\n            return False\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nChecks if the given array is a matrix.\n\nParameters:\nm (array): The array to check.\n\nReturns:\nbool: True if the array is a matrix, otherwise False."}
{"prompt": "def initialize_single_source(graph, source, weight, pre_node):\n    for node in graph:\n        weight[node] = float('inf')\n        pre_node[node] = None\n    weight[source] = 0\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function initializes the weights and predecessor nodes for each node in a graph, with the source node's weight set to 0.\n\nParameters:\n    graph (list): A list of all nodes in the graph.\n    source (node): The source node.\n    weight (dict): A dictionary containing the weights of each node in the graph.\n    pre_node (dict): A dictionary containing the predecessors of each node in the graph.\n\nReturns:\n    None."}
{"prompt": "def generate_parenthesis_v1(n):\n\n    def add_pair(res, s, left, right):\n        if left == 0 and right == 0:\n            res.append(s)\n            return\n        if right > 0:\n            add_pair(res, s + ')', left, right - 1)\n        if left > 0:\n            add_pair(res, s + '(', left - 1, right + 1)\n    res = []\n    add_pair(res, '', n, 0)\n    return res\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function generates all well-formed parentheses strings of length 2n given n pairs of parentheses. It takes in an integer n and returns a list of strings with all possible valid parentheses of length 2n."}
{"prompt": "def get_code_tree(T):\n    nonlocal tree_code\n    if T.sign is not None:\n        signs.append(T.sign)\n    if T.left:\n        tree_code += '0'\n        get_code_tree(T.left)\n    if T.right:\n        tree_code += '1'\n        get_code_tree(T.right)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function traverses a given \"T\" binary tree and stores the tree code in a nonlocal variable \"tree_code\". It stores the signs of each node of the tree in a list \"signs\" and appends a 0 or 1 to the \"tree_code\" depending on the left or right nodes of the tree."}
{"prompt": "def __init__(self, x):\n    self.val = x\n    self.next = None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__(self, x) is a constructor for a linked list node, which initializes the node with the value x and sets the next node pointer to None."}
{"prompt": "def __init__(self):\n    super().__init__()\n    self._front = None\n    self._rear = None\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function is the constructor for a class. It initializes the class by setting the front and rear attributes of the class to None."}
{"prompt": "def next_bigger(num):\n    digits = [int(i) for i in str(num)]\n    idx = len(digits) - 1\n    while idx >= 1 and digits[idx - 1] >= digits[idx]:\n        idx -= 1\n    if idx == 0:\n        return -1\n    pivot = digits[idx - 1]\n    swap_idx = len(digits) - 1\n    while pivot >= digits[swap_idx]:\n        swap_idx -= 1\n    (digits[swap_idx], digits[idx - 1]) = (digits[idx - 1], digits[swap_idx])\n    digits[idx:] = digits[:idx - 1:-1]\n    return int(''.join((str(x) for x in digits)))\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nnext_bigger(num):\n    Returns the next bigger number formed from the same digits as the given number. \n    If none exists, -1 is returned. \n\"\"\""}
{"prompt": "def __init__(self, val, left=None, right=None):\n    self.val = val\n    self.left = left\n    self.right = right\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nInitialize a new binary tree node with the given value and optional left/right child nodes.\n\"\"\""}
{"prompt": "def num_islands(positions):\n    ans = []\n    islands = Union()\n    for position in map(tuple, positions):\n        islands.add(position)\n        for delta in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n            adjacent = (position[0] + delta[0], position[1] + delta[1])\n            if adjacent in islands.parents:\n                islands.unite(position, adjacent)\n        ans += [islands.count]\n    return ans\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nnum_islands() returns a list of numbers representing the number of islands after each position in the given list of positions has been added. The list of positions is a list of coordinates, and the number of islands is determined by joining adjacent positions."}
{"prompt": "def get_byte(self):\n    if self._load_byte():\n        byte_list = self.buffer[:8]\n        self.buffer = self.buffer[8:]\n        return ''.join(byte_list)\n    else:\n        return -1\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function attempts to get the next byte from the buffer. If the buffer contains 8 or more bits, the first 8 bits of the buffer are returned as a string and the buffer is truncated to exclude those bits. If the buffer contains fewer than 8 bits, -1 is returned."}
{"prompt": "def peek(self):\n    if self.is_empty():\n        raise IndexError('Stack is empty')\n    return self._array[self._top]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Return the top element from the stack without removing it.\"\"\""}
{"prompt": "def __init__(self, value):\n    self.value = value\n    self.next = None\n    self.prev = None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__(self, value) is a function that initializes a new Node object with the given value. It sets the next and prev values for the Node object to None."}
{"prompt": "def longest_consecutive(root):\n    if root is None:\n        return 0\n    max_len = 0\n    dfs(root, 0, root.val, max_len)\n    return max_len\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function finds the length of the longest consecutive sequence path in a binary tree. It takes in the root node of the tree as an argument, and returns the length of the longest consecutive sequence in the tree."}
{"prompt": "def swap(i, j):\n    (arr[i], arr[j]) = (arr[j], arr[i])\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function swaps the elements at indexes i and j in an array arr."}
{"prompt": "def hosoya_testing(height):\n    res = []\n    for i in range(height):\n        for j in range(i + 1):\n            res.append(hosoya(i, j))\n    return res\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes in a height and returns a list of Hosoya numbers up to that height. The Hosoya numbers are calculated using the Hosoya Triangle."}
{"prompt": "def test_count_left_node(self):\n    self.assertEqual(4, count_left_node(self.tree.root))\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\" Counts the number of left nodes of a binary tree. \n\nInputs: \nself (object): Instance of the tree object. \n\nReturns: \nnumber (int): Number of left nodes in the tree. \"\"\""}
{"prompt": "def intersection(h1, h2):\n    count = 0\n    flag = None\n    h1_orig = h1\n    h2_orig = h2\n    while h1 or h2:\n        count += 1\n        if not flag and (h1.next is None or h2.next is None):\n            flag = (count, h1.next, h2.next)\n        if h1:\n            h1 = h1.next\n        if h2:\n            h2 = h2.next\n    long_len = count\n    short_len = flag[0]\n    if flag[1] is None:\n        shorter = h1_orig\n        longer = h2_orig\n    elif flag[2] is None:\n        shorter = h2_orig\n        longer = h1_orig\n    while longer and shorter:\n        while long_len > short_len:\n            longer = longer.next\n            long_len -= 1\n        if longer == shorter:\n            return longer\n        else:\n            longer = longer.next\n            shorter = shorter.next\n    return None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes two linked list heads (h1 and h2) as inputs and returns the node at which the two linked lists intersect (if they intersect at all). If there is no intersection it will return None."}
{"prompt": "def euler_totient(n):\n    result = n\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            while n % i == 0:\n                n //= i\n            result -= result // i\n    if n > 1:\n        result -= result // n\n    return result\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nComputes Euler's totient function of n.\n\nEuler's totient function is a function that counts the number of positive \nintegers up to a given integer n that are relatively prime to n.\n\nParameters:\nn (int): The number to compute the totient of.\n\nReturns:\nint: The Euler totient of n.\n\"\"\""}
{"prompt": "def setUp(self):\n    self.tree = bst()\n    self.tree.insert(9)\n    self.tree.insert(6)\n    self.tree.insert(12)\n    self.tree.insert(3)\n    self.tree.insert(8)\n    self.tree.insert(10)\n    self.tree.insert(15)\n    self.tree.insert(7)\n    self.tree.insert(18)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"Set up a binary search tree with 9, 6, 12, 3, 8, 10, 15, 7, and 18.\""}
{"prompt": "def fizzbuzz_with_helper_func(n):\n    return [fb(m) for m in range(1, n + 1)]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes a number n and returns a list of the numbers from 1 to n, \nwith each element in the list replaced with either 'fizz', 'buzz', or 'fizzbuzz' \naccording to the rules of the classic programming challenge 'fizzbuzz'. \nIt uses a helper function fb() to determine the appropriate string for each number."}
{"prompt": "def fix_insert(self, node):\n    if node.parent is None:\n        node.color = 0\n        self.root = node\n        return\n    while node.parent and node.parent.color == 1:\n        if node.parent is node.parent.parent.left:\n            uncle_node = node.parent.parent.right\n            if uncle_node and uncle_node.color == 1:\n                node.parent.color = 0\n                node.parent.parent.right.color = 0\n                node.parent.parent.color = 1\n                node = node.parent.parent\n                continue\n            elif node is node.parent.right:\n                node = node.parent\n                self.left_rotate(node)\n            node.parent.color = 0\n            node.parent.parent.color = 1\n            self.right_rotate(node.parent.parent)\n        else:\n            uncle_node = node.parent.parent.left\n            if uncle_node and uncle_node.color == 1:\n                node.parent.color = 0\n                node.parent.parent.left.color = 0\n                node.parent.parent.color = 1\n                node = node.parent.parent\n                continue\n            elif node is node.parent.left:\n                node = node.parent\n                self.right_rotate(node)\n            node.parent.color = 0\n            node.parent.parent.color = 1\n            self.left_rotate(node.parent.parent)\n    self.root.color = 0\n##############\nEND_FUNC\n##############\n", "completion": "\n\nFix insert to maintain the Red-Black Tree properties. The function will check the node's parent and uncle's color, and do the appropriate rotations and color changes to maintain the tree's properties."}
{"prompt": "def add_pair(res, s, left, right):\n    if left == 0 and right == 0:\n        res.append(s)\n    if left > 0:\n        add_pair(res, s + '(', left - 1, right)\n    if right > 0 and left < right:\n        add_pair(res, s + ')', left, right - 1)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nAdds valid parenthesis pairings to the res list given a starting string s, the number of left parenthesis left, and the number of right parenthesis left. \n\"\"\""}
{"prompt": "def is_rotated(s1, s2):\n    if len(s1) == len(s2):\n        return s2 in s1 + s1\n    else:\n        return False\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nChecks if string s1 is a rotated version of string s2. Returns True if s2 is rotation of s1, False otherwise. \n\"\"\""}
{"prompt": "def dfs(grid, matrix, height, i, j):\n    if i < 0 or i >= len(matrix) or j < 0 or (j >= len(matrix[0])):\n        return\n    if grid[i][j] or matrix[i][j] < height:\n        return\n    grid[i][j] = True\n    dfs(grid, matrix, matrix[i][j], i - 1, j)\n    dfs(grid, matrix, matrix[i][j], i + 1, j)\n    dfs(grid, matrix, matrix[i][j], i, j - 1)\n    dfs(grid, matrix, matrix[i][j], i, j + 1)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nRecursively traverse a grid of values to determine all cells with a value greater than or equal to a given height.\n\nParameters:\ngrid (list of lists): a 2D grid of booleans representing which cells have already been visited\nmatrix (list of lists): a 2D grid of integers representing the values of each cell\nheight (int): the value to compare against\ni (int): the x coordinate of the cell to be evaluated\nj (int): the y coordinate of the cell to be evaluated\n\nReturns:\nNone\n\"\"\""}
{"prompt": "def longest_increasing_subsequence_optimized(sequence):\n    max_seq = max(sequence)\n    tree = [0] * (max_seq << 2)\n\n    def update(pos, left, right, target, vertex):\n        if left == right:\n            tree[pos] = vertex\n            return\n        mid = left + right >> 1\n        if target <= mid:\n            update(pos << 1, left, mid, target, vertex)\n        else:\n            update(pos << 1 | 1, mid + 1, right, target, vertex)\n        tree[pos] = max_seq(tree[pos << 1], tree[pos << 1 | 1])\n\n    def get_max(pos, left, right, start, end):\n        if left > end or right < start:\n            return 0\n        if left >= start and right <= end:\n            return tree[pos]\n        mid = left + right >> 1\n        return max_seq(get_max(pos << 1, left, mid, start, end), get_max(pos << 1 | 1, mid + 1, right, start, end))\n    ans = 0\n    for element in sequence:\n        cur = get_max(1, 0, max_seq, 0, element - 1) + 1\n        ans = max_seq(ans, cur)\n        update(1, 0, max_seq, element, cur)\n    return ans\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function finds the longest increasing subsequence in a sequence using an optimized tree-based approach. It takes in a sequence as an argument and returns the length of the longest increasing subsequence."}
{"prompt": "def remove_bit(num, i):\n    mask = num >> i + 1\n    mask = mask << i\n    right = (1 << i) - 1 & num\n    return mask | right\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nremove_bit(num, i) takes in a number (num) and an index (i) as parameters and removes the bit at index (i) from number (num). It returns the number with the bit at index (i) removed."}
{"prompt": "def multiply(self, a, b):\n    if a is None or b is None:\n        return None\n    (m, n) = (len(a), len(b[0]))\n    if len(b) != n:\n        raise Exception(\"A's column number must be equal to B's row number.\")\n    l = len(b[0])\n    (table_a, table_b) = ({}, {})\n    for (i, row) in enumerate(a):\n        for (j, ele) in enumerate(row):\n            if ele:\n                if i not in table_a:\n                    table_a[i] = {}\n                table_a[i][j] = ele\n    for (i, row) in enumerate(b):\n        for (j, ele) in enumerate(row):\n            if ele:\n                if i not in table_b:\n                    table_b[i] = {}\n                table_b[i][j] = ele\n    c = [[0 for j in range(l)] for i in range(m)]\n    for i in table_a:\n        for k in table_a[i]:\n            if k not in table_b:\n                continue\n            for j in table_b[k]:\n                c[i][j] += table_a[i][k] * table_b[k][j]\n    return c\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function multiplies two sparse matrices, 'a' and 'b', together and returns the result as a new sparse matrix 'c'. It checks that the columns of 'a' and the rows of 'b' have the same length, and raises an exception if they do not. It then uses two dictionaries to store non-zero values in 'a' and 'b', and iterates over them to do the multiplication. \n\"\"\""}
{"prompt": "def __init__(self):\n    self.root = None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__() is a constructor method for the class that initializes the root attribute to None."}
{"prompt": "def insert(self, key):\n    node = TreeNode(key)\n    if not self.node:\n        self.node = node\n        self.node.left = AvlTree()\n        self.node.right = AvlTree()\n    elif key < self.node.val:\n        self.node.left.insert(key)\n    elif key > self.node.val:\n        self.node.right.insert(key)\n    self.re_balance()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nInserts a given key into the AVL tree. Inserts a new TreeNode with the given key, and then rebalances the tree. \n\"\"\""}
{"prompt": "def first_unique_char(s):\n    if len(s) == 1:\n        return 0\n    ban = []\n    for i in range(len(s)):\n        if all((s[i] != s[k] for k in range(i + 1, len(s)))) == True and s[i] not in ban:\n            return i\n        else:\n            ban.append(s[i])\n    return -1\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nFind the index of the first unique character in a given string.\n\nParameters:\ns (str): The given string.\n\nReturns:\nint: The index of the first unique character, or -1 if there is none."}
{"prompt": "def multiply(self, a, b):\n    if a is None or b is None:\n        return None\n    (m, n, l) = (len(a), len(a[0]), len(b[0]))\n    if len(b) != n:\n        raise Exception(\"A's column number must be equal to B's row number.\")\n    c = [[0 for _ in range(l)] for _ in range(m)]\n    table_b = {}\n    for (k, row) in enumerate(b):\n        table_b[k] = {}\n        for (j, eleB) in enumerate(row):\n            if eleB:\n                table_b[k][j] = eleB\n    for (i, row) in enumerate(a):\n        for (k, eleA) in enumerate(row):\n            if eleA:\n                for (j, eleB) in table_b[k].iteritems():\n                    c[i][j] += eleA * eleB\n    return c\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function performs matrix multiplication on two given matrices, a and b, and returns the resulting matrix. A's column number must be equal to B's row number, otherwise an exception is raised. If either a or b is None, the function will return None."}
{"prompt": "def word_squares(words):\n    n = len(words[0])\n    fulls = collections.defaultdict(list)\n    for word in words:\n        for i in range(n):\n            fulls[word[:i]].append(word)\n\n    def build(square):\n        if len(square) == n:\n            squares.append(square)\n            return\n        prefix = ''\n        for k in range(len(square)):\n            prefix += square[k][len(square)]\n        for word in fulls[prefix]:\n            build(square + [word])\n    squares = []\n    for word in words:\n        build([word])\n    return squares\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function takes a list of words and returns a list of all unique word squares formed from the words. A word square is a sequence of words such that the same string can be read both horizontally and vertically."}
{"prompt": "def __init__(self, node_from, node_to):\n    self.source = node_from\n    self.target = node_to\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis is the constructor for the Edge class. It takes two parameters, a source node and a target node, and sets the instance variables source and target to the corresponding nodes."}
{"prompt": "def decimal_to_binary_util(val):\n    bits = [128, 64, 32, 16, 8, 4, 2, 1]\n    val = int(val)\n    binary_rep = ''\n    for bit in bits:\n        if val >= bit:\n            binary_rep += str(1)\n            val -= bit\n        else:\n            binary_rep += str(0)\n    return binary_rep\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes in an integer value as input and returns its binary representation as a string. It does this by iterating through a list of bits and subtracting them from the input value until it reaches 0."}
{"prompt": "def __repr__(self):\n    return 'Interval ({}, {})'.format(self.start, self.end)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"Returns a string representation of the Interval object in the form of 'Interval (start, end)'\""}
{"prompt": "def find_all_cliques(edges):\n\n    def expand_clique(candidates, nays):\n        nonlocal compsub\n        if not candidates and (not nays):\n            nonlocal solutions\n            solutions.append(compsub.copy())\n        else:\n            for selected in candidates.copy():\n                candidates.remove(selected)\n                candidates_temp = get_connected(selected, candidates)\n                nays_temp = get_connected(selected, nays)\n                compsub.append(selected)\n                expand_clique(candidates_temp, nays_temp)\n                nays.add(compsub.pop())\n\n    def get_connected(vertex, old_set):\n        new_set = set()\n        for neighbor in edges[str(vertex)]:\n            if neighbor in old_set:\n                new_set.add(neighbor)\n        return new_set\n    compsub = []\n    solutions = []\n    possibles = set(edges.keys())\n    expand_clique(possibles, set())\n    return solutions\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nfind_all_cliques() finds all complete subgraphs (cliques) in a graph represented by a dictionary of edges. \nIt takes an argument 'edges', which is a dictionary of edges connecting each vertex in the graph. \nReturns a list of subgraphs (cliques) represented as lists of vertices."}
{"prompt": "def insert(self, data):\n    if self.root:\n        return self.recur_insert(self.root, data)\n    else:\n        self.root = Node(data)\n        return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nInsert a new node into a binary search tree.\n\nArgs:\n    self (object): The binary search tree object.\n    data (int): The data to insert into the tree.\n\nReturns:\n    bool: True if insertion is successful, False otherwise.\n\"\"\""}
{"prompt": "def int_divide(decompose):\n    arr = [[0 for i in range(decompose + 1)] for j in range(decompose + 1)]\n    arr[1][1] = 1\n    for i in range(1, decompose + 1):\n        for j in range(1, decompose + 1):\n            if i < j:\n                arr[i][j] = arr[i][i]\n            elif i == j:\n                arr[i][j] = 1 + arr[i][j - 1]\n            else:\n                arr[i][j] = arr[i][j - 1] + arr[i - j][j]\n    return arr[decompose][decompose]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function returns the number of ways to decompose a given number into a sum of positive integers. It uses a 2D array to store and calculate the number of ways to decompose a given number."}
{"prompt": "def _get_bit_sum(bitsum, val, sign):\n    i = 0\n    if sign == '+':\n        while val:\n            bitsum[i] += val & 1\n            i += 1\n            val >>= 1\n    else:\n        while val:\n            bitsum[i] -= val & 1\n            i += 1\n            val >>= 1\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function updates a given bitsum array based on a given value and sign. It iterates through the value, adding or subtracting one to the corresponding index in the bitsum array depending on the sign."}
{"prompt": "def partition(arr, first, last):\n    wall = first\n    for pos in range(first, last):\n        if arr[pos] < arr[last]:\n            (arr[pos], arr[wall]) = (arr[wall], arr[pos])\n            wall += 1\n    (arr[wall], arr[last]) = (arr[last], arr[wall])\n    return wall\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nPartition a given array around a pivot element.\n\nParameters: \narr (list): The array to be partitioned.\nfirst (int): The index of the first element of the array.\nlast (int): The index of the last element of the array.\n\nReturns: \nwall (int): The index of the pivot element after partitioning.\n\"\"\""}
{"prompt": "def backtrack(constructed_sofar=[], res=[]):\n    (to_stop, reached_target) = over(constructed_sofar)\n    if to_stop:\n        if reached_target:\n            res.append(constructed_sofar)\n        return\n    candidates = construct_candidates(constructed_sofar)\n    for candidate in candidates:\n        constructed_sofar.append(candidate)\n        backtrack(constructed_sofar[:], res)\n        constructed_sofar.pop()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nRecursively build a list of all possible solutions to a problem by constructing candidates, checking them against a set of constraints, and backtracking if a constraint is violated.\n\nParameters\nconstructed_sofar (list): The current list of items in the solution.\nres (list): The list of complete solutions.\n\nReturns\nres (list): The list of complete solutions.\n\"\"\""}
{"prompt": "def count_paths(m, n):\n    if m < 1 or n < 1:\n        return -1\n    count = [[None for j in range(n)] for i in range(m)]\n    for i in range(n):\n        count[0][i] = 1\n    for j in range(m):\n        count[j][0] = 1\n    for i in range(1, m):\n        for j in range(1, n):\n            count[i][j] = count[i - 1][j] + count[i][j - 1]\n    print(count[m - 1][n - 1])\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\ncount_paths(m, n) takes two positive integers m and n and prints the number of paths from the top-left corner to the bottom-right corner in an m x n grid.\n\"\"\""}
{"prompt": "def reverse_list(head):\n    if not head or not head.next:\n        return head\n    prev = None\n    while head:\n        current = head\n        head = head.next\n        current.next = prev\n        prev = current\n    return prev\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReverses the order of a given linked list.\n\nInputs: \nhead (Node): The head of a linked list\n\nReturns:\nNode: The head of the reversed linked list\n\"\"\""}
{"prompt": "def _rehash(self, old_hash):\n    return (old_hash + 1) % self.size\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function takes a hash and increases it by one, then returns the result modulo the size of the hash table."}
{"prompt": "def substitute(self, substitutions: Union[int, float, Fraction, Dict[int, Union[int, float, Fraction]]]) -> Fraction:\n    if isinstance(substitutions, int) or isinstance(substitutions, float) or isinstance(substitutions, Fraction):\n        substitutions = {v: Monomial._rationalize_if_possible(substitutions) for v in self.all_variables()}\n    elif not self.all_variables().issubset(set(substitutions.keys())):\n        raise ValueError(\"Some variables didn't receive their values.\")\n    if self.coeff == 0:\n        return Fraction(0, 1)\n    ans = Monomial._rationalize_if_possible(self.coeff)\n    for k in self.variables:\n        ans *= Monomial._rationalize_if_possible(substitutions[k] ** self.variables[k])\n    return Monomial._rationalize_if_possible(ans)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function takes in a substitution of integers, floats, or fractions and returns a fraction. It substitutes values for all variables in the monomial, then returns the result as a fraction."}
{"prompt": "def min_distance(self, dist, min_dist_set):\n    min_dist = float('inf')\n    for target in range(self.vertex_count):\n        if min_dist_set[target]:\n            continue\n        if dist[target] < min_dist:\n            min_dist = dist[target]\n            min_index = target\n    return min_index\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function finds the minimum distance from the given source to a specific vertex in the graph. It takes in the distance array, dist, and the min_dist_set array as parameters. It returns the index of the target vertex which has the minimum distance from the source."}
{"prompt": "def longest_common_prefix_v3(strs):\n    if not strs:\n        return ''\n    return longest_common(strs, 0, len(strs) - 1)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nFind the longest common prefix string amongst an array of strings.\n\nThis function takes a list of strings (strs) as input and returns the longest common prefix string found in the list. If the list is empty, the function returns an empty string. Otherwise, the function calls the longest_common() function with the list, the starting index of 0, and the ending index of the last element in the list."}
{"prompt": "def _repair_tree(self, node: Node, child_index: int) -> bool:\n    child = node.children[child_index]\n    if self.min_numbers_of_keys < len(child.keys) <= self.max_number_of_keys:\n        return False\n    if child_index > 0 and len(node.children[child_index - 1].keys) > self.min_numbers_of_keys:\n        self._rotate_right(node, child_index)\n        return True\n    if child_index < len(node.children) - 1 and len(node.children[child_index + 1].keys) > self.min_numbers_of_keys:\n        self._rotate_left(node, child_index)\n        return True\n    if child_index > 0:\n        self._merge(node, child_index - 1, child_index)\n    else:\n        self._merge(node, child_index, child_index + 1)\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nTry to repair the specified child node of the given node. Return True if a repair was done, False if the child was fine. The repair will either be a rotation or a merge.\n\"\"\""}
{"prompt": "def factor(n, i, combi, res):\n    while i * i <= n:\n        if n % i == 0:\n            res += (combi + [i, int(n / i)],)\n            factor(n / i, i, combi + [i], res)\n        i += 1\n    return res\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function finds all the different factor combinations of a number n and stores them in a tuple. \nThe function takes in four parameters: n (the number to factor), i (the first number to divide n by), \ncombi (the current combination of factors), and res (the result tuple). \nIt returns the result tuple containing all the factor combinations of n."}
{"prompt": "def subsets(nums):\n\n    def backtrack(res, nums, stack, pos):\n        if pos == len(nums):\n            res.append(list(stack))\n        else:\n            stack.append(nums[pos])\n            backtrack(res, nums, stack, pos + 1)\n            stack.pop()\n            backtrack(res, nums, stack, pos + 1)\n    res = []\n    backtrack(res, nums, [], 0)\n    return res\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes in a list of numbers and returns all possible subsets of the list. It uses a backtracking approach to build the subsets."}
{"prompt": "def _reset(self, found=''):\n    self.found = found\n    self.current_node = self.root\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Reset the trie object, setting the found string to the specified value and the current node to the root node\"\"\""}
{"prompt": "def findMetadata(d, keys, defaultValue):\n    v = None\n    for key in keys:\n        v = d.get(key, None)\n        k = key.lower()\n        if v is not None:\n            return v\n        for (dk, dv) in d.items():\n            dkm = dk.lower().replace(' ', '')\n            if dkm == key.lower():\n                return dv\n            dkm = dkm.split(':')[-1]\n            dkm = dkm.split('/')[-1]\n            if dkm == k:\n                return dv\n    return defaultValue\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nfindMetadata(d, keys, defaultValue)\n\nFinds the corresponding value for a given set of keys from a dictionary. \nIf the key is not found, the 'defaultValue' is returned.\n\nParameters:\nd (dict): The dictionary to search in.\nkeys (list): A set of keys to lookup in the dictionary.\ndefaultValue: The default value to return if the key is not found.\n\nReturns:\nThe corresponding value for the key, or the defaultValue if the key is not found.\n\"\"\""}
{"prompt": "@Slot()\ndef endModification(self):\n    assert self._modificationCount > 0\n    self._modificationCount -= 1\n    self._undoStack.endMacro()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nEnds a modification by decrementing the modification count and calling endMacro() on the undo stack."}
{"prompt": "def outEdges(self, attribute):\n    return [edge for edge in self.edges if edge.src == attribute]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\noutEdges(self, attribute):\n    Return a list of edges for which the source node is the given attribute.\n    Args:\n        self (object): the object which this method is called on\n        attribute (object): the attribute to search for in the source node\n    Returns:\n        list: a list of edges that have the given attribute in their source node\n\"\"\""}
{"prompt": "def redoImpl(self):\n    self.graph.removeEdge(self.graph.attribute(self.dstAttr))\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Redo the implementation by removing the edge attribute from the graph and returning true.\"\"\""}
{"prompt": "def setFiles(self, files):\n    with self._mutex:\n        self._files = files\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function sets the files property of the object to the given files. It is thread-safe using a mutex lock."}
{"prompt": "@classmethod\ndef update(cls, node):\n    if not isinstance(node.nodeDesc, cls):\n        raise ValueError('Node {} is not an instance of type {}'.format(node, cls))\n    if 'userNbBrackets' not in node.getAttributes().keys():\n        return\n    if node.userNbBrackets.value != 0:\n        node.nbBrackets.value = node.userNbBrackets.value\n        return\n    cameraInitOutput = node.input.getLinkParam(recursive=True)\n    if not cameraInitOutput:\n        node.nbBrackets.value = 0\n        return\n    if not cameraInitOutput.node.hasAttribute('viewpoints'):\n        if cameraInitOutput.node.hasAttribute('input'):\n            cameraInitOutput = cameraInitOutput.node.input.getLinkParam(recursive=True)\n    if cameraInitOutput and cameraInitOutput.node and cameraInitOutput.node.hasAttribute('viewpoints'):\n        viewpoints = cameraInitOutput.node.viewpoints.value\n    else:\n        node.nbBrackets.value = 0\n        return\n    inputs = []\n    for viewpoint in viewpoints:\n        jsonMetadata = viewpoint.metadata.value\n        if not jsonMetadata:\n            node.nbBrackets.value = 0\n            return\n        d = json.loads(jsonMetadata)\n        fnumber = findMetadata(d, ['FNumber', 'Exif:ApertureValue', 'ApertureValue', 'Aperture'], '')\n        shutterSpeed = findMetadata(d, ['Exif:ShutterSpeedValue', 'ShutterSpeedValue', 'ShutterSpeed'], '')\n        iso = findMetadata(d, ['Exif:ISOSpeedRatings', 'ISOSpeedRatings', 'ISO'], '')\n        if not fnumber and (not shutterSpeed):\n            node.nbBrackets.value = 1\n            return\n        inputs.append((viewpoint.path.value, (fnumber, shutterSpeed, iso)))\n    inputs.sort()\n    exposureGroups = []\n    exposures = []\n    for (path, exp) in inputs:\n        if exposures and exp != exposures[-1] and (exp == exposures[0]):\n            exposureGroups.append(exposures)\n            exposures = [exp]\n        else:\n            exposures.append(exp)\n    exposureGroups.append(exposures)\n    exposures = None\n    bracketSizes = set()\n    if len(exposureGroups) == 1:\n        if len(set(exposureGroups[0])) == 1:\n            node.nbBrackets.value = 1\n        else:\n            node.nbBrackets.value = len(exposureGroups[0])\n    else:\n        for expGroup in exposureGroups:\n            bracketSizes.add(len(expGroup))\n        if len(bracketSizes) == 1:\n            node.nbBrackets.value = bracketSizes.pop()\n        else:\n            node.nbBrackets.value = 0\n##############\nEND_FUNC\n##############\n", "completion": "\nThis classmethod updates the number of brackets in a node. It raises an error if the node is not an instance of the type and returns if the user has not specified the number of brackets. Otherwise, it checks the input of the node for viewpoint metadata and sets the number of brackets based on the various exposures."}
{"prompt": "@property\ndef name(self):\n    return '.'.join([str(v) for v in self.components])\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis property returns a string composed of the components of the object joined together by a period."}
{"prompt": "def checkValueTypes(self):\n    return self.elementDesc.checkValueTypes()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function returns the result of the checkValueTypes() method on the elementDesc attribute of the object."}
{"prompt": "def read(self):\n    if not self._filepath or not self._filepath.lower().endswith('.csv') or (not os.path.isfile(self._filepath)):\n        return []\n    dataList = []\n    try:\n        csvRows = []\n        with open(self._filepath, 'r') as fp:\n            reader = csv.reader(fp)\n            for row in reader:\n                csvRows.append(row)\n        for elt in csvRows[0]:\n            dataList.append(CsvColumn(elt))\n        for elt in csvRows[1:]:\n            for (idx, value) in enumerate(elt):\n                dataList[idx].appendValue(value)\n    except Exception as e:\n        logging.error('CsvData: Failed to load file: {}\\n{}'.format(self._filepath, str(e)))\n    return dataList\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function reads a CSV file and returns a list of CsvColumn objects. It takes self as an argument and uses the self._filepath attribute to locate the CSV file. If the file is not found or is not a valid CSV file, an empty list is returned. Otherwise, the CSV file is read and the data is stored in a dataList object which is then returned."}
{"prompt": "def matchDescription(self, value, strict=True):\n    if not super(GroupAttribute, self).matchDescription(value):\n        return False\n    attrMap = {attr.name: attr for attr in self._groupDesc}\n    matchCount = 0\n    for (k, v) in value.items():\n        if k in attrMap and attrMap[k].matchDescription(v, strict):\n            matchCount += 1\n    if strict:\n        return matchCount == len(value.items()) == len(self._groupDesc)\n    return matchCount > 0\n##############\nEND_FUNC\n##############\n", "completion": "\n\nMatch the given description to the attributes of the GroupAttribute object. If strict is True, all entries of the description must match. If strict is False, at least one must match. Returns a boolean indicating whether the description matches."}
{"prompt": "def __init__(self, nodeType, nodeDict, position=None, issue=CompatibilityIssue.UnknownIssue, parent=None):\n    super(CompatibilityNode, self).__init__(nodeType, position, parent)\n    self.issue = issue\n    self.nodeDict = copy.deepcopy(nodeDict)\n    self.version = Version(self.nodeDict.get('version', None))\n    self._inputs = self.nodeDict.get('inputs', {})\n    self.outputs = self.nodeDict.get('outputs', {})\n    self._internalFolder = self.nodeDict.get('internalFolder', '')\n    self._uids = self.nodeDict.get('uids', {})\n    self.parallelization = self.nodeDict.get('parallelization', {})\n    self.splitCount = self.parallelization.get('split', 1)\n    self.setSize(self.parallelization.get('size', 1))\n    for (attrName, value) in self._inputs.items():\n        self._addAttribute(attrName, value, False)\n    for (attrName, value) in self.outputs.items():\n        self._addAttribute(attrName, value, True)\n    self._chunks.setObjectList([NodeChunk(self, desc.Range(i, blockSize=self.parallelization.get('blockSize', 0))) for i in range(self.splitCount)])\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function initializes a CompatibilityNode object. It takes in a nodeType, nodeDict, position(optional), issue(CompatibilityIssue.UnknownIssue by default), and parent(optional) as arguments. It then sets the issue, nodeDict, version, inputs, outputs, internalFolder, uids, parallelization, and splitCount properties of the object. Finally, it adds the inputs and outputs to the attributes of the object, and sets the object's chunks. \n\"\"\""}
{"prompt": "def checkValueTypes(self):\n    if not isinstance(self.value, int) or (self.range and (not all([isinstance(r, int) for r in self.range]))):\n        return self.name\n    return ''\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function checks if the value is an integer and if the range is also an integer. If either of these conditions are not true, it returns the name, otherwise it returns an empty string."}
{"prompt": "def isRunning(self):\n    return self._status.status == Status.RUNNING\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturns True if the status of the object is set to running, False otherwise."}
{"prompt": "def toDict(self):\n    d = self.__dict__.copy()\n    d.pop('destroyed', None)\n    d['elapsedTimeStr'] = self.elapsedTimeStr\n    return d\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"Returns a dictionary containing instance variables of the object, excluding the destroyed variable, and including the elapsedTimeStr variable.\""}
{"prompt": "@Slot(QPointF, QPointF, float)\ndef rotate(self, lastPosition, currentPosition, dt):\n    (angle, direction) = self.createRotation(lastPosition, currentPosition)\n    rotatedAxis = self._camera.transform().rotation().rotatedVector(direction)\n    angle *= self._rotationSpeed * dt\n    self._camera.rotateAboutViewCenter(QQuaternion.fromAxisAndAngle(rotatedAxis, angle * pi * 180))\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function rotates the camera about the view center using the supplied last and current positions as reference points. The angle of rotation is calculated using the two points, multiplied by the rotation speed and the delta time. The direction of rotation is determined by rotating the supplied vector by the current camera transformation."}
{"prompt": "def getInputEdges(self, node, dependenciesOnly):\n    return set([edge for edge in self.getEdges(dependenciesOnly=dependenciesOnly) if edge.dst.node is node])\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturn a set of edges for the given node with the option of dependenciesOnly.\n\nArgs:\n    node (object): The node.\n    dependenciesOnly (bool): Whether to include only edges that have the given node as the destination.\n\nReturns:\n    set: A set of edges that are connected to the given node.\n\"\"\""}
{"prompt": "@property\ndef globalExecMode(self):\n    return self._chunks.at(0).execModeName\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturns the global execution mode name of the chunk at the given index."}
{"prompt": "@Slot()\ndef clear(self):\n    self._clipboard.clear()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nClear the contents of the clipboard."}
{"prompt": "def getFullLabelToGraph(self):\n    return '{} {}'.format(self.node.graph.name, self.getFullLabelToNode())\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturns a string in the format of \"{graph name} {full label to node}\". It should concatenate the graph name and the label of the node, including the full hierarchy of labels up to the node."}
{"prompt": "def __init__(self, graph, data, position=None, parent=None):\n    super(PasteNodesCommand, self).__init__(graph, parent)\n    self.data = data\n    self.position = position\n    self.nodeNames = []\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"This class implements a command to paste nodes into a graph. It takes a graph, data, optional position, and optional parent as parameters. It stores data, position, and the names of the nodes being pasted in respective class variables.\"\"\""}
{"prompt": "def defaultValue(self):\n    return {key: attr.defaultValue() for (key, attr) in self._value.items()}\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturns a dictionary of key-value pairs with each key being an attribute of 'self' and each value being the default value of the corresponding attribute."}
{"prompt": "def registerNodeType(nodeType):\n    global nodesDesc\n    if nodeType.__name__ in nodesDesc:\n        raise RuntimeError('Node Desc {} is already registered.'.format(nodeType.__name__))\n    nodesDesc[nodeType.__name__] = nodeType\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"Registers a node type to the global nodesDesc dictionary. Raises a RuntimeError if the node type has already been registered.\""}
{"prompt": "def __init__(self, buf=b'', callback=None, cb_args=(), cb_kwargs={}, stopped=None):\n    self._callback = callback\n    self._cb_args = cb_args\n    self._cb_kwargs = cb_kwargs\n    self._stopped = stopped\n    self._progress = 0\n    self._len = len(buf)\n    io.BytesIO.__init__(self, buf)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__(self, buf=b'', callback=None, cb_args=(), cb_kwargs={}, stopped=None)\n\nInitializes the ReadProgress instance, with the given buffer, callback function and arguments,\nstopped flag and progress value. Initializes the underlying io.BytesIO instance with the given buffer."}
{"prompt": "def stopRequest(self):\n    self._stopFlag.set()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function sets the stop flag associated with the object to indicate that a request to stop has been made."}
{"prompt": "def validateValue(self, value):\n    raise NotImplementedError('Attribute.validateValue is an abstract function that should be implemented in the derived class.')\n##############\nEND_FUNC\n##############\n", "completion": "\n\nAbstract function that should be implemented in the derived class to validate the value of an attribute."}
{"prompt": "def updateChunks(self):\n    dfsNodes = self._graph.dfsOnFinish(None)[0]\n    chunks = self._graph.getChunks(dfsNodes)\n    if self._sortedDFSChunks.objectList() == chunks:\n        return\n    for chunk in self._sortedDFSChunks:\n        chunk.statusChanged.disconnect(self.updateGraphComputingStatus)\n    self._sortedDFSChunks.setObjectList(chunks)\n    for chunk in self._sortedDFSChunks:\n        chunk.statusChanged.connect(self.updateGraphComputingStatus)\n    self.updateChunkMonitor(self._sortedDFSChunks)\n    self.updateGraphComputingStatus()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function updates the chunks for the graph by performing a depth-first search, getting the connected chunks and comparing them to the existing chunks. If there are any changes, the function will disconnect from all previous chunks, set the object list to the new chunks, connect to the new chunks, update the chunk monitor, and then update the graph computing status."}
{"prompt": "def getBaseType(self):\n    return self.attributeDesc.elementDesc.__class__.__name__\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturn the base type name of the element description associated with this attribute description."}
{"prompt": "def getRegisteredFiles(self):\n    return self._watchedFiles\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturn a list of files being watched by the object."}
{"prompt": "@property\ndef watchedExtensions(self):\n    return self._extensions\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Getter method that returns the list of watched extensions (self._extensions).\"\"\""}
{"prompt": "def onCameraInitChanged(self):\n    nodes = self._graph.dfsOnDiscover(startNodes=[self._cameraInit], reverse=True)[0]\n    self.setActiveNodes(nodes)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function is called when the camera initialization changes. It performs a depth-first search (dfs) on the graph, starting from the camera initialization node, and in the reverse direction. The result of the dfs is then used to set the active nodes."}
{"prompt": "def _setSelectedViewpoint(self, viewpointAttribute):\n    if self._selectedViewpoint:\n        self._selectedViewpoint.deleteLater()\n    self._selectedViewpoint = ViewpointWrapper(viewpointAttribute, self) if viewpointAttribute else None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nSet the selected viewpoint attribute for this object. If a viewpoint attribute already exists, delete it before setting a new one."}
{"prompt": "@staticmethod\ndef isLinkExpression(value):\n    return isinstance(value, str) and Attribute.stringIsLinkRe.match(value)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturns boolean indicating whether or not the given value is a valid link expression."}
{"prompt": "def setCameraInitIndex(self, idx):\n    camInit = self._cameraInits[idx] if self._cameraInits else None\n    self.cameraInit = camInit\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function sets the camera initialization index to a specified value and stores it in the cameraInit attribute."}
{"prompt": "def block(self, isBlocked):\n    self._block = bool(isBlocked)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nSet the \"block\" status of an object to the given boolean value."}
{"prompt": "def at(self, idx):\n    return self._objects[idx]\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturns the object at the given index within the list of objects."}
{"prompt": "def _buildCmdVars(self):\n\n    def _buildAttributeCmdVars(cmdVars, name, attr):\n        if attr.enabled:\n            group = attr.attributeDesc.group(attr.node) if isinstance(attr.attributeDesc.group, types.FunctionType) else attr.attributeDesc.group\n            if group is not None:\n                v = attr.getValueStr()\n                cmdVars[name] = '--{name} {value}'.format(name=name, value=v)\n                cmdVars[name + 'Value'] = str(v)\n                if v:\n                    cmdVars[group] = cmdVars.get(group, '') + ' ' + cmdVars[name]\n            elif isinstance(attr, GroupAttribute):\n                assert isinstance(attr.value, DictModel)\n                for v in attr._value:\n                    _buildAttributeCmdVars(cmdVars, v.name, v)\n    ' Generate command variables using input attributes and resolved output attributes names and values. '\n    for (uidIndex, value) in self._uids.items():\n        self._cmdVars['uid{}'.format(uidIndex)] = value\n    for (name, attr) in self._attributes.objects.items():\n        if attr.isOutput:\n            continue\n        _buildAttributeCmdVars(self._cmdVars, name, attr)\n    cmdVarsNoCache = self._cmdVars.copy()\n    cmdVarsNoCache['cache'] = ''\n    for (name, attr) in self._attributes.objects.items():\n        if attr.isInput:\n            continue\n        if not isinstance(attr.attributeDesc, desc.File):\n            continue\n        try:\n            defaultValue = attr.defaultValue()\n        except AttributeError as e:\n            logging.warning('Invalid lambda evaluation for \"{nodeName}.{attrName}\"'.format(nodeName=self.name, attrName=attr.name))\n        else:\n            try:\n                attr.value = defaultValue.format(**self._cmdVars)\n                attr._invalidationValue = defaultValue.format(**cmdVarsNoCache)\n            except KeyError as e:\n                logging.warning('Invalid expression with missing key on \"{nodeName}.{attrName}\" with value \"{defaultValue}\".\\nError: {err}'.format(nodeName=self.name, attrName=attr.name, defaultValue=defaultValue, err=str(e)))\n            except ValueError as e:\n                logging.warning('Invalid expression value on \"{nodeName}.{attrName}\" with value \"{defaultValue}\".\\nError: {err}'.format(nodeName=self.name, attrName=attr.name, defaultValue=defaultValue, err=str(e)))\n        v = attr.getValueStr()\n        self._cmdVars[name] = '--{name} {value}'.format(name=name, value=v)\n        self._cmdVars[name + 'Value'] = str(v)\n        if v:\n            self._cmdVars[attr.attributeDesc.group] = self._cmdVars.get(attr.attributeDesc.group, '') + ' ' + self._cmdVars[name]\n##############\nEND_FUNC\n##############\n", "completion": "\nGenerate command variables using input attributes and resolved output attributes names and values."}
{"prompt": "def allImagePaths(self):\n    return [vp.path.value for node in self._cameraInits for vp in node.viewpoints.value]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturn a list of all image paths in the camera inits of the object."}
{"prompt": "def merge(self, other):\n    self.startDateTime = min(self.startDateTime, other.startDateTime)\n    self.endDateTime = max(self.endDateTime, other.endDateTime)\n    self.elapsedTime += other.elapsedTime\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Merge two dateTime objects.\n\nThis function takes two dateTime objects and combines them into one object, setting the startDateTime to the earliest of the two and the endDateTime to the latest of the two, and adding the elapsedTime of the other object to the original.\n\nArgs:\n    self (dateTime): The original dateTime object.\n    other (dateTime): The dateTime object to merge with the original.\n\nReturns:\n    None\n\"\"\""}
{"prompt": "def setAttributes(self, node, attributesDict):\n    for attr in attributesDict:\n        if node.hasAttribute(attr):\n            node.attribute(attr).value = attributesDict[attr]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nSet the attributes of a given node with a given dictionary of attributes.\n\nParameters:\n    self (object): The object itself.\n    node (object): The node whose attributes are to be set.\n    attributesDict (dict): A dictionary of attributes and their values.\n\nReturns:\n    None\n\"\"\""}
{"prompt": "@changeTopology\ndef removeEdge(self, dstAttr):\n    if dstAttr not in self.edges.keys():\n        raise RuntimeError('Attribute \"{}\" is not connected'.format(dstAttr.getFullNameToNode()))\n    edge = self.edges.pop(dstAttr)\n    self.markNodesDirty(dstAttr.node)\n    dstAttr.valueChanged.emit()\n    dstAttr.isLinkChanged.emit()\n    edge.src.hasOutputConnectionsChanged.emit()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nRemove an edge from the graph connecting a source attribute and a destination attribute. Emit an event to mark the nodes connected by the edge dirty and emit value and isLink changed events for the destination attribute."}
{"prompt": "def setLocked(self, lock):\n    if self._locked == lock:\n        return\n    self._locked = lock\n    self.lockedChanged.emit()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function sets the locked state of the object. If the current locked state is the same as the given lock state, the function returns without changing anything. Otherwise, the locked state is changed to the given state and the lockedChanged signal is emitted."}
{"prompt": "def redoImpl(self):\n    self.graph.addEdge(self.graph.attribute(self.srcAttr), self.graph.attribute(self.dstAttr))\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\nRedo the implementation of an edge in the graph. Adds an edge between the source and destination attributes. Returns True if successful."}
{"prompt": "def progressUpdate(size=None, progress=None, logManager=None):\n    if not logManager.progressBar:\n        logManager.makeProgressBar(size, 'Upload progress:')\n    logManager.updateProgressBar(progress)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function updates a progress bar for an upload process. It accepts parameters for the size of the upload, the progress made so far, and an instance of a logManager. If the logManager does not have a progressBar, a progressBar is created with the specified size and a label. Otherwise, the progressBar is updated with the specified progress."}
{"prompt": "@Slot(Qt3DCore.QEntity, result=int)\ndef faceCount(self, entity):\n    count = 0\n    for geo in entity.findChildren(Qt3DRender.QGeometry):\n        count += sum([attr.count() for attr in geo.attributes() if attr.name() == 'vertexPosition'])\n    return count / 3\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes a QEntity as an argument and returns the face count of the QEntity as an integer. It does this by looping through any QGeometry objects found as children of the given QEntity, summing up the counts of any 'vertexPosition' attributes found in the QGeometry objects, and then dividing by 3."}
{"prompt": "def containsNodeName(self, name):\n    if name in self._nodes.keys():\n        return True\n    return False\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nChecks if a graph contains a node with the given name.\n\nParameters:\n    self (Graph): The graph being checked.\n    name (string): The name of the node to be found.\n\nReturns:\n    bool: True if the graph contains a node with the given name, False otherwise."}
{"prompt": "@property\ndef minDepth(self):\n    return self.graph.getDepth(self, minimal=True)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Returns the minimal depth of the node in the graph.\"\"\""}
{"prompt": "def edge(self, dstAttributeName):\n    return self._edges.get(dstAttributeName)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"Return the edge to the given destination attribute name from the current object.\""}
{"prompt": "def test_upgradeAllNodes():\n    registerNodeType(SampleNodeV1)\n    registerNodeType(SampleNodeV2)\n    g = Graph('')\n    n1 = g.addNewNode('SampleNodeV1')\n    n2 = g.addNewNode('SampleNodeV2')\n    n1Name = n1.name\n    n2Name = n2.name\n    graphFile = os.path.join(tempfile.mkdtemp(), 'test_description_conflict.mg')\n    g.save(graphFile)\n    unregisterNodeType(SampleNodeV2)\n    meshroom.core.nodesDesc[SampleNodeV1.__name__] = SampleNodeV2\n    g = loadGraph(graphFile)\n    os.remove(graphFile)\n    assert len(g.compatibilityNodes) == 2\n    assert g.node(n1Name).canUpgrade\n    assert not g.node(n2Name).canUpgrade\n    g.upgradeAllNodes()\n    assert len(g.compatibilityNodes) == 1\n    assert n2Name in g.compatibilityNodes.keys()\n    unregisterNodeType(SampleNodeV1)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function upgrades all nodes in a graph by first registering both SampleNodeV1 and SampleNodeV2 nodes, then adding them both to a graph. The graph is then saved to a temporary file, and the SampleNodeV2 node is unregistered. The graph is then reloaded and all nodes are checked to see if they can be upgraded. If they can, they are upgraded, and the SampleNodeV1 node is unregistered."}
{"prompt": "def pasteNodes(self, data, position):\n    nodes = []\n    with GraphModification(self):\n        positionCnt = 0\n        for key in sorted(data):\n            nodeType = data[key].get('nodeType', None)\n            if not nodeType:\n                pass\n            attributes = {}\n            attributes.update(data[key].get('inputs', {}))\n            attributes.update(data[key].get('outputs', {}))\n            node = Node(nodeType, position=position[positionCnt], **attributes)\n            self._addNode(node, key)\n            nodes.append(node)\n            positionCnt += 1\n        self._applyExpr()\n    return nodes\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function creates nodes in a graph and adds them to the graph based on a given data set and a given position. It returns a list of the created nodes."}
{"prompt": "def discoverVertex(self, vertex, graph):\n    if vertex.isAlreadySubmitted():\n        self.canSubmit = False\n        if vertex.isExtern():\n            self.canCompute = False\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function checks to see if the given vertex is already submitted and if so, sets the canSubmit and canCompute boolean flags to False. If the vertex is an external source, canCompute is set to False."}
{"prompt": "def addFiles(self, filenames):\n    if not isinstance(filenames, list):\n        filenames = [filenames]\n    for filename in filenames:\n        self.addFile(filename)\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nAdd files to the current object.\n\nParameters\n----------\nfilenames : list or string\n    A list of filenames to add, or a single filename as a string.\n\nReturns\n-------\nNone\n\"\"\""}
{"prompt": "@Slot(Qt3DCore.QTransform, QMatrix4x4, QQuaternion, QMatrix4x4, QVector3D, int)\ndef relativeLocalRotate(self, transformQtInstance, initialPosMat, initialRotQuat, initialScaleMat, axis, degree):\n    transformQuat = QQuaternion.fromAxisAndAngle(axis, degree)\n    newRotQuat = initialRotQuat * transformQuat\n    newRotationMat = self.quaternionToRotationMatrix(newRotQuat)\n    mat = initialPosMat * newRotationMat * initialScaleMat\n    transformQtInstance.setMatrix(mat)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function rotates the position relative to the local transform of the given Qt3DCore.QTransform instance, based on the given axis and degree. It applies the initial position matrix, the transformed quaternion, and the initial scale matrix to the instance."}
{"prompt": "@Slot(QObject, result='QVariantList')\ndef duplicateNodes(self, nodes):\n    nodes = self.filterNodes(nodes)\n    nPositions = []\n    with self.groupedGraphModification('Duplicate Selected Nodes', disableUpdates=False):\n        with self.groupedGraphModification('Node duplication', disableUpdates=True):\n            duplicates = self.push(commands.DuplicateNodesCommand(self._graph, nodes))\n        bbox = self._layout.boundingBox(duplicates)\n        for n in duplicates:\n            idx = duplicates.index(n)\n            yPos = n.y + self.layout.gridSpacing + bbox[3]\n            if idx > 0 and (n.x, yPos) in nPositions:\n                while (n.x, yPos) in nPositions:\n                    yPos = yPos + self.layout.gridSpacing + self.layout.nodeHeight\n                self.moveNode(n, Position(n.x, yPos))\n            else:\n                self.moveNode(n, Position(n.x, bbox[3] + self.layout.gridSpacing + n.y))\n            nPositions.append((n.x, n.y))\n    return duplicates\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function duplicates the given nodes and returns a list of the duplicated nodes. It also ensures that the duplicate nodes do not overlap by adjusting the y position of each node."}
{"prompt": "def getCgroupMemorySize():\n    pid = os.getpid()\n    filename = f'/proc/{pid}/cgroup'\n    cgroup = None\n    try:\n        with open(filename, 'r') as f:\n            lines = f.readlines()\n            for line in lines:\n                tokens = line.rstrip('\\r\\n').split(':')\n                if len(tokens) < 3:\n                    continue\n                if tokens[1] == 'memory':\n                    cgroup = tokens[2]\n    except OSError:\n        pass\n    if cgroup is None:\n        return -1\n    size = -1\n    filename = f'/sys/fs/cgroup/memory/{cgroup}/memory.limit_in_bytes'\n    try:\n        with open(filename, 'r') as f:\n            value = f.read().rstrip('\\r\\n')\n            if value.isnumeric():\n                size = int(value)\n    except OSError:\n        pass\n    return size\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\ngetCgroupMemorySize()\n\nReturns the memory size in bytes of the cgroup associated with the current process. If the current process does not belong to a cgroup, or an error occurs, returns -1."}
{"prompt": "def insert(self, i, toInsert):\n    if not isinstance(toInsert, list):\n        toInsert = [toInsert]\n    self.beginInsertRows(QtCore.QModelIndex(), i, i + len(toInsert) - 1)\n    for obj in reversed(toInsert):\n        self._referenceItem(obj)\n        self._objects.insert(i, obj)\n    self.endInsertRows()\n    self.countChanged.emit()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nInserts a list of objects into the model at the specified index.\n\nParameters:\n    i (int): The index to insert the objects at.\n    toInsert (list): The list of objects to insert into the model. If a single object is provided, it will be wrapped in a list.\n\"\"\""}
{"prompt": "def getContainsMouse(self):\n    return self._containsMouse\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturn whether the object contains a mouse or not."}
{"prompt": "def completeProgressBar(self):\n    assert self.progressBar\n    self.progressBar = False\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function sets the progressBar attribute of the calling object to False."}
{"prompt": "@staticmethod\ndef asStr(path):\n    if not isinstance(path, (QUrl, str)):\n        raise TypeError('Unexpected data type: {}'.format(path.__class__))\n    if isinstance(path, QUrl):\n        path = path.toLocalFile()\n    return path\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function takes either a QUrl or a string as input, and returns a string. If the input does not match either of these types, a TypeError is raised."}
{"prompt": "def buildIntrinsics(self, cameraInit, additionalViews, rebuild=False):\n    views = []\n    intrinsics = []\n    inputs = cameraInit.toDict()['inputs'] if cameraInit else {}\n    cameraInitCopy = Node('CameraInit', **inputs)\n    if rebuild:\n        for vp in cameraInitCopy.viewpoints.value:\n            vp.intrinsicId.resetValue()\n            vp.metadata.resetValue()\n        cameraInitCopy.intrinsics.resetValue()\n    try:\n        self.setBuildingIntrinsics(True)\n        (views, intrinsics) = cameraInitCopy.nodeDesc.buildIntrinsics(cameraInitCopy, additionalViews)\n    except Exception as e:\n        logging.error('Error while building intrinsics: {}'.format(str(e)))\n        raise\n    finally:\n        cameraInitCopy.deleteLater()\n        self.setBuildingIntrinsics(False)\n    self.intrinsicsBuilt.emit(cameraInit, views, intrinsics, rebuild)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function builds intrinsics from the given cameraInit and additionalViews and emits the intrinsicsBuilt signal with the cameraInit, views, intrinsics, and rebuild. It also handles exceptions that may occur while building the intrinsics."}
{"prompt": "def _unsetSfm(self):\n    self._setSfm(None)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function sets the Sfm value of the object to None."}
{"prompt": "@Slot(int, result=QObject)\ndef getColumn(self, index):\n    return self._data.at(index)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nGets a column of data from the given index.\n\nParameters:\n    index (int): The index of the data to retrieve.\n\nReturns:\n    QObject: The data at the given index."}
{"prompt": "def __iter__(self):\n    return iter(self._objects)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturns an iterator over the objects in this object."}
{"prompt": "@Slot(Attribute, Attribute)\ndef addEdge(self, src, dst):\n    if isinstance(dst, ListAttribute) and (not isinstance(src, ListAttribute)):\n        with self.groupedGraphModification('Insert and Add Edge on {}'.format(dst.getFullNameToNode())):\n            self.appendAttribute(dst)\n            self._addEdge(src, dst.at(-1))\n    else:\n        self._addEdge(src, dst)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nAdds an edge from a source Attribute to a destination Attribute. If the destination is a ListAttribute, the source will be connected to the last item in the ListAttribute. \n\"\"\""}
{"prompt": "@Slot('QVariant')\ndef importImagesUrls(self, imagePaths, recursive=False):\n    paths = []\n    for imagePath in imagePaths:\n        if isinstance(imagePath, QUrl):\n            p = imagePath.toLocalFile()\n            if not p:\n                p = imagePath.toString()\n        else:\n            p = imagePath\n        paths.append(p)\n    self.importImagesFromFolder(paths)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function imports images from local folders given a list of image paths. It will optionally recursively search subdirectories if recursive is set to True."}
{"prompt": "def removeAt(self, i, count=1):\n    self.beginRemoveRows(QtCore.QModelIndex(), i, i + count - 1)\n    for cpt in range(count):\n        obj = self._objects.pop(i)\n        self._dereferenceItem(obj)\n    self.endRemoveRows()\n    self.countChanged.emit()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nRemoves a given number of rows starting at the given index from the model. Emits the countChanged signal afterwards."}
{"prompt": "def registerTypes():\n    from PySide2.QtQml import qmlRegisterType\n    from meshroom.ui.components.clipboard import ClipboardHelper\n    from meshroom.ui.components.edge import EdgeMouseArea\n    from meshroom.ui.components.filepath import FilepathHelper\n    from meshroom.ui.components.scene3D import Scene3DHelper, TrackballController, Transformations3DHelper\n    from meshroom.ui.components.csvData import CsvData\n    qmlRegisterType(EdgeMouseArea, 'GraphEditor', 1, 0, 'EdgeMouseArea')\n    qmlRegisterType(ClipboardHelper, 'Meshroom.Helpers', 1, 0, 'ClipboardHelper')\n    qmlRegisterType(FilepathHelper, 'Meshroom.Helpers', 1, 0, 'FilepathHelper')\n    qmlRegisterType(Scene3DHelper, 'Meshroom.Helpers', 1, 0, 'Scene3DHelper')\n    qmlRegisterType(Transformations3DHelper, 'Meshroom.Helpers', 1, 0, 'Transformations3DHelper')\n    qmlRegisterType(TrackballController, 'Meshroom.Helpers', 1, 0, 'TrackballController')\n    qmlRegisterType(CsvData, 'DataObjects', 1, 0, 'CsvData')\n##############\nEND_FUNC\n##############\n", "completion": "\n\nNo docstring available for this function."}
{"prompt": "def _isDefault(self):\n    return self.value == self.defaultValue()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function checks if the value of a given object is equal to the object's default value."}
{"prompt": "def __init__(self, parent=None):\n    super(TaskManager, self).__init__(parent)\n    self._graph = None\n    self._nodes = DictModel(keyAttrName='_name', parent=self)\n    self._nodesToProcess = []\n    self._nodesExtern = []\n    self._thread = TaskThread(self)\n    self._blockRestart = False\n    self.restartRequested.connect(self.restart)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__() is a function that initializes the TaskManager object and its attributes. It sets the parent of the TaskManager, creates a graph, creates a dictionary model, and creates a TaskThread object. It also sets the _blockRestart attribute to False and connects the restartRequested signal to the restart method."}
{"prompt": "@Slot(result=StatusData)\ndef getFusedStatus(self):\n    fusedStatus = StatusData()\n    if self._chunks:\n        fusedStatus.fromDict(self._chunks[0].status.toDict())\n        for chunk in self._chunks[1:]:\n            fusedStatus.merge(chunk.status)\n    fusedStatus.status = self.getGlobalStatus()\n    return fusedStatus\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturn a StatusData object representing the merged status of the ChunkData instances in self._chunks with the global status applied.\n\"\"\""}
{"prompt": "def getValueStr(self):\n    if isinstance(self.attributeDesc, desc.ChoiceParam) and (not self.attributeDesc.exclusive):\n        assert isinstance(self.value, Sequence) and (not isinstance(self.value, str))\n        return self.attributeDesc.joinChar.join(self.getEvalValue())\n    if isinstance(self.attributeDesc, (desc.StringParam, desc.File)):\n        return '\"{}\"'.format(self.getEvalValue())\n    return str(self.getEvalValue())\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturn a string representation of the value of an Attribute."}
{"prompt": "def nodeFactory(nodeDict, name=None, template=False):\n    nodeType = nodeDict['nodeType']\n    if 'inputs' not in nodeDict and 'attributes' in nodeDict:\n        nodeDict['inputs'] = nodeDict['attributes']\n        del nodeDict['attributes']\n    inputs = nodeDict.get('inputs', {})\n    outputs = nodeDict.get('outputs', {})\n    version = nodeDict.get('version', None)\n    internalFolder = nodeDict.get('internalFolder', None)\n    position = Position(*nodeDict.get('position', []))\n    compatibilityIssue = None\n    nodeDesc = None\n    try:\n        nodeDesc = meshroom.core.nodesDesc[nodeType]\n    except KeyError:\n        compatibilityIssue = CompatibilityIssue.UnknownNodeType\n    if nodeDesc:\n        currentNodeVersion = meshroom.core.nodeVersion(nodeDesc)\n        if version and currentNodeVersion and (Version(version).major != Version(currentNodeVersion).major):\n            compatibilityIssue = CompatibilityIssue.VersionConflict\n        else:\n            if not template and (sorted([attr.name for attr in nodeDesc.inputs]) != sorted(inputs.keys()) or sorted([attr.name for attr in nodeDesc.outputs]) != sorted(outputs.keys())):\n                compatibilityIssue = CompatibilityIssue.DescriptionConflict\n            for (attrName, value) in inputs.items():\n                if not CompatibilityNode.attributeDescFromName(nodeDesc.inputs, attrName, value):\n                    compatibilityIssue = CompatibilityIssue.DescriptionConflict\n                    break\n            for (attrName, value) in outputs.items():\n                if not CompatibilityNode.attributeDescFromName(nodeDesc.outputs, attrName, value):\n                    compatibilityIssue = CompatibilityIssue.DescriptionConflict\n                    break\n    if compatibilityIssue is None:\n        node = Node(nodeType, position, **inputs)\n    else:\n        logging.warning(\"Compatibility issue detected for node '{}': {}\".format(name, compatibilityIssue.name))\n        node = CompatibilityNode(nodeType, nodeDict, position, compatibilityIssue)\n        if not internalFolder and nodeDesc:\n            logging.warning(\"No serialized output data: performing automatic upgrade on '{}'\".format(name))\n            node = node.upgrade()\n        elif template:\n            node = node.upgrade()\n    return node\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function creates a Node or CompatibilityNode object. It takes a dictionary of node attributes, a name, and a boolean value to indicate if it is a template. It checks for compatibility issues and logs a warning if one is detected. If no compatibility issue is detected, it creates a Node object with the given attributes. If a compatibility issue is detected and the node is not a template, it creates a CompatibilityNode object with the given attributes. If the node is a template, it upgrades it to the latest version."}
{"prompt": "def __neg__(self):\n    return not self.name\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"Returns a boolean value of the negation of the object's name attribute.\""}
{"prompt": "def updateStatisticsFromCache(self):\n    for node in self._nodes:\n        node.updateStatisticsFromCache()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nUpdate the statistics for each node from the cache."}
{"prompt": "def reset(self, objects):\n    self.clear()\n    self.update(objects)\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nReset the contents of the dictionary, replacing them with the objects provided."}
{"prompt": "def keys(self):\n    return self._objectByKey.keys()\n##############\nEND_FUNC\n##############\n", "completion": "\nThis function returns a list of the keys from the dictionary '_objectByKey'."}
{"prompt": "def getDocumentation(self):\n    if not self.nodeDesc:\n        return ''\n    return self.nodeDesc.documentation\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Returns the documentation associated with the node.\"\"\""}
{"prompt": "def retrieveChildrenUids(self):\n    allUids = []\n    for desc in self._groupDesc:\n        allUids.extend(desc.uid)\n    return allUids\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nRetrieve a list of UIDs for all children of the Group object."}
{"prompt": "@Slot(str)\ndef setFilepath(self, filepath):\n    if self._filepath == filepath:\n        return\n    self.setReady(False)\n    self._filepath = filepath\n    self.filepathChanged.emit()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Set the filepath for the object.\n\nArgs:\n    filepath (str): The path to the file.\n\nReturns:\n    None\n\"\"\""}
{"prompt": "def updateNodesPerUid(self):\n    nodesPerUid = {}\n    for node in self.nodes:\n        uid = node._uids.get(0)\n        try:\n            nodesPerUid.get(uid).append(node)\n        except AttributeError:\n            nodesPerUid.update({uid: [node]})\n    for node in self.nodes:\n        node.updateDuplicates(nodesPerUid)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Update a dictionary mapping UIDs to a list of associated nodes, then update each node with its duplicates.\"\"\""}
{"prompt": "def validateNodeDesc(nodeDesc):\n    errors = []\n    for param in nodeDesc.inputs:\n        err = param.checkValueTypes()\n        if err:\n            errors.append(err)\n    for param in nodeDesc.outputs:\n        err = param.checkValueTypes()\n        if err:\n            errors.append(err)\n    return errors\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function validates the node description and returns a list of errors. It iterates through the node description's inputs and outputs and checks their value types for any errors."}
{"prompt": "def updateStats(self):\n    self.lastTime = time.time()\n    if self.chunk.statistics.update(self.proc):\n        self.chunk.saveStatistics()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nUpdate the statistics for the given audio process. Sets the lastTime of the audio process to the current time, then updates the statistics and saves them."}
{"prompt": "@Slot(QMatrix4x4, result='QVariant')\ndef modelMatrixToMatrices(self, modelMat):\n    decomposition = self.decomposeModelMatrix(modelMat)\n    posMat = QMatrix4x4()\n    posMat.translate(decomposition.get('translation'))\n    rotMat = self.quaternionToRotationMatrix(decomposition.get('quaternion'))\n    scaleMat = QMatrix4x4()\n    scaleMat.scale(decomposition.get('scale'))\n    return {'position': posMat, 'rotation': rotMat, 'scale': scaleMat, 'quaternion': decomposition.get('quaternion')}\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturns a dictionary containing the separated matrices from a given model matrix. \nThe dictionary contains the position matrix, the rotation matrix, the scale matrix and the quaternion of the model matrix."}
{"prompt": "@Slot(str)\ndef setText(self, value):\n    self._clipboard.setText(value)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nSet the text of the clipboard.\n\nParameters:\n    value (str): The text to set the clipboard to.\n\"\"\""}
{"prompt": "def _pipelineTemplateFiles(self):\n    templates = []\n    for key in sorted(meshroom.core.pipelineTemplates.keys()):\n        name = ' '.join(re.findall('[A-Z][^A-Z]*', key[0].upper() + key[1:]))\n        variant = {'name': name, 'key': key, 'path': meshroom.core.pipelineTemplates[key]}\n        templates.append(variant)\n    return templates\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function creates a sorted list of pipeline template files with their associated name, key and path."}
{"prompt": "@property\ndef nodes(self):\n    return self._nodes\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"This getter method returns the private attribute '_nodes' of the class it is defined in.\"\"\""}
{"prompt": "def __init__(self, graph, edge, parent=None):\n    super(RemoveEdgeCommand, self).__init__(graph, parent)\n    self.srcAttr = edge.src.getFullNameToNode()\n    self.dstAttr = edge.dst.getFullNameToNode()\n    self.setText(\"Disconnect '{}'->'{}'\".format(self.srcAttr, self.dstAttr))\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function is an initialization for the class RemoveEdgeCommand. It sets up the class with the graph, edge, and parent information, as well as setting the text of the command to be the names of the source and destination nodes connected by the edge."}
{"prompt": "def getFullName(self):\n    if isinstance(self.root, ListAttribute):\n        return '{}[{}]'.format(self.root.getFullName(), self.root.index(self))\n    elif isinstance(self.root, GroupAttribute):\n        return '{}.{}'.format(self.root.getFullName(), self.getName())\n    return self.getName()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function returns the full name of an Attribute, including the root Group or List it belongs to. The name consists of the root's full name followed by the Attribute's name (if it belongs to a Group) or the Attribute's index in the List (if it belongs to a List)."}
{"prompt": "def decomposeModelMatrix(self, modelMat):\n    translation = modelMat.column(3).toVector3D()\n    quaternion = QQuaternion.fromDirection(modelMat.column(2).toVector3D(), modelMat.column(1).toVector3D())\n    scale = QVector3D(modelMat.column(0).length(), modelMat.column(1).length(), modelMat.column(2).length())\n    return {'translation': translation, 'quaternion': quaternion, 'scale': scale}\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function decomposes a 4x4 model matrix into its translation, quaternion, and scale components and returns the results in a dictionary."}
{"prompt": "@property\ndef root(self):\n    return self._root() if self._root else None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"This function returns the root of the object if it exists, otherwise returns None.\"\"\""}
{"prompt": "def update(self):\n    if not self._updateEnabled:\n        self._updateRequested = True\n        return\n    self.updateInternals()\n    if os.path.exists(self._cacheDir):\n        self.updateStatusFromCache()\n    for node in self.nodes:\n        node.dirty = False\n    self.updateNodesPerUid()\n    if self.dirtyTopology:\n        self.updateNodesTopologicalData()\n        self.dirtyTopology = False\n    self.updated.emit()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"update(self):\n    Updates data structures and emits the updated signal.\n    If _updateEnabled is False, sets _updateRequested to True and returns.\n    Calls updateInternals() and updates status from cache if present.\n    Sets all nodes dirty to False and updates nodes per UID.\n    Updates topological data if dirtyTopology is True and sets it to False.\n    Emits the updated signal.\n\"\"\""}
{"prompt": "@Slot()\ndef clearSubmittedChunks(self):\n    for chunk in self._chunks:\n        if chunk.isAlreadySubmitted():\n            chunk.upgradeStatusTo(Status.NONE, ExecMode.NONE)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"This function clears all submitted chunks from the given object. It iterates over each chunk in the object's _chunks attribute and upgrades its status to 'NONE' and exec mode to 'NONE' if the chunk has already been submitted.\"\"\""}
{"prompt": "def __init__(self, name, label, description, value, advanced, semantic, uid, group, enabled):\n    super(Attribute, self).__init__()\n    self._name = name\n    self._label = label\n    self._description = description\n    self._value = value\n    self._uid = uid\n    self._group = group\n    self._advanced = advanced\n    self._enabled = enabled\n    self._semantic = semantic\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__() is the constructor for the Attribute class. It takes the following parameters: \nname: string representing the name of the attribute\nlabel: string representing the label of the attribute\ndescription: string representing the description of the attribute\nvalue: value of the attribute\nadvanced: boolean indicating whether the attribute is advanced or not \nsemantic: string representing the semantic type of the attribute\nuid: string representing a unique identifier for the attribute\ngroup: string representing the group the attribute belongs to\nenabled: boolean indicating whether the attribute is enabled or not \n\"\"\""}
{"prompt": "def __init__(self, script, initScript=None, base=None, targetName=None, icons=None, shortcutName=None, shortcutDir=None, copyright=None, trademarks=None):\n    if not targetName:\n        targetName = os.path.splitext(os.path.basename(script))[0]\n    targetName += PlatformExecutable.exeExtensions[platform.system()]\n    icon = icons.get(platform.system(), None) if icons else None\n    if platform.system() in (self.Linux, self.Darwin):\n        initScript = os.path.join(currentDir, 'setupInitScriptUnix.py')\n    super(PlatformExecutable, self).__init__(script, initScript, base, targetName, icon, shortcutName, shortcutDir, copyright, trademarks)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"This function is the constructor for the PlatformExecutable class. It takes a script and various optional parameters, and sets various attributes, including a targetName, icon, shortcutName, shortcutDir, copyright, and trademarks. Additionally, it sets the initScript to a Unix-specific script if the platform is Linux or Darwin.\"\"\""}
{"prompt": "def attributeFactory(description, value, isOutput, node, root=None, parent=None):\n    if isinstance(description, desc.GroupAttribute):\n        cls = GroupAttribute\n    elif isinstance(description, desc.ListAttribute):\n        cls = ListAttribute\n    else:\n        cls = Attribute\n    attr = cls(node, description, isOutput, root, parent)\n    if value is not None:\n        attr.value = value\n    return attr\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function creates an Attribute, GroupAttribute, or ListAttribute object based on the given description and sets its value if specified. It takes five arguments: a description object, a value, a boolean indicating whether the attribute is an output, a node object, and optional root and parent attributes."}
{"prompt": "def decorator(self, *args, **kwargs):\n    assert isinstance(self, Graph)\n    result = func(self, *args, **kwargs)\n    self.dirtyTopology = True\n    self.update()\n    return result\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis decorator function is used to modify a Graph object, setting the \"dirtyTopology\" attribute to True and calling the \"update\" method. It takes in an instance of the Graph object as the first argument, with optional additional arguments and keyword arguments."}
{"prompt": "def duplicateNodes(self, srcNodes):\n    duplicates = OrderedDict()\n    with GraphModification(self):\n        duplicateEdges = {}\n        for srcNode in srcNodes:\n            (node, edges) = self.copyNode(srcNode, withEdges=False)\n            duplicate = self.addNode(node)\n            duplicateEdges.update(edges)\n            duplicates.setdefault(srcNode, []).append(duplicate)\n        for (attr, linkExpression) in duplicateEdges.items():\n            link = linkExpression[1:-1]\n            (edgeSrcNodeName, edgeSrcAttrName) = link.split('.', 1)\n            edgeSrcNode = self.node(edgeSrcNodeName)\n            if edgeSrcNode in duplicates:\n                edgeSrcNode = duplicates.get(edgeSrcNode)[0]\n            self.addEdge(edgeSrcNode.attribute(edgeSrcAttrName), attr)\n    return duplicates\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function creates duplicates of the specified nodes in the graph and returns a dictionary of source nodes to duplicated nodes. It takes in an argument of srcNodes which are the nodes to be duplicated. It also creates duplicate edges for the duplicated nodes."}
{"prompt": "def geometryChanged(self, newGeometry, oldGeometry):\n    super(EdgeMouseArea, self).geometryChanged(newGeometry, oldGeometry)\n    self.updateShape()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function updates the shape of the EdgeMouseArea whenever the geometry of the object changes. It calls the geometryChanged method of the super class and then calls updateShape to update the shape."}
{"prompt": "def onRequestDeletion(self, item):\n    item.deleteLater()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nDelete an item later."}
{"prompt": "@classmethod\ndef update(cls, node):\n    pass\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nUpdate the given node with a class method.\n\nParameters:\nnode (object): The node to be updated.\n\nReturns:\nNone.\n\"\"\""}
{"prompt": "@Property(type=QSizeF, notify=initialParamsChanged)\ndef orientedImageSize(self):\n    if self.orientation in (6, 8):\n        return QSizeF(self.imageSize.height(), self.imageSize.width())\n    else:\n        return self.imageSize\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function returns the size of an image after it has been rotated. If the image orientation is 6 or 8, the height and width are swapped. Otherwise, the image size is returned as is."}
{"prompt": "@Slot()\ndef save(self):\n    self._graph.save()\n    self._undoStack.setClean()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nSave the graph and set the undo stack to clean."}
{"prompt": "@Slot(str, result=bool)\n@Slot(QUrl, result=bool)\ndef isFile(self, path):\n    return os.path.isfile(self.asStr(path))\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nisFile() checks if the given path is an existing file and returns a boolean.\n\nParameters:\n    path (str or QUrl): Path of the file to check\n\nReturns:\n    bool: True if the path is a file, False otherwise."}
{"prompt": "@staticmethod\ndef sortNodesByIndex(nodes):\n    return sorted(nodes, key=lambda x: Graph.getNodeIndexFromName(x.name))\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nSort a list of nodes by their index in the graph.\n\nParameters: \nnodes (list): A list of nodes to be sorted.\n\nReturns: \nlist: A list of nodes sorted by their index in the graph."}
{"prompt": "def clearActiveNodes(self):\n    for key in self._activeNodes.keys():\n        self._activeNodes.get(key).node = None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function clears all active nodes stored in the _activeNodes dictionary. It sets the node attribute of each stored object to None."}
{"prompt": "@classmethod\ndef postUpdate(cls, node):\n    pass\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis is a class method for the class 'cls' that takes in a 'node' argument and does not return anything."}
{"prompt": "def getLabel(self):\n    return self._label\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturn the label associated with the object."}
{"prompt": "def setChunks(self, chunks):\n    self.chunks = chunks\n    self._filesTimePoller.setFiles(self.statusFiles)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nSet the chunks for the given object and set the filesTimePoller with the statusFiles."}
{"prompt": "@property\ndef issueDetails(self):\n    if self.issue == CompatibilityIssue.UnknownNodeType:\n        return \"Unknown node type: '{}'.\".format(self.nodeType)\n    elif self.issue == CompatibilityIssue.VersionConflict:\n        return \"Node version '{}' conflicts with current version '{}'.\".format(self.nodeDict['version'], nodeVersion(self.nodeDesc))\n    elif self.issue == CompatibilityIssue.DescriptionConflict:\n        return 'Node attributes do not match node description.'\n    else:\n        return 'Unknown error.'\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis property returns a string with details about a compatibility issue. Depending on the issue, it will return a different string with more information about the issue."}
{"prompt": "def setObjectList(self, objects):\n    oldSize = self.size()\n    self.beginResetModel()\n    for obj in self._objects:\n        self._dereferenceItem(obj)\n    self._objects = objects\n    for obj in self._objects:\n        self._referenceItem(obj)\n    self.endResetModel()\n    self.dataChanged.emit(self.index(0), self.index(self.size() - 1), [])\n    if self.size() != oldSize:\n        self.countChanged.emit()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nSet the object list and trigger the appropriate signals to update the model."}
{"prompt": "def __iter__(self):\n    return iter(self._objects.values())\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturns an iterator object that iterates over the values in the self._objects dictionary."}
{"prompt": "def fromDict(self, d):\n    version = d.get('fileVersion', 0.0)\n    if version != self.fileVersion:\n        logging.debug('Statistics: file version was {} and the current version is {}.'.format(version, self.fileVersion))\n    self.computer = {}\n    self.process = {}\n    self.times = []\n    try:\n        self.computer.fromDict(d.get('computer', {}))\n    except Exception as e:\n        logging.debug('Failed while loading statistics: computer: \"{}\".'.format(str(e)))\n    try:\n        self.process.fromDict(d.get('process', {}))\n    except Exception as e:\n        logging.debug('Failed while loading statistics: process: \"{}\".'.format(str(e)))\n    try:\n        self.times = d.get('times', [])\n    except Exception as e:\n        logging.debug('Failed while loading statistics: times: \"{}\".'.format(str(e)))\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function loads data from a dictionary into the computer, process, and times attributes. It also checks the file version and logs a debug message if it is different from the current version. It handles exceptions by logging debug messages."}
{"prompt": "@QtCore.Slot(QtCore.QObject, result=int)\ndef indexOf(self, matchObj, fromIndex=0, positive=True):\n    index = self._objects[fromIndex:].index(matchObj) + fromIndex\n    if positive and index < 0:\n        index += self.size()\n    return index\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function returns the index of a given match object starting from a given index. If positive is set to True, it will return an index greater than or equal to the given index, otherwise it will return an index less than or equal to the given index."}
{"prompt": "def findNode(self, nodeExpr):\n    candidates = self.findNodeCandidates('^' + nodeExpr)\n    if not candidates:\n        raise KeyError('No node candidate for \"{}\"'.format(nodeExpr))\n    if len(candidates) > 1:\n        for c in candidates:\n            if c.name == nodeExpr:\n                return c\n        raise KeyError('Multiple node candidates for \"{}\": {}'.format(nodeExpr, str([c.name for c in candidates])))\n    return candidates[0]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nFind a node corresponding to the given node expression.\n\nParameters:\n    nodeExpr (str): The node expression to search for.\n\nRaises:\n    KeyError: If no node candidate is found or if multiple candidates are found.\n\nReturns:\n    Node: The node that corresponds to the given node expression.\n\"\"\""}
{"prompt": "def updateGraphComputingStatus(self):\n    computingLocally = any([ch.status.execMode == ExecMode.LOCAL and ch.status.sessionUid == sessionUid and (ch.status.status in (Status.RUNNING, Status.SUBMITTED)) for ch in self._sortedDFSChunks])\n    submitted = any([ch.status.status == Status.SUBMITTED for ch in self._sortedDFSChunks])\n    if self._computingLocally != computingLocally or self._submitted != submitted:\n        self._computingLocally = computingLocally\n        self._submitted = submitted\n        self.computeStatusChanged.emit()\n##############\nEND_FUNC\n##############\n", "completion": "\nThis function updates the graph computing status and emits a compute status change signal. It checks if any of the chunks in the sorted DFS chunks list have an execution mode of local and a session UID that match the given session UID, as well as a status of either running or submitted. It also checks if any of the chunks have a status of submitted. If any of the conditions are met, it updates the computing locally and submitted values, and emits a compute status change signal."}
{"prompt": "def requestGraphUpdate(self):\n    if self.node.graph:\n        self.node.graph.markNodesDirty(self.node)\n        self.node.graph.update()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function requests a graph update from the node's graph. It marks any dirty nodes associated with the node and updates the graph."}
{"prompt": "def end(self):\n    for handler in self.logger.handlers[:]:\n        handler.close()\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"Closes all the handlers associated with the logger object.\"\"\""}
{"prompt": "@Slot()\ndef updateData(self):\n    self.setReady(False)\n    self._data.clear()\n    newColumns = self.read()\n    if newColumns:\n        self._data.setObjectList(newColumns)\n        self.setReady(True)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nUpdate the stored data. Clears the existing data and reads the new data from the source. Sets the ready status accordingly."}
{"prompt": "def getBaseType(self):\n    return self.getType()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturn the base type of the object."}
{"prompt": "def _setSfm(self, node):\n    self._sfm = node\n    self.updateSfMResults()\n    if self._sfm:\n        self._sfm.destroyed.connect(self._unsetSfm)\n        self._sfm.chunks[0].statusChanged.connect(self.updateSfMResults)\n    self.sfmChanged.emit()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function sets a node, updates the SfM results, and emits a signal when the SfM is changed. It also connects the node to a signal that will unset the SfM when it is destroyed and connects the node's status to a signal that will update the SfM results."}
{"prompt": "def emit(self, signalName, *args, **kwargs):\n    assert signalName in self, '%s is not a registered signal' % signalName\n    self[signalName].emit(*args, **kwargs)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nEmit a signal with the given name, passing any given positional and keyword arguments to the signal. Asserts that the signal is registered with the signal dict beforehand."}
{"prompt": "def processChunk(self, chunk):\n    raise NotImplementedError('No processChunk implementation on node: \"{}\"'.format(chunk.node.name))\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nRaises a NotImplementedError exception when called, with a message stating that there is no processChunk implementation on the node specified."}
{"prompt": "@Slot(Node)\ndef appendSelection(self, node):\n    if not self._selectedNodes.contains(node):\n        self._selectedNodes.append(node)\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nAppend a Node to the selection list if it is not already in the list."}
{"prompt": "def __bool__(self):\n    return self.size() > 0\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturn whether the size of the object is greater than 0."}
{"prompt": "@Slot(str, result=Attribute)\ndef attribute(self, fullName):\n    (node, attribute) = fullName.split('.', 1)\n    return self.node(node).attribute(attribute)\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nRetrieve an Attribute from a given node by its full name.\n\nArgs:\n    fullName (str): A string containing the full name of the Attribute to be retrieved.\n\nReturns:\n    Attribute: The Attribute object matching the given full name."}
{"prompt": "def __init__(self, reverse, dependenciesOnly):\n    super(SCVisitor, self).__init__(reverse, dependenciesOnly)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis is the constructor of the SCVisitor class. It calls the superclass constructor with the given parameters: reverse and dependenciesOnly."}
{"prompt": "def __init__(self, parent=None):\n    self._objects = []\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__(self, parent=None):\n    \"\"\"Initialize a new instance of this class, with the given parent.\n\n    Args:\n        parent (object): Optional parent object.\n\n    \"\"\"\n    self._objects = []"}
{"prompt": "def getEvalValue(self):\n    if isinstance(self.value, str):\n        return Template(self.value).safe_substitute(os.environ)\n    return self.value\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function evaluates a value (self.value) and returns its value. If the value is a string, it is substituted for any environment variables before being returned."}
{"prompt": "def get_link_key(node):\n    link_keys = ['uri', 'refuri', 'refname']\n    for key in link_keys:\n        if key in node.attributes.keys():\n            return key\n    return None\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturns the key for a link node if present in the node's attributes, otherwise returns None."}
{"prompt": "def getChunks(self, nodes=None):\n    chunks = []\n    for node in nodes or self.nodes:\n        chunks += [chunk for chunk in node.chunks]\n    return chunks\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function returns a list of chunks from the given list of nodes. If no nodes are given, then it will use the nodes stored in 'self.nodes'. Each chunk is taken from a node in the given list."}
{"prompt": "@property\ndef logger(self):\n    return self.logManager.logger\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis property returns the logger object for the logManager instance."}
{"prompt": "def __get__(self, instance, owner):\n    if instance is None:\n        return self\n    tmp = self._map.setdefault(self, weakref.WeakKeyDictionary())\n    return tmp.setdefault(instance, Signal())\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function sets up a WeakKeyDictionary which stores a Signal object that is associated with the instance passed to the function. It returns the Signal object associated with the instance if it already exists in the WeakKeyDictionary, otherwise it creates a new Signal object and stores it in the WeakKeyDictionary for future reference."}
{"prompt": "def __getitem__(self, idx):\n    return self._objects[idx]\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function returns the object stored at the given index in the self._objects list."}
{"prompt": "def lastNodeOfType(self, nodeTypes, startNode, preferredStatus=None):\n    if not startNode:\n        return None\n    nodes = self._graph.dfsOnDiscover(startNodes=[startNode], filterTypes=nodeTypes, reverse=True)[0]\n    if not nodes:\n        return None\n    node = nodes[-1]\n    if preferredStatus:\n        node = next((n for n in reversed(nodes) if n.getGlobalStatus() == preferredStatus), node)\n    return node\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturns the last node of a given type in a DFS traversal, starting from a given node, with an optional preferred global status."}
{"prompt": "@Slot(QVector3D, result=QVector3D)\ndef fromEquirectangular(self, vector):\n    return QVector3D(cos(vector.x()) * sin(vector.y()), sin(vector.x()), cos(vector.x()) * cos(vector.y()))\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturns a QVector3D constructed from an equirectangular vector. Given a QVector3D with coordinates (x, y, z) it will return a QVector3D with coordinates (cos(x) * sin(y), sin(x), cos(x) * cos(y))."}
{"prompt": "def _applyExpr(self):\n    with GraphModification(self):\n        for node in self._nodes:\n            node._applyExpr()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nApply the expression to all nodes in the graph.\n\nThis function applies the current expression to all nodes in the graph. It is intended to be used internally."}
{"prompt": "def undoImpl(self):\n    self.graph.removeNode(self.nodeName)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nRemove a node from the graph.\n\nParameters:\n    self (object): The instance of the current class.\n    self.graph (object): The graph object.\n    self.nodeName (str): The name of the node to be removed.\n\"\"\""}
{"prompt": "def hasExtension(filepath, extensions):\n    return os.path.splitext(filepath)[1].lower() in extensions\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nChecks whether the given filepath has an extension that is included in the given list of extensions.\n\nParameters:\nfilepath (str): The filepath to check.\nextensions (list): A list of extensions to check against.\n\nReturns:\nbool: True if the filepath has an extension in the given list, False otherwise.\n\"\"\""}
{"prompt": "def validateValue(self, value):\n    if not isinstance(value, str):\n        raise ValueError('StringParam value should be a string (param:{}, value:{}, type:{})'.format(self.name, value, type(value)))\n    return value\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"This function checks if the given value is a string. If not, it will raise a ValueError containing the parameter name, value, and type of the given value.\"\"\""}
{"prompt": "@Slot(QObject, result=bool)\ndef hasMetadata(self, viewpoint):\n    return len(viewpoint.metadata.value) > 2\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"This function returns a boolean value indicating whether the given viewpoint has more than two metadata entries.\"\"\""}
{"prompt": "@Slot(Attribute)\ndef resetAttribute(self, attribute):\n    self.push(commands.SetAttributeCommand(self._graph, attribute, attribute.defaultValue()))\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReset the given attribute to its default value on the graph."}
{"prompt": "@position.setter\ndef position(self, value):\n    if self._position == value:\n        return\n    self._position = value\n    self.positionChanged.emit()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function sets the value of the _position attribute and emits the positionChanged signal."}
{"prompt": "def insert(self, index, iterable):\n    self._objects[index:index] = iterable\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nInsert iterable into the list at the given index.\n\nArgs:\n    index (int): The index of the list where the iterable should be inserted.\n    iterable (iterable): An iterable, such as a list or tuple, to be inserted into the list.\n\nReturns:\n    None.\n\"\"\""}
{"prompt": "def fromDict(self, d):\n    for (k, v) in d.items():\n        setattr(self, k, v)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nsetattr(object, name, value)\n\nSet the named attribute on the given object to the specified value. The name must be a string. The object can be anything, even a module or a class. Returns None."}
{"prompt": "@Slot(str, result=str)\ndef nameToLabel(self, name):\n    (t, idx) = name.split('_')\n    return '{}{}'.format(t, idx if int(idx) > 1 else '')\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes in a string `name` and returns a string `result`. It splits the name by \"_\" and then returns a string with the characters before the \"_\" followed by the characters after the \"_\" if the number after the \"_\" is greater than 1."}
{"prompt": "def __repr__(self):\n    return self.name\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function returns a string representation of the object, typically the name of the object."}
{"prompt": "def __init__(self, parent=None):\n    super(SimpleFarmSubmitter, self).__init__(name='SimpleFarm', parent=parent)\n    self.engine = os.environ.get('MESHROOM_SIMPLEFARM_ENGINE', 'tractor')\n    self.share = os.environ.get('MESHROOM_SIMPLEFARM_SHARE', 'vfx')\n    self.prod = os.environ.get('PROD', 'mvg')\n    if 'REZ_REQUEST' in os.environ:\n        packages = os.environ.get('REZ_REQUEST', '').split()\n        resolvedPackages = os.environ.get('REZ_RESOLVE', '').split()\n        resolvedVersions = {}\n        for r in resolvedPackages:\n            if r.startswith('~'):\n                continue\n            v = r.split('-')\n            if len(v) == 2:\n                resolvedVersions[v[0]] = v[1]\n        for p in packages:\n            if p.startswith('~'):\n                continue\n            v = p.split('-')\n            self.reqPackages.append('-'.join([v[0], resolvedVersions[v[0]]]))\n        logging.debug('REZ Packages: {}'.format(str(self.reqPackages)))\n    elif 'REZ_MESHROOM_VERSION' in os.environ:\n        self.reqPackages = ['meshroom-{}'.format(os.environ.get('REZ_MESHROOM_VERSION', ''))]\n    else:\n        self.reqPackages = None\n    if 'REZ_DEV_PACKAGES_ROOT' in os.environ:\n        self.environment['REZ_DEV_PACKAGES_ROOT'] = os.environ['REZ_DEV_PACKAGES_ROOT']\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis is the constructor for the SimpleFarmSubmitter class. It sets up the environment variables and the required packages needed to submit jobs to a farm.  It also logs the packages to use for debugging purposes."}
{"prompt": "def _referenceItem(self, item):\n    if item.staticMetaObject != self._metaObject:\n        raise TypeError('Invalid object type: expected {}, got {}'.format(self._metaObject.className(), item.staticMetaObject.className()))\n    super(QTypedObjectListModel, self)._referenceItem(item)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function checks if the item is of the same type as the model's metaObject, and if so, passes the item to the superclass's referenceItem function. Raises a TypeError if the item is of the wrong type."}
{"prompt": "def checkValueTypes(self):\n    raise NotImplementedError('Attribute.checkValueTypes is an abstract function that should be implemented in the derived class.')\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function raises a NotImplementedError, indicating that it is an abstract function that should be implemented in the derived class."}
{"prompt": "def run(*args):\n    m = __import__('__main__')\n    importer = zipimport.zipimporter(os.path.dirname(os.__file__))\n    if len(args) == 0:\n        (name, ext) = os.path.splitext(os.path.basename(os.path.normcase(FILE_NAME)))\n        moduleName = '%s__main__' % name\n    else:\n        moduleName = args[0]\n    code = importer.get_code(moduleName)\n    exec(code, m.__dict__)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nrun(*args)\n\nRuns the module given by the first argument as the main module. If no argument is given, runs the module containing the file currently being executed.\n\"\"\""}
{"prompt": "def undoImpl(self):\n    listAttribute = self.graph.attribute(self.attrName)\n    listAttribute.remove(self.index, self.count)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"This function removes a specified number of elements from a given attribute in a graph.\"\"\""}
{"prompt": "def validateValue(self, value):\n    if JSValue is not None and isinstance(value, JSValue):\n        raise ValueError('GroupAttribute.validateValue: cannot recognize QJSValue. Please, use JSON.stringify(value) in QML.')\n    if isinstance(value, str):\n        value = ast.literal_eval(value)\n    if isinstance(value, dict):\n        if self._groupDesc:\n            commonKeys = set(value.keys()).intersection([attr.name for attr in self._groupDesc])\n            if not commonKeys:\n                raise ValueError('Value contains no key that matches with the group description: {}'.format(commonKeys))\n    elif isinstance(value, (list, tuple)):\n        if len(value) != len(self._groupDesc):\n            raise ValueError('Value contains incoherent number of values: desc size: {}, value size: {}'.format(len(self._groupDesc), len(value)))\n    else:\n        raise ValueError('GroupAttribute only supports dict/list/tuple input values (param:{}, value:{}, type:{})'.format(self.name, value, type(value)))\n    return value\n##############\nEND_FUNC\n##############\n", "completion": "\n\nValidates a value to ensure it is of the correct type and has the expected number of elements if it is a list or tuple. Raises a ValueError if the value is not a dict, list, tuple, or QJSValue, or if the value does not match the group description."}
{"prompt": "def isAlreadySubmitted(self):\n    for chunk in self._chunks:\n        if chunk.isAlreadySubmitted():\n            return True\n    return False\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function checks if the chunk has already been submitted. It returns True if one of the chunks has already been submitted, and False otherwise."}
{"prompt": "@Slot(Node, result=int)\ndef canSubmitOrCompute(self, startNode):\n    if startNode.isAlreadySubmittedOrFinished():\n        return 0\n\n    class SCVisitor(Visitor):\n\n        def __init__(self, reverse, dependenciesOnly):\n            super(SCVisitor, self).__init__(reverse, dependenciesOnly)\n        canCompute = True\n        canSubmit = True\n\n        def discoverVertex(self, vertex, graph):\n            if vertex.isAlreadySubmitted():\n                self.canSubmit = False\n                if vertex.isExtern():\n                    self.canCompute = False\n    visitor = SCVisitor(reverse=False, dependenciesOnly=True)\n    self.dfs(visitor=visitor, startNodes=[startNode])\n    return visitor.canCompute + 2 * visitor.canSubmit\n##############\nEND_FUNC\n##############\n", "completion": "\nThis function examines the dependencies of a given startNode, and returns an integer depending on whether or not it can be submitted or computed. It is 0 if the startNode has already been submitted or finished, 1 if only computations are possible, 2 if only submissions are possible, and 3 if both submissions and computations are possible."}
{"prompt": "def relink(self, node, base_dir):\n    key = get_link_key(node)\n    if key is None:\n        return\n    link = node.attributes[key]\n    if link.startswith('http') or link.startswith('mailto'):\n        return\n    if link.startswith('/'):\n        link = link[1:]\n    node.attributes[key] = base_dir + '/' + link\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function takes a node and a base directory as parameters, and relinks the node's attribute (specified by the key returned by get_link_key()) to a new link which is the base directory plus the original link. If the original link starts with 'http' or 'mailto', it is not changed. If the original link starts with a '/', it is removed."}
{"prompt": "def validateValue(self, value):\n    if self.exclusive:\n        return self.conformValue(value)\n    if isinstance(value, str):\n        value = value.split(',')\n    if not isinstance(value, Iterable):\n        raise ValueError('Non exclusive ChoiceParam value should be iterable (param:{}, value:{}, type:{})'.format(self.name, value, type(value)))\n    return [self.conformValue(v) for v in value]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nValidates the value of a ChoiceParam. If the ChoiceParam is exclusive, the value is simply conformed. Otherwise, if the value is a string, it is split by commas and each element is conformed. If the value is not an iterable, a ValueError is raised. Returns a list of conformed values."}
{"prompt": "@raiseIfLink\ndef extend(self, values):\n    self.insert(len(self._value), values)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nRaise an error if the argument `values` is a link."}
{"prompt": "def __eq__(self, other):\n    return self.name == other.name\n##############\nEND_FUNC\n##############\n", "completion": "\n\nCompares two objects and returns True if their names are equal, False otherwise."}
{"prompt": "@staticmethod\ndef resetExternalLinks(attributes, nodeDesc, newNames):\n    for (key, val) in attributes.items():\n        defaultValue = None\n        for desc in nodeDesc:\n            if desc.name == key:\n                defaultValue = desc.value\n                break\n        if isinstance(val, str):\n            if Attribute.isLinkExpression(val) and (not any((name in val for name in newNames))):\n                if defaultValue is not None:\n                    attributes[key] = defaultValue\n        elif isinstance(val, list):\n            removedCnt = len(val)\n            tmpVal = list(val)\n            for v in tmpVal:\n                if isinstance(v, str) and Attribute.isLinkExpression(v) and (not any((name in v for name in newNames))):\n                    val.remove(v)\n                    removedCnt -= 1\n            if removedCnt == 0 and defaultValue is not None:\n                attributes[key] = defaultValue\n    return attributes\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function resets external links in the given attributes dictionary, for node descriptions in nodeDesc and for new names in newNames. It will update the attributes dictionary by either setting the default value of the key or by removing entries in the list."}
{"prompt": "@property\ndef isParallelized(self):\n    return bool(self.nodeDesc.parallelization) if meshroom.useMultiChunks else False\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function returns a boolean indicating if the node is parallelized or not. If meshroom.useMultiChunks is True, then this function returns the parallelization of the nodeDesc attribute, otherwise False."}
{"prompt": "@Slot(QObject)\ndef setActiveNodes(self, nodes):\n    nodesByCategory = {}\n    for node in nodes:\n        if node is None:\n            continue\n        for (category, nodeTypes) in self.activeNodeCategories.items():\n            if node.nodeType in nodeTypes:\n                nodesByCategory[category] = node\n    for (category, node) in nodesByCategory.items():\n        self.activeNodes.get(category).node = node\n        if category == 'sfm':\n            self.setSfm(node)\n    for node in nodes:\n        if node is None:\n            continue\n        if not isinstance(node, CompatibilityNode):\n            self.activeNodes.get(node.nodeType).node = node\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function sets the active nodes for the given node categories. It takes in a list of nodes and checks if each node is compatible with the active node categories. If it is, the node is added to the dictionary of active nodes by category. If the node is of type 'sfm', the setSfm function is also called. Finally, if the node is not an instance of CompatibilityNode, it is added to the activeNodes dictionary."}
{"prompt": "@Slot(Qt3DCore.QEntity, Qt3DCore.QComponent)\ndef removeComponent(self, entity, component):\n    entity.removeComponent(component)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Removes a component from the given entity.\"\"\""}
{"prompt": "def dfsOnDiscover(self, startNodes=None, filterTypes=None, longestPathFirst=False, reverse=False, dependenciesOnly=False):\n    nodes = []\n    edges = []\n    visitor = Visitor(reverse=reverse, dependenciesOnly=dependenciesOnly)\n\n    def discoverVertex(vertex, graph):\n        if not filterTypes or vertex.nodeType in filterTypes:\n            nodes.append(vertex)\n    visitor.discoverVertex = discoverVertex\n    visitor.examineEdge = lambda edge, graph: edges.append(edge)\n    self.dfs(visitor=visitor, startNodes=startNodes, longestPathFirst=longestPathFirst)\n    return (nodes, edges)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function performs a Depth First Search (DFS) on the graph and returns a list of nodes and edges found by the search. It takes optional parameters startNodes, filterTypes, longestPathFirst, reverse, and dependenciesOnly, which can be used to customize the search."}
{"prompt": "@Slot(Attribute, 'QVariant')\ndef setAttribute(self, attribute, value):\n    self.push(commands.SetAttributeCommand(self._graph, attribute, value))\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function creates a new SetAttributeCommand with the given attribute and value and pushes it to the _graph."}
{"prompt": "def projectToTrackball(self, screenCoords):\n    sx = screenCoords.x()\n    sy = self._windowSize.height() - screenCoords.y()\n    p2d = QVector2D(sx / self._windowSize.width() - 0.5, sy / self._windowSize.height() - 0.5)\n    z = 0.0\n    r2 = pow(self._trackballSize, 2)\n    lengthSquared = p2d.lengthSquared()\n    if lengthSquared <= r2 * 0.5:\n        z = sqrt(r2 - lengthSquared)\n    else:\n        z = r2 * 0.5 / p2d.length()\n    return QVector3D(p2d.x(), p2d.y(), z)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function projects a given 2D screen coordinate onto a trackball. It uses the trackball size and window size to calculate the 3D vector associated with the screen coordinate."}
{"prompt": "@property\ndef dst(self):\n    return self._dst()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Returns the daylight savings time of the datetime object.\"\"\""}
{"prompt": "@classmethod\ndef handler(cls, messageType, context, message):\n    if not cls.outputQmlWarnings:\n        if 'QQmlApplicationEngine failed to load component' in message:\n            logging.warning('Set MESHROOM_OUTPUT_QML_WARNINGS=1 to get a detailed error message.')\n        elif any((w in message for w in cls.qmlWarningsBlacklist)):\n            return\n    MessageHandler.logFunctions[messageType](message)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis classmethod handles the logging of messages. It checks if the outputQmlWarnings flag is set and if not, it checks if the message contains a warning related to QQmlApplicationEngine and then filters it through the qmlWarningsBlacklist. Finally, it logs the message using the logging functions associated with the given message type."}
{"prompt": "def __init__(self, *args):\n    if len(args) == 0:\n        self.components = tuple()\n    elif len(args) == 1:\n        versionName = args[0]\n        if isinstance(versionName, str):\n            self.components = Version.toComponents(versionName)\n        elif isinstance(versionName, (list, tuple)):\n            self.components = tuple([int(v) for v in versionName])\n        else:\n            raise RuntimeError('Version: Unsupported input type.')\n    else:\n        self.components = tuple([int(v) for v in args])\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function creates a Version object from a given set of version components. If no components are given, an empty tuple is created. If a single input argument is given, it can be either a string or a list/tuple. If a string is given, it will be converted to a tuple of version components. If a list/tuple is given, it will be converted to a tuple of integers. If multiple input arguments are given, they will be converted to a tuple of integers."}
{"prompt": "@Slot(result=str)\ndef getFirst(self):\n    if not self._content:\n        return ''\n    return self._content[0]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function returns the first item from the '_content' list. If the list is empty, it will return an empty string. The result is a string."}
{"prompt": "def finishVertex(vertex, graph):\n    v = nodesStack.pop()\n    assert v == vertex\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function removes the given vertex from the graph, and checks if it is equal to the vertex at the top of the nodesStack."}
{"prompt": "def fromDict(self, d):\n    self.status = d.get('status', Status.NONE)\n    if not isinstance(self.status, Status):\n        self.status = Status[self.status]\n    self.execMode = d.get('execMode', ExecMode.NONE)\n    if not isinstance(self.execMode, ExecMode):\n        self.execMode = ExecMode[self.execMode]\n    self.nodeName = d.get('nodeName', '')\n    self.nodeType = d.get('nodeType', '')\n    self.packageName = d.get('packageName', '')\n    self.packageVersion = d.get('packageVersion', '')\n    self.graph = d.get('graph', '')\n    self.commandLine = d.get('commandLine', '')\n    self.env = d.get('env', '')\n    self.startDateTime = d.get('startDateTime', '')\n    self.endDateTime = d.get('endDateTime', '')\n    self.elapsedTime = d.get('elapsedTime', 0)\n    self.hostname = d.get('hostname', '')\n    self.sessionUid = d.get('sessionUid', '')\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function sets the properties of a given object using values from a dictionary. The supported properties are 'status', 'execMode', 'nodeName', 'nodeType', 'packageName', 'packageVersion', 'graph', 'commandLine', 'env', 'startDateTime', 'endDateTime', 'elapsedTime', 'hostname', and 'sessionUid'. If the value for any property is not of the appropriate type, the function will attempt to cast it."}
{"prompt": "@property\ndef depth(self):\n    return self.graph.getDepth(self)\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nReturn the depth of the current node in the graph."}
{"prompt": "def _updateInitialParams(self):\n    if not self._reconstruction.cameraInit:\n        self._initialIntrinsics = None\n        self._metadata = {}\n    else:\n        self._initialIntrinsics = self._reconstruction.getIntrinsic(self._viewpoint)\n        try:\n            self._metadata = json.loads(self._viewpoint.metadata.value) if self._viewpoint.metadata.value else None\n        except Exception as e:\n            logging.warning(\"Failed to parse Viewpoint metadata: '{}', '{}'\".format(str(e), str(self._viewpoint.metadata.value)))\n            self._metadata = {}\n        if not self._metadata:\n            self._metadata = {}\n    self.initialParamsChanged.emit()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function updates the initial parameters for a given viewpoint. It sets the initial intrinsics and loads the metadata from the viewpoint before emitting a signal to indicate that the initial parameters have changed."}
{"prompt": "def stopProcess(self, chunk):\n    self._stopped = True\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nStop the current process.\n\nArgs:\n    self (object): The object instance.\n    chunk (any): The chunk to process.\n\nReturns:\n    None\n\"\"\""}
{"prompt": "@Slot(str, result=bool)\ndef load(self, filepath, setupProjectFile=True):\n    try:\n        status = super(Reconstruction, self).loadGraph(filepath, setupProjectFile)\n        if Version(self._graph.fileReleaseVersion).major == '0':\n            self.warning.emit(Message('Automatic project upgrade', 'This project was created with an older version of Meshroom and has been automatically upgraded.\\nData might have been lost in the process.', 'Open it with the corresponding version of Meshroom to recover your data.'))\n        return status\n    except FileNotFoundError as e:\n        self.error.emit(Message('No Such File', \"Error While Loading '{}': No Such File.\".format(os.path.basename(filepath)), ''))\n        logging.error(\"Error while loading '{}': No Such File.\".format(os.path.basename(filepath)))\n        return False\n    except Exception as e:\n        import traceback\n        trace = traceback.format_exc()\n        self.error.emit(Message('Error While Loading Project File', \"An unexpected error has occurred while loading file: '{}'\".format(os.path.basename(filepath)), trace))\n        logging.error(trace)\n        return False\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function attempts to load a graph from a given filepath and set up the project file if needed. It returns a boolean result indicating whether the graph was successfully loaded. If the graph was created with an older version of Meshroom, a warning message is emitted. In the event of a FileNotFoundError or any other exception, an error message is emitted and False is returned."}
{"prompt": "def upgrade(self):\n    if not self.canUpgrade:\n        raise NodeUpgradeError(self.name, 'no matching node type')\n    commonInputs = []\n    for (attrName, value) in self._inputs.items():\n        if self.attributeDescFromName(self.nodeDesc.inputs, attrName, value, strict=False):\n            commonInputs.append(attrName)\n    node = Node(self.nodeType, position=self.position)\n    attrValues = {key: value for (key, value) in self.inputs.items()}\n    try:\n        upgradedAttrValues = node.nodeDesc.upgradeAttributeValues(attrValues, self.version)\n    except Exception as e:\n        logging.error('Error in the upgrade implementation of the node: {}.\\n{}'.format(self.name, str(e)))\n        upgradedAttrValues = attrValues\n    if not isinstance(upgradedAttrValues, dict):\n        logging.error('Error in the upgrade implementation of the node: {}. The return type is incorrect.'.format(self.name))\n        upgradedAttrValues = attrValues\n    upgradedAttrValuesTmp = {key: value for (key, value) in upgradedAttrValues.items() if key in commonInputs}\n    node.upgradeAttributeValues(upgradedAttrValues)\n    return node\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function upgrades an existing node. It takes a node object as an argument, checks if it can be upgraded, and then updates its attributes according to its node descriptor. It also catches any errors that may arise during the upgrade process and logs them."}
{"prompt": "@Slot()\n@Slot(str)\ndef new(self, pipeline=None):\n    p = pipeline if pipeline != None else self._defaultPipeline\n    ' Create a new pipeline. '\n    loweredPipelineTemplates = dict(((k.lower(), v) for (k, v) in meshroom.core.pipelineTemplates.items()))\n    if p.lower() in loweredPipelineTemplates:\n        self.load(loweredPipelineTemplates[p.lower()], setupProjectFile=False)\n    else:\n        self.load(p, setupProjectFile=False)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nCreate a new pipeline."}
{"prompt": "def requestBlockRestart(self):\n    self._blockRestart = True\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function sets the internal variable \"_blockRestart\" to True."}
{"prompt": "def __init__(self, iteration=0, blockSize=0, fullSize=0):\n    self.iteration = iteration\n    self.blockSize = blockSize\n    self.fullSize = fullSize\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function initializes the attributes of an object with the default values given. The attributes are iteration, blockSize, and fullSize, and they are all set to 0 by default."}
{"prompt": "@Property(type=QSizeF, notify=initialParamsChanged)\ndef imageSize(self):\n    if not self._initialIntrinsics:\n        return QSizeF(0, 0)\n    return QSizeF(self._initialIntrinsics.width.value, self._initialIntrinsics.height.value)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function returns a QSizeF object that contains the width and height of the initialIntrinsics object. If the initialIntrinsics object is not present, the QSizeF object will have a width and height of 0. A signal is emitted if the initialParamsChanged property is changed."}
{"prompt": "def redoImpl(self):\n    listAttribute = self.graph.attribute(self.listAttrName)\n    listAttribute.remove(self.index)\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nredoImpl(self) removes the element at self.index from the listAttribute attribute of self.graph and returns True."}
{"prompt": "def importImagesSync(self, images, cameraInit):\n    try:\n        self.buildIntrinsics(cameraInit, images)\n    except Exception as e:\n        self.importImagesFailed.emit(str(e))\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function attempts to build camera intrinsics from a list of images and cameraInit parameters. If an exception is encountered, the signal importImagesFailed is emitted with the exception message as a string."}
{"prompt": "def __iter__(self):\n    return self._objects.__iter__()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Returns an iterator over the objects contained in the collection.\"\"\""}
{"prompt": "@Slot(str)\ndef beginModification(self, name):\n    self._modificationCount += 1\n    self._undoStack.beginMacro(name)\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nBegin a modification operation, adding an operation to the undo stack with the given name."}
{"prompt": "def checkValueTypes(self):\n    if not isinstance(self.value, str) and (not callable(self.value)):\n        return self.name\n    return ''\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function checks whether the value stored in self.value is of type string or callable. If it is not, it returns the name stored in self.name, else it returns an empty string."}
{"prompt": "def test_transitive_reduction():\n    graph = Graph('Tests tasks depth')\n    tA = graph.addNewNode('Ls', input='/tmp')\n    tB = graph.addNewNode('AppendText', inputText='echo B')\n    tC = graph.addNewNode('AppendText', inputText='echo C')\n    tD = graph.addNewNode('AppendText', inputText='echo D')\n    tE = graph.addNewNode('AppendFiles')\n    graph.addEdges((tA.output, tE.input), (tA.output, tB.input), (tB.output, tC.input), (tB.output, tD.input), (tB.output, tE.input4), (tC.output, tE.input3), (tD.output, tE.input2))\n    edgesScore = graph.dfsMaxEdgeLength()\n    flowEdges = graph.flowEdges()\n    flowEdgesRes = [(tB, tA), (tD, tB), (tC, tB), (tE, tD), (tE, tC)]\n    assert set(flowEdgesRes) == set(flowEdges)\n    assert len(graph._nodesMinMaxDepths) == len(graph.nodes)\n    for (node, (minDepth, maxDepth)) in graph._nodesMinMaxDepths.items():\n        assert node.depth == maxDepth\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function performs a transitive reduction on a graph. It adds nodes and edges to the graph, computes the edges score, finds the flow edges and asserts that the flow edges are correct. It also asserts that the number of nodes and their minimum and maximum depths are correct."}
{"prompt": "@Slot(result=str)\ndef getText(self):\n    return self._clipboard.text()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nGet the text from the clipboard.\n\nReturns:\n    str: The text from the clipboard."}
{"prompt": "@Slot(str, result=str)\n@Slot(QUrl, result=str)\ndef extension(self, path):\n    return os.path.splitext(self.asStr(path))[-1]\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nReturns the extension of the given path as a string. Path can be either a string or a QUrl."}
{"prompt": "def _get_value(self):\n    if self.isLink:\n        return self.getLinkParam().value\n    return self._value\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nGet the value of the object. If it is a link, get the linked parameter's value; otherwise, get the object's value."}
{"prompt": "def addFiles(self, files):\n    for file in files:\n        self.addFile(file)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nAdd Files: Add a list of files to the current object.\n\nParameters:\nfiles (list): List of files to be added.\n\nReturns:\nNone\n\"\"\""}
{"prompt": "def updateDuplicates(self, nodesPerUid):\n    uid = self._uids.get(0)\n    if not nodesPerUid or not uid:\n        if len(self._duplicates) > 0:\n            self._duplicates.clear()\n            self._hasDuplicates = False\n            self.hasDuplicatesChanged.emit()\n        return\n    newList = [node for node in nodesPerUid.get(uid) if node != self]\n    if len(newList) == len(self._duplicates):\n        newListName = set([node.name for node in newList])\n        oldListName = set([node.name for node in self._duplicates.values()])\n        if newListName == oldListName:\n            return\n    self._duplicates.setObjectList(newList)\n    if bool(len(newList)) != self._hasDuplicates:\n        self._hasDuplicates = bool(len(newList))\n        self.hasDuplicatesChanged.emit()\n##############\nEND_FUNC\n##############\n", "completion": "\nThis function checks if a given list of nodes is a duplicate of the node it belongs to and updates the list accordingly. It also emits a signal if the list of duplicates has changed."}
{"prompt": "def _addEdge(self, src, dst):\n    with self.groupedGraphModification(\"Connect '{}'->'{}'\".format(src.getFullNameToNode(), dst.getFullNameToNode())):\n        if dst in self._graph.edges.keys():\n            self.removeEdge(self._graph.edge(dst))\n        self.push(commands.AddEdgeCommand(self._graph, src, dst))\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nAdd an edge to the graph.\n\nParameters:\n    src (Node): Source node to connect\n    dst (Node): Destination node to connect\n\nReturns:\n    None\n\"\"\""}
{"prompt": "def clearLocallySubmittedChunks(self):\n    for chunk in self._chunks:\n        if chunk.isAlreadySubmitted() and (not chunk.isExtern()):\n            chunk.upgradeStatusTo(Status.NONE, ExecMode.NONE)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function clears all locally submitted chunks, setting their status to NONE and exec mode to NONE."}
{"prompt": "@alive.setter\ndef alive(self, value):\n    if self._alive == value:\n        return\n    self._alive = value\n    self.aliveChanged.emit()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function sets the value for self._alive and emits a signal (aliveChanged) if the value has been changed."}
{"prompt": "@Slot(Qt3DCore.QTransform, QMatrix4x4, QMatrix4x4, QMatrix4x4, QVector3D)\ndef relativeLocalScale(self, transformQtInstance, initialPosMat, initialRotMat, initialScaleMat, scaleVec):\n    scaleMat = self.copyMatrix4x4(initialScaleMat)\n    scaleVecTuple = scaleVec.toTuple()\n    for i in range(3):\n        currentRow = list(scaleMat.row(i).toTuple())\n        value = currentRow[i] + scaleVecTuple[i]\n        value = value if value >= 0 else -value\n        currentRow[i] = value\n        scaleMat.setRow(i, QVector3D(currentRow[0], currentRow[1], currentRow[2]))\n    mat = initialPosMat * initialRotMat * scaleMat\n    transformQtInstance.setMatrix(mat)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function updates the scale of the given Qt3DCore.QTransform object using the given initial position matrix, initial rotation matrix, initial scale matrix, and scale vector."}
{"prompt": "def compareFilesTimes(self, times):\n    newRecords = dict(zip(self.chunks, times))\n    for (chunk, fileModTime) in newRecords.items():\n        if fileModTime != chunk.statusFileLastModTime:\n            chunk.updateStatusFromCache()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\ncompareFilesTimes() compares the modification times of the status files for the given chunks and updates them if they are different.\n\nInputs:\n- self: object instance\n- times: a list of modification times\n\nOutputs:\n- None"}
{"prompt": "def items(self):\n    return self._objectByKey.items()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturn a view object of the dictionary's key-value pairs."}
{"prompt": "def setDefaultPipeline(self, defaultPipeline):\n    self._defaultPipeline = defaultPipeline\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"Set the default pipeline for this class to the given parameter\""}
{"prompt": "def __init__(self, keyAttrName, **kwargs):\n    self._objects = {}\n    self._keyAttrName = keyAttrName\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__(self, keyAttrName, **kwargs)\n\nInitialize a new instance of the class.\n\nParameters:\n    keyAttrName (str): The name of the attribute on the objects used as a key.\n    **kwargs (dict): Additional keyword arguments.\n\nReturns:\n    None.\n\"\"\""}
{"prompt": "def getGlobalStatus(self):\n    chunksStatus = [chunk.status.status for chunk in self._chunks]\n    anyOf = (Status.ERROR, Status.STOPPED, Status.KILLED, Status.RUNNING, Status.SUBMITTED)\n    allOf = (Status.SUCCESS,)\n    for status in anyOf:\n        if any((s == status for s in chunksStatus)):\n            return status\n    for status in allOf:\n        if all((s == status for s in chunksStatus)):\n            return status\n    return Status.NONE\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturns the global status of the task, based on the statuses of its chunks. If any chunk has a status of Status.ERROR, Status.STOPPED, Status.KILLED, or Status.RUNNING, the global status is that status. If all chunks have a status of Status.SUCCESS, the global status is Status.SUCCESS. Otherwise, the global status is Status.NONE."}
{"prompt": "def getExportValue(self):\n    if self.isLink:\n        return self.getLinkParam().asLinkExpr()\n    return [attr.getExportValue() for attr in self._value]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturn the export value of the object. If the object is a link, returns the link parameters as a link expression, otherwise returns a list of export values for each attribute in the object's value."}
{"prompt": "def finishEdge(edge, graph):\n    (u, v) = edge\n    for (i, n) in enumerate(reversed(nodesStack)):\n        index = i + 1\n        if index > edgesScore[n, v]:\n            edgesScore[n, v] = index\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function updates the score of an edge in a graph. It takes in an edge (u, v) and a graph, then updates the edgesScore dictionary with the index of the node in the reversed nodesStack."}
{"prompt": "def at(self, idx):\n    return self._value.at(idx)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Returns the element at the specified index of the underlying sequence of values.\"\"\""}
{"prompt": "def getCameraInitIndex(self):\n    if not self._cameraInit:\n        return -1\n    if not self._cameraInit.graph:\n        return -1\n    return self._cameraInits.indexOf(self._cameraInit)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function returns the index of the cameraInit in the cameraInits list. If cameraInit is not set, or the graph is not set, it will return -1."}
{"prompt": "def discoverVertex(vertex, graph):\n    self._nodesMinMaxDepths[vertex] = (0, 0)\n    self._computationBlocked[vertex] = False\n    if isinstance(vertex, CompatibilityNode):\n        compatNodes.append(vertex)\n        if not vertex.hasStatus(Status.SUCCESS):\n            self._computationBlocked[vertex] = True\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nDiscover a vertex in the graph.\n\nArgs:\n    vertex (object): The vertex to discover.\n    graph (object): The graph containing the vertex.\n\nReturns:\n    None\n\"\"\""}
{"prompt": "def undoImpl(self):\n    for name in self.nodeNames:\n        self.graph.removeNode(name)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function removes all nodes with the given names from the graph."}
{"prompt": "def finishVertex(vertex, graph):\n    chunksToProcess = []\n    for chunk in vertex.chunks:\n        if chunk.status.status is not Status.SUCCESS:\n            chunksToProcess.append(chunk)\n    if chunksToProcess:\n        nodes.append(vertex)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function checks the status of each chunk in a given vertex. Any chunks that have not yet been marked as successful will be added to the list \"chunksToProcess\". If there are any chunks in the list, the vertex will be appended to the nodes list.\n\"\"\""}
{"prompt": "@staticmethod\ndef attributeDescFromValue(attrName, value, isOutput):\n    params = {'name': attrName, 'label': attrName, 'description': 'Incompatible parameter', 'value': value, 'uid': (), 'group': 'incompatible'}\n    if isinstance(value, bool):\n        return desc.BoolParam(**params)\n    if isinstance(value, int):\n        return desc.IntParam(range=None, **params)\n    elif isinstance(value, float):\n        return desc.FloatParam(range=None, **params)\n    elif isinstance(value, str):\n        if isOutput or os.path.isabs(value) or Attribute.isLinkExpression(value):\n            return desc.File(**params)\n        else:\n            return desc.StringParam(**params)\n    elif isinstance(value, (list, dict)):\n        del params['value']\n        del params['uid']\n        attrDesc = None\n        if isinstance(value, list):\n            elt = value[0] if value else ''\n            eltDesc = CompatibilityNode.attributeDescFromValue('element', elt, isOutput)\n            attrDesc = desc.ListAttribute(elementDesc=eltDesc, **params)\n        elif isinstance(value, dict):\n            groupDesc = []\n            for (key, value) in value.items():\n                eltDesc = CompatibilityNode.attributeDescFromValue(key, value, isOutput)\n                groupDesc.append(eltDesc)\n            attrDesc = desc.GroupAttribute(groupDesc=groupDesc, **params)\n        attrDesc._value = value\n        return attrDesc\n    return desc.StringParam(**params)\n##############\nEND_FUNC\n##############\n", "completion": "\nThis staticmethod creates the correct attribute descriptor based on the parameter type (e.g. bool, int, float, str, list, dict). It takes an attribute name, a value, and a boolean indicating whether the attribute is an output. It returns the appropriate descriptor."}
{"prompt": "def __get__(self, instance, owner):\n    tmp = self._map.setdefault(self, weakref.WeakKeyDictionary())\n    signal = tmp.setdefault(instance, SignalFactory())\n    for name in self._names:\n        signal.register(name)\n    return signal\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function gets a Signal object associated with the given instance, and registers all the names in self._names with the Signal object. If a Signal object does not exist for the given instance, a new one is created."}
{"prompt": "def __init__(self, graph, parent=None):\n    super(GraphCommand, self).__init__(parent)\n    self.graph = graph\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__(self, graph, parent=None):\n    \"\"\"Initialize a GraphCommand object.\n\n    Arguments:\n        graph (Graph): An instance of Graph.\n        parent (QObject): The parent object of the GraphCommand.\n    \"\"\""}
{"prompt": "def __init__(self, node, attributeDesc, isOutput, root=None, parent=None):\n    super(GroupAttribute, self).__init__(node, attributeDesc, isOutput, root, parent)\n    self._value = DictModel(keyAttrName='name', parent=self)\n    subAttributes = []\n    for subAttrDesc in self.attributeDesc.groupDesc:\n        childAttr = attributeFactory(subAttrDesc, None, self.isOutput, self.node, self)\n        subAttributes.append(childAttr)\n        childAttr.valueChanged.connect(self.valueChanged)\n    self._value.reset(subAttributes)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"This function initializes a GroupAttribute instance, which is a special type of attribute used to group other attributes. It takes the node, attributeDescription, isOutput, root and parent parameters. It sets the value of the instance to a DictModel, and creates a list of child attributes based on the groupDesc in the attributeDescription. It also connects the valueChanged signal of each child attribute to the valueChanged signal of the instance.\"\"\""}
{"prompt": "def stopComputation(self):\n    for chunk in self._chunks.values():\n        if not chunk.isExtern():\n            chunk.stopProcess()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nstopComputation() stops the processes for all chunks in self._chunks that are not external."}
{"prompt": "@Slot(Qt3DCore.QEntity, Qt3DCore.QComponent)\ndef addComponent(self, entity, component):\n    entity.addComponent(component)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nAdd a component to an entity.\n\nArgs:\n    entity (Qt3DCore.QEntity): The entity to add the component to\n    component (Qt3DCore.QComponent): The component to be added to the entity"}
{"prompt": "@Slot(str, result=str)\n@Slot(QUrl, result=str)\ndef globFirst(self, path):\n    import glob\n    fileList = glob.glob(self.asStr(path))\n    fileList.sort()\n    if fileList:\n        return fileList[0]\n    return ''\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function takes a string or QUrl as an argument, and returns a sorted list of the first matched file as a string. If no files are found, it returns an empty string."}
{"prompt": "def removeFile(self, filename):\n    if filename in self._watchedFiles:\n        self._watchedFiles.remove(filename)\n    if self._watching:\n        self._fileWatcher.removePath(filename)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Remove a file from the list of watched files and from the file watcher.\n\nParameters\n----------\nfilename : str\n    The file to be removed from the list of watched files.\n\n\"\"\""}
{"prompt": "def _applyExpr(self):\n    v = self._value\n    g = self.node.graph\n    if not g:\n        return\n    if isinstance(v, Attribute):\n        g.addEdge(v, self)\n        self.resetValue()\n    elif self.isInput and Attribute.isLinkExpression(v):\n        link = v[1:-1]\n        (linkNode, linkAttr) = link.split('.')\n        try:\n            g.addEdge(g.node(linkNode).attribute(linkAttr), self)\n        except KeyError as err:\n            logging.warning('Connect Attribute from Expression failed.\\nExpression: \"{exp}\"\\nError: \"{err}\".'.format(exp=v, err=err))\n        self.resetValue()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n_applyExpr(self):\n    \"\"\"Applies an expression to the given attribute. \n    If the attribute is an instance of Attribute, it adds an edge in the graph. \n    If the attribute is an input and is a link expression, it splits the expression and tries to add an edge in the graph. \n    If unsuccessful, it logs a warning. \n    Finally, it resets the value. \n    \"\"\""}
{"prompt": "@Slot(QVector4D, Qt3DRender.QCamera, QSize, result=QVector2D)\ndef pointFromWorldToScreen(self, point, camera, windowSize):\n    viewMatrix = camera.transform().matrix().inverted()\n    projectedPoint = (camera.projectionMatrix() * viewMatrix[0]).map(point)\n    projectedPoint2D = QVector2D(projectedPoint.x() / projectedPoint.w(), projectedPoint.y() / projectedPoint.w())\n    screenPoint2D = QVector2D(int((projectedPoint2D.x() + 1) * windowSize.width() / 2), int((projectedPoint2D.y() - 1) * windowSize.height() / -2))\n    return screenPoint2D\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function takes in a 4D vector point, a Qt3DRender QCamera object, and a QSize object representing the window size and returns a 2D vector representing the corresponding point on the screen."}
{"prompt": "@Slot(QObject)\ndef setActiveNode(self, node):\n    for (category, nodeTypes) in self.activeNodeCategories.items():\n        if node.nodeType in nodeTypes:\n            self.activeNodes.get(category).node = node\n            if category == 'sfm':\n                self.setSfm(node)\n            if node.nodeType == 'CameraInit':\n                self.setCameraInitIndex(self._cameraInits.indexOf(node))\n    self.activeNodes.get(node.nodeType).node = node\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function sets the active node for the given category or node type. If the node is a 'CameraInit' node, the appropriate index is set in the cameraInits list. If the node is of type 'sfm', the setSfm() function is called."}
{"prompt": "def test_listModel_add_remove():\n    m = QObjectListModel(keyAttrName='name')\n    node = DummyNode('DummyNode_1')\n    m.add(node)\n    assert len(m) == 1\n    assert m.get('DummyNode_1') == node\n    m.remove(node)\n    assert len(m) == 0\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function tests the QObjectListModel class by adding and removing a DummyNode object from the model. It asserts that the size of the model is as expected after each operation, and that the added node is returned when queried."}
{"prompt": "def getValueStr(self):\n    if isinstance(self.value, ListModel):\n        return self.attributeDesc.joinChar.join([v.getValueStr() for v in self.value])\n    return super(ListAttribute, self).getValueStr()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Return a string representation of the value of the ListAttribute, either as a comma-separated list of the strings returned by each value's getValueStr() method, or as the result of the superclass's getValueStr() method if the value is not a ListModel.\"\"\""}
{"prompt": "def parse_args(self):\n    module_name = self.arguments[self.arguments.index(':module:') + 1]\n    class_name = self.arguments[self.arguments.index(':class:') + 1]\n    return (module_name, class_name)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nParse arguments from the command line and return a tuple of (module_name, class_name). \n\"\"\""}
{"prompt": "def __init__(self, viewpointAttribute, reconstruction):\n    super(ViewpointWrapper, self).__init__(parent=reconstruction)\n    self._viewpoint = viewpointAttribute\n    self._reconstruction = reconstruction\n    self._initialIntrinsics = None\n    self._T = None\n    self._R = None\n    self._solvedIntrinsics = {}\n    self._reconstructed = False\n    self._undistortedImagePath = ''\n    self._activeNode_PrepareDenseScene = self._reconstruction.activeNodes.get('PrepareDenseScene')\n    self._updateInitialParams()\n    self._updateSfMParams()\n    self._updateDenseSceneParams()\n    self._reconstruction.cameraInitChanged.connect(self._updateInitialParams)\n    self._reconstruction.sfmReportChanged.connect(self._updateSfMParams)\n    self._activeNode_PrepareDenseScene.nodeChanged.connect(self._updateDenseSceneParams)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis is the constructor for the ViewpointWrapper class. It sets up the viewpoint attribute and reconstruction, initializes the initial and solved intrinsics, sets up the transformation matrices, sets up the reconstructed variable, creates the undistorted image path, and sets up the active nodes. It also connects the cameraInitChanged, sfmReportChanged, and nodeChanged signals. \n\"\"\""}
{"prompt": "def uid(self, uidIndex):\n    uids = []\n    for (k, v) in self._value.items():\n        if v.enabled and uidIndex in v.desc.uid:\n            uids.append(v.uid(uidIndex))\n    return hashValue(uids)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function returns a hash value of the uids associated with the given uidIndex. It iterates through each item in the self._value dictionary, appending the uid associated with the given uidIndex to a list if the item is enabled and its desc contains the given uidIndex. The list is then passed to a hashValue function to generate the hash value."}
{"prompt": "@Slot(QVector3D, QVector3D, result=QQuaternion)\ndef rotationBetweenAandB(self, A, B):\n    A = A / A.length()\n    B = B / B.length()\n    v = QVector3D.crossProduct(A, B)\n    s = v.length()\n    c = QVector3D.dotProduct(A, B)\n    return QQuaternion.fromAxisAndAngle(v / s, atan2(s, c) * 180 / pi)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCalculate and return the rotation between two 3D vectors A and B, as a QQuaternion.\n\"\"\""}
{"prompt": "def upgradeNode(self, nodeName):\n    node = self.node(nodeName)\n    if not isinstance(node, CompatibilityNode):\n        raise ValueError('Upgrade is only available on CompatibilityNode instances.')\n    upgradedNode = node.upgrade()\n    with GraphModification(self):\n        (inEdges, outEdges) = self.removeNode(nodeName)\n        self.addNode(upgradedNode, nodeName)\n        for (dst, src) in outEdges.items():\n            try:\n                self.addEdge(self.attribute(src), self.attribute(dst))\n            except (KeyError, ValueError) as e:\n                logging.warning('Failed to restore edge {} -> {}: {}'.format(src, dst, str(e)))\n    return (upgradedNode, inEdges, outEdges)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nupgradeNode(self, nodeName)\n\n\"\"\"\nUpgrades a given CompatibilityNode instance and restores any edges connected to it. \n\nParameters: \nself (Graph): The Graph object to modify.\nnodeName (str): The name of the node to upgrade.\n\nRaises:\nValueError: If the node is not a CompatibilityNode instance.\n\nReturns:\nupgradedNode (CompatibilityNode): The upgraded node.\ninEdges (dict): A dictionary of edges that were connected to the upgraded node.\noutEdges (dict): A dictionary of edges that were connected to the upgraded node.\n\"\"\""}
{"prompt": "def upgradeValue(self, exportedValue):\n    self._set_value(exportedValue)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Upgrades the value of the given object to the exported value\"\"\""}
{"prompt": "def initialize(self, node, inputs, recursiveInputs):\n    pass\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"This function initializes a node with the given inputs and recursive inputs\"\"\""}
{"prompt": "@cacheDir.setter\ndef cacheDir(self, value):\n    if self._cacheDir == value:\n        return\n    self._cacheDir = value.replace(os.path.sep, '/')\n    self.updateInternals(force=True)\n    self.updateStatusFromCache(force=True)\n    self.cacheDirChanged.emit()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function sets the cache directory and updates the internal values, status from the cache, and emits a signal when the cache directory has changed."}
{"prompt": "def isFinishedOrRunning(self):\n    return self._status.status in (Status.SUCCESS, Status.RUNNING)\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nReturn whether the status of the object is either 'SUCCESS' or 'RUNNING'."}
{"prompt": "def getEnabled(self):\n    if isinstance(self.desc.enabled, types.FunctionType):\n        try:\n            return self.desc.enabled(self.node)\n        except:\n            return True\n    return self.attributeDesc.enabled\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function checks if a node is enabled. It first checks if the \"enabled\" attribute of the node is a function type. If so, it will try to execute the function and return the result. If not, it will return the enabled attribute of the node."}
{"prompt": "def load(self, sourceFile):\n    self._sourceFile = sourceFile\n    super(QmlInstantEngine, self).load(sourceFile)\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nLoad a QML file from the given source file.\n\nParameters:\n    sourceFile (str): The path to the QML file to be loaded.\n\nReturns:\n    None"}
{"prompt": "def _systemInfo(self):\n    import platform\n    import sys\n    return {'platform': '{} {}'.format(platform.system(), platform.release()), 'python': 'Python {}'.format(sys.version.split(' ')[0])}\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function returns a dictionary with the platform and Python version information. \nIt uses the 'platform' and 'sys' modules to gather the data."}
{"prompt": "def buildCommandLine(self, chunk):\n    cmdPrefix = ''\n    if 'REZ_ENV' in os.environ and chunk.node.packageVersion:\n        alreadyInEnv = os.environ.get('REZ_{}_VERSION'.format(chunk.node.packageName.upper()), '').startswith(chunk.node.packageVersion)\n        if not alreadyInEnv:\n            cmdPrefix = '{rez} {packageFullName} -- '.format(rez=os.environ.get('REZ_ENV'), packageFullName=chunk.node.packageFullName)\n    cmdSuffix = ''\n    if chunk.node.isParallelized and chunk.node.size > 1:\n        cmdSuffix = ' ' + self.commandLineRange.format(**chunk.range.toDict())\n    return cmdPrefix + chunk.node.nodeDesc.commandLine.format(**chunk.node._cmdVars) + cmdSuffix\n##############\nEND_FUNC\n##############\n", "completion": "\n\nbuildCommandLine(self, chunk) -> str:\n    \"\"\"Build the command line for a given chunk of work.\n\n    This function builds the command line for the given chunk, taking into account any environment\n    setup and parallelization.\n\n    Args:\n        self (object): Instance of the class in which this function is defined.\n        chunk (object): Chunk of work to build the command line for.\n\n    Returns:\n        str: The command line for the given chunk.\n    \"\"\""}
{"prompt": "@staticmethod\ndef attributeDescFromName(refAttributes, name, value, strict=True):\n    attrDesc = next((d for d in refAttributes if d.name == name), None)\n    if attrDesc is None:\n        return None\n    if Attribute.isLinkExpression(value):\n        return attrDesc\n    if attrDesc.matchDescription(value, strict):\n        return attrDesc\n    return None\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturn Attribute description from name, value, and strict flag. Returns None if the name is not found in the reference attributes, if the value is a link expression, or if the value does not match the description in the attribute description."}
{"prompt": "def remove(self, obj):\n    self._objects.remove(obj)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nRemove an object from the list of objects stored by this instance."}
{"prompt": "def configureLogger(self):\n    for handler in self.logger.handlers[:]:\n        self.logger.removeHandler(handler)\n    handler = logging.FileHandler(self.chunk.logFile)\n    formatter = self.Formatter('[%(asctime)s.%(msecs)03d][%(levelname)s] %(message)s', self.dateTimeFormatting)\n    handler.setFormatter(formatter)\n    self.logger.addHandler(handler)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nConfigures the logger by removing existing handlers and adding a new FileHandler with the specified formatter."}
{"prompt": "def moduleVersion(moduleName, default=None):\n    return getattr(sys.modules[moduleName], '__version__', default)\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nRetrieve the __version__ attribute of a given module.\n\nParameters:\nmoduleName (str): The name of the module.\ndefault (optional): The default value to use if the module doesn't have a __version__ attribute. Defaults to None.\n\nReturns:\nThe __version__ attribute of the module, or the default value if it doesn't exist."}
{"prompt": "def start(self, level):\n    open(self.chunk.logFile, 'w').close()\n    self.configureLogger()\n    self.logger.setLevel(self.textToLevel(level))\n    self.progressBar = False\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function clears the log file, configures the logger and sets the log level based on the input level."}
{"prompt": "def submit(self, nodes, edges, filepath, submitLabel='{projectName}'):\n    raise NotImplementedError(\"'submit' method must be implemented in subclasses\")\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function is intended to be implemented in subclasses, and will be used to submit a graph consisting of nodes and edges to a filepath with a given submitLabel. It raises a NotImplementedError if it is not implemented in the subclass."}
{"prompt": "def dfsVisit(self, u, visitor, colors, nodeChildren, longestPathFirst):\n    try:\n        self._dfsVisit(u, visitor, colors, nodeChildren, longestPathFirst)\n    except StopBranchVisit:\n        pass\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function is a helper for a depth-first search which traverses a graph and calls a visitor function for each node. It takes in the node (u), visitor function, colors dictionary, nodeChildren dictionary, and boolean longestPathFirst as parameters. The function will call the private _dfsVisit function, and catch any StopBranchVisit exceptions."}
{"prompt": "def getFullNameToNode(self):\n    return '{}.{}'.format(self.node.name, self.getFullName())\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturns a string composed of the node name and the object's full name, separated by a period."}
{"prompt": "def computeSize(self, node):\n    size = 0\n    for param in self._params:\n        param = node.attribute(param)\n        if param.isLink:\n            size += param.getLinkParam().node.size\n        elif isinstance(param.desc, ListAttribute):\n            size += len(param)\n        else:\n            size += 1\n    return size\n##############\nEND_FUNC\n##############\n", "completion": "\n\nCompute the size of a node based on a set of parameters. 'self._params' is a list of parameters to use for computing the size, 'node' is the node whose size is being computed. Returns the size of the node."}
{"prompt": "def matchDescription(self, value, strict=True):\n    if not super(ListAttribute, self).matchDescription(value, strict):\n        return False\n    if value:\n        return self._elementDesc.matchDescription(value[0], strict)\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\nCheck if an element description matches the attribute description.\n\nParameters:\n- self (ListAttribute): The ListAttribute instance.\n- value (list): The list of elements.\n- strict (bool, optional): Whether to perform a strict match or not. Defaults to True.\n\nReturns:\nTrue if the element description matches the attribute description, False otherwise."}
{"prompt": "@Slot(Qt3DCore.QEntity, str, result='QVariantList')\ndef findChildrenByProperty(self, entity, propertyName):\n    children = []\n    for child in entity.childNodes():\n        try:\n            if child.metaObject().indexOfProperty(propertyName) != -1:\n                children.append(child)\n        except RuntimeError:\n            continue\n        children += self.findChildrenByProperty(child, propertyName)\n    return children\n##############\nEND_FUNC\n##############\n", "completion": "\n\nFinds all the children of a given entity with the given property name and returns a list of QVariants containing the children that match."}
{"prompt": "def append(self, obj):\n    self._objects.append(obj)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nAppend an object to the end of the list stored in the _objects attribute of the object."}
{"prompt": "def getRanges(self, node):\n    (blockSize, fullSize, nbBlocks) = self.getSizes(node)\n    ranges = []\n    for i in range(nbBlocks):\n        ranges.append(Range(iteration=i, blockSize=blockSize, fullSize=fullSize))\n    return ranges\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function takes a node as an argument and returns a list of Range objects for each iteration. The Range objects contain the iteration number, block size, and full size of the node."}
{"prompt": "def setter(instance, value):\n    currentValue = getattr(instance, attributeName)\n    if currentValue == value:\n        return\n    resetCallbackName = '__reset__' + attributeName\n    if resetOnDestroy and (not hasattr(instance, resetCallbackName)):\n        setattr(instance, resetCallbackName, lambda self=instance, *args: setter(self, None))\n    resetCallback = getattr(instance, resetCallbackName, None)\n    if resetCallback and currentValue and shiboken2.isValid(currentValue):\n        currentValue.destroyed.disconnect(resetCallback)\n    setattr(instance, attributeName, value)\n    if resetCallback and value:\n        value.destroyed.connect(resetCallback)\n    getattr(instance, signalName(notify)).emit()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function sets an attribute of an instance to a specified value, and emits a signal when it has been set. If the resetOnDestroy argument is set to True, a reset callback will be set on the instance to reset the attribute to None when the value is destroyed."}
{"prompt": "def values(self):\n    return self._objects\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function returns a list of objects stored in the `self._objects` attribute."}
{"prompt": "def __init__(self, sourceFile='', watching=True, verbose=False, parent=None):\n    super(QmlInstantEngine, self).__init__(parent)\n    self._fileWatcher = QFileSystemWatcher()\n    self._sourceFile = ''\n    self._watchedFiles = []\n    self._verbose = verbose\n    self._watching = False\n    self._extensions = ['qml', 'js']\n    self._rootItem = None\n\n    def onObjectCreated(root, url):\n        if not root:\n            return\n        if self._rootItem:\n            root.setGeometry(self._rootItem.geometry())\n            self._rootItem.deleteLater()\n        self._rootItem = root\n    self.objectCreated.connect(onObjectCreated)\n    self.setWatching(watching)\n    if sourceFile:\n        self.load(sourceFile)\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\n__init__(self, sourceFile='', watching=True, verbose=False, parent=None) initializes a QmlInstantEngine object with the given parameters. It also sets up a QFileSystemWatcher object and connects it to the objectCreated signal. If a source file is given, it is loaded. \n\"\"\""}
{"prompt": "def setReference(self, iterable):\n    self._reference = iterable\n    self.sort()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nSets the reference for the object to the given iterable and sorts it.\n\"\"\""}
{"prompt": "def checkCompatibilityNodes(self, graph, nodes, context):\n    compatNodes = []\n    for node in nodes:\n        if node in graph._compatibilityNodes.values():\n            compatNodes.append(node.nameToLabel(node.name))\n    if compatNodes:\n        raise RuntimeError('[{}] Compatibility Issue:\\nCannot compute because of these incompatible nodes:\\n{}'.format(context, sorted(compatNodes)))\n##############\nEND_FUNC\n##############\n", "completion": "\n\nCheck for nodes in a graph that are incompatible with a given context and raise a RuntimeError if any are found. \n\nParameters: \n    graph (Graph): The graph to check for incompatible nodes\n    nodes (list): A list of the nodes to check for compatibility \n    context (str): The context to check the nodes against"}
{"prompt": "def outputImagesValueFunct(attr):\n    basename = os.path.basename(attr.node.input.value)\n    fileStem = os.path.splitext(basename)[0]\n    inputExt = os.path.splitext(basename)[1]\n    outputExt = '.' + attr.node.extension.value if attr.node.extension.value else None\n    if inputExt in ['.abc', '.sfm']:\n        return desc.Node.internalFolder + '<VIEW_ID>' + (outputExt or '.*')\n    if inputExt:\n        return desc.Node.internalFolder + fileStem + (outputExt or inputExt)\n    if '*' in fileStem:\n        return desc.Node.internalFolder + fileStem + (outputExt or '.*')\n    return desc.Node.internalFolder + '*' + (outputExt or '.*')\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function takes an attribute as an argument and returns a string representing the output images value. The value includes the internal folder location, the file stem, and either the input extension or output extension (if specified)."}
{"prompt": "def _referenceItem(self, item):\n    if not item.parent():\n        item.setParent(self)\n    if not self._keyAttrName:\n        return\n    key = getattr(item, self._keyAttrName, None)\n    if key is None:\n        return\n    if key in self._objectByKey:\n        raise ValueError('Object key {}:{} is not unique'.format(self._keyAttrName, key))\n    self._objectByKey[key] = item\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function is used to reference an item to its parent object and check if the assigned key attribute is unique. If not, a ValueError is raised."}
{"prompt": "def data(self, index, role):\n    obj = super(QTypedObjectListModel, self).data(index, self.ObjectRole)\n    if role == self.ObjectRole:\n        return obj\n    if obj:\n        return obj.property(self.roles[role])\n    return None\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nReturns the object or property of the object stored at the given index in the model, based on the given role."}
{"prompt": "@property\ndef statisticsFile(self):\n    if self.range.blockSize == 0:\n        return os.path.join(self.node.graph.cacheDir, self.node.internalFolder, 'statistics')\n    else:\n        return os.path.join(self.node.graph.cacheDir, self.node.internalFolder, str(self.index) + '.statistics')\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturn the path to the statistics file for this index of the range of this node."}
{"prompt": "def importImagesAsync(self, images, cameraInit):\n    logging.debug('Import images: ' + str(images))\n    self.runAsync(self.importImagesSync, args=(images, cameraInit))\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function imports images asynchronously. It takes in 'images', which is a list of image paths, and 'cameraInit', which is a boolean indicating whether the camera should be initialized. It logs the 'images' variable and runs a synchronous function (importImagesSync) with 'images' and 'cameraInit' as arguments."}
{"prompt": "@Slot()\ndef onImportImagesFailed(self, msg):\n    self.error.emit(Message('Failed to Import Images', 'You probably have a corrupted image within the images that you are trying to import.', ''))\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function emits an error message when the import of images fails. It emits a Message object with information about the failure."}
{"prompt": "@Slot(QObject, result=bool)\ndef hasValidIntrinsic(self, viewpoint):\n    allIntrinsicIds = [i.intrinsicId.value for i in self._cameraInit.intrinsics.value]\n    return viewpoint.intrinsicId.value in allIntrinsicIds\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Check if the given viewpoint has a valid intrinsic.\n\nArgs:\n    viewpoint (QObject): The viewpoint to check.\n\nReturns:\n    bool: True if the viewpoint has a valid intrinsic, False otherwise.\n\"\"\""}
{"prompt": "def alreadySubmittedChunks(self):\n    return [ch for ch in self._chunks if ch.isAlreadySubmitted()]\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturn a list of chunks that have already been submitted to the server."}
{"prompt": "def __init__(self, params):\n    assert isinstance(params, (list, tuple))\n    self._params = params\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__(self, params):\n    \"\"\"Constructor for the class. \n\n    Args:\n        params (list or tuple): The parameters to be used for the class.\n    \"\"\""}
{"prompt": "def parseNumericList(numericListString):\n    nList = []\n    for item in numericListString.split(','):\n        if '-' in item:\n            (start, end) = item.split('-')\n            start = int(start)\n            end = int(end)\n            nList.extend(range(start, end + 1))\n        else:\n            value = int(item)\n            nList.append(value)\n    return nList\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nparseNumericList(numericListString) takes a string of numeric values separated by commas and returns a list of integers. If a range is specified with a dash, a range of all values between the start and end of the range will be included in the list. \n\nExample:\nparseNumericList(\"1,2,3-5\") returns [1, 2, 3, 4, 5]"}
{"prompt": "@Slot(Attribute)\ndef removeAttribute(self, attribute):\n    self.push(commands.ListAttributeRemoveCommand(self._graph, attribute))\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nRemove an attribute from the graph.\n\nParameters:\n    attribute (Attribute): The attribute to be removed.\n\nReturns:\n    None\n\"\"\""}
{"prompt": "def processChunk(self, chunk):\n    try:\n        chunk.logManager.start(chunk.node.verboseLevel.value)\n        if not chunk.node.inputFiles:\n            chunk.logger.warning('Nothing to publish')\n            return\n        if not chunk.node.output.value:\n            return\n        outFiles = self.resolvedPaths(chunk.node.inputFiles.value, chunk.node.output.value)\n        if not outFiles:\n            error = 'Publish: input files listed, but nothing to publish'\n            chunk.logger.error(error)\n            chunk.logger.info('Listed input files: {}'.format([i.value for i in chunk.node.inputFiles.value]))\n            raise RuntimeError(error)\n        if not os.path.exists(chunk.node.output.value):\n            os.mkdir(chunk.node.output.value)\n        for (iFile, oFile) in outFiles.items():\n            chunk.logger.info('Publish file {} into {}'.format(iFile, oFile))\n            shutil.copyfile(iFile, oFile)\n        chunk.logger.info('Publish end')\n    finally:\n        chunk.logManager.end()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nprocessChunk(self, chunk):\n    '''Copies files from the input file list to the output path. \n    Raises a RuntimeError if there are no files to publish.\n    Logs the start and end of the publish process.\n    '''"}
