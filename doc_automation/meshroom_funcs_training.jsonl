{"prompt": "def findMetadata(d, keys, defaultValue):\n    v = None\n    for key in keys:\n        v = d.get(key, None)\n        k = key.lower()\n        if v is not None:\n            return v\n        for (dk, dv) in d.items():\n            dkm = dk.lower().replace(' ', '')\n            if dkm == key.lower():\n                return dv\n            dkm = dkm.split(':')[-1]\n            dkm = dkm.split('/')[-1]\n            if dkm == k:\n                return dv\n    return defaultValue\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nfindMetadata(d, keys, defaultValue)\n\nFinds the corresponding value for a given set of keys from a dictionary. \nIf the key is not found, the 'defaultValue' is returned.\n\nParameters:\nd (dict): The dictionary to search in.\nkeys (list): A set of keys to lookup in the dictionary.\ndefaultValue: The default value to return if the key is not found.\n\nReturns:\nThe corresponding value for the key, or the defaultValue if the key is not found.\n\"\"\""}
{"prompt": "@Slot()\ndef endModification(self):\n    assert self._modificationCount > 0\n    self._modificationCount -= 1\n    self._undoStack.endMacro()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nEnds a modification by decrementing the modification count and calling endMacro() on the undo stack."}
{"prompt": "def outEdges(self, attribute):\n    return [edge for edge in self.edges if edge.src == attribute]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\noutEdges(self, attribute):\n    Return a list of edges for which the source node is the given attribute.\n    Args:\n        self (object): the object which this method is called on\n        attribute (object): the attribute to search for in the source node\n    Returns:\n        list: a list of edges that have the given attribute in their source node\n\"\"\""}
{"prompt": "def redoImpl(self):\n    self.graph.removeEdge(self.graph.attribute(self.dstAttr))\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Redo the implementation by removing the edge attribute from the graph and returning true.\"\"\""}
{"prompt": "def setFiles(self, files):\n    with self._mutex:\n        self._files = files\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function sets the files property of the object to the given files. It is thread-safe using a mutex lock."}
{"prompt": "@classmethod\ndef update(cls, node):\n    if not isinstance(node.nodeDesc, cls):\n        raise ValueError('Node {} is not an instance of type {}'.format(node, cls))\n    if 'userNbBrackets' not in node.getAttributes().keys():\n        return\n    if node.userNbBrackets.value != 0:\n        node.nbBrackets.value = node.userNbBrackets.value\n        return\n    cameraInitOutput = node.input.getLinkParam(recursive=True)\n    if not cameraInitOutput:\n        node.nbBrackets.value = 0\n        return\n    if not cameraInitOutput.node.hasAttribute('viewpoints'):\n        if cameraInitOutput.node.hasAttribute('input'):\n            cameraInitOutput = cameraInitOutput.node.input.getLinkParam(recursive=True)\n    if cameraInitOutput and cameraInitOutput.node and cameraInitOutput.node.hasAttribute('viewpoints'):\n        viewpoints = cameraInitOutput.node.viewpoints.value\n    else:\n        node.nbBrackets.value = 0\n        return\n    inputs = []\n    for viewpoint in viewpoints:\n        jsonMetadata = viewpoint.metadata.value\n        if not jsonMetadata:\n            node.nbBrackets.value = 0\n            return\n        d = json.loads(jsonMetadata)\n        fnumber = findMetadata(d, ['FNumber', 'Exif:ApertureValue', 'ApertureValue', 'Aperture'], '')\n        shutterSpeed = findMetadata(d, ['Exif:ShutterSpeedValue', 'ShutterSpeedValue', 'ShutterSpeed'], '')\n        iso = findMetadata(d, ['Exif:ISOSpeedRatings', 'ISOSpeedRatings', 'ISO'], '')\n        if not fnumber and (not shutterSpeed):\n            node.nbBrackets.value = 1\n            return\n        inputs.append((viewpoint.path.value, (fnumber, shutterSpeed, iso)))\n    inputs.sort()\n    exposureGroups = []\n    exposures = []\n    for (path, exp) in inputs:\n        if exposures and exp != exposures[-1] and (exp == exposures[0]):\n            exposureGroups.append(exposures)\n            exposures = [exp]\n        else:\n            exposures.append(exp)\n    exposureGroups.append(exposures)\n    exposures = None\n    bracketSizes = set()\n    if len(exposureGroups) == 1:\n        if len(set(exposureGroups[0])) == 1:\n            node.nbBrackets.value = 1\n        else:\n            node.nbBrackets.value = len(exposureGroups[0])\n    else:\n        for expGroup in exposureGroups:\n            bracketSizes.add(len(expGroup))\n        if len(bracketSizes) == 1:\n            node.nbBrackets.value = bracketSizes.pop()\n        else:\n            node.nbBrackets.value = 0\n##############\nEND_FUNC\n##############\n", "completion": "\nThis classmethod updates the number of brackets in a node. It raises an error if the node is not an instance of the type and returns if the user has not specified the number of brackets. Otherwise, it checks the input of the node for viewpoint metadata and sets the number of brackets based on the various exposures."}
{"prompt": "@property\ndef name(self):\n    return '.'.join([str(v) for v in self.components])\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis property returns a string composed of the components of the object joined together by a period."}
{"prompt": "def checkValueTypes(self):\n    return self.elementDesc.checkValueTypes()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function returns the result of the checkValueTypes() method on the elementDesc attribute of the object."}
{"prompt": "def read(self):\n    if not self._filepath or not self._filepath.lower().endswith('.csv') or (not os.path.isfile(self._filepath)):\n        return []\n    dataList = []\n    try:\n        csvRows = []\n        with open(self._filepath, 'r') as fp:\n            reader = csv.reader(fp)\n            for row in reader:\n                csvRows.append(row)\n        for elt in csvRows[0]:\n            dataList.append(CsvColumn(elt))\n        for elt in csvRows[1:]:\n            for (idx, value) in enumerate(elt):\n                dataList[idx].appendValue(value)\n    except Exception as e:\n        logging.error('CsvData: Failed to load file: {}\\n{}'.format(self._filepath, str(e)))\n    return dataList\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function reads a CSV file and returns a list of CsvColumn objects. It takes self as an argument and uses the self._filepath attribute to locate the CSV file. If the file is not found or is not a valid CSV file, an empty list is returned. Otherwise, the CSV file is read and the data is stored in a dataList object which is then returned."}
{"prompt": "def matchDescription(self, value, strict=True):\n    if not super(GroupAttribute, self).matchDescription(value):\n        return False\n    attrMap = {attr.name: attr for attr in self._groupDesc}\n    matchCount = 0\n    for (k, v) in value.items():\n        if k in attrMap and attrMap[k].matchDescription(v, strict):\n            matchCount += 1\n    if strict:\n        return matchCount == len(value.items()) == len(self._groupDesc)\n    return matchCount > 0\n##############\nEND_FUNC\n##############\n", "completion": "\n\nMatch the given description to the attributes of the GroupAttribute object. If strict is True, all entries of the description must match. If strict is False, at least one must match. Returns a boolean indicating whether the description matches."}
{"prompt": "def __init__(self, nodeType, nodeDict, position=None, issue=CompatibilityIssue.UnknownIssue, parent=None):\n    super(CompatibilityNode, self).__init__(nodeType, position, parent)\n    self.issue = issue\n    self.nodeDict = copy.deepcopy(nodeDict)\n    self.version = Version(self.nodeDict.get('version', None))\n    self._inputs = self.nodeDict.get('inputs', {})\n    self.outputs = self.nodeDict.get('outputs', {})\n    self._internalFolder = self.nodeDict.get('internalFolder', '')\n    self._uids = self.nodeDict.get('uids', {})\n    self.parallelization = self.nodeDict.get('parallelization', {})\n    self.splitCount = self.parallelization.get('split', 1)\n    self.setSize(self.parallelization.get('size', 1))\n    for (attrName, value) in self._inputs.items():\n        self._addAttribute(attrName, value, False)\n    for (attrName, value) in self.outputs.items():\n        self._addAttribute(attrName, value, True)\n    self._chunks.setObjectList([NodeChunk(self, desc.Range(i, blockSize=self.parallelization.get('blockSize', 0))) for i in range(self.splitCount)])\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function initializes a CompatibilityNode object. It takes in a nodeType, nodeDict, position(optional), issue(CompatibilityIssue.UnknownIssue by default), and parent(optional) as arguments. It then sets the issue, nodeDict, version, inputs, outputs, internalFolder, uids, parallelization, and splitCount properties of the object. Finally, it adds the inputs and outputs to the attributes of the object, and sets the object's chunks. \n\"\"\""}
{"prompt": "def checkValueTypes(self):\n    if not isinstance(self.value, int) or (self.range and (not all([isinstance(r, int) for r in self.range]))):\n        return self.name\n    return ''\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function checks if the value is an integer and if the range is also an integer. If either of these conditions are not true, it returns the name, otherwise it returns an empty string."}
{"prompt": "def isRunning(self):\n    return self._status.status == Status.RUNNING\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturns True if the status of the object is set to running, False otherwise."}
{"prompt": "def toDict(self):\n    d = self.__dict__.copy()\n    d.pop('destroyed', None)\n    d['elapsedTimeStr'] = self.elapsedTimeStr\n    return d\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"Returns a dictionary containing instance variables of the object, excluding the destroyed variable, and including the elapsedTimeStr variable.\""}
{"prompt": "@Slot(QPointF, QPointF, float)\ndef rotate(self, lastPosition, currentPosition, dt):\n    (angle, direction) = self.createRotation(lastPosition, currentPosition)\n    rotatedAxis = self._camera.transform().rotation().rotatedVector(direction)\n    angle *= self._rotationSpeed * dt\n    self._camera.rotateAboutViewCenter(QQuaternion.fromAxisAndAngle(rotatedAxis, angle * pi * 180))\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function rotates the camera about the view center using the supplied last and current positions as reference points. The angle of rotation is calculated using the two points, multiplied by the rotation speed and the delta time. The direction of rotation is determined by rotating the supplied vector by the current camera transformation."}
{"prompt": "def getInputEdges(self, node, dependenciesOnly):\n    return set([edge for edge in self.getEdges(dependenciesOnly=dependenciesOnly) if edge.dst.node is node])\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturn a set of edges for the given node with the option of dependenciesOnly.\n\nArgs:\n    node (object): The node.\n    dependenciesOnly (bool): Whether to include only edges that have the given node as the destination.\n\nReturns:\n    set: A set of edges that are connected to the given node.\n\"\"\""}
{"prompt": "@property\ndef globalExecMode(self):\n    return self._chunks.at(0).execModeName\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturns the global execution mode name of the chunk at the given index."}
{"prompt": "@Slot()\ndef clear(self):\n    self._clipboard.clear()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nClear the contents of the clipboard."}
{"prompt": "def getFullLabelToGraph(self):\n    return '{} {}'.format(self.node.graph.name, self.getFullLabelToNode())\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturns a string in the format of \"{graph name} {full label to node}\". It should concatenate the graph name and the label of the node, including the full hierarchy of labels up to the node."}
{"prompt": "def __init__(self, graph, data, position=None, parent=None):\n    super(PasteNodesCommand, self).__init__(graph, parent)\n    self.data = data\n    self.position = position\n    self.nodeNames = []\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"This class implements a command to paste nodes into a graph. It takes a graph, data, optional position, and optional parent as parameters. It stores data, position, and the names of the nodes being pasted in respective class variables.\"\"\""}
{"prompt": "def defaultValue(self):\n    return {key: attr.defaultValue() for (key, attr) in self._value.items()}\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturns a dictionary of key-value pairs with each key being an attribute of 'self' and each value being the default value of the corresponding attribute."}
{"prompt": "def registerNodeType(nodeType):\n    global nodesDesc\n    if nodeType.__name__ in nodesDesc:\n        raise RuntimeError('Node Desc {} is already registered.'.format(nodeType.__name__))\n    nodesDesc[nodeType.__name__] = nodeType\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"Registers a node type to the global nodesDesc dictionary. Raises a RuntimeError if the node type has already been registered.\""}
{"prompt": "def __init__(self, buf=b'', callback=None, cb_args=(), cb_kwargs={}, stopped=None):\n    self._callback = callback\n    self._cb_args = cb_args\n    self._cb_kwargs = cb_kwargs\n    self._stopped = stopped\n    self._progress = 0\n    self._len = len(buf)\n    io.BytesIO.__init__(self, buf)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__(self, buf=b'', callback=None, cb_args=(), cb_kwargs={}, stopped=None)\n\nInitializes the ReadProgress instance, with the given buffer, callback function and arguments,\nstopped flag and progress value. Initializes the underlying io.BytesIO instance with the given buffer."}
{"prompt": "def stopRequest(self):\n    self._stopFlag.set()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function sets the stop flag associated with the object to indicate that a request to stop has been made."}
{"prompt": "def validateValue(self, value):\n    raise NotImplementedError('Attribute.validateValue is an abstract function that should be implemented in the derived class.')\n##############\nEND_FUNC\n##############\n", "completion": "\n\nAbstract function that should be implemented in the derived class to validate the value of an attribute."}
{"prompt": "def updateChunks(self):\n    dfsNodes = self._graph.dfsOnFinish(None)[0]\n    chunks = self._graph.getChunks(dfsNodes)\n    if self._sortedDFSChunks.objectList() == chunks:\n        return\n    for chunk in self._sortedDFSChunks:\n        chunk.statusChanged.disconnect(self.updateGraphComputingStatus)\n    self._sortedDFSChunks.setObjectList(chunks)\n    for chunk in self._sortedDFSChunks:\n        chunk.statusChanged.connect(self.updateGraphComputingStatus)\n    self.updateChunkMonitor(self._sortedDFSChunks)\n    self.updateGraphComputingStatus()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function updates the chunks for the graph by performing a depth-first search, getting the connected chunks and comparing them to the existing chunks. If there are any changes, the function will disconnect from all previous chunks, set the object list to the new chunks, connect to the new chunks, update the chunk monitor, and then update the graph computing status."}
{"prompt": "def getBaseType(self):\n    return self.attributeDesc.elementDesc.__class__.__name__\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturn the base type name of the element description associated with this attribute description."}
{"prompt": "def getRegisteredFiles(self):\n    return self._watchedFiles\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturn a list of files being watched by the object."}
{"prompt": "@property\ndef watchedExtensions(self):\n    return self._extensions\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Getter method that returns the list of watched extensions (self._extensions).\"\"\""}
{"prompt": "def onCameraInitChanged(self):\n    nodes = self._graph.dfsOnDiscover(startNodes=[self._cameraInit], reverse=True)[0]\n    self.setActiveNodes(nodes)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function is called when the camera initialization changes. It performs a depth-first search (dfs) on the graph, starting from the camera initialization node, and in the reverse direction. The result of the dfs is then used to set the active nodes."}
{"prompt": "def _setSelectedViewpoint(self, viewpointAttribute):\n    if self._selectedViewpoint:\n        self._selectedViewpoint.deleteLater()\n    self._selectedViewpoint = ViewpointWrapper(viewpointAttribute, self) if viewpointAttribute else None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nSet the selected viewpoint attribute for this object. If a viewpoint attribute already exists, delete it before setting a new one."}
{"prompt": "@staticmethod\ndef isLinkExpression(value):\n    return isinstance(value, str) and Attribute.stringIsLinkRe.match(value)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturns boolean indicating whether or not the given value is a valid link expression."}
{"prompt": "def setCameraInitIndex(self, idx):\n    camInit = self._cameraInits[idx] if self._cameraInits else None\n    self.cameraInit = camInit\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function sets the camera initialization index to a specified value and stores it in the cameraInit attribute."}
{"prompt": "def block(self, isBlocked):\n    self._block = bool(isBlocked)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nSet the \"block\" status of an object to the given boolean value."}
{"prompt": "def at(self, idx):\n    return self._objects[idx]\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturns the object at the given index within the list of objects."}
{"prompt": "def _buildCmdVars(self):\n\n    def _buildAttributeCmdVars(cmdVars, name, attr):\n        if attr.enabled:\n            group = attr.attributeDesc.group(attr.node) if isinstance(attr.attributeDesc.group, types.FunctionType) else attr.attributeDesc.group\n            if group is not None:\n                v = attr.getValueStr()\n                cmdVars[name] = '--{name} {value}'.format(name=name, value=v)\n                cmdVars[name + 'Value'] = str(v)\n                if v:\n                    cmdVars[group] = cmdVars.get(group, '') + ' ' + cmdVars[name]\n            elif isinstance(attr, GroupAttribute):\n                assert isinstance(attr.value, DictModel)\n                for v in attr._value:\n                    _buildAttributeCmdVars(cmdVars, v.name, v)\n    ' Generate command variables using input attributes and resolved output attributes names and values. '\n    for (uidIndex, value) in self._uids.items():\n        self._cmdVars['uid{}'.format(uidIndex)] = value\n    for (name, attr) in self._attributes.objects.items():\n        if attr.isOutput:\n            continue\n        _buildAttributeCmdVars(self._cmdVars, name, attr)\n    cmdVarsNoCache = self._cmdVars.copy()\n    cmdVarsNoCache['cache'] = ''\n    for (name, attr) in self._attributes.objects.items():\n        if attr.isInput:\n            continue\n        if not isinstance(attr.attributeDesc, desc.File):\n            continue\n        try:\n            defaultValue = attr.defaultValue()\n        except AttributeError as e:\n            logging.warning('Invalid lambda evaluation for \"{nodeName}.{attrName}\"'.format(nodeName=self.name, attrName=attr.name))\n        else:\n            try:\n                attr.value = defaultValue.format(**self._cmdVars)\n                attr._invalidationValue = defaultValue.format(**cmdVarsNoCache)\n            except KeyError as e:\n                logging.warning('Invalid expression with missing key on \"{nodeName}.{attrName}\" with value \"{defaultValue}\".\\nError: {err}'.format(nodeName=self.name, attrName=attr.name, defaultValue=defaultValue, err=str(e)))\n            except ValueError as e:\n                logging.warning('Invalid expression value on \"{nodeName}.{attrName}\" with value \"{defaultValue}\".\\nError: {err}'.format(nodeName=self.name, attrName=attr.name, defaultValue=defaultValue, err=str(e)))\n        v = attr.getValueStr()\n        self._cmdVars[name] = '--{name} {value}'.format(name=name, value=v)\n        self._cmdVars[name + 'Value'] = str(v)\n        if v:\n            self._cmdVars[attr.attributeDesc.group] = self._cmdVars.get(attr.attributeDesc.group, '') + ' ' + self._cmdVars[name]\n##############\nEND_FUNC\n##############\n", "completion": "\nGenerate command variables using input attributes and resolved output attributes names and values."}
{"prompt": "def allImagePaths(self):\n    return [vp.path.value for node in self._cameraInits for vp in node.viewpoints.value]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturn a list of all image paths in the camera inits of the object."}
{"prompt": "def merge(self, other):\n    self.startDateTime = min(self.startDateTime, other.startDateTime)\n    self.endDateTime = max(self.endDateTime, other.endDateTime)\n    self.elapsedTime += other.elapsedTime\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Merge two dateTime objects.\n\nThis function takes two dateTime objects and combines them into one object, setting the startDateTime to the earliest of the two and the endDateTime to the latest of the two, and adding the elapsedTime of the other object to the original.\n\nArgs:\n    self (dateTime): The original dateTime object.\n    other (dateTime): The dateTime object to merge with the original.\n\nReturns:\n    None\n\"\"\""}
{"prompt": "def setAttributes(self, node, attributesDict):\n    for attr in attributesDict:\n        if node.hasAttribute(attr):\n            node.attribute(attr).value = attributesDict[attr]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nSet the attributes of a given node with a given dictionary of attributes.\n\nParameters:\n    self (object): The object itself.\n    node (object): The node whose attributes are to be set.\n    attributesDict (dict): A dictionary of attributes and their values.\n\nReturns:\n    None\n\"\"\""}
{"prompt": "@changeTopology\ndef removeEdge(self, dstAttr):\n    if dstAttr not in self.edges.keys():\n        raise RuntimeError('Attribute \"{}\" is not connected'.format(dstAttr.getFullNameToNode()))\n    edge = self.edges.pop(dstAttr)\n    self.markNodesDirty(dstAttr.node)\n    dstAttr.valueChanged.emit()\n    dstAttr.isLinkChanged.emit()\n    edge.src.hasOutputConnectionsChanged.emit()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nRemove an edge from the graph connecting a source attribute and a destination attribute. Emit an event to mark the nodes connected by the edge dirty and emit value and isLink changed events for the destination attribute."}
{"prompt": "def setLocked(self, lock):\n    if self._locked == lock:\n        return\n    self._locked = lock\n    self.lockedChanged.emit()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function sets the locked state of the object. If the current locked state is the same as the given lock state, the function returns without changing anything. Otherwise, the locked state is changed to the given state and the lockedChanged signal is emitted."}
{"prompt": "def redoImpl(self):\n    self.graph.addEdge(self.graph.attribute(self.srcAttr), self.graph.attribute(self.dstAttr))\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\nRedo the implementation of an edge in the graph. Adds an edge between the source and destination attributes. Returns True if successful."}
{"prompt": "def progressUpdate(size=None, progress=None, logManager=None):\n    if not logManager.progressBar:\n        logManager.makeProgressBar(size, 'Upload progress:')\n    logManager.updateProgressBar(progress)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function updates a progress bar for an upload process. It accepts parameters for the size of the upload, the progress made so far, and an instance of a logManager. If the logManager does not have a progressBar, a progressBar is created with the specified size and a label. Otherwise, the progressBar is updated with the specified progress."}
{"prompt": "@Slot(Qt3DCore.QEntity, result=int)\ndef faceCount(self, entity):\n    count = 0\n    for geo in entity.findChildren(Qt3DRender.QGeometry):\n        count += sum([attr.count() for attr in geo.attributes() if attr.name() == 'vertexPosition'])\n    return count / 3\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes a QEntity as an argument and returns the face count of the QEntity as an integer. It does this by looping through any QGeometry objects found as children of the given QEntity, summing up the counts of any 'vertexPosition' attributes found in the QGeometry objects, and then dividing by 3."}
{"prompt": "def containsNodeName(self, name):\n    if name in self._nodes.keys():\n        return True\n    return False\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nChecks if a graph contains a node with the given name.\n\nParameters:\n    self (Graph): The graph being checked.\n    name (string): The name of the node to be found.\n\nReturns:\n    bool: True if the graph contains a node with the given name, False otherwise."}
{"prompt": "@property\ndef minDepth(self):\n    return self.graph.getDepth(self, minimal=True)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Returns the minimal depth of the node in the graph.\"\"\""}
{"prompt": "def edge(self, dstAttributeName):\n    return self._edges.get(dstAttributeName)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"Return the edge to the given destination attribute name from the current object.\""}
{"prompt": "def test_upgradeAllNodes():\n    registerNodeType(SampleNodeV1)\n    registerNodeType(SampleNodeV2)\n    g = Graph('')\n    n1 = g.addNewNode('SampleNodeV1')\n    n2 = g.addNewNode('SampleNodeV2')\n    n1Name = n1.name\n    n2Name = n2.name\n    graphFile = os.path.join(tempfile.mkdtemp(), 'test_description_conflict.mg')\n    g.save(graphFile)\n    unregisterNodeType(SampleNodeV2)\n    meshroom.core.nodesDesc[SampleNodeV1.__name__] = SampleNodeV2\n    g = loadGraph(graphFile)\n    os.remove(graphFile)\n    assert len(g.compatibilityNodes) == 2\n    assert g.node(n1Name).canUpgrade\n    assert not g.node(n2Name).canUpgrade\n    g.upgradeAllNodes()\n    assert len(g.compatibilityNodes) == 1\n    assert n2Name in g.compatibilityNodes.keys()\n    unregisterNodeType(SampleNodeV1)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function upgrades all nodes in a graph by first registering both SampleNodeV1 and SampleNodeV2 nodes, then adding them both to a graph. The graph is then saved to a temporary file, and the SampleNodeV2 node is unregistered. The graph is then reloaded and all nodes are checked to see if they can be upgraded. If they can, they are upgraded, and the SampleNodeV1 node is unregistered."}
{"prompt": "def pasteNodes(self, data, position):\n    nodes = []\n    with GraphModification(self):\n        positionCnt = 0\n        for key in sorted(data):\n            nodeType = data[key].get('nodeType', None)\n            if not nodeType:\n                pass\n            attributes = {}\n            attributes.update(data[key].get('inputs', {}))\n            attributes.update(data[key].get('outputs', {}))\n            node = Node(nodeType, position=position[positionCnt], **attributes)\n            self._addNode(node, key)\n            nodes.append(node)\n            positionCnt += 1\n        self._applyExpr()\n    return nodes\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function creates nodes in a graph and adds them to the graph based on a given data set and a given position. It returns a list of the created nodes."}
{"prompt": "def discoverVertex(self, vertex, graph):\n    if vertex.isAlreadySubmitted():\n        self.canSubmit = False\n        if vertex.isExtern():\n            self.canCompute = False\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function checks to see if the given vertex is already submitted and if so, sets the canSubmit and canCompute boolean flags to False. If the vertex is an external source, canCompute is set to False."}
{"prompt": "def addFiles(self, filenames):\n    if not isinstance(filenames, list):\n        filenames = [filenames]\n    for filename in filenames:\n        self.addFile(filename)\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nAdd files to the current object.\n\nParameters\n----------\nfilenames : list or string\n    A list of filenames to add, or a single filename as a string.\n\nReturns\n-------\nNone\n\"\"\""}
{"prompt": "@Slot(Qt3DCore.QTransform, QMatrix4x4, QQuaternion, QMatrix4x4, QVector3D, int)\ndef relativeLocalRotate(self, transformQtInstance, initialPosMat, initialRotQuat, initialScaleMat, axis, degree):\n    transformQuat = QQuaternion.fromAxisAndAngle(axis, degree)\n    newRotQuat = initialRotQuat * transformQuat\n    newRotationMat = self.quaternionToRotationMatrix(newRotQuat)\n    mat = initialPosMat * newRotationMat * initialScaleMat\n    transformQtInstance.setMatrix(mat)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function rotates the position relative to the local transform of the given Qt3DCore.QTransform instance, based on the given axis and degree. It applies the initial position matrix, the transformed quaternion, and the initial scale matrix to the instance."}
{"prompt": "@Slot(QObject, result='QVariantList')\ndef duplicateNodes(self, nodes):\n    nodes = self.filterNodes(nodes)\n    nPositions = []\n    with self.groupedGraphModification('Duplicate Selected Nodes', disableUpdates=False):\n        with self.groupedGraphModification('Node duplication', disableUpdates=True):\n            duplicates = self.push(commands.DuplicateNodesCommand(self._graph, nodes))\n        bbox = self._layout.boundingBox(duplicates)\n        for n in duplicates:\n            idx = duplicates.index(n)\n            yPos = n.y + self.layout.gridSpacing + bbox[3]\n            if idx > 0 and (n.x, yPos) in nPositions:\n                while (n.x, yPos) in nPositions:\n                    yPos = yPos + self.layout.gridSpacing + self.layout.nodeHeight\n                self.moveNode(n, Position(n.x, yPos))\n            else:\n                self.moveNode(n, Position(n.x, bbox[3] + self.layout.gridSpacing + n.y))\n            nPositions.append((n.x, n.y))\n    return duplicates\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function duplicates the given nodes and returns a list of the duplicated nodes. It also ensures that the duplicate nodes do not overlap by adjusting the y position of each node."}
{"prompt": "def getCgroupMemorySize():\n    pid = os.getpid()\n    filename = f'/proc/{pid}/cgroup'\n    cgroup = None\n    try:\n        with open(filename, 'r') as f:\n            lines = f.readlines()\n            for line in lines:\n                tokens = line.rstrip('\\r\\n').split(':')\n                if len(tokens) < 3:\n                    continue\n                if tokens[1] == 'memory':\n                    cgroup = tokens[2]\n    except OSError:\n        pass\n    if cgroup is None:\n        return -1\n    size = -1\n    filename = f'/sys/fs/cgroup/memory/{cgroup}/memory.limit_in_bytes'\n    try:\n        with open(filename, 'r') as f:\n            value = f.read().rstrip('\\r\\n')\n            if value.isnumeric():\n                size = int(value)\n    except OSError:\n        pass\n    return size\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\ngetCgroupMemorySize()\n\nReturns the memory size in bytes of the cgroup associated with the current process. If the current process does not belong to a cgroup, or an error occurs, returns -1."}
{"prompt": "def insert(self, i, toInsert):\n    if not isinstance(toInsert, list):\n        toInsert = [toInsert]\n    self.beginInsertRows(QtCore.QModelIndex(), i, i + len(toInsert) - 1)\n    for obj in reversed(toInsert):\n        self._referenceItem(obj)\n        self._objects.insert(i, obj)\n    self.endInsertRows()\n    self.countChanged.emit()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nInserts a list of objects into the model at the specified index.\n\nParameters:\n    i (int): The index to insert the objects at.\n    toInsert (list): The list of objects to insert into the model. If a single object is provided, it will be wrapped in a list.\n\"\"\""}
{"prompt": "def getContainsMouse(self):\n    return self._containsMouse\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturn whether the object contains a mouse or not."}
{"prompt": "def completeProgressBar(self):\n    assert self.progressBar\n    self.progressBar = False\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function sets the progressBar attribute of the calling object to False."}
{"prompt": "@staticmethod\ndef asStr(path):\n    if not isinstance(path, (QUrl, str)):\n        raise TypeError('Unexpected data type: {}'.format(path.__class__))\n    if isinstance(path, QUrl):\n        path = path.toLocalFile()\n    return path\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function takes either a QUrl or a string as input, and returns a string. If the input does not match either of these types, a TypeError is raised."}
{"prompt": "def buildIntrinsics(self, cameraInit, additionalViews, rebuild=False):\n    views = []\n    intrinsics = []\n    inputs = cameraInit.toDict()['inputs'] if cameraInit else {}\n    cameraInitCopy = Node('CameraInit', **inputs)\n    if rebuild:\n        for vp in cameraInitCopy.viewpoints.value:\n            vp.intrinsicId.resetValue()\n            vp.metadata.resetValue()\n        cameraInitCopy.intrinsics.resetValue()\n    try:\n        self.setBuildingIntrinsics(True)\n        (views, intrinsics) = cameraInitCopy.nodeDesc.buildIntrinsics(cameraInitCopy, additionalViews)\n    except Exception as e:\n        logging.error('Error while building intrinsics: {}'.format(str(e)))\n        raise\n    finally:\n        cameraInitCopy.deleteLater()\n        self.setBuildingIntrinsics(False)\n    self.intrinsicsBuilt.emit(cameraInit, views, intrinsics, rebuild)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function builds intrinsics from the given cameraInit and additionalViews and emits the intrinsicsBuilt signal with the cameraInit, views, intrinsics, and rebuild. It also handles exceptions that may occur while building the intrinsics."}
{"prompt": "def _unsetSfm(self):\n    self._setSfm(None)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function sets the Sfm value of the object to None."}
{"prompt": "@Slot(int, result=QObject)\ndef getColumn(self, index):\n    return self._data.at(index)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nGets a column of data from the given index.\n\nParameters:\n    index (int): The index of the data to retrieve.\n\nReturns:\n    QObject: The data at the given index."}
{"prompt": "def __iter__(self):\n    return iter(self._objects)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturns an iterator over the objects in this object."}
{"prompt": "@Slot(Attribute, Attribute)\ndef addEdge(self, src, dst):\n    if isinstance(dst, ListAttribute) and (not isinstance(src, ListAttribute)):\n        with self.groupedGraphModification('Insert and Add Edge on {}'.format(dst.getFullNameToNode())):\n            self.appendAttribute(dst)\n            self._addEdge(src, dst.at(-1))\n    else:\n        self._addEdge(src, dst)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nAdds an edge from a source Attribute to a destination Attribute. If the destination is a ListAttribute, the source will be connected to the last item in the ListAttribute. \n\"\"\""}
{"prompt": "@Slot('QVariant')\ndef importImagesUrls(self, imagePaths, recursive=False):\n    paths = []\n    for imagePath in imagePaths:\n        if isinstance(imagePath, QUrl):\n            p = imagePath.toLocalFile()\n            if not p:\n                p = imagePath.toString()\n        else:\n            p = imagePath\n        paths.append(p)\n    self.importImagesFromFolder(paths)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function imports images from local folders given a list of image paths. It will optionally recursively search subdirectories if recursive is set to True."}
{"prompt": "def removeAt(self, i, count=1):\n    self.beginRemoveRows(QtCore.QModelIndex(), i, i + count - 1)\n    for cpt in range(count):\n        obj = self._objects.pop(i)\n        self._dereferenceItem(obj)\n    self.endRemoveRows()\n    self.countChanged.emit()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nRemoves a given number of rows starting at the given index from the model. Emits the countChanged signal afterwards."}
{"prompt": "def registerTypes():\n    from PySide2.QtQml import qmlRegisterType\n    from meshroom.ui.components.clipboard import ClipboardHelper\n    from meshroom.ui.components.edge import EdgeMouseArea\n    from meshroom.ui.components.filepath import FilepathHelper\n    from meshroom.ui.components.scene3D import Scene3DHelper, TrackballController, Transformations3DHelper\n    from meshroom.ui.components.csvData import CsvData\n    qmlRegisterType(EdgeMouseArea, 'GraphEditor', 1, 0, 'EdgeMouseArea')\n    qmlRegisterType(ClipboardHelper, 'Meshroom.Helpers', 1, 0, 'ClipboardHelper')\n    qmlRegisterType(FilepathHelper, 'Meshroom.Helpers', 1, 0, 'FilepathHelper')\n    qmlRegisterType(Scene3DHelper, 'Meshroom.Helpers', 1, 0, 'Scene3DHelper')\n    qmlRegisterType(Transformations3DHelper, 'Meshroom.Helpers', 1, 0, 'Transformations3DHelper')\n    qmlRegisterType(TrackballController, 'Meshroom.Helpers', 1, 0, 'TrackballController')\n    qmlRegisterType(CsvData, 'DataObjects', 1, 0, 'CsvData')\n##############\nEND_FUNC\n##############\n", "completion": "\n\nNo docstring available for this function."}
{"prompt": "def _isDefault(self):\n    return self.value == self.defaultValue()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function checks if the value of a given object is equal to the object's default value."}
{"prompt": "def __init__(self, parent=None):\n    super(TaskManager, self).__init__(parent)\n    self._graph = None\n    self._nodes = DictModel(keyAttrName='_name', parent=self)\n    self._nodesToProcess = []\n    self._nodesExtern = []\n    self._thread = TaskThread(self)\n    self._blockRestart = False\n    self.restartRequested.connect(self.restart)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__() is a function that initializes the TaskManager object and its attributes. It sets the parent of the TaskManager, creates a graph, creates a dictionary model, and creates a TaskThread object. It also sets the _blockRestart attribute to False and connects the restartRequested signal to the restart method."}
{"prompt": "@Slot(result=StatusData)\ndef getFusedStatus(self):\n    fusedStatus = StatusData()\n    if self._chunks:\n        fusedStatus.fromDict(self._chunks[0].status.toDict())\n        for chunk in self._chunks[1:]:\n            fusedStatus.merge(chunk.status)\n    fusedStatus.status = self.getGlobalStatus()\n    return fusedStatus\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturn a StatusData object representing the merged status of the ChunkData instances in self._chunks with the global status applied.\n\"\"\""}
{"prompt": "def getValueStr(self):\n    if isinstance(self.attributeDesc, desc.ChoiceParam) and (not self.attributeDesc.exclusive):\n        assert isinstance(self.value, Sequence) and (not isinstance(self.value, str))\n        return self.attributeDesc.joinChar.join(self.getEvalValue())\n    if isinstance(self.attributeDesc, (desc.StringParam, desc.File)):\n        return '\"{}\"'.format(self.getEvalValue())\n    return str(self.getEvalValue())\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturn a string representation of the value of an Attribute."}
{"prompt": "def nodeFactory(nodeDict, name=None, template=False):\n    nodeType = nodeDict['nodeType']\n    if 'inputs' not in nodeDict and 'attributes' in nodeDict:\n        nodeDict['inputs'] = nodeDict['attributes']\n        del nodeDict['attributes']\n    inputs = nodeDict.get('inputs', {})\n    outputs = nodeDict.get('outputs', {})\n    version = nodeDict.get('version', None)\n    internalFolder = nodeDict.get('internalFolder', None)\n    position = Position(*nodeDict.get('position', []))\n    compatibilityIssue = None\n    nodeDesc = None\n    try:\n        nodeDesc = meshroom.core.nodesDesc[nodeType]\n    except KeyError:\n        compatibilityIssue = CompatibilityIssue.UnknownNodeType\n    if nodeDesc:\n        currentNodeVersion = meshroom.core.nodeVersion(nodeDesc)\n        if version and currentNodeVersion and (Version(version).major != Version(currentNodeVersion).major):\n            compatibilityIssue = CompatibilityIssue.VersionConflict\n        else:\n            if not template and (sorted([attr.name for attr in nodeDesc.inputs]) != sorted(inputs.keys()) or sorted([attr.name for attr in nodeDesc.outputs]) != sorted(outputs.keys())):\n                compatibilityIssue = CompatibilityIssue.DescriptionConflict\n            for (attrName, value) in inputs.items():\n                if not CompatibilityNode.attributeDescFromName(nodeDesc.inputs, attrName, value):\n                    compatibilityIssue = CompatibilityIssue.DescriptionConflict\n                    break\n            for (attrName, value) in outputs.items():\n                if not CompatibilityNode.attributeDescFromName(nodeDesc.outputs, attrName, value):\n                    compatibilityIssue = CompatibilityIssue.DescriptionConflict\n                    break\n    if compatibilityIssue is None:\n        node = Node(nodeType, position, **inputs)\n    else:\n        logging.warning(\"Compatibility issue detected for node '{}': {}\".format(name, compatibilityIssue.name))\n        node = CompatibilityNode(nodeType, nodeDict, position, compatibilityIssue)\n        if not internalFolder and nodeDesc:\n            logging.warning(\"No serialized output data: performing automatic upgrade on '{}'\".format(name))\n            node = node.upgrade()\n        elif template:\n            node = node.upgrade()\n    return node\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function creates a Node or CompatibilityNode object. It takes a dictionary of node attributes, a name, and a boolean value to indicate if it is a template. It checks for compatibility issues and logs a warning if one is detected. If no compatibility issue is detected, it creates a Node object with the given attributes. If a compatibility issue is detected and the node is not a template, it creates a CompatibilityNode object with the given attributes. If the node is a template, it upgrades it to the latest version."}
{"prompt": "def __neg__(self):\n    return not self.name\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"Returns a boolean value of the negation of the object's name attribute.\""}
{"prompt": "def updateStatisticsFromCache(self):\n    for node in self._nodes:\n        node.updateStatisticsFromCache()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nUpdate the statistics for each node from the cache."}
{"prompt": "def reset(self, objects):\n    self.clear()\n    self.update(objects)\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nReset the contents of the dictionary, replacing them with the objects provided."}
{"prompt": "def keys(self):\n    return self._objectByKey.keys()\n##############\nEND_FUNC\n##############\n", "completion": "\nThis function returns a list of the keys from the dictionary '_objectByKey'."}
{"prompt": "def getDocumentation(self):\n    if not self.nodeDesc:\n        return ''\n    return self.nodeDesc.documentation\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Returns the documentation associated with the node.\"\"\""}
{"prompt": "def retrieveChildrenUids(self):\n    allUids = []\n    for desc in self._groupDesc:\n        allUids.extend(desc.uid)\n    return allUids\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nRetrieve a list of UIDs for all children of the Group object."}
{"prompt": "@Slot(str)\ndef setFilepath(self, filepath):\n    if self._filepath == filepath:\n        return\n    self.setReady(False)\n    self._filepath = filepath\n    self.filepathChanged.emit()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Set the filepath for the object.\n\nArgs:\n    filepath (str): The path to the file.\n\nReturns:\n    None\n\"\"\""}
{"prompt": "def updateNodesPerUid(self):\n    nodesPerUid = {}\n    for node in self.nodes:\n        uid = node._uids.get(0)\n        try:\n            nodesPerUid.get(uid).append(node)\n        except AttributeError:\n            nodesPerUid.update({uid: [node]})\n    for node in self.nodes:\n        node.updateDuplicates(nodesPerUid)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Update a dictionary mapping UIDs to a list of associated nodes, then update each node with its duplicates.\"\"\""}
{"prompt": "def validateNodeDesc(nodeDesc):\n    errors = []\n    for param in nodeDesc.inputs:\n        err = param.checkValueTypes()\n        if err:\n            errors.append(err)\n    for param in nodeDesc.outputs:\n        err = param.checkValueTypes()\n        if err:\n            errors.append(err)\n    return errors\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function validates the node description and returns a list of errors. It iterates through the node description's inputs and outputs and checks their value types for any errors."}
{"prompt": "def updateStats(self):\n    self.lastTime = time.time()\n    if self.chunk.statistics.update(self.proc):\n        self.chunk.saveStatistics()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nUpdate the statistics for the given audio process. Sets the lastTime of the audio process to the current time, then updates the statistics and saves them."}
{"prompt": "@Slot(QMatrix4x4, result='QVariant')\ndef modelMatrixToMatrices(self, modelMat):\n    decomposition = self.decomposeModelMatrix(modelMat)\n    posMat = QMatrix4x4()\n    posMat.translate(decomposition.get('translation'))\n    rotMat = self.quaternionToRotationMatrix(decomposition.get('quaternion'))\n    scaleMat = QMatrix4x4()\n    scaleMat.scale(decomposition.get('scale'))\n    return {'position': posMat, 'rotation': rotMat, 'scale': scaleMat, 'quaternion': decomposition.get('quaternion')}\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturns a dictionary containing the separated matrices from a given model matrix. \nThe dictionary contains the position matrix, the rotation matrix, the scale matrix and the quaternion of the model matrix."}
{"prompt": "@Slot(str)\ndef setText(self, value):\n    self._clipboard.setText(value)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nSet the text of the clipboard.\n\nParameters:\n    value (str): The text to set the clipboard to.\n\"\"\""}
{"prompt": "def _pipelineTemplateFiles(self):\n    templates = []\n    for key in sorted(meshroom.core.pipelineTemplates.keys()):\n        name = ' '.join(re.findall('[A-Z][^A-Z]*', key[0].upper() + key[1:]))\n        variant = {'name': name, 'key': key, 'path': meshroom.core.pipelineTemplates[key]}\n        templates.append(variant)\n    return templates\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function creates a sorted list of pipeline template files with their associated name, key and path."}
{"prompt": "@property\ndef nodes(self):\n    return self._nodes\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"This getter method returns the private attribute '_nodes' of the class it is defined in.\"\"\""}
{"prompt": "def __init__(self, graph, edge, parent=None):\n    super(RemoveEdgeCommand, self).__init__(graph, parent)\n    self.srcAttr = edge.src.getFullNameToNode()\n    self.dstAttr = edge.dst.getFullNameToNode()\n    self.setText(\"Disconnect '{}'->'{}'\".format(self.srcAttr, self.dstAttr))\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function is an initialization for the class RemoveEdgeCommand. It sets up the class with the graph, edge, and parent information, as well as setting the text of the command to be the names of the source and destination nodes connected by the edge."}
{"prompt": "def getFullName(self):\n    if isinstance(self.root, ListAttribute):\n        return '{}[{}]'.format(self.root.getFullName(), self.root.index(self))\n    elif isinstance(self.root, GroupAttribute):\n        return '{}.{}'.format(self.root.getFullName(), self.getName())\n    return self.getName()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function returns the full name of an Attribute, including the root Group or List it belongs to. The name consists of the root's full name followed by the Attribute's name (if it belongs to a Group) or the Attribute's index in the List (if it belongs to a List)."}
{"prompt": "def decomposeModelMatrix(self, modelMat):\n    translation = modelMat.column(3).toVector3D()\n    quaternion = QQuaternion.fromDirection(modelMat.column(2).toVector3D(), modelMat.column(1).toVector3D())\n    scale = QVector3D(modelMat.column(0).length(), modelMat.column(1).length(), modelMat.column(2).length())\n    return {'translation': translation, 'quaternion': quaternion, 'scale': scale}\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function decomposes a 4x4 model matrix into its translation, quaternion, and scale components and returns the results in a dictionary."}
{"prompt": "@property\ndef root(self):\n    return self._root() if self._root else None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"This function returns the root of the object if it exists, otherwise returns None.\"\"\""}
{"prompt": "def update(self):\n    if not self._updateEnabled:\n        self._updateRequested = True\n        return\n    self.updateInternals()\n    if os.path.exists(self._cacheDir):\n        self.updateStatusFromCache()\n    for node in self.nodes:\n        node.dirty = False\n    self.updateNodesPerUid()\n    if self.dirtyTopology:\n        self.updateNodesTopologicalData()\n        self.dirtyTopology = False\n    self.updated.emit()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"update(self):\n    Updates data structures and emits the updated signal.\n    If _updateEnabled is False, sets _updateRequested to True and returns.\n    Calls updateInternals() and updates status from cache if present.\n    Sets all nodes dirty to False and updates nodes per UID.\n    Updates topological data if dirtyTopology is True and sets it to False.\n    Emits the updated signal.\n\"\"\""}
{"prompt": "@Slot()\ndef clearSubmittedChunks(self):\n    for chunk in self._chunks:\n        if chunk.isAlreadySubmitted():\n            chunk.upgradeStatusTo(Status.NONE, ExecMode.NONE)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"This function clears all submitted chunks from the given object. It iterates over each chunk in the object's _chunks attribute and upgrades its status to 'NONE' and exec mode to 'NONE' if the chunk has already been submitted.\"\"\""}
{"prompt": "def __init__(self, name, label, description, value, advanced, semantic, uid, group, enabled):\n    super(Attribute, self).__init__()\n    self._name = name\n    self._label = label\n    self._description = description\n    self._value = value\n    self._uid = uid\n    self._group = group\n    self._advanced = advanced\n    self._enabled = enabled\n    self._semantic = semantic\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__() is the constructor for the Attribute class. It takes the following parameters: \nname: string representing the name of the attribute\nlabel: string representing the label of the attribute\ndescription: string representing the description of the attribute\nvalue: value of the attribute\nadvanced: boolean indicating whether the attribute is advanced or not \nsemantic: string representing the semantic type of the attribute\nuid: string representing a unique identifier for the attribute\ngroup: string representing the group the attribute belongs to\nenabled: boolean indicating whether the attribute is enabled or not \n\"\"\""}
{"prompt": "def __init__(self, script, initScript=None, base=None, targetName=None, icons=None, shortcutName=None, shortcutDir=None, copyright=None, trademarks=None):\n    if not targetName:\n        targetName = os.path.splitext(os.path.basename(script))[0]\n    targetName += PlatformExecutable.exeExtensions[platform.system()]\n    icon = icons.get(platform.system(), None) if icons else None\n    if platform.system() in (self.Linux, self.Darwin):\n        initScript = os.path.join(currentDir, 'setupInitScriptUnix.py')\n    super(PlatformExecutable, self).__init__(script, initScript, base, targetName, icon, shortcutName, shortcutDir, copyright, trademarks)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"This function is the constructor for the PlatformExecutable class. It takes a script and various optional parameters, and sets various attributes, including a targetName, icon, shortcutName, shortcutDir, copyright, and trademarks. Additionally, it sets the initScript to a Unix-specific script if the platform is Linux or Darwin.\"\"\""}
{"prompt": "def attributeFactory(description, value, isOutput, node, root=None, parent=None):\n    if isinstance(description, desc.GroupAttribute):\n        cls = GroupAttribute\n    elif isinstance(description, desc.ListAttribute):\n        cls = ListAttribute\n    else:\n        cls = Attribute\n    attr = cls(node, description, isOutput, root, parent)\n    if value is not None:\n        attr.value = value\n    return attr\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function creates an Attribute, GroupAttribute, or ListAttribute object based on the given description and sets its value if specified. It takes five arguments: a description object, a value, a boolean indicating whether the attribute is an output, a node object, and optional root and parent attributes."}
{"prompt": "def decorator(self, *args, **kwargs):\n    assert isinstance(self, Graph)\n    result = func(self, *args, **kwargs)\n    self.dirtyTopology = True\n    self.update()\n    return result\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis decorator function is used to modify a Graph object, setting the \"dirtyTopology\" attribute to True and calling the \"update\" method. It takes in an instance of the Graph object as the first argument, with optional additional arguments and keyword arguments."}
{"prompt": "def duplicateNodes(self, srcNodes):\n    duplicates = OrderedDict()\n    with GraphModification(self):\n        duplicateEdges = {}\n        for srcNode in srcNodes:\n            (node, edges) = self.copyNode(srcNode, withEdges=False)\n            duplicate = self.addNode(node)\n            duplicateEdges.update(edges)\n            duplicates.setdefault(srcNode, []).append(duplicate)\n        for (attr, linkExpression) in duplicateEdges.items():\n            link = linkExpression[1:-1]\n            (edgeSrcNodeName, edgeSrcAttrName) = link.split('.', 1)\n            edgeSrcNode = self.node(edgeSrcNodeName)\n            if edgeSrcNode in duplicates:\n                edgeSrcNode = duplicates.get(edgeSrcNode)[0]\n            self.addEdge(edgeSrcNode.attribute(edgeSrcAttrName), attr)\n    return duplicates\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function creates duplicates of the specified nodes in the graph and returns a dictionary of source nodes to duplicated nodes. It takes in an argument of srcNodes which are the nodes to be duplicated. It also creates duplicate edges for the duplicated nodes."}
{"prompt": "def geometryChanged(self, newGeometry, oldGeometry):\n    super(EdgeMouseArea, self).geometryChanged(newGeometry, oldGeometry)\n    self.updateShape()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function updates the shape of the EdgeMouseArea whenever the geometry of the object changes. It calls the geometryChanged method of the super class and then calls updateShape to update the shape."}
{"prompt": "def onRequestDeletion(self, item):\n    item.deleteLater()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nDelete an item later."}
{"prompt": "@classmethod\ndef update(cls, node):\n    pass\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nUpdate the given node with a class method.\n\nParameters:\nnode (object): The node to be updated.\n\nReturns:\nNone.\n\"\"\""}
{"prompt": "@Property(type=QSizeF, notify=initialParamsChanged)\ndef orientedImageSize(self):\n    if self.orientation in (6, 8):\n        return QSizeF(self.imageSize.height(), self.imageSize.width())\n    else:\n        return self.imageSize\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function returns the size of an image after it has been rotated. If the image orientation is 6 or 8, the height and width are swapped. Otherwise, the image size is returned as is."}
{"prompt": "@Slot()\ndef save(self):\n    self._graph.save()\n    self._undoStack.setClean()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nSave the graph and set the undo stack to clean."}
{"prompt": "@Slot(str, result=bool)\n@Slot(QUrl, result=bool)\ndef isFile(self, path):\n    return os.path.isfile(self.asStr(path))\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nisFile() checks if the given path is an existing file and returns a boolean.\n\nParameters:\n    path (str or QUrl): Path of the file to check\n\nReturns:\n    bool: True if the path is a file, False otherwise."}
{"prompt": "@staticmethod\ndef sortNodesByIndex(nodes):\n    return sorted(nodes, key=lambda x: Graph.getNodeIndexFromName(x.name))\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nSort a list of nodes by their index in the graph.\n\nParameters: \nnodes (list): A list of nodes to be sorted.\n\nReturns: \nlist: A list of nodes sorted by their index in the graph."}
{"prompt": "def clearActiveNodes(self):\n    for key in self._activeNodes.keys():\n        self._activeNodes.get(key).node = None\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function clears all active nodes stored in the _activeNodes dictionary. It sets the node attribute of each stored object to None."}
{"prompt": "@classmethod\ndef postUpdate(cls, node):\n    pass\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis is a class method for the class 'cls' that takes in a 'node' argument and does not return anything."}
{"prompt": "def getLabel(self):\n    return self._label\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturn the label associated with the object."}
{"prompt": "def setChunks(self, chunks):\n    self.chunks = chunks\n    self._filesTimePoller.setFiles(self.statusFiles)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nSet the chunks for the given object and set the filesTimePoller with the statusFiles."}
{"prompt": "@property\ndef issueDetails(self):\n    if self.issue == CompatibilityIssue.UnknownNodeType:\n        return \"Unknown node type: '{}'.\".format(self.nodeType)\n    elif self.issue == CompatibilityIssue.VersionConflict:\n        return \"Node version '{}' conflicts with current version '{}'.\".format(self.nodeDict['version'], nodeVersion(self.nodeDesc))\n    elif self.issue == CompatibilityIssue.DescriptionConflict:\n        return 'Node attributes do not match node description.'\n    else:\n        return 'Unknown error.'\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis property returns a string with details about a compatibility issue. Depending on the issue, it will return a different string with more information about the issue."}
{"prompt": "def setObjectList(self, objects):\n    oldSize = self.size()\n    self.beginResetModel()\n    for obj in self._objects:\n        self._dereferenceItem(obj)\n    self._objects = objects\n    for obj in self._objects:\n        self._referenceItem(obj)\n    self.endResetModel()\n    self.dataChanged.emit(self.index(0), self.index(self.size() - 1), [])\n    if self.size() != oldSize:\n        self.countChanged.emit()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nSet the object list and trigger the appropriate signals to update the model."}
{"prompt": "def __iter__(self):\n    return iter(self._objects.values())\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturns an iterator object that iterates over the values in the self._objects dictionary."}
{"prompt": "def fromDict(self, d):\n    version = d.get('fileVersion', 0.0)\n    if version != self.fileVersion:\n        logging.debug('Statistics: file version was {} and the current version is {}.'.format(version, self.fileVersion))\n    self.computer = {}\n    self.process = {}\n    self.times = []\n    try:\n        self.computer.fromDict(d.get('computer', {}))\n    except Exception as e:\n        logging.debug('Failed while loading statistics: computer: \"{}\".'.format(str(e)))\n    try:\n        self.process.fromDict(d.get('process', {}))\n    except Exception as e:\n        logging.debug('Failed while loading statistics: process: \"{}\".'.format(str(e)))\n    try:\n        self.times = d.get('times', [])\n    except Exception as e:\n        logging.debug('Failed while loading statistics: times: \"{}\".'.format(str(e)))\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function loads data from a dictionary into the computer, process, and times attributes. It also checks the file version and logs a debug message if it is different from the current version. It handles exceptions by logging debug messages."}
{"prompt": "@QtCore.Slot(QtCore.QObject, result=int)\ndef indexOf(self, matchObj, fromIndex=0, positive=True):\n    index = self._objects[fromIndex:].index(matchObj) + fromIndex\n    if positive and index < 0:\n        index += self.size()\n    return index\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function returns the index of a given match object starting from a given index. If positive is set to True, it will return an index greater than or equal to the given index, otherwise it will return an index less than or equal to the given index."}
{"prompt": "def findNode(self, nodeExpr):\n    candidates = self.findNodeCandidates('^' + nodeExpr)\n    if not candidates:\n        raise KeyError('No node candidate for \"{}\"'.format(nodeExpr))\n    if len(candidates) > 1:\n        for c in candidates:\n            if c.name == nodeExpr:\n                return c\n        raise KeyError('Multiple node candidates for \"{}\": {}'.format(nodeExpr, str([c.name for c in candidates])))\n    return candidates[0]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nFind a node corresponding to the given node expression.\n\nParameters:\n    nodeExpr (str): The node expression to search for.\n\nRaises:\n    KeyError: If no node candidate is found or if multiple candidates are found.\n\nReturns:\n    Node: The node that corresponds to the given node expression.\n\"\"\""}
{"prompt": "def updateGraphComputingStatus(self):\n    computingLocally = any([ch.status.execMode == ExecMode.LOCAL and ch.status.sessionUid == sessionUid and (ch.status.status in (Status.RUNNING, Status.SUBMITTED)) for ch in self._sortedDFSChunks])\n    submitted = any([ch.status.status == Status.SUBMITTED for ch in self._sortedDFSChunks])\n    if self._computingLocally != computingLocally or self._submitted != submitted:\n        self._computingLocally = computingLocally\n        self._submitted = submitted\n        self.computeStatusChanged.emit()\n##############\nEND_FUNC\n##############\n", "completion": "\nThis function updates the graph computing status and emits a compute status change signal. It checks if any of the chunks in the sorted DFS chunks list have an execution mode of local and a session UID that match the given session UID, as well as a status of either running or submitted. It also checks if any of the chunks have a status of submitted. If any of the conditions are met, it updates the computing locally and submitted values, and emits a compute status change signal."}
{"prompt": "def requestGraphUpdate(self):\n    if self.node.graph:\n        self.node.graph.markNodesDirty(self.node)\n        self.node.graph.update()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function requests a graph update from the node's graph. It marks any dirty nodes associated with the node and updates the graph."}
{"prompt": "def end(self):\n    for handler in self.logger.handlers[:]:\n        handler.close()\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"Closes all the handlers associated with the logger object.\"\"\""}
{"prompt": "@Slot()\ndef updateData(self):\n    self.setReady(False)\n    self._data.clear()\n    newColumns = self.read()\n    if newColumns:\n        self._data.setObjectList(newColumns)\n        self.setReady(True)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nUpdate the stored data. Clears the existing data and reads the new data from the source. Sets the ready status accordingly."}
{"prompt": "def getBaseType(self):\n    return self.getType()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturn the base type of the object."}
{"prompt": "def _setSfm(self, node):\n    self._sfm = node\n    self.updateSfMResults()\n    if self._sfm:\n        self._sfm.destroyed.connect(self._unsetSfm)\n        self._sfm.chunks[0].statusChanged.connect(self.updateSfMResults)\n    self.sfmChanged.emit()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function sets a node, updates the SfM results, and emits a signal when the SfM is changed. It also connects the node to a signal that will unset the SfM when it is destroyed and connects the node's status to a signal that will update the SfM results."}
{"prompt": "def emit(self, signalName, *args, **kwargs):\n    assert signalName in self, '%s is not a registered signal' % signalName\n    self[signalName].emit(*args, **kwargs)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nEmit a signal with the given name, passing any given positional and keyword arguments to the signal. Asserts that the signal is registered with the signal dict beforehand."}
{"prompt": "def processChunk(self, chunk):\n    raise NotImplementedError('No processChunk implementation on node: \"{}\"'.format(chunk.node.name))\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nRaises a NotImplementedError exception when called, with a message stating that there is no processChunk implementation on the node specified."}
{"prompt": "@Slot(Node)\ndef appendSelection(self, node):\n    if not self._selectedNodes.contains(node):\n        self._selectedNodes.append(node)\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nAppend a Node to the selection list if it is not already in the list."}
{"prompt": "def __bool__(self):\n    return self.size() > 0\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturn whether the size of the object is greater than 0."}
{"prompt": "@Slot(str, result=Attribute)\ndef attribute(self, fullName):\n    (node, attribute) = fullName.split('.', 1)\n    return self.node(node).attribute(attribute)\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nRetrieve an Attribute from a given node by its full name.\n\nArgs:\n    fullName (str): A string containing the full name of the Attribute to be retrieved.\n\nReturns:\n    Attribute: The Attribute object matching the given full name."}
{"prompt": "def __init__(self, reverse, dependenciesOnly):\n    super(SCVisitor, self).__init__(reverse, dependenciesOnly)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis is the constructor of the SCVisitor class. It calls the superclass constructor with the given parameters: reverse and dependenciesOnly."}
{"prompt": "def __init__(self, parent=None):\n    self._objects = []\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__(self, parent=None):\n    \"\"\"Initialize a new instance of this class, with the given parent.\n\n    Args:\n        parent (object): Optional parent object.\n\n    \"\"\"\n    self._objects = []"}
{"prompt": "def getEvalValue(self):\n    if isinstance(self.value, str):\n        return Template(self.value).safe_substitute(os.environ)\n    return self.value\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function evaluates a value (self.value) and returns its value. If the value is a string, it is substituted for any environment variables before being returned."}
{"prompt": "def get_link_key(node):\n    link_keys = ['uri', 'refuri', 'refname']\n    for key in link_keys:\n        if key in node.attributes.keys():\n            return key\n    return None\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturns the key for a link node if present in the node's attributes, otherwise returns None."}
{"prompt": "def getChunks(self, nodes=None):\n    chunks = []\n    for node in nodes or self.nodes:\n        chunks += [chunk for chunk in node.chunks]\n    return chunks\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function returns a list of chunks from the given list of nodes. If no nodes are given, then it will use the nodes stored in 'self.nodes'. Each chunk is taken from a node in the given list."}
{"prompt": "@property\ndef logger(self):\n    return self.logManager.logger\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis property returns the logger object for the logManager instance."}
{"prompt": "def __get__(self, instance, owner):\n    if instance is None:\n        return self\n    tmp = self._map.setdefault(self, weakref.WeakKeyDictionary())\n    return tmp.setdefault(instance, Signal())\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function sets up a WeakKeyDictionary which stores a Signal object that is associated with the instance passed to the function. It returns the Signal object associated with the instance if it already exists in the WeakKeyDictionary, otherwise it creates a new Signal object and stores it in the WeakKeyDictionary for future reference."}
{"prompt": "def __getitem__(self, idx):\n    return self._objects[idx]\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function returns the object stored at the given index in the self._objects list."}
{"prompt": "def lastNodeOfType(self, nodeTypes, startNode, preferredStatus=None):\n    if not startNode:\n        return None\n    nodes = self._graph.dfsOnDiscover(startNodes=[startNode], filterTypes=nodeTypes, reverse=True)[0]\n    if not nodes:\n        return None\n    node = nodes[-1]\n    if preferredStatus:\n        node = next((n for n in reversed(nodes) if n.getGlobalStatus() == preferredStatus), node)\n    return node\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturns the last node of a given type in a DFS traversal, starting from a given node, with an optional preferred global status."}
{"prompt": "@Slot(QVector3D, result=QVector3D)\ndef fromEquirectangular(self, vector):\n    return QVector3D(cos(vector.x()) * sin(vector.y()), sin(vector.x()), cos(vector.x()) * cos(vector.y()))\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturns a QVector3D constructed from an equirectangular vector. Given a QVector3D with coordinates (x, y, z) it will return a QVector3D with coordinates (cos(x) * sin(y), sin(x), cos(x) * cos(y))."}
{"prompt": "def _applyExpr(self):\n    with GraphModification(self):\n        for node in self._nodes:\n            node._applyExpr()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nApply the expression to all nodes in the graph.\n\nThis function applies the current expression to all nodes in the graph. It is intended to be used internally."}
{"prompt": "def undoImpl(self):\n    self.graph.removeNode(self.nodeName)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nRemove a node from the graph.\n\nParameters:\n    self (object): The instance of the current class.\n    self.graph (object): The graph object.\n    self.nodeName (str): The name of the node to be removed.\n\"\"\""}
{"prompt": "def hasExtension(filepath, extensions):\n    return os.path.splitext(filepath)[1].lower() in extensions\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nChecks whether the given filepath has an extension that is included in the given list of extensions.\n\nParameters:\nfilepath (str): The filepath to check.\nextensions (list): A list of extensions to check against.\n\nReturns:\nbool: True if the filepath has an extension in the given list, False otherwise.\n\"\"\""}
{"prompt": "def validateValue(self, value):\n    if not isinstance(value, str):\n        raise ValueError('StringParam value should be a string (param:{}, value:{}, type:{})'.format(self.name, value, type(value)))\n    return value\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"This function checks if the given value is a string. If not, it will raise a ValueError containing the parameter name, value, and type of the given value.\"\"\""}
{"prompt": "@Slot(QObject, result=bool)\ndef hasMetadata(self, viewpoint):\n    return len(viewpoint.metadata.value) > 2\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"This function returns a boolean value indicating whether the given viewpoint has more than two metadata entries.\"\"\""}
{"prompt": "@Slot(Attribute)\ndef resetAttribute(self, attribute):\n    self.push(commands.SetAttributeCommand(self._graph, attribute, attribute.defaultValue()))\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReset the given attribute to its default value on the graph."}
{"prompt": "@position.setter\ndef position(self, value):\n    if self._position == value:\n        return\n    self._position = value\n    self.positionChanged.emit()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function sets the value of the _position attribute and emits the positionChanged signal."}
{"prompt": "def insert(self, index, iterable):\n    self._objects[index:index] = iterable\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nInsert iterable into the list at the given index.\n\nArgs:\n    index (int): The index of the list where the iterable should be inserted.\n    iterable (iterable): An iterable, such as a list or tuple, to be inserted into the list.\n\nReturns:\n    None.\n\"\"\""}
{"prompt": "def fromDict(self, d):\n    for (k, v) in d.items():\n        setattr(self, k, v)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nsetattr(object, name, value)\n\nSet the named attribute on the given object to the specified value. The name must be a string. The object can be anything, even a module or a class. Returns None."}
{"prompt": "@Slot(str, result=str)\ndef nameToLabel(self, name):\n    (t, idx) = name.split('_')\n    return '{}{}'.format(t, idx if int(idx) > 1 else '')\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function takes in a string `name` and returns a string `result`. It splits the name by \"_\" and then returns a string with the characters before the \"_\" followed by the characters after the \"_\" if the number after the \"_\" is greater than 1."}
{"prompt": "def __repr__(self):\n    return self.name\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function returns a string representation of the object, typically the name of the object."}
{"prompt": "def __init__(self, parent=None):\n    super(SimpleFarmSubmitter, self).__init__(name='SimpleFarm', parent=parent)\n    self.engine = os.environ.get('MESHROOM_SIMPLEFARM_ENGINE', 'tractor')\n    self.share = os.environ.get('MESHROOM_SIMPLEFARM_SHARE', 'vfx')\n    self.prod = os.environ.get('PROD', 'mvg')\n    if 'REZ_REQUEST' in os.environ:\n        packages = os.environ.get('REZ_REQUEST', '').split()\n        resolvedPackages = os.environ.get('REZ_RESOLVE', '').split()\n        resolvedVersions = {}\n        for r in resolvedPackages:\n            if r.startswith('~'):\n                continue\n            v = r.split('-')\n            if len(v) == 2:\n                resolvedVersions[v[0]] = v[1]\n        for p in packages:\n            if p.startswith('~'):\n                continue\n            v = p.split('-')\n            self.reqPackages.append('-'.join([v[0], resolvedVersions[v[0]]]))\n        logging.debug('REZ Packages: {}'.format(str(self.reqPackages)))\n    elif 'REZ_MESHROOM_VERSION' in os.environ:\n        self.reqPackages = ['meshroom-{}'.format(os.environ.get('REZ_MESHROOM_VERSION', ''))]\n    else:\n        self.reqPackages = None\n    if 'REZ_DEV_PACKAGES_ROOT' in os.environ:\n        self.environment['REZ_DEV_PACKAGES_ROOT'] = os.environ['REZ_DEV_PACKAGES_ROOT']\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis is the constructor for the SimpleFarmSubmitter class. It sets up the environment variables and the required packages needed to submit jobs to a farm.  It also logs the packages to use for debugging purposes."}
{"prompt": "def _referenceItem(self, item):\n    if item.staticMetaObject != self._metaObject:\n        raise TypeError('Invalid object type: expected {}, got {}'.format(self._metaObject.className(), item.staticMetaObject.className()))\n    super(QTypedObjectListModel, self)._referenceItem(item)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function checks if the item is of the same type as the model's metaObject, and if so, passes the item to the superclass's referenceItem function. Raises a TypeError if the item is of the wrong type."}
{"prompt": "def checkValueTypes(self):\n    raise NotImplementedError('Attribute.checkValueTypes is an abstract function that should be implemented in the derived class.')\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function raises a NotImplementedError, indicating that it is an abstract function that should be implemented in the derived class."}
{"prompt": "def run(*args):\n    m = __import__('__main__')\n    importer = zipimport.zipimporter(os.path.dirname(os.__file__))\n    if len(args) == 0:\n        (name, ext) = os.path.splitext(os.path.basename(os.path.normcase(FILE_NAME)))\n        moduleName = '%s__main__' % name\n    else:\n        moduleName = args[0]\n    code = importer.get_code(moduleName)\n    exec(code, m.__dict__)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nrun(*args)\n\nRuns the module given by the first argument as the main module. If no argument is given, runs the module containing the file currently being executed.\n\"\"\""}
{"prompt": "def undoImpl(self):\n    listAttribute = self.graph.attribute(self.attrName)\n    listAttribute.remove(self.index, self.count)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"This function removes a specified number of elements from a given attribute in a graph.\"\"\""}
{"prompt": "def validateValue(self, value):\n    if JSValue is not None and isinstance(value, JSValue):\n        raise ValueError('GroupAttribute.validateValue: cannot recognize QJSValue. Please, use JSON.stringify(value) in QML.')\n    if isinstance(value, str):\n        value = ast.literal_eval(value)\n    if isinstance(value, dict):\n        if self._groupDesc:\n            commonKeys = set(value.keys()).intersection([attr.name for attr in self._groupDesc])\n            if not commonKeys:\n                raise ValueError('Value contains no key that matches with the group description: {}'.format(commonKeys))\n    elif isinstance(value, (list, tuple)):\n        if len(value) != len(self._groupDesc):\n            raise ValueError('Value contains incoherent number of values: desc size: {}, value size: {}'.format(len(self._groupDesc), len(value)))\n    else:\n        raise ValueError('GroupAttribute only supports dict/list/tuple input values (param:{}, value:{}, type:{})'.format(self.name, value, type(value)))\n    return value\n##############\nEND_FUNC\n##############\n", "completion": "\n\nValidates a value to ensure it is of the correct type and has the expected number of elements if it is a list or tuple. Raises a ValueError if the value is not a dict, list, tuple, or QJSValue, or if the value does not match the group description."}
{"prompt": "def isAlreadySubmitted(self):\n    for chunk in self._chunks:\n        if chunk.isAlreadySubmitted():\n            return True\n    return False\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function checks if the chunk has already been submitted. It returns True if one of the chunks has already been submitted, and False otherwise."}
{"prompt": "@Slot(Node, result=int)\ndef canSubmitOrCompute(self, startNode):\n    if startNode.isAlreadySubmittedOrFinished():\n        return 0\n\n    class SCVisitor(Visitor):\n\n        def __init__(self, reverse, dependenciesOnly):\n            super(SCVisitor, self).__init__(reverse, dependenciesOnly)\n        canCompute = True\n        canSubmit = True\n\n        def discoverVertex(self, vertex, graph):\n            if vertex.isAlreadySubmitted():\n                self.canSubmit = False\n                if vertex.isExtern():\n                    self.canCompute = False\n    visitor = SCVisitor(reverse=False, dependenciesOnly=True)\n    self.dfs(visitor=visitor, startNodes=[startNode])\n    return visitor.canCompute + 2 * visitor.canSubmit\n##############\nEND_FUNC\n##############\n", "completion": "\nThis function examines the dependencies of a given startNode, and returns an integer depending on whether or not it can be submitted or computed. It is 0 if the startNode has already been submitted or finished, 1 if only computations are possible, 2 if only submissions are possible, and 3 if both submissions and computations are possible."}
{"prompt": "def relink(self, node, base_dir):\n    key = get_link_key(node)\n    if key is None:\n        return\n    link = node.attributes[key]\n    if link.startswith('http') or link.startswith('mailto'):\n        return\n    if link.startswith('/'):\n        link = link[1:]\n    node.attributes[key] = base_dir + '/' + link\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function takes a node and a base directory as parameters, and relinks the node's attribute (specified by the key returned by get_link_key()) to a new link which is the base directory plus the original link. If the original link starts with 'http' or 'mailto', it is not changed. If the original link starts with a '/', it is removed."}
{"prompt": "def validateValue(self, value):\n    if self.exclusive:\n        return self.conformValue(value)\n    if isinstance(value, str):\n        value = value.split(',')\n    if not isinstance(value, Iterable):\n        raise ValueError('Non exclusive ChoiceParam value should be iterable (param:{}, value:{}, type:{})'.format(self.name, value, type(value)))\n    return [self.conformValue(v) for v in value]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nValidates the value of a ChoiceParam. If the ChoiceParam is exclusive, the value is simply conformed. Otherwise, if the value is a string, it is split by commas and each element is conformed. If the value is not an iterable, a ValueError is raised. Returns a list of conformed values."}
{"prompt": "@raiseIfLink\ndef extend(self, values):\n    self.insert(len(self._value), values)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nRaise an error if the argument `values` is a link."}
{"prompt": "def __eq__(self, other):\n    return self.name == other.name\n##############\nEND_FUNC\n##############\n", "completion": "\n\nCompares two objects and returns True if their names are equal, False otherwise."}
{"prompt": "@staticmethod\ndef resetExternalLinks(attributes, nodeDesc, newNames):\n    for (key, val) in attributes.items():\n        defaultValue = None\n        for desc in nodeDesc:\n            if desc.name == key:\n                defaultValue = desc.value\n                break\n        if isinstance(val, str):\n            if Attribute.isLinkExpression(val) and (not any((name in val for name in newNames))):\n                if defaultValue is not None:\n                    attributes[key] = defaultValue\n        elif isinstance(val, list):\n            removedCnt = len(val)\n            tmpVal = list(val)\n            for v in tmpVal:\n                if isinstance(v, str) and Attribute.isLinkExpression(v) and (not any((name in v for name in newNames))):\n                    val.remove(v)\n                    removedCnt -= 1\n            if removedCnt == 0 and defaultValue is not None:\n                attributes[key] = defaultValue\n    return attributes\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function resets external links in the given attributes dictionary, for node descriptions in nodeDesc and for new names in newNames. It will update the attributes dictionary by either setting the default value of the key or by removing entries in the list."}
{"prompt": "@property\ndef isParallelized(self):\n    return bool(self.nodeDesc.parallelization) if meshroom.useMultiChunks else False\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function returns a boolean indicating if the node is parallelized or not. If meshroom.useMultiChunks is True, then this function returns the parallelization of the nodeDesc attribute, otherwise False."}
{"prompt": "@Slot(QObject)\ndef setActiveNodes(self, nodes):\n    nodesByCategory = {}\n    for node in nodes:\n        if node is None:\n            continue\n        for (category, nodeTypes) in self.activeNodeCategories.items():\n            if node.nodeType in nodeTypes:\n                nodesByCategory[category] = node\n    for (category, node) in nodesByCategory.items():\n        self.activeNodes.get(category).node = node\n        if category == 'sfm':\n            self.setSfm(node)\n    for node in nodes:\n        if node is None:\n            continue\n        if not isinstance(node, CompatibilityNode):\n            self.activeNodes.get(node.nodeType).node = node\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function sets the active nodes for the given node categories. It takes in a list of nodes and checks if each node is compatible with the active node categories. If it is, the node is added to the dictionary of active nodes by category. If the node is of type 'sfm', the setSfm function is also called. Finally, if the node is not an instance of CompatibilityNode, it is added to the activeNodes dictionary."}
{"prompt": "@Slot(Qt3DCore.QEntity, Qt3DCore.QComponent)\ndef removeComponent(self, entity, component):\n    entity.removeComponent(component)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Removes a component from the given entity.\"\"\""}
{"prompt": "def dfsOnDiscover(self, startNodes=None, filterTypes=None, longestPathFirst=False, reverse=False, dependenciesOnly=False):\n    nodes = []\n    edges = []\n    visitor = Visitor(reverse=reverse, dependenciesOnly=dependenciesOnly)\n\n    def discoverVertex(vertex, graph):\n        if not filterTypes or vertex.nodeType in filterTypes:\n            nodes.append(vertex)\n    visitor.discoverVertex = discoverVertex\n    visitor.examineEdge = lambda edge, graph: edges.append(edge)\n    self.dfs(visitor=visitor, startNodes=startNodes, longestPathFirst=longestPathFirst)\n    return (nodes, edges)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function performs a Depth First Search (DFS) on the graph and returns a list of nodes and edges found by the search. It takes optional parameters startNodes, filterTypes, longestPathFirst, reverse, and dependenciesOnly, which can be used to customize the search."}
{"prompt": "@Slot(Attribute, 'QVariant')\ndef setAttribute(self, attribute, value):\n    self.push(commands.SetAttributeCommand(self._graph, attribute, value))\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function creates a new SetAttributeCommand with the given attribute and value and pushes it to the _graph."}
{"prompt": "def projectToTrackball(self, screenCoords):\n    sx = screenCoords.x()\n    sy = self._windowSize.height() - screenCoords.y()\n    p2d = QVector2D(sx / self._windowSize.width() - 0.5, sy / self._windowSize.height() - 0.5)\n    z = 0.0\n    r2 = pow(self._trackballSize, 2)\n    lengthSquared = p2d.lengthSquared()\n    if lengthSquared <= r2 * 0.5:\n        z = sqrt(r2 - lengthSquared)\n    else:\n        z = r2 * 0.5 / p2d.length()\n    return QVector3D(p2d.x(), p2d.y(), z)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function projects a given 2D screen coordinate onto a trackball. It uses the trackball size and window size to calculate the 3D vector associated with the screen coordinate."}
{"prompt": "@property\ndef dst(self):\n    return self._dst()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Returns the daylight savings time of the datetime object.\"\"\""}
{"prompt": "@classmethod\ndef handler(cls, messageType, context, message):\n    if not cls.outputQmlWarnings:\n        if 'QQmlApplicationEngine failed to load component' in message:\n            logging.warning('Set MESHROOM_OUTPUT_QML_WARNINGS=1 to get a detailed error message.')\n        elif any((w in message for w in cls.qmlWarningsBlacklist)):\n            return\n    MessageHandler.logFunctions[messageType](message)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis classmethod handles the logging of messages. It checks if the outputQmlWarnings flag is set and if not, it checks if the message contains a warning related to QQmlApplicationEngine and then filters it through the qmlWarningsBlacklist. Finally, it logs the message using the logging functions associated with the given message type."}
{"prompt": "def __init__(self, *args):\n    if len(args) == 0:\n        self.components = tuple()\n    elif len(args) == 1:\n        versionName = args[0]\n        if isinstance(versionName, str):\n            self.components = Version.toComponents(versionName)\n        elif isinstance(versionName, (list, tuple)):\n            self.components = tuple([int(v) for v in versionName])\n        else:\n            raise RuntimeError('Version: Unsupported input type.')\n    else:\n        self.components = tuple([int(v) for v in args])\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function creates a Version object from a given set of version components. If no components are given, an empty tuple is created. If a single input argument is given, it can be either a string or a list/tuple. If a string is given, it will be converted to a tuple of version components. If a list/tuple is given, it will be converted to a tuple of integers. If multiple input arguments are given, they will be converted to a tuple of integers."}
{"prompt": "@Slot(result=str)\ndef getFirst(self):\n    if not self._content:\n        return ''\n    return self._content[0]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function returns the first item from the '_content' list. If the list is empty, it will return an empty string. The result is a string."}
{"prompt": "def finishVertex(vertex, graph):\n    v = nodesStack.pop()\n    assert v == vertex\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function removes the given vertex from the graph, and checks if it is equal to the vertex at the top of the nodesStack."}
{"prompt": "def fromDict(self, d):\n    self.status = d.get('status', Status.NONE)\n    if not isinstance(self.status, Status):\n        self.status = Status[self.status]\n    self.execMode = d.get('execMode', ExecMode.NONE)\n    if not isinstance(self.execMode, ExecMode):\n        self.execMode = ExecMode[self.execMode]\n    self.nodeName = d.get('nodeName', '')\n    self.nodeType = d.get('nodeType', '')\n    self.packageName = d.get('packageName', '')\n    self.packageVersion = d.get('packageVersion', '')\n    self.graph = d.get('graph', '')\n    self.commandLine = d.get('commandLine', '')\n    self.env = d.get('env', '')\n    self.startDateTime = d.get('startDateTime', '')\n    self.endDateTime = d.get('endDateTime', '')\n    self.elapsedTime = d.get('elapsedTime', 0)\n    self.hostname = d.get('hostname', '')\n    self.sessionUid = d.get('sessionUid', '')\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function sets the properties of a given object using values from a dictionary. The supported properties are 'status', 'execMode', 'nodeName', 'nodeType', 'packageName', 'packageVersion', 'graph', 'commandLine', 'env', 'startDateTime', 'endDateTime', 'elapsedTime', 'hostname', and 'sessionUid'. If the value for any property is not of the appropriate type, the function will attempt to cast it."}
{"prompt": "@property\ndef depth(self):\n    return self.graph.getDepth(self)\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nReturn the depth of the current node in the graph."}
{"prompt": "def _updateInitialParams(self):\n    if not self._reconstruction.cameraInit:\n        self._initialIntrinsics = None\n        self._metadata = {}\n    else:\n        self._initialIntrinsics = self._reconstruction.getIntrinsic(self._viewpoint)\n        try:\n            self._metadata = json.loads(self._viewpoint.metadata.value) if self._viewpoint.metadata.value else None\n        except Exception as e:\n            logging.warning(\"Failed to parse Viewpoint metadata: '{}', '{}'\".format(str(e), str(self._viewpoint.metadata.value)))\n            self._metadata = {}\n        if not self._metadata:\n            self._metadata = {}\n    self.initialParamsChanged.emit()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function updates the initial parameters for a given viewpoint. It sets the initial intrinsics and loads the metadata from the viewpoint before emitting a signal to indicate that the initial parameters have changed."}
{"prompt": "def stopProcess(self, chunk):\n    self._stopped = True\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nStop the current process.\n\nArgs:\n    self (object): The object instance.\n    chunk (any): The chunk to process.\n\nReturns:\n    None\n\"\"\""}
{"prompt": "@Slot(str, result=bool)\ndef load(self, filepath, setupProjectFile=True):\n    try:\n        status = super(Reconstruction, self).loadGraph(filepath, setupProjectFile)\n        if Version(self._graph.fileReleaseVersion).major == '0':\n            self.warning.emit(Message('Automatic project upgrade', 'This project was created with an older version of Meshroom and has been automatically upgraded.\\nData might have been lost in the process.', 'Open it with the corresponding version of Meshroom to recover your data.'))\n        return status\n    except FileNotFoundError as e:\n        self.error.emit(Message('No Such File', \"Error While Loading '{}': No Such File.\".format(os.path.basename(filepath)), ''))\n        logging.error(\"Error while loading '{}': No Such File.\".format(os.path.basename(filepath)))\n        return False\n    except Exception as e:\n        import traceback\n        trace = traceback.format_exc()\n        self.error.emit(Message('Error While Loading Project File', \"An unexpected error has occurred while loading file: '{}'\".format(os.path.basename(filepath)), trace))\n        logging.error(trace)\n        return False\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function attempts to load a graph from a given filepath and set up the project file if needed. It returns a boolean result indicating whether the graph was successfully loaded. If the graph was created with an older version of Meshroom, a warning message is emitted. In the event of a FileNotFoundError or any other exception, an error message is emitted and False is returned."}
{"prompt": "def upgrade(self):\n    if not self.canUpgrade:\n        raise NodeUpgradeError(self.name, 'no matching node type')\n    commonInputs = []\n    for (attrName, value) in self._inputs.items():\n        if self.attributeDescFromName(self.nodeDesc.inputs, attrName, value, strict=False):\n            commonInputs.append(attrName)\n    node = Node(self.nodeType, position=self.position)\n    attrValues = {key: value for (key, value) in self.inputs.items()}\n    try:\n        upgradedAttrValues = node.nodeDesc.upgradeAttributeValues(attrValues, self.version)\n    except Exception as e:\n        logging.error('Error in the upgrade implementation of the node: {}.\\n{}'.format(self.name, str(e)))\n        upgradedAttrValues = attrValues\n    if not isinstance(upgradedAttrValues, dict):\n        logging.error('Error in the upgrade implementation of the node: {}. The return type is incorrect.'.format(self.name))\n        upgradedAttrValues = attrValues\n    upgradedAttrValuesTmp = {key: value for (key, value) in upgradedAttrValues.items() if key in commonInputs}\n    node.upgradeAttributeValues(upgradedAttrValues)\n    return node\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function upgrades an existing node. It takes a node object as an argument, checks if it can be upgraded, and then updates its attributes according to its node descriptor. It also catches any errors that may arise during the upgrade process and logs them."}
{"prompt": "@Slot()\n@Slot(str)\ndef new(self, pipeline=None):\n    p = pipeline if pipeline != None else self._defaultPipeline\n    ' Create a new pipeline. '\n    loweredPipelineTemplates = dict(((k.lower(), v) for (k, v) in meshroom.core.pipelineTemplates.items()))\n    if p.lower() in loweredPipelineTemplates:\n        self.load(loweredPipelineTemplates[p.lower()], setupProjectFile=False)\n    else:\n        self.load(p, setupProjectFile=False)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nCreate a new pipeline."}
{"prompt": "def requestBlockRestart(self):\n    self._blockRestart = True\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function sets the internal variable \"_blockRestart\" to True."}
{"prompt": "def __init__(self, iteration=0, blockSize=0, fullSize=0):\n    self.iteration = iteration\n    self.blockSize = blockSize\n    self.fullSize = fullSize\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function initializes the attributes of an object with the default values given. The attributes are iteration, blockSize, and fullSize, and they are all set to 0 by default."}
{"prompt": "@Property(type=QSizeF, notify=initialParamsChanged)\ndef imageSize(self):\n    if not self._initialIntrinsics:\n        return QSizeF(0, 0)\n    return QSizeF(self._initialIntrinsics.width.value, self._initialIntrinsics.height.value)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function returns a QSizeF object that contains the width and height of the initialIntrinsics object. If the initialIntrinsics object is not present, the QSizeF object will have a width and height of 0. A signal is emitted if the initialParamsChanged property is changed."}
{"prompt": "def redoImpl(self):\n    listAttribute = self.graph.attribute(self.listAttrName)\n    listAttribute.remove(self.index)\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nredoImpl(self) removes the element at self.index from the listAttribute attribute of self.graph and returns True."}
{"prompt": "def importImagesSync(self, images, cameraInit):\n    try:\n        self.buildIntrinsics(cameraInit, images)\n    except Exception as e:\n        self.importImagesFailed.emit(str(e))\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function attempts to build camera intrinsics from a list of images and cameraInit parameters. If an exception is encountered, the signal importImagesFailed is emitted with the exception message as a string."}
{"prompt": "def __iter__(self):\n    return self._objects.__iter__()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Returns an iterator over the objects contained in the collection.\"\"\""}
{"prompt": "@Slot(str)\ndef beginModification(self, name):\n    self._modificationCount += 1\n    self._undoStack.beginMacro(name)\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nBegin a modification operation, adding an operation to the undo stack with the given name."}
{"prompt": "def checkValueTypes(self):\n    if not isinstance(self.value, str) and (not callable(self.value)):\n        return self.name\n    return ''\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function checks whether the value stored in self.value is of type string or callable. If it is not, it returns the name stored in self.name, else it returns an empty string."}
{"prompt": "def test_transitive_reduction():\n    graph = Graph('Tests tasks depth')\n    tA = graph.addNewNode('Ls', input='/tmp')\n    tB = graph.addNewNode('AppendText', inputText='echo B')\n    tC = graph.addNewNode('AppendText', inputText='echo C')\n    tD = graph.addNewNode('AppendText', inputText='echo D')\n    tE = graph.addNewNode('AppendFiles')\n    graph.addEdges((tA.output, tE.input), (tA.output, tB.input), (tB.output, tC.input), (tB.output, tD.input), (tB.output, tE.input4), (tC.output, tE.input3), (tD.output, tE.input2))\n    edgesScore = graph.dfsMaxEdgeLength()\n    flowEdges = graph.flowEdges()\n    flowEdgesRes = [(tB, tA), (tD, tB), (tC, tB), (tE, tD), (tE, tC)]\n    assert set(flowEdgesRes) == set(flowEdges)\n    assert len(graph._nodesMinMaxDepths) == len(graph.nodes)\n    for (node, (minDepth, maxDepth)) in graph._nodesMinMaxDepths.items():\n        assert node.depth == maxDepth\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function performs a transitive reduction on a graph. It adds nodes and edges to the graph, computes the edges score, finds the flow edges and asserts that the flow edges are correct. It also asserts that the number of nodes and their minimum and maximum depths are correct."}
{"prompt": "@Slot(result=str)\ndef getText(self):\n    return self._clipboard.text()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nGet the text from the clipboard.\n\nReturns:\n    str: The text from the clipboard."}
{"prompt": "@Slot(str, result=str)\n@Slot(QUrl, result=str)\ndef extension(self, path):\n    return os.path.splitext(self.asStr(path))[-1]\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nReturns the extension of the given path as a string. Path can be either a string or a QUrl."}
{"prompt": "def _get_value(self):\n    if self.isLink:\n        return self.getLinkParam().value\n    return self._value\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nGet the value of the object. If it is a link, get the linked parameter's value; otherwise, get the object's value."}
{"prompt": "def addFiles(self, files):\n    for file in files:\n        self.addFile(file)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nAdd Files: Add a list of files to the current object.\n\nParameters:\nfiles (list): List of files to be added.\n\nReturns:\nNone\n\"\"\""}
{"prompt": "def updateDuplicates(self, nodesPerUid):\n    uid = self._uids.get(0)\n    if not nodesPerUid or not uid:\n        if len(self._duplicates) > 0:\n            self._duplicates.clear()\n            self._hasDuplicates = False\n            self.hasDuplicatesChanged.emit()\n        return\n    newList = [node for node in nodesPerUid.get(uid) if node != self]\n    if len(newList) == len(self._duplicates):\n        newListName = set([node.name for node in newList])\n        oldListName = set([node.name for node in self._duplicates.values()])\n        if newListName == oldListName:\n            return\n    self._duplicates.setObjectList(newList)\n    if bool(len(newList)) != self._hasDuplicates:\n        self._hasDuplicates = bool(len(newList))\n        self.hasDuplicatesChanged.emit()\n##############\nEND_FUNC\n##############\n", "completion": "\nThis function checks if a given list of nodes is a duplicate of the node it belongs to and updates the list accordingly. It also emits a signal if the list of duplicates has changed."}
{"prompt": "def _addEdge(self, src, dst):\n    with self.groupedGraphModification(\"Connect '{}'->'{}'\".format(src.getFullNameToNode(), dst.getFullNameToNode())):\n        if dst in self._graph.edges.keys():\n            self.removeEdge(self._graph.edge(dst))\n        self.push(commands.AddEdgeCommand(self._graph, src, dst))\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nAdd an edge to the graph.\n\nParameters:\n    src (Node): Source node to connect\n    dst (Node): Destination node to connect\n\nReturns:\n    None\n\"\"\""}
{"prompt": "def clearLocallySubmittedChunks(self):\n    for chunk in self._chunks:\n        if chunk.isAlreadySubmitted() and (not chunk.isExtern()):\n            chunk.upgradeStatusTo(Status.NONE, ExecMode.NONE)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function clears all locally submitted chunks, setting their status to NONE and exec mode to NONE."}
{"prompt": "@alive.setter\ndef alive(self, value):\n    if self._alive == value:\n        return\n    self._alive = value\n    self.aliveChanged.emit()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function sets the value for self._alive and emits a signal (aliveChanged) if the value has been changed."}
{"prompt": "@Slot(Qt3DCore.QTransform, QMatrix4x4, QMatrix4x4, QMatrix4x4, QVector3D)\ndef relativeLocalScale(self, transformQtInstance, initialPosMat, initialRotMat, initialScaleMat, scaleVec):\n    scaleMat = self.copyMatrix4x4(initialScaleMat)\n    scaleVecTuple = scaleVec.toTuple()\n    for i in range(3):\n        currentRow = list(scaleMat.row(i).toTuple())\n        value = currentRow[i] + scaleVecTuple[i]\n        value = value if value >= 0 else -value\n        currentRow[i] = value\n        scaleMat.setRow(i, QVector3D(currentRow[0], currentRow[1], currentRow[2]))\n    mat = initialPosMat * initialRotMat * scaleMat\n    transformQtInstance.setMatrix(mat)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function updates the scale of the given Qt3DCore.QTransform object using the given initial position matrix, initial rotation matrix, initial scale matrix, and scale vector."}
{"prompt": "def compareFilesTimes(self, times):\n    newRecords = dict(zip(self.chunks, times))\n    for (chunk, fileModTime) in newRecords.items():\n        if fileModTime != chunk.statusFileLastModTime:\n            chunk.updateStatusFromCache()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\ncompareFilesTimes() compares the modification times of the status files for the given chunks and updates them if they are different.\n\nInputs:\n- self: object instance\n- times: a list of modification times\n\nOutputs:\n- None"}
{"prompt": "def items(self):\n    return self._objectByKey.items()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturn a view object of the dictionary's key-value pairs."}
{"prompt": "def setDefaultPipeline(self, defaultPipeline):\n    self._defaultPipeline = defaultPipeline\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"Set the default pipeline for this class to the given parameter\""}
{"prompt": "def __init__(self, keyAttrName, **kwargs):\n    self._objects = {}\n    self._keyAttrName = keyAttrName\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__(self, keyAttrName, **kwargs)\n\nInitialize a new instance of the class.\n\nParameters:\n    keyAttrName (str): The name of the attribute on the objects used as a key.\n    **kwargs (dict): Additional keyword arguments.\n\nReturns:\n    None.\n\"\"\""}
{"prompt": "def getGlobalStatus(self):\n    chunksStatus = [chunk.status.status for chunk in self._chunks]\n    anyOf = (Status.ERROR, Status.STOPPED, Status.KILLED, Status.RUNNING, Status.SUBMITTED)\n    allOf = (Status.SUCCESS,)\n    for status in anyOf:\n        if any((s == status for s in chunksStatus)):\n            return status\n    for status in allOf:\n        if all((s == status for s in chunksStatus)):\n            return status\n    return Status.NONE\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturns the global status of the task, based on the statuses of its chunks. If any chunk has a status of Status.ERROR, Status.STOPPED, Status.KILLED, or Status.RUNNING, the global status is that status. If all chunks have a status of Status.SUCCESS, the global status is Status.SUCCESS. Otherwise, the global status is Status.NONE."}
{"prompt": "def getExportValue(self):\n    if self.isLink:\n        return self.getLinkParam().asLinkExpr()\n    return [attr.getExportValue() for attr in self._value]\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nReturn the export value of the object. If the object is a link, returns the link parameters as a link expression, otherwise returns a list of export values for each attribute in the object's value."}
{"prompt": "def finishEdge(edge, graph):\n    (u, v) = edge\n    for (i, n) in enumerate(reversed(nodesStack)):\n        index = i + 1\n        if index > edgesScore[n, v]:\n            edgesScore[n, v] = index\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function updates the score of an edge in a graph. It takes in an edge (u, v) and a graph, then updates the edgesScore dictionary with the index of the node in the reversed nodesStack."}
{"prompt": "def at(self, idx):\n    return self._value.at(idx)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Returns the element at the specified index of the underlying sequence of values.\"\"\""}
{"prompt": "def getCameraInitIndex(self):\n    if not self._cameraInit:\n        return -1\n    if not self._cameraInit.graph:\n        return -1\n    return self._cameraInits.indexOf(self._cameraInit)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function returns the index of the cameraInit in the cameraInits list. If cameraInit is not set, or the graph is not set, it will return -1."}
{"prompt": "def discoverVertex(vertex, graph):\n    self._nodesMinMaxDepths[vertex] = (0, 0)\n    self._computationBlocked[vertex] = False\n    if isinstance(vertex, CompatibilityNode):\n        compatNodes.append(vertex)\n        if not vertex.hasStatus(Status.SUCCESS):\n            self._computationBlocked[vertex] = True\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nDiscover a vertex in the graph.\n\nArgs:\n    vertex (object): The vertex to discover.\n    graph (object): The graph containing the vertex.\n\nReturns:\n    None\n\"\"\""}
{"prompt": "def undoImpl(self):\n    for name in self.nodeNames:\n        self.graph.removeNode(name)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function removes all nodes with the given names from the graph."}
{"prompt": "def finishVertex(vertex, graph):\n    chunksToProcess = []\n    for chunk in vertex.chunks:\n        if chunk.status.status is not Status.SUCCESS:\n            chunksToProcess.append(chunk)\n    if chunksToProcess:\n        nodes.append(vertex)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function checks the status of each chunk in a given vertex. Any chunks that have not yet been marked as successful will be added to the list \"chunksToProcess\". If there are any chunks in the list, the vertex will be appended to the nodes list.\n\"\"\""}
{"prompt": "@staticmethod\ndef attributeDescFromValue(attrName, value, isOutput):\n    params = {'name': attrName, 'label': attrName, 'description': 'Incompatible parameter', 'value': value, 'uid': (), 'group': 'incompatible'}\n    if isinstance(value, bool):\n        return desc.BoolParam(**params)\n    if isinstance(value, int):\n        return desc.IntParam(range=None, **params)\n    elif isinstance(value, float):\n        return desc.FloatParam(range=None, **params)\n    elif isinstance(value, str):\n        if isOutput or os.path.isabs(value) or Attribute.isLinkExpression(value):\n            return desc.File(**params)\n        else:\n            return desc.StringParam(**params)\n    elif isinstance(value, (list, dict)):\n        del params['value']\n        del params['uid']\n        attrDesc = None\n        if isinstance(value, list):\n            elt = value[0] if value else ''\n            eltDesc = CompatibilityNode.attributeDescFromValue('element', elt, isOutput)\n            attrDesc = desc.ListAttribute(elementDesc=eltDesc, **params)\n        elif isinstance(value, dict):\n            groupDesc = []\n            for (key, value) in value.items():\n                eltDesc = CompatibilityNode.attributeDescFromValue(key, value, isOutput)\n                groupDesc.append(eltDesc)\n            attrDesc = desc.GroupAttribute(groupDesc=groupDesc, **params)\n        attrDesc._value = value\n        return attrDesc\n    return desc.StringParam(**params)\n##############\nEND_FUNC\n##############\n", "completion": "\nThis staticmethod creates the correct attribute descriptor based on the parameter type (e.g. bool, int, float, str, list, dict). It takes an attribute name, a value, and a boolean indicating whether the attribute is an output. It returns the appropriate descriptor."}
{"prompt": "def __get__(self, instance, owner):\n    tmp = self._map.setdefault(self, weakref.WeakKeyDictionary())\n    signal = tmp.setdefault(instance, SignalFactory())\n    for name in self._names:\n        signal.register(name)\n    return signal\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function gets a Signal object associated with the given instance, and registers all the names in self._names with the Signal object. If a Signal object does not exist for the given instance, a new one is created."}
{"prompt": "def __init__(self, graph, parent=None):\n    super(GraphCommand, self).__init__(parent)\n    self.graph = graph\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__(self, graph, parent=None):\n    \"\"\"Initialize a GraphCommand object.\n\n    Arguments:\n        graph (Graph): An instance of Graph.\n        parent (QObject): The parent object of the GraphCommand.\n    \"\"\""}
{"prompt": "def __init__(self, node, attributeDesc, isOutput, root=None, parent=None):\n    super(GroupAttribute, self).__init__(node, attributeDesc, isOutput, root, parent)\n    self._value = DictModel(keyAttrName='name', parent=self)\n    subAttributes = []\n    for subAttrDesc in self.attributeDesc.groupDesc:\n        childAttr = attributeFactory(subAttrDesc, None, self.isOutput, self.node, self)\n        subAttributes.append(childAttr)\n        childAttr.valueChanged.connect(self.valueChanged)\n    self._value.reset(subAttributes)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"This function initializes a GroupAttribute instance, which is a special type of attribute used to group other attributes. It takes the node, attributeDescription, isOutput, root and parent parameters. It sets the value of the instance to a DictModel, and creates a list of child attributes based on the groupDesc in the attributeDescription. It also connects the valueChanged signal of each child attribute to the valueChanged signal of the instance.\"\"\""}
{"prompt": "def stopComputation(self):\n    for chunk in self._chunks.values():\n        if not chunk.isExtern():\n            chunk.stopProcess()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nstopComputation() stops the processes for all chunks in self._chunks that are not external."}
{"prompt": "@Slot(Qt3DCore.QEntity, Qt3DCore.QComponent)\ndef addComponent(self, entity, component):\n    entity.addComponent(component)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nAdd a component to an entity.\n\nArgs:\n    entity (Qt3DCore.QEntity): The entity to add the component to\n    component (Qt3DCore.QComponent): The component to be added to the entity"}
{"prompt": "@Slot(str, result=str)\n@Slot(QUrl, result=str)\ndef globFirst(self, path):\n    import glob\n    fileList = glob.glob(self.asStr(path))\n    fileList.sort()\n    if fileList:\n        return fileList[0]\n    return ''\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function takes a string or QUrl as an argument, and returns a sorted list of the first matched file as a string. If no files are found, it returns an empty string."}
{"prompt": "def removeFile(self, filename):\n    if filename in self._watchedFiles:\n        self._watchedFiles.remove(filename)\n    if self._watching:\n        self._fileWatcher.removePath(filename)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Remove a file from the list of watched files and from the file watcher.\n\nParameters\n----------\nfilename : str\n    The file to be removed from the list of watched files.\n\n\"\"\""}
{"prompt": "def _applyExpr(self):\n    v = self._value\n    g = self.node.graph\n    if not g:\n        return\n    if isinstance(v, Attribute):\n        g.addEdge(v, self)\n        self.resetValue()\n    elif self.isInput and Attribute.isLinkExpression(v):\n        link = v[1:-1]\n        (linkNode, linkAttr) = link.split('.')\n        try:\n            g.addEdge(g.node(linkNode).attribute(linkAttr), self)\n        except KeyError as err:\n            logging.warning('Connect Attribute from Expression failed.\\nExpression: \"{exp}\"\\nError: \"{err}\".'.format(exp=v, err=err))\n        self.resetValue()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n_applyExpr(self):\n    \"\"\"Applies an expression to the given attribute. \n    If the attribute is an instance of Attribute, it adds an edge in the graph. \n    If the attribute is an input and is a link expression, it splits the expression and tries to add an edge in the graph. \n    If unsuccessful, it logs a warning. \n    Finally, it resets the value. \n    \"\"\""}
{"prompt": "@Slot(QVector4D, Qt3DRender.QCamera, QSize, result=QVector2D)\ndef pointFromWorldToScreen(self, point, camera, windowSize):\n    viewMatrix = camera.transform().matrix().inverted()\n    projectedPoint = (camera.projectionMatrix() * viewMatrix[0]).map(point)\n    projectedPoint2D = QVector2D(projectedPoint.x() / projectedPoint.w(), projectedPoint.y() / projectedPoint.w())\n    screenPoint2D = QVector2D(int((projectedPoint2D.x() + 1) * windowSize.width() / 2), int((projectedPoint2D.y() - 1) * windowSize.height() / -2))\n    return screenPoint2D\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function takes in a 4D vector point, a Qt3DRender QCamera object, and a QSize object representing the window size and returns a 2D vector representing the corresponding point on the screen."}
{"prompt": "@Slot(QObject)\ndef setActiveNode(self, node):\n    for (category, nodeTypes) in self.activeNodeCategories.items():\n        if node.nodeType in nodeTypes:\n            self.activeNodes.get(category).node = node\n            if category == 'sfm':\n                self.setSfm(node)\n            if node.nodeType == 'CameraInit':\n                self.setCameraInitIndex(self._cameraInits.indexOf(node))\n    self.activeNodes.get(node.nodeType).node = node\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function sets the active node for the given category or node type. If the node is a 'CameraInit' node, the appropriate index is set in the cameraInits list. If the node is of type 'sfm', the setSfm() function is called."}
{"prompt": "def test_listModel_add_remove():\n    m = QObjectListModel(keyAttrName='name')\n    node = DummyNode('DummyNode_1')\n    m.add(node)\n    assert len(m) == 1\n    assert m.get('DummyNode_1') == node\n    m.remove(node)\n    assert len(m) == 0\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function tests the QObjectListModel class by adding and removing a DummyNode object from the model. It asserts that the size of the model is as expected after each operation, and that the added node is returned when queried."}
{"prompt": "def getValueStr(self):\n    if isinstance(self.value, ListModel):\n        return self.attributeDesc.joinChar.join([v.getValueStr() for v in self.value])\n    return super(ListAttribute, self).getValueStr()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Return a string representation of the value of the ListAttribute, either as a comma-separated list of the strings returned by each value's getValueStr() method, or as the result of the superclass's getValueStr() method if the value is not a ListModel.\"\"\""}
{"prompt": "def parse_args(self):\n    module_name = self.arguments[self.arguments.index(':module:') + 1]\n    class_name = self.arguments[self.arguments.index(':class:') + 1]\n    return (module_name, class_name)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nParse arguments from the command line and return a tuple of (module_name, class_name). \n\"\"\""}
{"prompt": "def __init__(self, viewpointAttribute, reconstruction):\n    super(ViewpointWrapper, self).__init__(parent=reconstruction)\n    self._viewpoint = viewpointAttribute\n    self._reconstruction = reconstruction\n    self._initialIntrinsics = None\n    self._T = None\n    self._R = None\n    self._solvedIntrinsics = {}\n    self._reconstructed = False\n    self._undistortedImagePath = ''\n    self._activeNode_PrepareDenseScene = self._reconstruction.activeNodes.get('PrepareDenseScene')\n    self._updateInitialParams()\n    self._updateSfMParams()\n    self._updateDenseSceneParams()\n    self._reconstruction.cameraInitChanged.connect(self._updateInitialParams)\n    self._reconstruction.sfmReportChanged.connect(self._updateSfMParams)\n    self._activeNode_PrepareDenseScene.nodeChanged.connect(self._updateDenseSceneParams)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis is the constructor for the ViewpointWrapper class. It sets up the viewpoint attribute and reconstruction, initializes the initial and solved intrinsics, sets up the transformation matrices, sets up the reconstructed variable, creates the undistorted image path, and sets up the active nodes. It also connects the cameraInitChanged, sfmReportChanged, and nodeChanged signals. \n\"\"\""}
{"prompt": "def uid(self, uidIndex):\n    uids = []\n    for (k, v) in self._value.items():\n        if v.enabled and uidIndex in v.desc.uid:\n            uids.append(v.uid(uidIndex))\n    return hashValue(uids)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function returns a hash value of the uids associated with the given uidIndex. It iterates through each item in the self._value dictionary, appending the uid associated with the given uidIndex to a list if the item is enabled and its desc contains the given uidIndex. The list is then passed to a hashValue function to generate the hash value."}
{"prompt": "@Slot(QVector3D, QVector3D, result=QQuaternion)\ndef rotationBetweenAandB(self, A, B):\n    A = A / A.length()\n    B = B / B.length()\n    v = QVector3D.crossProduct(A, B)\n    s = v.length()\n    c = QVector3D.dotProduct(A, B)\n    return QQuaternion.fromAxisAndAngle(v / s, atan2(s, c) * 180 / pi)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nCalculate and return the rotation between two 3D vectors A and B, as a QQuaternion.\n\"\"\""}
{"prompt": "def upgradeNode(self, nodeName):\n    node = self.node(nodeName)\n    if not isinstance(node, CompatibilityNode):\n        raise ValueError('Upgrade is only available on CompatibilityNode instances.')\n    upgradedNode = node.upgrade()\n    with GraphModification(self):\n        (inEdges, outEdges) = self.removeNode(nodeName)\n        self.addNode(upgradedNode, nodeName)\n        for (dst, src) in outEdges.items():\n            try:\n                self.addEdge(self.attribute(src), self.attribute(dst))\n            except (KeyError, ValueError) as e:\n                logging.warning('Failed to restore edge {} -> {}: {}'.format(src, dst, str(e)))\n    return (upgradedNode, inEdges, outEdges)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nupgradeNode(self, nodeName)\n\n\"\"\"\nUpgrades a given CompatibilityNode instance and restores any edges connected to it. \n\nParameters: \nself (Graph): The Graph object to modify.\nnodeName (str): The name of the node to upgrade.\n\nRaises:\nValueError: If the node is not a CompatibilityNode instance.\n\nReturns:\nupgradedNode (CompatibilityNode): The upgraded node.\ninEdges (dict): A dictionary of edges that were connected to the upgraded node.\noutEdges (dict): A dictionary of edges that were connected to the upgraded node.\n\"\"\""}
{"prompt": "def upgradeValue(self, exportedValue):\n    self._set_value(exportedValue)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Upgrades the value of the given object to the exported value\"\"\""}
{"prompt": "def initialize(self, node, inputs, recursiveInputs):\n    pass\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"This function initializes a node with the given inputs and recursive inputs\"\"\""}
{"prompt": "@cacheDir.setter\ndef cacheDir(self, value):\n    if self._cacheDir == value:\n        return\n    self._cacheDir = value.replace(os.path.sep, '/')\n    self.updateInternals(force=True)\n    self.updateStatusFromCache(force=True)\n    self.cacheDirChanged.emit()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function sets the cache directory and updates the internal values, status from the cache, and emits a signal when the cache directory has changed."}
{"prompt": "def isFinishedOrRunning(self):\n    return self._status.status in (Status.SUCCESS, Status.RUNNING)\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nReturn whether the status of the object is either 'SUCCESS' or 'RUNNING'."}
{"prompt": "def getEnabled(self):\n    if isinstance(self.desc.enabled, types.FunctionType):\n        try:\n            return self.desc.enabled(self.node)\n        except:\n            return True\n    return self.attributeDesc.enabled\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function checks if a node is enabled. It first checks if the \"enabled\" attribute of the node is a function type. If so, it will try to execute the function and return the result. If not, it will return the enabled attribute of the node."}
{"prompt": "def load(self, sourceFile):\n    self._sourceFile = sourceFile\n    super(QmlInstantEngine, self).load(sourceFile)\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nLoad a QML file from the given source file.\n\nParameters:\n    sourceFile (str): The path to the QML file to be loaded.\n\nReturns:\n    None"}
{"prompt": "def _systemInfo(self):\n    import platform\n    import sys\n    return {'platform': '{} {}'.format(platform.system(), platform.release()), 'python': 'Python {}'.format(sys.version.split(' ')[0])}\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nThis function returns a dictionary with the platform and Python version information. \nIt uses the 'platform' and 'sys' modules to gather the data."}
{"prompt": "def buildCommandLine(self, chunk):\n    cmdPrefix = ''\n    if 'REZ_ENV' in os.environ and chunk.node.packageVersion:\n        alreadyInEnv = os.environ.get('REZ_{}_VERSION'.format(chunk.node.packageName.upper()), '').startswith(chunk.node.packageVersion)\n        if not alreadyInEnv:\n            cmdPrefix = '{rez} {packageFullName} -- '.format(rez=os.environ.get('REZ_ENV'), packageFullName=chunk.node.packageFullName)\n    cmdSuffix = ''\n    if chunk.node.isParallelized and chunk.node.size > 1:\n        cmdSuffix = ' ' + self.commandLineRange.format(**chunk.range.toDict())\n    return cmdPrefix + chunk.node.nodeDesc.commandLine.format(**chunk.node._cmdVars) + cmdSuffix\n##############\nEND_FUNC\n##############\n", "completion": "\n\nbuildCommandLine(self, chunk) -> str:\n    \"\"\"Build the command line for a given chunk of work.\n\n    This function builds the command line for the given chunk, taking into account any environment\n    setup and parallelization.\n\n    Args:\n        self (object): Instance of the class in which this function is defined.\n        chunk (object): Chunk of work to build the command line for.\n\n    Returns:\n        str: The command line for the given chunk.\n    \"\"\""}
{"prompt": "@staticmethod\ndef attributeDescFromName(refAttributes, name, value, strict=True):\n    attrDesc = next((d for d in refAttributes if d.name == name), None)\n    if attrDesc is None:\n        return None\n    if Attribute.isLinkExpression(value):\n        return attrDesc\n    if attrDesc.matchDescription(value, strict):\n        return attrDesc\n    return None\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturn Attribute description from name, value, and strict flag. Returns None if the name is not found in the reference attributes, if the value is a link expression, or if the value does not match the description in the attribute description."}
{"prompt": "def remove(self, obj):\n    self._objects.remove(obj)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nRemove an object from the list of objects stored by this instance."}
{"prompt": "def configureLogger(self):\n    for handler in self.logger.handlers[:]:\n        self.logger.removeHandler(handler)\n    handler = logging.FileHandler(self.chunk.logFile)\n    formatter = self.Formatter('[%(asctime)s.%(msecs)03d][%(levelname)s] %(message)s', self.dateTimeFormatting)\n    handler.setFormatter(formatter)\n    self.logger.addHandler(handler)\n##############\nEND_FUNC\n##############\n", "completion": "\n\nConfigures the logger by removing existing handlers and adding a new FileHandler with the specified formatter."}
{"prompt": "def moduleVersion(moduleName, default=None):\n    return getattr(sys.modules[moduleName], '__version__', default)\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nRetrieve the __version__ attribute of a given module.\n\nParameters:\nmoduleName (str): The name of the module.\ndefault (optional): The default value to use if the module doesn't have a __version__ attribute. Defaults to None.\n\nReturns:\nThe __version__ attribute of the module, or the default value if it doesn't exist."}
{"prompt": "def start(self, level):\n    open(self.chunk.logFile, 'w').close()\n    self.configureLogger()\n    self.logger.setLevel(self.textToLevel(level))\n    self.progressBar = False\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function clears the log file, configures the logger and sets the log level based on the input level."}
{"prompt": "def submit(self, nodes, edges, filepath, submitLabel='{projectName}'):\n    raise NotImplementedError(\"'submit' method must be implemented in subclasses\")\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function is intended to be implemented in subclasses, and will be used to submit a graph consisting of nodes and edges to a filepath with a given submitLabel. It raises a NotImplementedError if it is not implemented in the subclass."}
{"prompt": "def dfsVisit(self, u, visitor, colors, nodeChildren, longestPathFirst):\n    try:\n        self._dfsVisit(u, visitor, colors, nodeChildren, longestPathFirst)\n    except StopBranchVisit:\n        pass\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function is a helper for a depth-first search which traverses a graph and calls a visitor function for each node. It takes in the node (u), visitor function, colors dictionary, nodeChildren dictionary, and boolean longestPathFirst as parameters. The function will call the private _dfsVisit function, and catch any StopBranchVisit exceptions."}
{"prompt": "def getFullNameToNode(self):\n    return '{}.{}'.format(self.node.name, self.getFullName())\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturns a string composed of the node name and the object's full name, separated by a period."}
{"prompt": "def computeSize(self, node):\n    size = 0\n    for param in self._params:\n        param = node.attribute(param)\n        if param.isLink:\n            size += param.getLinkParam().node.size\n        elif isinstance(param.desc, ListAttribute):\n            size += len(param)\n        else:\n            size += 1\n    return size\n##############\nEND_FUNC\n##############\n", "completion": "\n\nCompute the size of a node based on a set of parameters. 'self._params' is a list of parameters to use for computing the size, 'node' is the node whose size is being computed. Returns the size of the node."}
{"prompt": "def matchDescription(self, value, strict=True):\n    if not super(ListAttribute, self).matchDescription(value, strict):\n        return False\n    if value:\n        return self._elementDesc.matchDescription(value[0], strict)\n    return True\n##############\nEND_FUNC\n##############\n", "completion": "\n\nCheck if an element description matches the attribute description.\n\nParameters:\n- self (ListAttribute): The ListAttribute instance.\n- value (list): The list of elements.\n- strict (bool, optional): Whether to perform a strict match or not. Defaults to True.\n\nReturns:\nTrue if the element description matches the attribute description, False otherwise."}
{"prompt": "@Slot(Qt3DCore.QEntity, str, result='QVariantList')\ndef findChildrenByProperty(self, entity, propertyName):\n    children = []\n    for child in entity.childNodes():\n        try:\n            if child.metaObject().indexOfProperty(propertyName) != -1:\n                children.append(child)\n        except RuntimeError:\n            continue\n        children += self.findChildrenByProperty(child, propertyName)\n    return children\n##############\nEND_FUNC\n##############\n", "completion": "\n\nFinds all the children of a given entity with the given property name and returns a list of QVariants containing the children that match."}
{"prompt": "def append(self, obj):\n    self._objects.append(obj)\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nAppend an object to the end of the list stored in the _objects attribute of the object."}
{"prompt": "def getRanges(self, node):\n    (blockSize, fullSize, nbBlocks) = self.getSizes(node)\n    ranges = []\n    for i in range(nbBlocks):\n        ranges.append(Range(iteration=i, blockSize=blockSize, fullSize=fullSize))\n    return ranges\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function takes a node as an argument and returns a list of Range objects for each iteration. The Range objects contain the iteration number, block size, and full size of the node."}
{"prompt": "def setter(instance, value):\n    currentValue = getattr(instance, attributeName)\n    if currentValue == value:\n        return\n    resetCallbackName = '__reset__' + attributeName\n    if resetOnDestroy and (not hasattr(instance, resetCallbackName)):\n        setattr(instance, resetCallbackName, lambda self=instance, *args: setter(self, None))\n    resetCallback = getattr(instance, resetCallbackName, None)\n    if resetCallback and currentValue and shiboken2.isValid(currentValue):\n        currentValue.destroyed.disconnect(resetCallback)\n    setattr(instance, attributeName, value)\n    if resetCallback and value:\n        value.destroyed.connect(resetCallback)\n    getattr(instance, signalName(notify)).emit()\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function sets an attribute of an instance to a specified value, and emits a signal when it has been set. If the resetOnDestroy argument is set to True, a reset callback will be set on the instance to reset the attribute to None when the value is destroyed."}
{"prompt": "def values(self):\n    return self._objects\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function returns a list of objects stored in the `self._objects` attribute."}
{"prompt": "def __init__(self, sourceFile='', watching=True, verbose=False, parent=None):\n    super(QmlInstantEngine, self).__init__(parent)\n    self._fileWatcher = QFileSystemWatcher()\n    self._sourceFile = ''\n    self._watchedFiles = []\n    self._verbose = verbose\n    self._watching = False\n    self._extensions = ['qml', 'js']\n    self._rootItem = None\n\n    def onObjectCreated(root, url):\n        if not root:\n            return\n        if self._rootItem:\n            root.setGeometry(self._rootItem.geometry())\n            self._rootItem.deleteLater()\n        self._rootItem = root\n    self.objectCreated.connect(onObjectCreated)\n    self.setWatching(watching)\n    if sourceFile:\n        self.load(sourceFile)\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\n__init__(self, sourceFile='', watching=True, verbose=False, parent=None) initializes a QmlInstantEngine object with the given parameters. It also sets up a QFileSystemWatcher object and connects it to the objectCreated signal. If a source file is given, it is loaded. \n\"\"\""}
{"prompt": "def setReference(self, iterable):\n    self._reference = iterable\n    self.sort()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nSets the reference for the object to the given iterable and sorts it.\n\"\"\""}
{"prompt": "def checkCompatibilityNodes(self, graph, nodes, context):\n    compatNodes = []\n    for node in nodes:\n        if node in graph._compatibilityNodes.values():\n            compatNodes.append(node.nameToLabel(node.name))\n    if compatNodes:\n        raise RuntimeError('[{}] Compatibility Issue:\\nCannot compute because of these incompatible nodes:\\n{}'.format(context, sorted(compatNodes)))\n##############\nEND_FUNC\n##############\n", "completion": "\n\nCheck for nodes in a graph that are incompatible with a given context and raise a RuntimeError if any are found. \n\nParameters: \n    graph (Graph): The graph to check for incompatible nodes\n    nodes (list): A list of the nodes to check for compatibility \n    context (str): The context to check the nodes against"}
{"prompt": "def outputImagesValueFunct(attr):\n    basename = os.path.basename(attr.node.input.value)\n    fileStem = os.path.splitext(basename)[0]\n    inputExt = os.path.splitext(basename)[1]\n    outputExt = '.' + attr.node.extension.value if attr.node.extension.value else None\n    if inputExt in ['.abc', '.sfm']:\n        return desc.Node.internalFolder + '<VIEW_ID>' + (outputExt or '.*')\n    if inputExt:\n        return desc.Node.internalFolder + fileStem + (outputExt or inputExt)\n    if '*' in fileStem:\n        return desc.Node.internalFolder + fileStem + (outputExt or '.*')\n    return desc.Node.internalFolder + '*' + (outputExt or '.*')\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function takes an attribute as an argument and returns a string representing the output images value. The value includes the internal folder location, the file stem, and either the input extension or output extension (if specified)."}
{"prompt": "def _referenceItem(self, item):\n    if not item.parent():\n        item.setParent(self)\n    if not self._keyAttrName:\n        return\n    key = getattr(item, self._keyAttrName, None)\n    if key is None:\n        return\n    if key in self._objectByKey:\n        raise ValueError('Object key {}:{} is not unique'.format(self._keyAttrName, key))\n    self._objectByKey[key] = item\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function is used to reference an item to its parent object and check if the assigned key attribute is unique. If not, a ValueError is raised."}
{"prompt": "def data(self, index, role):\n    obj = super(QTypedObjectListModel, self).data(index, self.ObjectRole)\n    if role == self.ObjectRole:\n        return obj\n    if obj:\n        return obj.property(self.roles[role])\n    return None\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nReturns the object or property of the object stored at the given index in the model, based on the given role."}
{"prompt": "@property\ndef statisticsFile(self):\n    if self.range.blockSize == 0:\n        return os.path.join(self.node.graph.cacheDir, self.node.internalFolder, 'statistics')\n    else:\n        return os.path.join(self.node.graph.cacheDir, self.node.internalFolder, str(self.index) + '.statistics')\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturn the path to the statistics file for this index of the range of this node."}
{"prompt": "def importImagesAsync(self, images, cameraInit):\n    logging.debug('Import images: ' + str(images))\n    self.runAsync(self.importImagesSync, args=(images, cameraInit))\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function imports images asynchronously. It takes in 'images', which is a list of image paths, and 'cameraInit', which is a boolean indicating whether the camera should be initialized. It logs the 'images' variable and runs a synchronous function (importImagesSync) with 'images' and 'cameraInit' as arguments."}
{"prompt": "@Slot()\ndef onImportImagesFailed(self, msg):\n    self.error.emit(Message('Failed to Import Images', 'You probably have a corrupted image within the images that you are trying to import.', ''))\n##############\nEND_FUNC\n##############\n", "completion": "\n\nThis function emits an error message when the import of images fails. It emits a Message object with information about the failure."}
{"prompt": "@Slot(QObject, result=bool)\ndef hasValidIntrinsic(self, viewpoint):\n    allIntrinsicIds = [i.intrinsicId.value for i in self._cameraInit.intrinsics.value]\n    return viewpoint.intrinsicId.value in allIntrinsicIds\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"Check if the given viewpoint has a valid intrinsic.\n\nArgs:\n    viewpoint (QObject): The viewpoint to check.\n\nReturns:\n    bool: True if the viewpoint has a valid intrinsic, False otherwise.\n\"\"\""}
{"prompt": "def alreadySubmittedChunks(self):\n    return [ch for ch in self._chunks if ch.isAlreadySubmitted()]\n##############\nEND_FUNC\n##############\n", "completion": "\n\nReturn a list of chunks that have already been submitted to the server."}
{"prompt": "def __init__(self, params):\n    assert isinstance(params, (list, tuple))\n    self._params = params\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\n__init__(self, params):\n    \"\"\"Constructor for the class. \n\n    Args:\n        params (list or tuple): The parameters to be used for the class.\n    \"\"\""}
{"prompt": "def parseNumericList(numericListString):\n    nList = []\n    for item in numericListString.split(','):\n        if '-' in item:\n            (start, end) = item.split('-')\n            start = int(start)\n            end = int(end)\n            nList.extend(range(start, end + 1))\n        else:\n            value = int(item)\n            nList.append(value)\n    return nList\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nparseNumericList(numericListString) takes a string of numeric values separated by commas and returns a list of integers. If a range is specified with a dash, a range of all values between the start and end of the range will be included in the list. \n\nExample:\nparseNumericList(\"1,2,3-5\") returns [1, 2, 3, 4, 5]"}
{"prompt": "@Slot(Attribute)\ndef removeAttribute(self, attribute):\n    self.push(commands.ListAttributeRemoveCommand(self._graph, attribute))\n##############\nEND_FUNC\n##############\n", "completion": "\n\"\"\"\nRemove an attribute from the graph.\n\nParameters:\n    attribute (Attribute): The attribute to be removed.\n\nReturns:\n    None\n\"\"\""}
{"prompt": "def processChunk(self, chunk):\n    try:\n        chunk.logManager.start(chunk.node.verboseLevel.value)\n        if not chunk.node.inputFiles:\n            chunk.logger.warning('Nothing to publish')\n            return\n        if not chunk.node.output.value:\n            return\n        outFiles = self.resolvedPaths(chunk.node.inputFiles.value, chunk.node.output.value)\n        if not outFiles:\n            error = 'Publish: input files listed, but nothing to publish'\n            chunk.logger.error(error)\n            chunk.logger.info('Listed input files: {}'.format([i.value for i in chunk.node.inputFiles.value]))\n            raise RuntimeError(error)\n        if not os.path.exists(chunk.node.output.value):\n            os.mkdir(chunk.node.output.value)\n        for (iFile, oFile) in outFiles.items():\n            chunk.logger.info('Publish file {} into {}'.format(iFile, oFile))\n            shutil.copyfile(iFile, oFile)\n        chunk.logger.info('Publish end')\n    finally:\n        chunk.logManager.end()\n##############\nEND_FUNC\n##############\n", "completion": "\n\n\"\"\"\nprocessChunk(self, chunk):\n    '''Copies files from the input file list to the output path. \n    Raises a RuntimeError if there are no files to publish.\n    Logs the start and end of the publish process.\n    '''"}
