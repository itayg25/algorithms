[
  "def has_path_sum(root, sum):\n    if root is None:\n        return False\n    if root.left is None and root.right is None and (root.val == sum):\n        return True\n    sum -= root.val\n    return has_path_sum(root.left, sum) or has_path_sum(root.right, sum)",
  "def has_path_sum2(root, sum):\n    if root is None:\n        return False\n    stack = [(root, root.val)]\n    while stack:\n        (node, val) = stack.pop()\n        if node.left is None and node.right is None:\n            if val == sum:\n                return True\n        if node.left is not None:\n            stack.append((node.left, val + node.left.val))\n        if node.right is not None:\n            stack.append((node.right, val + node.right.val))\n    return False",
  "def has_path_sum3(root, sum):\n    if root is None:\n        return False\n    queue = [(root, sum - root.val)]\n    while queue:\n        (node, val) = queue.pop(0)\n        if node.left is None and node.right is None:\n            if val == 0:\n                return True\n        if node.left is not None:\n            queue.append((node.left, val - node.left.val))\n        if node.right is not None:\n            queue.append((node.right, val - node.right.val))\n    return False",
  "def max_path_sum(root):\n    maximum = float('-inf')\n    helper(root, maximum)\n    return maximum",
  "def helper(root, maximum):\n    if root is None:\n        return 0\n    left = helper(root.left, maximum)\n    right = helper(root.right, maximum)\n    maximum = max(maximum, left + right + root.val)\n    return root.val + maximum",
  "def is_same_tree(tree_p, tree_q):\n    if tree_p is None and tree_q is None:\n        return True\n    if tree_p is not None and tree_q is not None and (tree_p.val == tree_q.val):\n        return is_same_tree(tree_p.left, tree_q.left) and is_same_tree(tree_p.right, tree_q.right)\n    return False",
  "def __init__(self, val=0):\n    self.val = val\n    self.left = None\n    self.right = None",
  "def reverse(root):\n    if root is None:\n        return\n    (root.left, root.right) = (root.right, root.left)\n    if root.left:\n        reverse(root.left)\n    if root.right:\n        reverse(root.right)",
  "def is_balanced(root):\n    return __is_balanced_recursive(root)",
  "def __is_balanced_recursive(root):\n    return -1 != __get_depth(root)",
  "def __get_depth(root):\n    if root is None:\n        return 0\n    left = __get_depth(root.left)\n    right = __get_depth(root.right)\n    if abs(left - right) > 1 or -1 in [left, right]:\n        return -1\n    return 1 + max(left, right)",
  "def binary_tree_paths(root):\n    res = []\n    if root is None:\n        return res\n    dfs(res, root, str(root.val))\n    return res",
  "def dfs(res, root, cur):\n    if root.left is None and root.right is None:\n        res.append(cur)\n    if root.left:\n        dfs(res, root.left, cur + '->' + str(root.left.val))\n    if root.right:\n        dfs(res, root.right, cur + '->' + str(root.right.val))",
  "def tree_print(tree):\n    for key in tree:\n        print(key, end=' ')\n        tree_element = tree[key]\n        for subElem in tree_element:\n            print(' -> ', subElem, end=' ')\n            if type(subElem) != str:\n                print('\\n ')\n        print()",
  "def __init__(self):\n    self.keys = []\n    self.children = []",
  "def __repr__(self):\n    return '<id_node: {0}>'.format(self.keys)",
  "@property\ndef is_leaf(self):\n    return len(self.children) == 0",
  "def __init__(self, t_val=2):\n    self.min_numbers_of_keys = t_val - 1\n    self.max_number_of_keys = 2 * t_val - 1\n    self.root = Node()",
  "def _split_child(self, parent: Node, child_index: int):\n    new_right_child = Node()\n    half_max = self.max_number_of_keys // 2\n    child = parent.children[child_index]\n    middle_key = child.keys[half_max]\n    new_right_child.keys = child.keys[half_max + 1:]\n    child.keys = child.keys[:half_max]\n    if not child.is_leaf:\n        new_right_child.children = child.children[half_max + 1:]\n        child.children = child.children[:half_max + 1]\n    parent.keys.insert(child_index, middle_key)\n    parent.children.insert(child_index + 1, new_right_child)",
  "def insert_key(self, key):\n    if len(self.root.keys) >= self.max_number_of_keys:\n        new_root = Node()\n        new_root.children.append(self.root)\n        self.root = new_root\n        self._split_child(new_root, 0)\n        self._insert_to_nonfull_node(self.root, key)\n    else:\n        self._insert_to_nonfull_node(self.root, key)",
  "def _insert_to_nonfull_node(self, node: Node, key):\n    i = len(node.keys) - 1\n    while i >= 0 and node.keys[i] >= key:\n        i -= 1\n    if node.is_leaf:\n        node.keys.insert(i + 1, key)\n    else:\n        if len(node.children[i + 1].keys) >= self.max_number_of_keys:\n            self._split_child(node, i + 1)\n            if node.keys[i + 1] < key:\n                i += 1\n        self._insert_to_nonfull_node(node.children[i + 1], key)",
  "def find(self, key) -> bool:\n    current_node = self.root\n    while True:\n        i = len(current_node.keys) - 1\n        while i >= 0 and current_node.keys[i] > key:\n            i -= 1\n        if i >= 0 and current_node.keys[i] == key:\n            return True\n        if current_node.is_leaf:\n            return False\n        current_node = current_node.children[i + 1]",
  "def remove_key(self, key):\n    self._remove_key(self.root, key)",
  "def _remove_key(self, node: Node, key) -> bool:\n    try:\n        key_index = node.keys.index(key)\n        if node.is_leaf:\n            node.keys.remove(key)\n        else:\n            self._remove_from_nonleaf_node(node, key_index)\n        return True\n    except ValueError:\n        if node.is_leaf:\n            print('Key not found.')\n            return False\n        else:\n            i = 0\n            number_of_keys = len(node.keys)\n            while i < number_of_keys and key > node.keys[i]:\n                i += 1\n            action_performed = self._repair_tree(node, i)\n            if action_performed:\n                return self._remove_key(node, key)\n            else:\n                return self._remove_key(node.children[i], key)",
  "def _repair_tree(self, node: Node, child_index: int) -> bool:\n    child = node.children[child_index]\n    if self.min_numbers_of_keys < len(child.keys) <= self.max_number_of_keys:\n        return False\n    if child_index > 0 and len(node.children[child_index - 1].keys) > self.min_numbers_of_keys:\n        self._rotate_right(node, child_index)\n        return True\n    if child_index < len(node.children) - 1 and len(node.children[child_index + 1].keys) > self.min_numbers_of_keys:\n        self._rotate_left(node, child_index)\n        return True\n    if child_index > 0:\n        self._merge(node, child_index - 1, child_index)\n    else:\n        self._merge(node, child_index, child_index + 1)\n    return True",
  "def _rotate_left(self, parent_node: Node, child_index: int):\n    new_child_key = parent_node.keys[child_index]\n    new_parent_key = parent_node.children[child_index + 1].keys.pop(0)\n    parent_node.children[child_index].keys.append(new_child_key)\n    parent_node.keys[child_index] = new_parent_key\n    if not parent_node.children[child_index + 1].is_leaf:\n        ownerless_child = parent_node.children[child_index + 1].children.pop(0)\n        parent_node.children[child_index].children.append(ownerless_child)",
  "def _rotate_right(self, parent_node: Node, child_index: int):\n    parent_key = parent_node.keys[child_index - 1]\n    new_parent_key = parent_node.children[child_index - 1].keys.pop()\n    parent_node.children[child_index].keys.insert(0, parent_key)\n    parent_node.keys[child_index - 1] = new_parent_key\n    if not parent_node.children[child_index - 1].is_leaf:\n        ownerless_child = parent_node.children[child_index - 1].children.pop()\n        parent_node.children[child_index].children.insert(0, ownerless_child)",
  "def _merge(self, parent_node: Node, to_merge_index: int, transfered_child_index: int):\n    from_merge_node = parent_node.children.pop(transfered_child_index)\n    parent_key_to_merge = parent_node.keys.pop(to_merge_index)\n    to_merge_node = parent_node.children[to_merge_index]\n    to_merge_node.keys.append(parent_key_to_merge)\n    to_merge_node.keys.extend(from_merge_node.keys)\n    if not to_merge_node.is_leaf:\n        to_merge_node.children.extend(from_merge_node.children)\n    if parent_node == self.root and (not parent_node.keys):\n        self.root = to_merge_node",
  "def _remove_from_nonleaf_node(self, node: Node, key_index: int):\n    key = node.keys[key_index]\n    left_subtree = node.children[key_index]\n    if len(left_subtree.keys) > self.min_numbers_of_keys:\n        largest_key = self._find_largest_and_delete_in_left_subtree(left_subtree)\n    elif len(node.children[key_index + 1].keys) > self.min_numbers_of_keys:\n        largest_key = self._find_largest_and_delete_in_right_subtree(node.children[key_index + 1])\n    else:\n        self._merge(node, key_index, key_index + 1)\n        return self._remove_key(node, key)\n    node.keys[key_index] = largest_key",
  "def _find_largest_and_delete_in_left_subtree(self, node: Node):\n    if node.is_leaf:\n        return node.keys.pop()\n    else:\n        ch_index = len(node.children) - 1\n        self._repair_tree(node, ch_index)\n        largest_key_in_subtree = self._find_largest_and_delete_in_left_subtree(node.children[len(node.children) - 1])\n        return largest_key_in_subtree",
  "def _find_largest_and_delete_in_right_subtree(self, node: Node):\n    if node.is_leaf:\n        return node.keys.pop(0)\n    else:\n        ch_index = 0\n        self._repair_tree(node, ch_index)\n        largest_key_in_subtree = self._find_largest_and_delete_in_right_subtree(node.children[0])\n        return largest_key_in_subtree",
  "def traverse_tree(self):\n    self._traverse_tree(self.root)\n    print()",
  "def _traverse_tree(self, node: Node):\n    if node.is_leaf:\n        print(node.keys, end=' ')\n    else:\n        for (i, key) in enumerate(node.keys):\n            self._traverse_tree(node.children[i])\n            print(key, end=' ')\n        self._traverse_tree(node.children[-1])",
  "def is_symmetric(root):\n    if root is None:\n        return True\n    return helper(root.left, root.right)",
  "def helper(p, q):\n    if p is None and q is None:\n        return True\n    if p is not None or q is not None or q.val != p.val:\n        return False\n    return helper(p.left, q.right) and helper(p.right, q.left)",
  "def is_symmetric_iterative(root):\n    if root is None:\n        return True\n    stack = [[root.left, root.right]]\n    while stack:\n        (left, right) = stack.pop()\n        if left is None and right is None:\n            continue\n        if left is None or right is None:\n            return False\n        if left.val == right.val:\n            stack.append([left.left, right.right])\n            stack.append([left.right, right.left])\n        else:\n            return False\n    return True",
  "def is_subtree(big, small):\n    flag = False\n    queue = collections.deque()\n    queue.append(big)\n    while queue:\n        node = queue.popleft()\n        if node.val == small.val:\n            flag = comp(node, small)\n            break\n        else:\n            queue.append(node.left)\n            queue.append(node.right)\n    return flag",
  "def comp(p, q):\n    if p is None and q is None:\n        return True\n    if p is not None and q is not None:\n        return p.val == q.val and comp(p.left, q.left) and comp(p.right, q.right)\n    return False",
  "def max_height(root):\n    if root is None:\n        return 0\n    height = 0\n    queue = [root]\n    while queue:\n        height += 1\n        level = []\n        while queue:\n            node = queue.pop(0)\n            if node.left is not None:\n                level.append(node.left)\n            if node.right is not None:\n                level.append(node.right)\n        queue = level\n    return height",
  "def print_tree(root):\n    if root is not None:\n        print(root.val)\n        print_tree(root.left)\n        print_tree(root.right)",
  "def min_depth(self, root):\n    if root is None:\n        return 0\n    if root.left is not None or root.right is not None:\n        return max(self.minDepth(root.left), self.minDepth(root.right)) + 1\n    return min(self.minDepth(root.left), self.minDepth(root.right)) + 1",
  "def min_height(root):\n    if root is None:\n        return 0\n    height = 0\n    level = [root]\n    while level:\n        height += 1\n        new_level = []\n        for node in level:\n            if node.left is None and node.right is None:\n                return height\n            if node.left is not None:\n                new_level.append(node.left)\n            if node.right is not None:\n                new_level.append(node.right)\n        level = new_level\n    return height",
  "def print_tree(root):\n    if root is not None:\n        print(root.val)\n        print_tree(root.left)\n        print_tree(root.right)",
  "def bin_tree_to_list(root):\n    if not root:\n        return root\n    root = bin_tree_to_list_util(root)\n    while root.left:\n        root = root.left\n    return root",
  "def bin_tree_to_list_util(root):\n    if not root:\n        return root\n    if root.left:\n        left = bin_tree_to_list_util(root.left)\n        while left.right:\n            left = left.right\n        left.right = root\n        root.left = left\n    if root.right:\n        right = bin_tree_to_list_util(root.right)\n        while right.left:\n            right = right.left\n        right.left = root\n        root.right = right\n    return root",
  "def print_tree(root):\n    while root:\n        print(root.val)\n        root = root.right",
  "def construct_tree_util(pre: list, post: list, low: int, high: int, size: int):\n    global pre_index\n    if pre_index == -1:\n        pre_index = 0\n    if pre_index >= size or low > high:\n        return None\n    root = TreeNode(pre[pre_index])\n    pre_index += 1\n    if low == high or pre_index >= size:\n        return root\n    i = low\n    while i <= high:\n        if pre[pre_index] == post[i]:\n            break\n        i += 1\n    if i <= high:\n        root.left = construct_tree_util(pre, post, low, i, size)\n        root.right = construct_tree_util(pre, post, i + 1, high, size)\n    return root",
  "def construct_tree(pre: list, post: list, size: int):\n    global pre_index\n    root = construct_tree_util(pre, post, 0, size - 1, size)\n    return print_inorder(root)",
  "def print_inorder(root: TreeNode, result=None):\n    if root is None:\n        return []\n    if result is None:\n        result = []\n    print_inorder(root.left, result)\n    result.append(root.val)\n    print_inorder(root.right, result)\n    return result",
  "def __init__(self, val, left=None, right=None):\n    self.val = val\n    self.left = left\n    self.right = right",
  "def lca(root, p, q):\n    if root is None or root is p or root is q:\n        return root\n    left = lca(root.left, p, q)\n    right = lca(root.right, p, q)\n    if left is not None and right is not None:\n        return root\n    return left if left else right",
  "def path_sum(root, sum):\n    if root is None:\n        return []\n    res = []\n    dfs(root, sum, [], res)\n    return res",
  "def dfs(root, sum, ls, res):\n    if root.left is None and root.right is None and (root.val == sum):\n        ls.append(root.val)\n        res.append(ls)\n    if root.left is not None:\n        dfs(root.left, sum - root.val, ls + [root.val], res)\n    if root.right is not None:\n        dfs(root.right, sum - root.val, ls + [root.val], res)",
  "def path_sum2(root, s):\n    if root is None:\n        return []\n    res = []\n    stack = [(root, [root.val])]\n    while stack:\n        (node, ls) = stack.pop()\n        if node.left is None and node.right is None and (sum(ls) == s):\n            res.append(ls)\n        if node.left is not None:\n            stack.append((node.left, ls + [node.left.val]))\n        if node.right is not None:\n            stack.append((node.right, ls + [node.right.val]))\n    return res",
  "def path_sum3(root, sum):\n    if root is None:\n        return []\n    res = []\n    queue = [(root, root.val, [root.val])]\n    while queue:\n        (node, val, ls) = queue.pop(0)\n        if node.left is None and node.right is None and (val == sum):\n            res.append(ls)\n        if node.left is not None:\n            queue.append((node.left, val + node.left.val, ls + [node.left.val]))\n        if node.right is not None:\n            queue.append((node.right, val + node.right.val, ls + [node.right.val]))\n    return res",
  "def longest_consecutive(root):\n    if root is None:\n        return 0\n    max_len = 0\n    dfs(root, 0, root.val, max_len)\n    return max_len",
  "def dfs(root, cur, target, max_len):\n    if root is None:\n        return\n    if root.val == target:\n        cur += 1\n    else:\n        cur = 1\n    max_len = max(cur, max_len)\n    dfs(root.left, cur, root.val + 1, max_len)\n    dfs(root.right, cur, root.val + 1, max_len)",
  "def find_deepest_left(root, is_left, depth, res):\n    if not root:\n        return\n    if is_left and depth > res.depth:\n        res.depth = depth\n        res.Node = root\n    find_deepest_left(root.left, True, depth + 1, res)\n    find_deepest_left(root.right, False, depth + 1, res)",
  "def __init__(self):\n    self.depth = 0\n    self.Node = None",
  "def __init__(self, freq):\n    self.arr = freq\n    self.n = len(freq)",
  "def get_sum(self, bit_tree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += bit_tree[i]\n        i -= i & -i\n    return s",
  "def update_bit(self, bit_tree, i, v):\n    i += 1\n    while i <= self.n:\n        bit_tree[i] += v\n        i += i & -i",
  "def construct(self):\n    bit_tree = [0] * (self.n + 1)\n    for i in range(self.n):\n        self.update_bit(bit_tree, i, self.arr[i])\n    return bit_tree",
  "def __init__(self, arr, function):\n    self.segment = [0 for x in range(3 * len(arr) + 3)]\n    self.arr = arr\n    self.fn = function\n    self.make_tree(0, 0, len(arr) - 1)",
  "def make_tree(self, i, l, r):\n    if l == r:\n        self.segment[i] = self.arr[l]\n    elif l < r:\n        self.make_tree(2 * i + 1, l, int((l + r) / 2))\n        self.make_tree(2 * i + 2, int((l + r) / 2) + 1, r)\n        self.segment[i] = self.fn(self.segment[2 * i + 1], self.segment[2 * i + 2])",
  "def __query(self, i, L, R, l, r):\n    if l > R or r < L or L > R or (l > r):\n        return None\n    if L >= l and R <= r:\n        return self.segment[i]\n    val1 = self.__query(2 * i + 1, L, int((L + R) / 2), l, r)\n    val2 = self.__query(2 * i + 2, int((L + R + 2) / 2), R, l, r)\n    print(L, R, ' returned ', val1, val2)\n    if val1 != None:\n        if val2 != None:\n            return self.fn(val1, val2)\n        return val1\n    return val2",
  "def query(self, L, R):\n    return self.__query(0, 0, len(self.arr) - 1, L, R)",
  "def __init__(self, arr, function):\n    self.tree = [None for _ in range(len(arr))] + arr\n    self.size = len(arr)\n    self.fn = function\n    self.build_tree()",
  "def build_tree(self):\n    for i in range(self.size - 1, 0, -1):\n        self.tree[i] = self.fn(self.tree[i * 2], self.tree[i * 2 + 1])",
  "def update(self, p, v):\n    p += self.size\n    self.tree[p] = v\n    while p > 1:\n        p = p // 2\n        self.tree[p] = self.fn(self.tree[p * 2], self.tree[p * 2 + 1])",
  "def query(self, l, r):\n    (l, r) = (l + self.size, r + self.size)\n    res = None\n    while l <= r:\n        if l % 2 == 1:\n            res = self.tree[l] if res is None else self.fn(res, self.tree[l])\n        if r % 2 == 0:\n            res = self.tree[r] if res is None else self.fn(res, self.tree[r])\n        (l, r) = ((l + 1) // 2, (r - 1) // 2)\n    return res",
  "def __init__(self, letter, is_terminal=False):\n    self.children = dict()\n    self.letter = letter\n    self.is_terminal = is_terminal",
  "def __init__(self):\n    self.root = TrieNode('')",
  "def add_word(self, word):\n    cur = self.root\n    for letter in word:\n        if letter not in cur.children:\n            cur.children[letter] = TrieNode(letter)\n        cur = cur.children[letter]\n    cur.is_terminal = True",
  "def search(self, word, node=None):\n    cur = node\n    if not cur:\n        cur = self.root\n    for (i, letter) in enumerate(word):\n        if letter == '.':\n            if i == len(word) - 1:\n                for child in cur.children.itervalues():\n                    if child.is_terminal:\n                        return True\n                return False\n            for child in cur.children.itervalues():\n                if self.search(word[i + 1:], child) == True:\n                    return True\n            return False\n        if letter not in cur.children:\n            return False\n        cur = cur.children[letter]\n    return cur.is_terminal",
  "def __init__(self):\n    self.word_dict = collections.defaultdict(list)",
  "def add_word(self, word):\n    if word:\n        self.word_dict[len(word)].append(word)",
  "def search(self, word):\n    if not word:\n        return False\n    if '.' not in word:\n        return word in self.word_dict[len(word)]\n    for v in self.word_dict[len(word)]:\n        for (i, ch) in enumerate(word):\n            if ch != v[i] and ch != '.':\n                break\n        else:\n            return True\n    return False",
  "def __init__(self):\n    self.children = collections.defaultdict(TrieNode)\n    self.is_word = False",
  "def __init__(self):\n    self.root = TrieNode()",
  "def insert(self, word):\n    current = self.root\n    for letter in word:\n        current = current.children[letter]\n    current.is_word = True",
  "def search(self, word):\n    current = self.root\n    for letter in word:\n        current = current.children.get(letter)\n        if current is None:\n            return False\n    return current.is_word",
  "def starts_with(self, prefix):\n    current = self.root\n    for letter in prefix:\n        current = current.children.get(letter)\n        if current is None:\n            return False\n    return True",
  "def inorder(root):\n    res = []\n    if not root:\n        return res\n    stack = []\n    while root or stack:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        res.append(root.val)\n        root = root.right\n    return res",
  "def inorder_rec(root, res=None):\n    if root is None:\n        return []\n    if res is None:\n        res = []\n    inorder_rec(root.left, res)\n    res.append(root.val)\n    inorder_rec(root.right, res)\n    return res",
  "def __init__(self, val, left=None, right=None):\n    self.val = val\n    self.left = left\n    self.right = right",
  "def level_order(root):\n    ans = []\n    if not root:\n        return ans\n    level = [root]\n    while level:\n        current = []\n        new_level = []\n        for node in level:\n            current.append(node.val)\n            if node.left:\n                new_level.append(node.left)\n            if node.right:\n                new_level.append(node.right)\n        level = new_level\n        ans.append(current)\n    return ans",
  "def postorder(root):\n    res_temp = []\n    res = []\n    if not root:\n        return res\n    stack = []\n    stack.append(root)\n    while stack:\n        root = stack.pop()\n        res_temp.append(root.val)\n        if root.left:\n            stack.append(root.left)\n        if root.right:\n            stack.append(root.right)\n    while res_temp:\n        res.append(res_temp.pop())\n    return res",
  "def postorder_rec(root, res=None):\n    if root is None:\n        return []\n    if res is None:\n        res = []\n    postorder_rec(root.left, res)\n    postorder_rec(root.right, res)\n    res.append(root.val)\n    return res",
  "def __init__(self, val, left=None, right=None):\n    self.val = val\n    self.left = left\n    self.right = right",
  "def zigzag_level(root):\n    res = []\n    if not root:\n        return res\n    level = [root]\n    flag = 1\n    while level:\n        current = []\n        new_level = []\n        for node in level:\n            current.append(node.val)\n            if node.left:\n                new_level.append(node.left)\n            if node.right:\n                new_level.append(node.right)\n        level = new_level\n        res.append(current[::flag])\n        flag *= -1\n    return res",
  "def preorder(root):\n    res = []\n    if not root:\n        return res\n    stack = []\n    stack.append(root)\n    while stack:\n        root = stack.pop()\n        res.append(root.val)\n        if root.right:\n            stack.append(root.right)\n        if root.left:\n            stack.append(root.left)\n    return res",
  "def preorder_rec(root, res=None):\n    if root is None:\n        return []\n    if res is None:\n        res = []\n    res.append(root.val)\n    preorder_rec(root.left, res)\n    preorder_rec(root.right, res)\n    return res",
  "def __init__(self, val, left=None, right=None):\n    self.val = val\n    self.left = left\n    self.right = right",
  "def __init__(self):\n    self.node = None\n    self.height = -1\n    self.balance = 0",
  "def insert(self, key):\n    node = TreeNode(key)\n    if not self.node:\n        self.node = node\n        self.node.left = AvlTree()\n        self.node.right = AvlTree()\n    elif key < self.node.val:\n        self.node.left.insert(key)\n    elif key > self.node.val:\n        self.node.right.insert(key)\n    self.re_balance()",
  "def re_balance(self):\n    self.update_heights(recursive=False)\n    self.update_balances(False)\n    while self.balance < -1 or self.balance > 1:\n        if self.balance > 1:\n            if self.node.left.balance < 0:\n                self.node.left.rotate_left()\n                self.update_heights()\n                self.update_balances()\n            self.rotate_right()\n            self.update_heights()\n            self.update_balances()\n        if self.balance < -1:\n            if self.node.right.balance > 0:\n                self.node.right.rotate_right()\n                self.update_heights()\n                self.update_balances()\n            self.rotate_left()\n            self.update_heights()\n            self.update_balances()",
  "def update_heights(self, recursive=True):\n    if self.node:\n        if recursive:\n            if self.node.left:\n                self.node.left.update_heights()\n            if self.node.right:\n                self.node.right.update_heights()\n        self.height = 1 + max(self.node.left.height, self.node.right.height)\n    else:\n        self.height = -1",
  "def update_balances(self, recursive=True):\n    if self.node:\n        if recursive:\n            if self.node.left:\n                self.node.left.update_balances()\n            if self.node.right:\n                self.node.right.update_balances()\n        self.balance = self.node.left.height - self.node.right.height\n    else:\n        self.balance = 0",
  "def rotate_right(self):\n    new_root = self.node.left.node\n    new_left_sub = new_root.right.node\n    old_root = self.node\n    self.node = new_root\n    old_root.left.node = new_left_sub\n    new_root.right.node = old_root",
  "def rotate_left(self):\n    new_root = self.node.right.node\n    new_left_sub = new_root.left.node\n    old_root = self.node\n    self.node = new_root\n    old_root.right.node = new_left_sub\n    new_root.left.node = old_root",
  "def in_order_traverse(self):\n    result = []\n    if not self.node:\n        return result\n    result.extend(self.node.left.in_order_traverse())\n    result.append(self.node.key)\n    result.extend(self.node.right.in_order_traverse())\n    return result",
  "def __init__(self, val, is_red, parent=None, left=None, right=None):\n    self.val = val\n    self.parent = parent\n    self.left = left\n    self.right = right\n    self.color = is_red",
  "def __init__(self):\n    self.root = None",
  "def left_rotate(self, node):\n    right_node = node.right\n    if right_node is None:\n        return\n    else:\n        node.right = right_node.left\n        if right_node.left is not None:\n            right_node.left.parent = node\n        right_node.parent = node.parent\n        if node.parent is None:\n            self.root = right_node\n        elif node is node.parent.left:\n            node.parent.left = right_node\n        else:\n            node.parent.right = right_node\n        right_node.left = node\n        node.parent = right_node",
  "def right_rotate(self, node):\n    left_node = node.left\n    if left_node is None:\n        return\n    else:\n        node.left = left_node.right\n        if left_node.right is not None:\n            left_node.right.parent = node\n        left_node.parent = node.parent\n        if node.parent is None:\n            self.root = left_node\n        elif node is node.parent.left:\n            node.parent.left = left_node\n        else:\n            node.parent.right = left_node\n        left_node.right = node\n        node.parent = left_node",
  "def insert(self, node):\n    root = self.root\n    insert_node_parent = None\n    while root is not None:\n        insert_node_parent = root\n        if insert_node_parent.val < node.val:\n            root = root.right\n        else:\n            root = root.left\n    node.parent = insert_node_parent\n    if insert_node_parent is None:\n        self.root = node\n    elif insert_node_parent.val > node.val:\n        insert_node_parent.left = node\n    else:\n        insert_node_parent.right = node\n    node.left = None\n    node.right = None\n    node.color = 1\n    self.fix_insert(node)",
  "def fix_insert(self, node):\n    if node.parent is None:\n        node.color = 0\n        self.root = node\n        return\n    while node.parent and node.parent.color == 1:\n        if node.parent is node.parent.parent.left:\n            uncle_node = node.parent.parent.right\n            if uncle_node and uncle_node.color == 1:\n                node.parent.color = 0\n                node.parent.parent.right.color = 0\n                node.parent.parent.color = 1\n                node = node.parent.parent\n                continue\n            elif node is node.parent.right:\n                node = node.parent\n                self.left_rotate(node)\n            node.parent.color = 0\n            node.parent.parent.color = 1\n            self.right_rotate(node.parent.parent)\n        else:\n            uncle_node = node.parent.parent.left\n            if uncle_node and uncle_node.color == 1:\n                node.parent.color = 0\n                node.parent.parent.left.color = 0\n                node.parent.parent.color = 1\n                node = node.parent.parent\n                continue\n            elif node is node.parent.left:\n                node = node.parent\n                self.right_rotate(node)\n            node.parent.color = 0\n            node.parent.parent.color = 1\n            self.left_rotate(node.parent.parent)\n    self.root.color = 0",
  "def transplant(self, node_u, node_v):\n    if node_u.parent is None:\n        self.root = node_v\n    elif node_u is node_u.parent.left:\n        node_u.parent.left = node_v\n    elif node_u is node_u.parent.right:\n        node_u.parent.right = node_v\n    if node_v:\n        node_v.parent = node_u.parent",
  "def maximum(self, node):\n    temp_node = node\n    while temp_node.right is not None:\n        temp_node = temp_node.right\n    return temp_node",
  "def minimum(self, node):\n    temp_node = node\n    while temp_node.left:\n        temp_node = temp_node.left\n    return temp_node",
  "def delete(self, node):\n    node_color = node.color\n    if node.left is None:\n        temp_node = node.right\n        self.transplant(node, node.right)\n    elif node.right is None:\n        temp_node = node.left\n        self.transplant(node, node.left)\n    else:\n        node_min = self.minimum(node.right)\n        node_color = node_min.color\n        temp_node = node_min.right\n        if node_min.parent is not node:\n            self.transplant(node_min, node_min.right)\n            node_min.right = node.right\n            node_min.right.parent = node_min\n        self.transplant(node, node_min)\n        node_min.left = node.left\n        node_min.left.parent = node_min\n        node_min.color = node.color\n    if node_color == 0:\n        self.delete_fixup(temp_node)",
  "def delete_fixup(self, node):\n    while node is not self.root and node.color == 0:\n        if node is node.parent.left:\n            node_brother = node.parent.right\n            if node_brother.color == 1:\n                node_brother.color = 0\n                node.parent.color = 1\n                self.left_rotate(node.parent)\n                node_brother = node.parent.right\n            if (node_brother.left is None or node_brother.left.color == 0) and (node_brother.right is None or node_brother.right.color == 0):\n                node_brother.color = 1\n                node = node.parent\n            else:\n                if node_brother.right is None or node_brother.right.color == 0:\n                    node_brother.color = 1\n                    node_brother.left.color = 0\n                    self.right_rotate(node_brother)\n                    node_brother = node.parent.right\n                node_brother.color = node.parent.color\n                node.parent.color = 0\n                node_brother.right.color = 0\n                self.left_rotate(node.parent)\n                node = self.root\n        else:\n            node_brother = node.parent.left\n            if node_brother.color == 1:\n                node_brother.color = 0\n                node.parent.color = 1\n                self.left_rotate(node.parent)\n                node_brother = node.parent.right\n            if (node_brother.left is None or node_brother.left.color == 0) and (node_brother.right is None or node_brother.right.color == 0):\n                node_brother.color = 1\n                node = node.parent\n            else:\n                if node_brother.left is None or node_brother.left.color == 0:\n                    node_brother.color = 1\n                    node_brother.right.color = 0\n                    self.left_rotate(node_brother)\n                    node_brother = node.parent.left\n                node_brother.color = node.parent.color\n                node.parent.color = 0\n                node_brother.left.color = 0\n                self.right_rotate(node.parent)\n                node = self.root\n    node.color = 0",
  "def inorder(self):\n    res = []\n    if not self.root:\n        return res\n    stack = []\n    root = self.root\n    while root or stack:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        res.append({'val': root.val, 'color': root.color})\n        root = root.right\n    return res",
  "def kth_smallest(root, k):\n    stack = []\n    while root or stack:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        k -= 1\n        if k == 0:\n            break\n        root = root.right\n    return root.val",
  "def __init__(self, val, left=None, right=None):\n    self.val = val\n    self.left = left\n    self.right = right",
  "def kth_smallest(self, root, k):\n    count = []\n    self.helper(root, count)\n    return count[k - 1]",
  "def helper(self, node, count):\n    if not node:\n        return\n    self.helper(node.left, count)\n    count.append(node.val)\n    self.helper(node.right, count)",
  "def serialize(root):\n\n    def build_string(node):\n        if node:\n            vals.append(str(node.val))\n            build_string(node.left)\n            build_string(node.right)\n        else:\n            vals.append('#')\n    vals = []\n    build_string(root)\n    return ' '.join(vals)",
  "def deserialize(data):\n\n    def build_tree():\n        val = next(vals)\n        if val == '#':\n            return None\n        node = TreeNode(int(val))\n        node.left = build_tree()\n        node.right = build_tree()\n        return node\n    vals = iter(data.split())\n    return build_tree()",
  "def __init__(self, x):\n    self.val = x\n    self.left = None\n    self.right = None",
  "def build_string(node):\n    if node:\n        vals.append(str(node.val))\n        build_string(node.left)\n        build_string(node.right)\n    else:\n        vals.append('#')",
  "def build_tree():\n    val = next(vals)\n    if val == '#':\n        return None\n    node = TreeNode(int(val))\n    node.left = build_tree()\n    node.right = build_tree()\n    return node",
  "def num_trees(n):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i + 1):\n            dp[i] += dp[i - j] * dp[j - 1]\n    return dp[-1]",
  "def height(root):\n    if root is None:\n        return 0\n    else:\n        return 1 + max(height(root.left), height(root.right))",
  "def setUp(self):\n    self.tree = bst()\n    self.tree.insert(9)\n    self.tree.insert(6)\n    self.tree.insert(12)\n    self.tree.insert(3)\n    self.tree.insert(8)\n    self.tree.insert(10)\n    self.tree.insert(15)\n    self.tree.insert(7)\n    self.tree.insert(18)",
  "def test_height(self):\n    self.assertEqual(4, height(self.tree.root))",
  "def __init__(self, data):\n    self.data = data\n    self.left = None\n    self.right = None",
  "def __init__(self):\n    self.root = None",
  "def get_root(self):\n    return self.root",
  "def size(self):\n    return self.recur_size(self.root)",
  "def recur_size(self, root):\n    if root is None:\n        return 0\n    else:\n        return 1 + self.recur_size(root.left) + self.recur_size(root.right)",
  "def search(self, data):\n    return self.recur_search(self.root, data)",
  "def recur_search(self, root, data):\n    if root is None:\n        return False\n    if root.data == data:\n        return True\n    elif data > root.data:\n        return self.recur_search(root.right, data)\n    else:\n        return self.recur_search(root.left, data)",
  "def insert(self, data):\n    if self.root:\n        return self.recur_insert(self.root, data)\n    else:\n        self.root = Node(data)\n        return True",
  "def recur_insert(self, root, data):\n    if root.data == data:\n        return False\n    elif data < root.data:\n        if root.left:\n            return self.recur_insert(root.left, data)\n        else:\n            root.left = Node(data)\n            return True\n    elif root.right:\n        return self.recur_insert(root.right, data)\n    else:\n        root.right = Node(data)\n        return True",
  "def preorder(self, root):\n    if root:\n        print(str(root.data), end=' ')\n        self.preorder(root.left)\n        self.preorder(root.right)",
  "def inorder(self, root):\n    if root:\n        self.inorder(root.left)\n        print(str(root.data), end=' ')\n        self.inorder(root.right)",
  "def postorder(self, root):\n    if root:\n        self.postorder(root.left)\n        self.postorder(root.right)\n        print(str(root.data), end=' ')",
  "def setUp(self):\n    self.tree = BST()\n    self.tree.insert(10)\n    self.tree.insert(15)\n    self.tree.insert(6)\n    self.tree.insert(4)\n    self.tree.insert(9)\n    self.tree.insert(12)\n    self.tree.insert(24)\n    self.tree.insert(7)\n    self.tree.insert(20)\n    self.tree.insert(30)\n    self.tree.insert(18)",
  "def test_search(self):\n    self.assertTrue(self.tree.search(24))\n    self.assertFalse(self.tree.search(50))",
  "def test_size(self):\n    self.assertEqual(11, self.tree.size())",
  "def predecessor(root, node):\n    pred = None\n    while root:\n        if node.val > root.val:\n            pred = root\n            root = root.right\n        else:\n            root = root.left\n    return pred",
  "def num_empty(root):\n    if root is None:\n        return 1\n    elif root.left is None and root.right:\n        return 1 + num_empty(root.right)\n    elif root.right is None and root.left:\n        return 1 + num_empty(root.left)\n    else:\n        return num_empty(root.left) + num_empty(root.right)",
  "def setUp(self):\n    self.tree = bst()\n    self.tree.insert(9)\n    self.tree.insert(6)\n    self.tree.insert(12)\n    self.tree.insert(3)\n    self.tree.insert(8)\n    self.tree.insert(10)\n    self.tree.insert(15)\n    self.tree.insert(7)\n    self.tree.insert(18)",
  "def test_num_empty(self):\n    self.assertEqual(10, num_empty(self.tree.root))",
  "def delete_node(self, root, key):\n    if not root:\n        return None\n    if root.val == key:\n        if root.left:\n            left_right_most = root.left\n            while left_right_most.right:\n                left_right_most = left_right_most.right\n            left_right_most.right = root.right\n            return root.left\n        else:\n            return root.right\n    elif root.val > key:\n        root.left = self.deleteNode(root.left, key)\n    else:\n        root.right = self.deleteNode(root.right, key)\n    return root",
  "def array_to_bst(nums):\n    if not nums:\n        return None\n    mid = len(nums) // 2\n    node = TreeNode(nums[mid])\n    node.left = array_to_bst(nums[:mid])\n    node.right = array_to_bst(nums[mid + 1:])\n    return node",
  "def __init__(self, x):\n    self.val = x\n    self.left = None\n    self.right = None",
  "def successor(root, node):\n    succ = None\n    while root:\n        if node.val < root.val:\n            succ = root\n            root = root.left\n        else:\n            root = root.right\n    return succ",
  "def depth_sum(root, n):\n    if root:\n        return recur_depth_sum(root, 1)",
  "def recur_depth_sum(root, n):\n    if root is None:\n        return 0\n    elif root.left is None and root.right is None:\n        return root.data * n\n    else:\n        return n * root.data + recur_depth_sum(root.left, n + 1) + recur_depth_sum(root.right, n + 1)",
  "def setUp(self):\n    self.tree = bst()\n    self.tree.insert(9)\n    self.tree.insert(6)\n    self.tree.insert(12)\n    self.tree.insert(3)\n    self.tree.insert(8)\n    self.tree.insert(10)\n    self.tree.insert(15)\n    self.tree.insert(7)\n    self.tree.insert(18)",
  "def test_depth_sum(self):\n    self.assertEqual(253, depth_sum(self.tree.root, 4))",
  "def closest_value(root, target):\n    a = root.val\n    kid = root.left if target < a else root.right\n    if not kid:\n        return a\n    b = closest_value(kid, target)\n    return min((a, b), key=lambda x: abs(target - x))",
  "def lowest_common_ancestor(root, p, q):\n    while root:\n        if p.val > root.val < q.val:\n            root = root.right\n        elif p.val < root.val > q.val:\n            root = root.left\n        else:\n            return root",
  "def __init__(self, root):\n    self.stack = []\n    while root:\n        self.stack.append(root)\n        root = root.left",
  "def has_next(self):\n    return bool(self.stack)",
  "def next(self):\n    node = self.stack.pop()\n    tmp = node\n    if tmp.right:\n        tmp = tmp.right\n        while tmp:\n            self.stack.append(tmp)\n            tmp = tmp.left\n    return node.val",
  "def is_bst(root):\n    stack = []\n    pre = None\n    while root or stack:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if pre and root.val <= pre.val:\n            return False\n        pre = root\n        root = root.right\n    return True",
  "def count_left_node(root):\n    if root is None:\n        return 0\n    elif root.left is None:\n        return count_left_node(root.right)\n    else:\n        return 1 + count_left_node(root.left) + count_left_node(root.right)",
  "def setUp(self):\n    self.tree = bst()\n    self.tree.insert(9)\n    self.tree.insert(6)\n    self.tree.insert(12)\n    self.tree.insert(3)\n    self.tree.insert(8)\n    self.tree.insert(10)\n    self.tree.insert(15)\n    self.tree.insert(7)\n    self.tree.insert(18)",
  "def test_count_left_node(self):\n    self.assertEqual(4, count_left_node(self.tree.root))",
  "def match_symbol(words, symbols):\n    import re\n    combined = []\n    for s in symbols:\n        for c in words:\n            r = re.search(s, c)\n            if r:\n                combined.append(re.sub(s, '[{}]'.format(s), c))\n    return combined",
  "def match_symbol_1(words, symbols):\n    res = []\n    symbols = sorted(symbols, key=lambda _: len(_), reverse=True)\n    for word in words:\n        for symbol in symbols:\n            word_replaced = ''\n            if word.find(symbol) != -1:\n                word_replaced = word.replace(symbol, '[' + symbol + ']')\n                res.append(word_replaced)\n                break\n        if word_replaced == '':\n            res.append(word)\n    return res",
  "def bracket(words, symbols):\n    root = TreeNode()\n    for s in symbols:\n        t = root\n        for char in s:\n            if char not in t.c:\n                t.c[char] = TreeNode()\n            t = t.c[char]\n        t.sym = s\n    result = dict()\n    for word in words:\n        i = 0\n        symlist = list()\n        while i < len(word):\n            (j, t) = (i, root)\n            while j < len(word) and word[j] in t.c:\n                t = t.c[word[j]]\n                if t.sym is not None:\n                    symlist.append((j + 1 - len(t.sym), j + 1, t.sym))\n                j += 1\n            i += 1\n        if len(symlist) > 0:\n            sym = reduce(lambda x, y: x if x[1] - x[0] >= y[1] - y[0] else y, symlist)\n            result[word] = '{}[{}]{}'.format(word[:sym[0]], sym[2], word[sym[1]:])\n    return tuple((word if word not in result else result[word] for word in words))",
  "def __init__(self):\n    self.c = dict()\n    self.sym = None",
  "def license_number(key, k):\n    (res, alnum) = ([], [])\n    for char in key:\n        if char != '-':\n            alnum.append(char)\n    for (i, char) in enumerate(reversed(alnum)):\n        res.append(char)\n        if (i + 1) % k == 0 and i != len(alnum) - 1:\n            res.append('-')\n    return ''.join(res[::-1])",
  "def check_pangram(input_string):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    for ch in alphabet:\n        if ch not in input_string.lower():\n            return False\n    return True",
  "def strong_password(n, password):\n    count_error = 0\n    if any((i.isdigit() for i in password)) == False:\n        count_error = count_error + 1\n    if any((i.islower() for i in password)) == False:\n        count_error = count_error + 1\n    if any((i.isupper() for i in password)) == False:\n        count_error = count_error + 1\n    if any((i in '!@#$%^&*()-+' for i in password)) == False:\n        count_error = count_error + 1\n    return max(count_error, 6 - n)",
  "def delete_reoccurring_characters(string):\n    seen_characters = set()\n    output_string = ''\n    for char in string:\n        if char not in seen_characters:\n            seen_characters.add(char)\n            output_string += char\n    return output_string",
  "def strip_url_params1(url, params_to_strip=None):\n    if not params_to_strip:\n        params_to_strip = []\n    if url:\n        result = ''\n        tokens = url.split('?')\n        domain = tokens[0]\n        query_string = tokens[-1]\n        result += domain\n        if len(tokens) > 1:\n            result += '?'\n        if not query_string:\n            return url\n        else:\n            key_value_string = []\n            string = ''\n            for char in query_string:\n                if char.isdigit():\n                    key_value_string.append(string + char)\n                    string = ''\n                else:\n                    string += char\n            dict = defaultdict(int)\n            for i in key_value_string:\n                _token = i.split('=')\n                if _token[0]:\n                    length = len(_token[0])\n                    if length == 1:\n                        if _token and (not _token[0] in dict):\n                            if params_to_strip:\n                                if _token[0] != params_to_strip[0]:\n                                    dict[_token[0]] = _token[1]\n                                    result = result + _token[0] + '=' + _token[1]\n                            elif not _token[0] in dict:\n                                dict[_token[0]] = _token[1]\n                                result = result + _token[0] + '=' + _token[1]\n                    else:\n                        check = _token[0]\n                        letter = check[1]\n                        if _token and (not letter in dict):\n                            if params_to_strip:\n                                if letter != params_to_strip[0]:\n                                    dict[letter] = _token[1]\n                                    result = result + _token[0] + '=' + _token[1]\n                            elif not letter in dict:\n                                dict[letter] = _token[1]\n                                result = result + _token[0] + '=' + _token[1]\n    return result",
  "def strip_url_params2(url, param_to_strip=[]):\n    if '?' not in url:\n        return url\n    queries = url.split('?')[1].split('&')\n    queries_obj = [query[0] for query in queries]\n    for i in range(len(queries_obj) - 1, 0, -1):\n        if queries_obj[i] in param_to_strip or queries_obj[i] in queries_obj[0:i]:\n            queries.pop(i)\n    return url.split('?')[0] + '?' + '&'.join(queries)",
  "def strip_url_params3(url, strip=None):\n    if not strip:\n        strip = []\n    parse = urllib.parse.urlparse(url)\n    query = urllib.parse.parse_qs(parse.query)\n    query = {k: v[0] for (k, v) in query.items() if k not in strip}\n    query = urllib.parse.urlencode(query)\n    new = parse._replace(query=query)\n    return new.geturl()",
  "def repeat_substring(s):\n    str = (s + s)[1:-1]\n    return s in str",
  "def recursive(s):\n    l = len(s)\n    if l < 2:\n        return s\n    return recursive(s[l // 2:]) + recursive(s[:l // 2])",
  "def iterative(s):\n    r = list(s)\n    (i, j) = (0, len(s) - 1)\n    while i < j:\n        (r[i], r[j]) = (r[j], r[i])\n        i += 1\n        j -= 1\n    return ''.join(r)",
  "def pythonic(s):\n    r = list(reversed(s))\n    return ''.join(r)",
  "def ultra_pythonic(s):\n    return s[::-1]",
  "def panagram(string):\n    letters = set(ascii_lowercase)\n    for c in string:\n        try:\n            letters.remove(c.lower())\n        except:\n            pass\n    return len(letters) == 0",
  "def reverse(array, i, j):\n    while i < j:\n        (array[i], array[j]) = (array[j], array[i])\n        i += 1\n        j -= 1",
  "def reverse_words(string):\n    arr = string.strip().split()\n    n = len(arr)\n    reverse(arr, 0, n - 1)\n    return ' '.join(arr)",
  "def roman_to_int(s: 'str') -> 'int':\n    number = 0\n    roman = {'M': 1000, 'D': 500, 'C': 100, 'L': 50, 'X': 10, 'V': 5, 'I': 1}\n    for i in range(len(s) - 1):\n        if roman[s[i]] < roman[s[i + 1]]:\n            number -= roman[s[i]]\n        else:\n            number += roman[s[i]]\n    return number + roman[s[-1]]",
  "def is_rotated(s1, s2):\n    if len(s1) == len(s2):\n        return s2 in s1 + s1\n    else:\n        return False",
  "def is_rotated_v1(s1, s2):\n    if len(s1) != len(s2):\n        return False\n    if len(s1) == 0:\n        return True\n    for c in range(len(s1)):\n        if all((s1[(c + i) % len(s1)] == s2[i] for i in range(len(s1)))):\n            return True\n    return False",
  "def caesar_cipher(s, k):\n    result = ''\n    for char in s:\n        n = ord(char)\n        if 64 < n < 91:\n            n = (n - 65 + k) % 26 + 65\n        if 96 < n < 123:\n            n = (n - 97 + k) % 26 + 97\n        result = result + chr(n)\n    return result",
  "def is_palindrome(s):\n    i = 0\n    j = len(s) - 1\n    while i < j:\n        while not s[i].isalnum():\n            i += 1\n        while not s[j].isalnum():\n            j -= 1\n        if s[i].lower() != s[j].lower():\n            return False\n        (i, j) = (i + 1, j - 1)\n    return True",
  "def remove_punctuation(s):\n    return ''.join((i.lower() for i in s if i in ascii_letters))",
  "def string_reverse(s):\n    return s[::-1]",
  "def is_palindrome_reverse(s):\n    s = remove_punctuation(s)\n    if s == string_reverse(s):\n        return True\n    return False",
  "def is_palindrome_two_pointer(s):\n    s = remove_punctuation(s)\n    for i in range(0, len(s) // 2):\n        if s[i] != s[len(s) - i - 1]:\n            return False\n    return True",
  "def is_palindrome_stack(s):\n    stack = []\n    s = remove_punctuation(s)\n    for i in range(len(s) // 2, len(s)):\n        stack.append(s[i])\n    for i in range(0, len(s) // 2):\n        if s[i] != stack.pop():\n            return False\n    return True",
  "def is_palindrome_deque(s):\n    s = remove_punctuation(s)\n    deq = deque()\n    for char in s:\n        deq.appendleft(char)\n    equal = True\n    while len(deq) > 1 and equal:\n        first = deq.pop()\n        last = deq.popleft()\n        if first != last:\n            equal = False\n    return equal",
  "def fizzbuzz(n):\n    if n < 1:\n        raise ValueError('n cannot be less than one')\n    if n is None:\n        raise TypeError('n cannot be None')\n    result = []\n    for i in range(1, n + 1):\n        if i % 3 == 0 and i % 5 == 0:\n            result.append('FizzBuzz')\n        elif i % 3 == 0:\n            result.append('Fizz')\n        elif i % 5 == 0:\n            result.append('Buzz')\n        else:\n            result.append(i)\n    return result",
  "def fizzbuzz_with_helper_func(n):\n    return [fb(m) for m in range(1, n + 1)]",
  "def fb(m):\n    r = (m % 3 == 0) * 'Fizz' + (m % 5 == 0) * 'Buzz'\n    return r if r != '' else m",
  "def encode(strs):\n    res = ''\n    for string in strs.split():\n        res += str(len(string)) + ':' + string\n    return res",
  "def decode(s):\n    strs = []\n    i = 0\n    while i < len(s):\n        index = s.find(':', i)\n        size = int(s[i:index])\n        strs.append(s[index + 1:index + 1 + size])\n        i = index + 1 + size\n    return strs",
  "def text_justification(words, max_width):\n    ret = []\n    row_len = 0\n    row_words = []\n    index = 0\n    is_first_word = True\n    while index < len(words):\n        while row_len <= max_width and index < len(words):\n            if len(words[index]) > max_width:\n                raise ValueError('there exists word whose length is larger than max_width')\n            tmp = row_len\n            row_words.append(words[index])\n            tmp += len(words[index])\n            if not is_first_word:\n                tmp += 1\n            if tmp > max_width:\n                row_words.pop()\n                break\n            row_len = tmp\n            index += 1\n            is_first_word = False\n        row = ''\n        if index == len(words):\n            for word in row_words:\n                row += word + ' '\n            row = row[:-1]\n            row += ' ' * (max_width - len(row))\n        elif len(row_words) != 1:\n            space_num = max_width - row_len\n            space_num_of_each_interval = space_num // (len(row_words) - 1)\n            space_num_rest = space_num - space_num_of_each_interval * (len(row_words) - 1)\n            for j in range(len(row_words)):\n                row += row_words[j]\n                if j != len(row_words) - 1:\n                    row += ' ' * (1 + space_num_of_each_interval)\n                if space_num_rest > 0:\n                    row += ' '\n                    space_num_rest -= 1\n        else:\n            row += row_words[0]\n            row += ' ' * (max_width - len(row))\n        ret.append(row)\n        row_len = 0\n        row_words = []\n        is_first_word = True\n    return ret",
  "def domain_name_1(url):\n    full_domain_name = url.split('//')[-1]\n    actual_domain = full_domain_name.split('.')\n    if len(actual_domain) > 2:\n        return actual_domain[1]\n    return actual_domain[0]",
  "def domain_name_2(url):\n    return url.split('//')[-1].split('www.')[-1].split('.')[0]",
  "def judge_circle(moves):\n    dict_moves = {'U': 0, 'D': 0, 'R': 0, 'L': 0}\n    for char in moves:\n        dict_moves[char] = dict_moves[char] + 1\n    return dict_moves['L'] == dict_moves['R'] and dict_moves['U'] == dict_moves['D']",
  "def rabin_karp(word, text):\n    if word == '' or text == '':\n        return None\n    if len(word) > len(text):\n        return None\n    rolling_hash = RollingHash(text, len(word))\n    word_hash = RollingHash(word, len(word))\n    for i in range(len(text) - len(word) + 1):\n        if rolling_hash.hash == word_hash.hash:\n            if rolling_hash.window_text() == word:\n                return i\n        rolling_hash.move_window()\n    return None",
  "def __init__(self, text, size_word):\n    self.text = text\n    self.hash = 0\n    self.size_word = size_word\n    for i in range(0, size_word):\n        self.hash += (ord(self.text[i]) - ord('a') + 1) * 26 ** (size_word - i - 1)\n    self.window_start = 0\n    self.window_end = size_word",
  "def move_window(self):\n    if self.window_end <= len(self.text) - 1:\n        self.hash -= (ord(self.text[self.window_start]) - ord('a') + 1) * 26 ** (self.size_word - 1)\n        self.hash *= 26\n        self.hash += ord(self.text[self.window_end]) - ord('a') + 1\n        self.window_start += 1\n        self.window_end += 1",
  "def window_text(self):\n    return self.text[self.window_start:self.window_end]",
  "def int_to_roman(num):\n    m = ['', 'M', 'MM', 'MMM']\n    c = ['', 'C', 'CC', 'CCC', 'CD', 'D', 'DC', 'DCC', 'DCCC', 'CM']\n    x = ['', 'X', 'XX', 'XXX', 'XL', 'L', 'LX', 'LXX', 'LXXX', 'XC']\n    i = ['', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX']\n    return m[num // 1000] + c[num % 1000 // 100] + x[num % 100 // 10] + i[num % 10]",
  "def knuth_morris_pratt(text: Sequence, pattern: Sequence) -> List[int]:\n    n = len(text)\n    m = len(pattern)\n    pi = [0 for i in range(m)]\n    i = 0\n    j = 0\n    for i in range(1, m):\n        while j and pattern[i] != pattern[j]:\n            j = pi[j - 1]\n        if pattern[i] == pattern[j]:\n            j += 1\n            pi[i] = j\n    j = 0\n    ret = []\n    for i in range(n):\n        while j and text[i] != pattern[j]:\n            j = pi[j - 1]\n        if text[i] == pattern[j]:\n            j += 1\n            if j == m:\n                ret.append(i - m + 1)\n                j = pi[j - 1]\n    return ret",
  "def atbash(s):\n    translated = ''\n    for i in range(len(s)):\n        n = ord(s[i])\n        if s[i].isalpha():\n            if s[i].isupper():\n                x = n - ord('A')\n                translated += chr(ord('Z') - x)\n            if s[i].islower():\n                x = n - ord('a')\n                translated += chr(ord('z') - x)\n        else:\n            translated += s[i]\n    return translated",
  "def word_squares(words):\n    n = len(words[0])\n    fulls = collections.defaultdict(list)\n    for word in words:\n        for i in range(n):\n            fulls[word[:i]].append(word)\n\n    def build(square):\n        if len(square) == n:\n            squares.append(square)\n            return\n        prefix = ''\n        for k in range(len(square)):\n            prefix += square[k][len(square)]\n        for word in fulls[prefix]:\n            build(square + [word])\n    squares = []\n    for word in words:\n        build([word])\n    return squares",
  "def build(square):\n    if len(square) == n:\n        squares.append(square)\n        return\n    prefix = ''\n    for k in range(len(square)):\n        prefix += square[k][len(square)]\n    for word in fulls[prefix]:\n        build(square + [word])",
  "def common_prefix(s1, s2):\n    if not s1 or not s2:\n        return ''\n    k = 0\n    while s1[k] == s2[k]:\n        k = k + 1\n        if k >= len(s1) or k >= len(s2):\n            return s1[0:k]\n    return s1[0:k]",
  "def longest_common_prefix_v1(strs):\n    if not strs:\n        return ''\n    result = strs[0]\n    for i in range(len(strs)):\n        result = common_prefix(result, strs[i])\n    return result",
  "def longest_common_prefix_v2(strs):\n    if not strs:\n        return ''\n    for i in range(len(strs[0])):\n        for string in strs[1:]:\n            if i == len(string) or string[i] != strs[0][i]:\n                return strs[0][0:i]\n    return strs[0]",
  "def longest_common_prefix_v3(strs):\n    if not strs:\n        return ''\n    return longest_common(strs, 0, len(strs) - 1)",
  "def longest_common(strs, left, right):\n    if left == right:\n        return strs[left]\n    mid = (left + right) // 2\n    lcp_left = longest_common(strs, left, mid)\n    lcp_right = longest_common(strs, mid + 1, right)\n    return common_prefix(lcp_left, lcp_right)",
  "def is_valid_coordinates_0(coordinates):\n    for char in coordinates:\n        if not (char.isdigit() or char in ['-', '.', ',', ' ']):\n            return False\n    l = coordinates.split(', ')\n    if len(l) != 2:\n        return False\n    try:\n        latitude = float(l[0])\n        longitude = float(l[1])\n    except:\n        return False\n    return -90 <= latitude <= 90 and -180 <= longitude <= 180",
  "def is_valid_coordinates_1(coordinates):\n    try:\n        (lat, lng) = [abs(float(c)) for c in coordinates.split(',') if 'e' not in c]\n    except ValueError:\n        return False\n    return lat <= 90 and lng <= 180",
  "def is_valid_coordinates_regular_expression(coordinates):\n    return bool(re.match('-?(\\\\d|[1-8]\\\\d|90)\\\\.?\\\\d*, -?(\\\\d|[1-9]\\\\d|1[0-7]\\\\d|180)\\\\.?\\\\d*$', coordinates))",
  "def make_sentence(str_piece, dictionaries):\n    global count\n    if len(str_piece) == 0:\n        return True\n    for i in range(0, len(str_piece)):\n        (prefix, suffix) = (str_piece[0:i], str_piece[i:])\n        if prefix in dictionaries:\n            if suffix in dictionaries or make_sentence(suffix, dictionaries):\n                count += 1\n    return True",
  "def contain_string(haystack, needle):\n    if len(needle) == 0:\n        return 0\n    if len(needle) > len(haystack):\n        return -1\n    for i in range(len(haystack)):\n        if len(haystack) - i < len(needle):\n            return -1\n        if haystack[i:i + len(needle)] == needle:\n            return i\n    return -1",
  "def count_binary_substring(s):\n    cur = 1\n    pre = 0\n    count = 0\n    for i in range(1, len(s)):\n        if s[i] != s[i - 1]:\n            count = count + min(pre, cur)\n            pre = cur\n            cur = 1\n        else:\n            cur = cur + 1\n    count = count + min(pre, cur)\n    return count",
  "def first_unique_char(s):\n    if len(s) == 1:\n        return 0\n    ban = []\n    for i in range(len(s)):\n        if all((s[i] != s[k] for k in range(i + 1, len(s)))) == True and s[i] not in ban:\n            return i\n        else:\n            ban.append(s[i])\n    return -1",
  "def repeat_string(A, B):\n    count = 1\n    tmp = A\n    max_count = len(B) / len(A) + 1\n    while not B in tmp:\n        tmp = tmp + A\n        if count > max_count:\n            count = -1\n            break\n        count = count + 1\n    return count",
  "def multiply(num1: 'str', num2: 'str') -> 'str':\n    interm = []\n    zero = ord('0')\n    i_pos = 1\n    for i in reversed(num1):\n        j_pos = 1\n        add = 0\n        for j in reversed(num2):\n            mult = (ord(i) - zero) * (ord(j) - zero) * j_pos * i_pos\n            j_pos *= 10\n            add += mult\n        i_pos *= 10\n        interm.append(add)\n    return str(sum(interm))",
  "def convert_morse_word(word):\n    morse_word = ''\n    word = word.lower()\n    for char in word:\n        morse_word = morse_word + morse_code[char]\n    return morse_word",
  "def unique_morse(words):\n    unique_morse_word = []\n    for word in words:\n        morse_word = convert_morse_word(word)\n        if morse_word not in unique_morse_word:\n            unique_morse_word.append(morse_word)\n    return len(unique_morse_word)",
  "def is_one_edit(s, t):\n    if len(s) > len(t):\n        return is_one_edit(t, s)\n    if len(t) - len(s) > 1 or t == s:\n        return False\n    for i in range(len(s)):\n        if s[i] != t[i]:\n            return s[i + 1:] == t[i + 1:] or s[i:] == t[i + 1:]\n    return True",
  "def is_one_edit2(s, t):\n    (l1, l2) = (len(s), len(t))\n    if l1 > l2:\n        return is_one_edit2(t, s)\n    if len(t) - len(s) > 1 or t == s:\n        return False\n    for i in range(len(s)):\n        if s[i] != t[i]:\n            if l1 == l2:\n                s = s[:i] + t[i] + s[i + 1:]\n            else:\n                s = s[:i] + t[i] + s[i:]\n            break\n    return s == t or s == t[:-1]",
  "def group_anagrams(strs):\n    d = {}\n    ans = []\n    k = 0\n    for str in strs:\n        sstr = ''.join(sorted(str))\n        if sstr not in d:\n            d[sstr] = k\n            k += 1\n            ans.append([])\n            ans[-1].append(str)\n        else:\n            ans[d[sstr]].append(str)\n    return ans",
  "def rotate(s, k):\n    long_string = s * (k // len(s) + 2)\n    if k <= len(s):\n        return long_string[k:k + len(s)]\n    else:\n        return long_string[k - len(s):k]",
  "def rotate_alt(string, k):\n    k = k % len(string)\n    return string[k:] + string[:k]",
  "def decode_string(s):\n    stack = []\n    cur_num = 0\n    cur_string = ''\n    for c in s:\n        if c == '[':\n            stack.append((cur_string, cur_num))\n            cur_string = ''\n            cur_num = 0\n        elif c == ']':\n            (prev_string, num) = stack.pop()\n            cur_string = prev_string + num * cur_string\n        elif c.isdigit():\n            cur_num = cur_num * 10 + int(c)\n        else:\n            cur_string += c\n    return cur_string",
  "def is_merge_recursive(s, part1, part2):\n    if not part1:\n        return s == part2\n    if not part2:\n        return s == part1\n    if not s:\n        return part1 + part2 == ''\n    if s[0] == part1[0] and is_merge_recursive(s[1:], part1[1:], part2):\n        return True\n    if s[0] == part2[0] and is_merge_recursive(s[1:], part1, part2[1:]):\n        return True\n    return False",
  "def is_merge_iterative(s, part1, part2):\n    tuple_list = [(s, part1, part2)]\n    while tuple_list:\n        (string, p1, p2) = tuple_list.pop()\n        if string:\n            if p1 and string[0] == p1[0]:\n                tuple_list.append((string[1:], p1[1:], p2))\n            if p2 and string[0] == p2[0]:\n                tuple_list.append((string[1:], p1, p2[1:]))\n        elif not p1 and (not p2):\n            return True\n    return False",
  "def add_binary(a, b):\n    s = ''\n    (c, i, j) = (0, len(a) - 1, len(b) - 1)\n    zero = ord('0')\n    while i >= 0 or j >= 0 or c == 1:\n        if i >= 0:\n            c += ord(a[i]) - zero\n            i -= 1\n        if j >= 0:\n            c += ord(b[j]) - zero\n            j -= 1\n        s = chr(c % 2 + zero) + s\n        c //= 2\n    return s",
  "def longest_palindrome(s):\n    if len(s) < 2:\n        return s\n    n_str = '#' + '#'.join(s) + '#'\n    p = [0] * len(n_str)\n    (mx, loc) = (0, 0)\n    (index, maxlen) = (0, 0)\n    for i in range(len(n_str)):\n        if i < mx and 2 * loc - i < len(n_str):\n            p[i] = min(mx - i, p[2 * loc - i])\n        else:\n            p[i] = 1\n        while p[i] + i < len(n_str) and i - p[i] >= 0 and (n_str[i - p[i]] == n_str[i + p[i]]):\n            p[i] += 1\n        if i + p[i] > mx:\n            mx = i + p[i]\n            loc = i\n        if p[i] > maxlen:\n            index = i\n            maxlen = p[i]\n    s = n_str[index - p[index] + 1:index + p[index]]\n    return s.replace('#', '')",
  "def min_distance(word1, word2):\n    return len(word1) + len(word2) - 2 * lcs(word1, word2, len(word1), len(word2))",
  "def lcs(s1, s2, i, j):\n    if i == 0 or j == 0:\n        return 0\n    elif s1[i - 1] == s2[j - 1]:\n        return 1 + lcs(s1, s2, i - 1, j - 1)\n    else:\n        return max(lcs(s1, s2, i - 1, j), lcs(s1, s2, i, j - 1))",
  "def reverse_vowel(s):\n    vowels = 'AEIOUaeiou'\n    (i, j) = (0, len(s) - 1)\n    s = list(s)\n    while i < j:\n        while i < j and s[i] not in vowels:\n            i += 1\n        while i < j and s[j] not in vowels:\n            j -= 1\n        (s[i], s[j]) = (s[j], s[i])\n        (i, j) = (i + 1, j - 1)\n    return ''.join(s)",
  "def flip_bit_longest_seq(num):\n    curr_len = 0\n    prev_len = 0\n    max_len = 0\n    while num:\n        if num & 1 == 1:\n            curr_len += 1\n        elif num & 1 == 0:\n            if num & 2 == 0:\n                prev_len = 0\n            else:\n                prev_len = curr_len\n            curr_len = 0\n        max_len = max(max_len, prev_len + curr_len)\n        num = num >> 1\n    return max_len + 1",
  "def count_ones_recur(n):\n    if not n:\n        return 0\n    return 1 + count_ones_recur(n & n - 1)",
  "def count_ones_iter(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count",
  "def binary_gap(N):\n    last = None\n    ans = 0\n    index = 0\n    while N != 0:\n        if N & 1:\n            if last is not None:\n                ans = max(ans, index - last)\n            last = index\n        index = index + 1\n        N = N >> 1\n    return ans",
  "def binary_gap_improved(N):\n    last = None\n    ans = 0\n    index = 0\n    while N != 0:\n        tes = N & 1\n        if tes:\n            if last is not None:\n                ans = max(ans, index - last + 1)\n            else:\n                last = index\n        else:\n            last = index + 1\n        index = index + 1\n        N = N >> 1\n    return ans",
  "def remove_bit(num, i):\n    mask = num >> i + 1\n    mask = mask << i\n    right = (1 << i) - 1 & num\n    return mask | right",
  "def reverse_bits(n):\n    m = 0\n    i = 0\n    while i < 32:\n        m = (m << 1) + (n & 1)\n        n >>= 1\n        i += 1\n    return m",
  "def swap_pair(num):\n    odd = (num & int('AAAAAAAA', 16)) >> 1\n    even = (num & int('55555555', 16)) << 1\n    return odd | even",
  "def get_bit(num, i):\n    return num & 1 << i != 0",
  "def set_bit(num, i):\n    return num | 1 << i",
  "def clear_bit(num, i):\n    mask = ~(1 << i)\n    return num & mask",
  "def update_bit(num, i, bit):\n    mask = ~(1 << i)\n    return num & mask | bit << i",
  "def single_number3(nums):\n    ab = 0\n    for n in nums:\n        ab ^= n\n    right_most = ab & -ab\n    (a, b) = (0, 0)\n    for n in nums:\n        if n & right_most:\n            a ^= n\n        else:\n            b ^= n\n    return [a, b]",
  "def single_number2(nums):\n    (ones, twos) = (0, 0)\n    for i in range(len(nums)):\n        ones = (ones ^ nums[i]) & ~twos\n        twos = (twos ^ nums[i]) & ~ones\n    return ones",
  "def insert_one_bit(num, bit, i):\n    mask = num >> i\n    mask = mask << 1 | bit\n    mask = mask << i\n    right = (1 << i) - 1 & num\n    return right | mask",
  "def insert_mult_bits(num, bits, len, i):\n    mask = num >> i\n    mask = mask << len | bits\n    mask = mask << i\n    right = (1 << i) - 1 & num\n    return right | mask",
  "def count_flips_to_convert(a, b):\n    diff = a ^ b\n    count = 0\n    while diff:\n        diff &= diff - 1\n        count += 1\n    return count",
  "def is_power_of_two(n):\n    return n > 0 and (not n & n - 1)",
  "def single_number(nums):\n    i = 0\n    for num in nums:\n        i ^= num\n    return i",
  "def add_bitwise_operator(x, y):\n    while y:\n        carry = x & y\n        x = x ^ y\n        y = carry << 1\n    return x",
  "def subsets(nums):\n    n = len(nums)\n    total = 1 << n\n    res = set()\n    for i in range(total):\n        subset = tuple((num for (j, num) in enumerate(nums) if i & 1 << j))\n        res.add(subset)\n    return res",
  "def int_to_bytes_big_endian(num):\n    bytestr = deque()\n    while num > 0:\n        bytestr.appendleft(num & 255)\n        num >>= 8\n    return bytes(bytestr)",
  "def int_to_bytes_little_endian(num):\n    bytestr = []\n    while num > 0:\n        bytestr.append(num & 255)\n        num >>= 8\n    return bytes(bytestr)",
  "def bytes_big_endian_to_int(bytestr):\n    num = 0\n    for b in bytestr:\n        num <<= 8\n        num += b\n    return num",
  "def bytes_little_endian_to_int(bytestr):\n    num = 0\n    e = 0\n    for b in bytestr:\n        num += b << e\n        e += 8\n    return num",
  "def find_difference(s, t):\n    ret = 0\n    for ch in s + t:\n        ret = ret ^ ord(ch)\n    return chr(ret)",
  "def find_missing_number(nums):\n    missing = 0\n    for (i, num) in enumerate(nums):\n        missing ^= num\n        missing ^= i + 1\n    return missing",
  "def find_missing_number2(nums):\n    num_sum = sum(nums)\n    n = len(nums)\n    total_sum = n * (n + 1) // 2\n    missing = total_sum - num_sum\n    return missing",
  "def has_alternative_bit(n):\n    first_bit = 0\n    second_bit = 0\n    while n:\n        first_bit = n & 1\n        if n >> 1:\n            second_bit = n >> 1 & 1\n            if not first_bit ^ second_bit:\n                return False\n        else:\n            return True\n        n = n >> 1\n    return True",
  "def has_alternative_bit_fast(n):\n    mask1 = int('aaaaaaaa', 16)\n    mask2 = int('55555555', 16)\n    return mask1 == n + (n ^ mask1) or mask2 == n + (n ^ mask2)",
  "def DFA(transitions, start, final, string):\n    num = len(string)\n    num_final = len(final)\n    cur = start\n    for i in range(num):\n        if transitions[cur][string[i]] is None:\n            return False\n        else:\n            cur = transitions[cur][string[i]]\n    for i in range(num_final):\n        if cur == final[i]:\n            return True\n    return False",
  "def num_islands(grid):\n    count = 0\n    for i in range(len(grid)):\n        for (j, col) in enumerate(grid[i]):\n            if col == 1:\n                dfs(grid, i, j)\n                count += 1\n    return count",
  "def dfs(grid, i, j):\n    if (i < 0 or i >= len(grid)) or (j < 0 or j >= len(grid[0])):\n        return\n    if grid[i][j] != 1:\n        return\n    grid[i][j] = 0\n    dfs(grid, i + 1, j)\n    dfs(grid, i - 1, j)\n    dfs(grid, i, j + 1)\n    dfs(grid, i, j - 1)",
  "def pacific_atlantic(matrix):\n    n = len(matrix)\n    if not n:\n        return []\n    m = len(matrix[0])\n    if not m:\n        return []\n    res = []\n    atlantic = [[False for _ in range(n)] for _ in range(m)]\n    pacific = [[False for _ in range(n)] for _ in range(m)]\n    for i in range(n):\n        dfs(pacific, matrix, float('-inf'), i, 0)\n        dfs(atlantic, matrix, float('-inf'), i, m - 1)\n    for i in range(m):\n        dfs(pacific, matrix, float('-inf'), 0, i)\n        dfs(atlantic, matrix, float('-inf'), n - 1, i)\n    for i in range(n):\n        for j in range(m):\n            if pacific[i][j] and atlantic[i][j]:\n                res.append([i, j])\n    return res",
  "def dfs(grid, matrix, height, i, j):\n    if i < 0 or i >= len(matrix) or j < 0 or (j >= len(matrix[0])):\n        return\n    if grid[i][j] or matrix[i][j] < height:\n        return\n    grid[i][j] = True\n    dfs(grid, matrix, matrix[i][j], i - 1, j)\n    dfs(grid, matrix, matrix[i][j], i + 1, j)\n    dfs(grid, matrix, matrix[i][j], i, j - 1)\n    dfs(grid, matrix, matrix[i][j], i, j + 1)",
  "def get_factors(n):\n\n    def factor(n, i, combi, res):\n        while i * i <= n:\n            if n % i == 0:\n                res += (combi + [i, int(n / i)],)\n                factor(n / i, i, combi + [i], res)\n            i += 1\n        return res\n    return factor(n, 2, [], [])",
  "def get_factors_iterative1(n):\n    (todo, res) = ([(n, 2, [])], [])\n    while todo:\n        (n, i, combi) = todo.pop()\n        while i * i <= n:\n            if n % i == 0:\n                res += (combi + [i, n // i],)\n                (todo.append((n // i, i, combi + [i])),)\n            i += 1\n    return res",
  "def get_factors_iterative2(n):\n    (ans, stack, x) = ([], [], 2)\n    while True:\n        if x > n // x:\n            if not stack:\n                return ans\n            ans.append(stack + [n])\n            x = stack.pop()\n            n *= x\n            x += 1\n        elif n % x == 0:\n            stack.append(x)\n            n //= x\n        else:\n            x += 1",
  "def factor(n, i, combi, res):\n    while i * i <= n:\n        if n % i == 0:\n            res += (combi + [i, int(n / i)],)\n            factor(n / i, i, combi + [i], res)\n        i += 1\n    return res",
  "def walls_and_gates(rooms):\n    for i in range(len(rooms)):\n        for j in range(len(rooms[0])):\n            if rooms[i][j] == 0:\n                dfs(rooms, i, j, 0)",
  "def dfs(rooms, i, j, depth):\n    if (i < 0 or i >= len(rooms)) or (j < 0 or j >= len(rooms[0])):\n        return\n    if rooms[i][j] < depth:\n        return\n    rooms[i][j] = depth\n    dfs(rooms, i + 1, j, depth + 1)\n    dfs(rooms, i - 1, j, depth + 1)\n    dfs(rooms, i, j + 1, depth + 1)\n    dfs(rooms, i, j - 1, depth + 1)",
  "def find_path(maze):\n    cnt = dfs(maze, 0, 0, 0, -1)\n    return cnt",
  "def dfs(maze, i, j, depth, cnt):\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    row = len(maze)\n    col = len(maze[0])\n    if i == row - 1 and j == col - 1:\n        if cnt == -1:\n            cnt = depth\n        elif cnt > depth:\n            cnt = depth\n        return cnt\n    maze[i][j] = 0\n    for k in range(len(directions)):\n        nx_i = i + directions[k][0]\n        nx_j = j + directions[k][1]\n        if nx_i >= 0 and nx_i < row and (nx_j >= 0) and (nx_j < col):\n            if maze[nx_i][nx_j] == 1:\n                cnt = dfs(maze, nx_i, nx_j, depth + 1, cnt)\n    maze[i][j] = 1\n    return cnt",
  "def __init__(self, board, row, col):\n    self.board = board\n    self.row = row\n    self.col = col\n    self.val = self.possible_values()",
  "def possible_values(self):\n    a = '123456789'\n    (d, val) = ({}, {})\n    for i in range(self.row):\n        for j in range(self.col):\n            ele = self.board[i][j]\n            if ele != '.':\n                d['r', i] = d.get(('r', i), []) + [ele]\n                d['c', j] = d.get(('c', j), []) + [ele]\n                d[i // 3, j // 3] = d.get((i // 3, j // 3), []) + [ele]\n            else:\n                val[i, j] = []\n    for (i, j) in val.keys():\n        inval = d.get(('r', i), []) + d.get(('c', j), []) + d.get((i / 3, j / 3), [])\n        val[i, j] = [n for n in a if n not in inval]\n    return val",
  "def solve(self):\n    if len(self.val) == 0:\n        return True\n    kee = min(self.val.keys(), key=lambda x: len(self.val[x]))\n    nums = self.val[kee]\n    for n in nums:\n        update = {kee: self.val[kee]}\n        if self.valid_one(n, kee, update):\n            if self.solve():\n                return True\n        self.undo(kee, update)\n    return False",
  "def valid_one(self, n, kee, update):\n    self.board[kee[0]][kee[1]] = n\n    del self.val[kee]\n    (i, j) = kee\n    for ind in self.val.keys():\n        if n in self.val[ind]:\n            if ind[0] == i or ind[1] == j or (ind[0] / 3, ind[1] / 3) == (i / 3, j / 3):\n                update[ind] = n\n                self.val[ind].remove(n)\n                if len(self.val[ind]) == 0:\n                    return False\n    return True",
  "def undo(self, kee, update):\n    self.board[kee[0]][kee[1]] = '.'\n    for k in update:\n        if k not in self.val:\n            self.val[k] = update[k]\n        else:\n            self.val[k].append(update[k])\n    return None",
  "def __str__(self):\n    resp = ''\n    for i in range(self.row):\n        for j in range(self.col):\n            resp += ' {0} '.format(self.board[i][j])\n        resp += '\\n'\n    return resp",
  "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    while gap > 0:\n        y_index = gap\n        while y_index < len(arr):\n            y = arr[y_index]\n            x_index = y_index - gap\n            while x_index >= 0 and y < arr[x_index]:\n                arr[x_index + gap] = arr[x_index]\n                x_index = x_index - gap\n            arr[x_index + gap] = y\n            y_index = y_index + 1\n        gap = gap // 2\n    return arr",
  "def bucket_sort(arr):\n    num_buckets = len(arr)\n    buckets = [[] for bucket in range(num_buckets)]\n    for value in arr:\n        index = value * num_buckets // (max(arr) + 1)\n        buckets[index].append(value)\n    sorted_list = []\n    for i in range(num_buckets):\n        sorted_list.extend(next_sort(buckets[i]))\n    return sorted_list",
  "def next_sort(arr):\n    for i in range(1, len(arr)):\n        j = i - 1\n        key = arr[i]\n        while arr[j] > key and j >= 0:\n            arr[j + 1] = arr[j]\n            j = j - 1\n        arr[j + 1] = key\n    return arr",
  "def quick_sort(arr, simulation=False):\n    iteration = 0\n    if simulation:\n        print('iteration', iteration, ':', *arr)\n    (arr, _) = quick_sort_recur(arr, 0, len(arr) - 1, iteration, simulation)\n    return arr",
  "def quick_sort_recur(arr, first, last, iteration, simulation):\n    if first < last:\n        pos = partition(arr, first, last)\n        if simulation:\n            iteration = iteration + 1\n            print('iteration', iteration, ':', *arr)\n        (_, iteration) = quick_sort_recur(arr, first, pos - 1, iteration, simulation)\n        (_, iteration) = quick_sort_recur(arr, pos + 1, last, iteration, simulation)\n    return (arr, iteration)",
  "def partition(arr, first, last):\n    wall = first\n    for pos in range(first, last):\n        if arr[pos] < arr[last]:\n            (arr[pos], arr[wall]) = (arr[wall], arr[pos])\n            wall += 1\n    (arr[wall], arr[last]) = (arr[last], arr[wall])\n    return wall",
  "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    (left, right) = (merge_sort(arr[:mid]), merge_sort(arr[mid:]))\n    return merge(left, right, arr.copy())",
  "def merge(left, right, merged):\n    (left_cursor, right_cursor) = (0, 0)\n    while left_cursor < len(left) and right_cursor < len(right):\n        if left[left_cursor] <= right[right_cursor]:\n            merged[left_cursor + right_cursor] = left[left_cursor]\n            left_cursor += 1\n        else:\n            merged[left_cursor + right_cursor] = right[right_cursor]\n            right_cursor += 1\n    for left_cursor in range(left_cursor, len(left)):\n        merged[left_cursor + right_cursor] = left[left_cursor]\n    for right_cursor in range(right_cursor, len(right)):\n        merged[left_cursor + right_cursor] = right[right_cursor]\n    return merged",
  "def cycle_sort(arr):\n    len_arr = len(arr)\n    for cur in range(len_arr - 1):\n        item = arr[cur]\n        index = cur\n        for i in range(cur + 1, len_arr):\n            if arr[i] < item:\n                index += 1\n        if index == cur:\n            continue\n        while item == arr[index]:\n            index += 1\n        (arr[index], item) = (item, arr[index])\n        while index != cur:\n            index = cur\n            for i in range(cur + 1, len_arr):\n                if arr[i] < item:\n                    index += 1\n            while item == arr[index]:\n                index += 1\n            (arr[index], item) = (item, arr[index])\n    return arr",
  "def pigeonhole_sort(arr):\n    Max = max(arr)\n    Min = min(arr)\n    size = Max - Min + 1\n    holes = [0] * size\n    for i in arr:\n        holes[i - Min] += 1\n    i = 0\n    for count in range(size):\n        while holes[count] > 0:\n            holes[count] -= 1\n            arr[i] = count + Min\n            i += 1\n    return arr",
  "def top_sort_recursive(graph):\n    (order, enter, state) = ([], set(graph), {})\n\n    def dfs(node):\n        state[node] = GRAY\n        for k in graph.get(node, ()):\n            sk = state.get(k, None)\n            if sk == GRAY:\n                raise ValueError('cycle')\n            if sk == BLACK:\n                continue\n            enter.discard(k)\n            dfs(k)\n        order.append(node)\n        state[node] = BLACK\n    while enter:\n        dfs(enter.pop())\n    return order",
  "def top_sort(graph):\n    (order, enter, state) = ([], set(graph), {})\n\n    def is_ready(node):\n        lst = graph.get(node, ())\n        if len(lst) == 0:\n            return True\n        for k in lst:\n            sk = state.get(k, None)\n            if sk == GRAY:\n                raise ValueError('cycle')\n            if sk != BLACK:\n                return False\n        return True\n    while enter:\n        node = enter.pop()\n        stack = []\n        while True:\n            state[node] = GRAY\n            stack.append(node)\n            for k in graph.get(node, ()):\n                sk = state.get(k, None)\n                if sk == GRAY:\n                    raise ValueError('cycle')\n                if sk == BLACK:\n                    continue\n                enter.discard(k)\n                stack.append(k)\n            while stack and is_ready(stack[-1]):\n                node = stack.pop()\n                order.append(node)\n                state[node] = BLACK\n            if len(stack) == 0:\n                break\n            node = stack.pop()\n    return order",
  "def dfs(node):\n    state[node] = GRAY\n    for k in graph.get(node, ()):\n        sk = state.get(k, None)\n        if sk == GRAY:\n            raise ValueError('cycle')\n        if sk == BLACK:\n            continue\n        enter.discard(k)\n        dfs(k)\n    order.append(node)\n    state[node] = BLACK",
  "def is_ready(node):\n    lst = graph.get(node, ())\n    if len(lst) == 0:\n        return True\n    for k in lst:\n        sk = state.get(k, None)\n        if sk == GRAY:\n            raise ValueError('cycle')\n        if sk != BLACK:\n            return False\n    return True",
  "def pancake_sort(arr):\n    len_arr = len(arr)\n    if len_arr <= 1:\n        return arr\n    for cur in range(len(arr), 1, -1):\n        index_max = arr.index(max(arr[0:cur]))\n        if index_max + 1 != cur:\n            if index_max != 0:\n                arr[:index_max + 1] = reversed(arr[:index_max + 1])\n            arr[:cur] = reversed(arr[:cur])\n    return arr",
  "def insertion_sort(arr, simulation=False):\n    iteration = 0\n    if simulation:\n        print('iteration', iteration, ':', *arr)\n    for i in range(len(arr)):\n        cursor = arr[i]\n        pos = i\n        while pos > 0 and arr[pos - 1] > cursor:\n            arr[pos] = arr[pos - 1]\n            pos = pos - 1\n        arr[pos] = cursor\n        if simulation:\n            iteration = iteration + 1\n            print('iteration', iteration, ':', *arr)\n    return arr",
  "def gnome_sort(arr):\n    n = len(arr)\n    index = 0\n    while index < n:\n        if index == 0 or arr[index] >= arr[index - 1]:\n            index = index + 1\n        else:\n            (arr[index], arr[index - 1]) = (arr[index - 1], arr[index])\n            index = index - 1\n    return arr",
  "def bubble_sort(arr, simulation=False):\n\n    def swap(i, j):\n        (arr[i], arr[j]) = (arr[j], arr[i])\n    n = len(arr)\n    swapped = True\n    iteration = 0\n    if simulation:\n        print('iteration', iteration, ':', *arr)\n    x = -1\n    while swapped:\n        swapped = False\n        x = x + 1\n        for i in range(1, n - x):\n            if arr[i - 1] > arr[i]:\n                swap(i - 1, i)\n                swapped = True\n                if simulation:\n                    iteration = iteration + 1\n                    print('iteration', iteration, ':', *arr)\n    return arr",
  "def swap(i, j):\n    (arr[i], arr[j]) = (arr[j], arr[i])",
  "def stoogesort(arr, l, h):\n    if l >= h:\n        return\n    if arr[l] > arr[h]:\n        t = arr[l]\n        arr[l] = arr[h]\n        arr[h] = t\n    if h - l + 1 > 2:\n        t = int((h - l + 1) / 3)\n        stoogesort(arr, l, h - t)\n        stoogesort(arr, l + t, h)\n        stoogesort(arr, l, h - t)",
  "def selection_sort(arr, simulation=False):\n    iteration = 0\n    if simulation:\n        print('iteration', iteration, ':', *arr)\n    for i in range(len(arr)):\n        minimum = i\n        for j in range(i + 1, len(arr)):\n            if arr[j] < arr[minimum]:\n                minimum = j\n        (arr[minimum], arr[i]) = (arr[i], arr[minimum])\n        if simulation:\n            iteration = iteration + 1\n            print('iteration', iteration, ':', *arr)\n    return arr",
  "def bogo_sort(arr, simulation=False):\n    iteration = 0\n    if simulation:\n        print('iteration', iteration, ':', *arr)\n\n    def is_sorted(arr):\n        i = 0\n        arr_len = len(arr)\n        while i + 1 < arr_len:\n            if arr[i] > arr[i + 1]:\n                return False\n            i += 1\n        return True\n    while not is_sorted(arr):\n        random.shuffle(arr)\n        if simulation:\n            iteration = iteration + 1\n            print('iteration', iteration, ':', *arr)\n    return arr",
  "def is_sorted(arr):\n    i = 0\n    arr_len = len(arr)\n    while i + 1 < arr_len:\n        if arr[i] > arr[i + 1]:\n            return False\n        i += 1\n    return True",
  "def radix_sort(arr, simulation=False):\n    position = 1\n    max_number = max(arr)\n    iteration = 0\n    if simulation:\n        print('iteration', iteration, ':', *arr)\n    while position <= max_number:\n        queue_list = [list() for _ in range(10)]\n        for num in arr:\n            digit_number = num // position % 10\n            queue_list[digit_number].append(num)\n        index = 0\n        for numbers in queue_list:\n            for num in numbers:\n                arr[index] = num\n                index += 1\n        if simulation:\n            iteration = iteration + 1\n            print('iteration', iteration, ':', *arr)\n        position *= 10\n    return arr",
  "def counting_sort(arr):\n    m = min(arr)\n    different = 0\n    if m < 0:\n        different = -m\n        for i in range(len(arr)):\n            arr[i] += -m\n    k = max(arr)\n    temp_arr = [0] * (k + 1)\n    for i in range(0, len(arr)):\n        temp_arr[arr[i]] = temp_arr[arr[i]] + 1\n    for i in range(1, k + 1):\n        temp_arr[i] = temp_arr[i] + temp_arr[i - 1]\n    result_arr = arr.copy()\n    for i in range(len(arr) - 1, -1, -1):\n        result_arr[temp_arr[arr[i]] - 1] = arr[i] - different\n        temp_arr[arr[i]] = temp_arr[arr[i]] - 1\n    return result_arr",
  "def wiggle_sort(nums):\n    for i in range(len(nums)):\n        if (i % 2 == 1) == (nums[i - 1] > nums[i]):\n            (nums[i - 1], nums[i]) = (nums[i], nums[i - 1])",
  "def sort_colors(nums):\n    i = j = 0\n    for k in range(len(nums)):\n        v = nums[k]\n        nums[k] = 2\n        if v < 2:\n            nums[j] = 1\n            j += 1\n        if v == 0:\n            nums[i] = 0\n            i += 1",
  "def max_heap_sort(arr, simulation=False):\n    iteration = 0\n    if simulation:\n        print('iteration', iteration, ':', *arr)\n    for i in range(len(arr) - 1, 0, -1):\n        iteration = max_heapify(arr, i, simulation, iteration)\n    if simulation:\n        iteration = iteration + 1\n        print('iteration', iteration, ':', *arr)\n    return arr",
  "def max_heapify(arr, end, simulation, iteration):\n    last_parent = (end - 1) // 2\n    for parent in range(last_parent, -1, -1):\n        current_parent = parent\n        while current_parent <= last_parent:\n            child = 2 * current_parent + 1\n            if child + 1 <= end and arr[child] < arr[child + 1]:\n                child = child + 1\n            if arr[child] > arr[current_parent]:\n                (arr[current_parent], arr[child]) = (arr[child], arr[current_parent])\n                current_parent = child\n                if simulation:\n                    iteration = iteration + 1\n                    print('iteration', iteration, ':', *arr)\n            else:\n                break\n    (arr[0], arr[end]) = (arr[end], arr[0])\n    return iteration",
  "def min_heap_sort(arr, simulation=False):\n    iteration = 0\n    if simulation:\n        print('iteration', iteration, ':', *arr)\n    for i in range(0, len(arr) - 1):\n        iteration = min_heapify(arr, i, simulation, iteration)\n    return arr",
  "def min_heapify(arr, start, simulation, iteration):\n    end = len(arr) - 1\n    last_parent = (end - start - 1) // 2\n    for parent in range(last_parent, -1, -1):\n        current_parent = parent\n        while current_parent <= last_parent:\n            child = 2 * current_parent + 1\n            if child + 1 <= end - start and arr[child + start] > arr[child + 1 + start]:\n                child = child + 1\n            if arr[child + start] < arr[current_parent + start]:\n                (arr[current_parent + start], arr[child + start]) = (arr[child + start], arr[current_parent + start])\n                current_parent = child\n                if simulation:\n                    iteration = iteration + 1\n                    print('iteration', iteration, ':', *arr)\n            else:\n                break\n    return iteration",
  "def exchange_sort(arr):\n    arr_len = len(arr)\n    for i in range(arr_len - 1):\n        for j in range(i + 1, arr_len):\n            if arr[i] > arr[j]:\n                (arr[i], arr[j]) = (arr[j], arr[i])\n    return arr",
  "def cocktail_shaker_sort(arr):\n\n    def swap(i, j):\n        (arr[i], arr[j]) = (arr[j], arr[i])\n    n = len(arr)\n    swapped = True\n    while swapped:\n        swapped = False\n        for i in range(1, n):\n            if arr[i - 1] > arr[i]:\n                swap(i - 1, i)\n                swapped = True\n        if swapped == False:\n            return arr\n        swapped = False\n        for i in range(n - 1, 0, -1):\n            if arr[i - 1] > arr[i]:\n                swap(i - 1, i)\n                swapped = True\n    return arr",
  "def swap(i, j):\n    (arr[i], arr[j]) = (arr[j], arr[i])",
  "def comb_sort(arr):\n\n    def swap(i, j):\n        (arr[i], arr[j]) = (arr[j], arr[i])\n    n = len(arr)\n    gap = n\n    shrink = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink)\n        if gap > 1:\n            sorted = False\n        else:\n            gap = 1\n            sorted = True\n        i = 0\n        while i + gap < n:\n            if arr[i] > arr[i + gap]:\n                swap(i, i + gap)\n                sorted = False\n            i = i + 1\n    return arr",
  "def swap(i, j):\n    (arr[i], arr[j]) = (arr[j], arr[i])",
  "def can_attend_meetings(intervals):\n    intervals = sorted(intervals, key=lambda x: x.start)\n    for i in range(1, len(intervals)):\n        if intervals[i].start < intervals[i - 1].end:\n            return False\n    return True",
  "def bitonic_sort(arr, reverse=False):\n\n    def compare(arr, reverse):\n        n = len(arr) // 2\n        for i in range(n):\n            if reverse != (arr[i] > arr[i + n]):\n                (arr[i], arr[i + n]) = (arr[i + n], arr[i])\n        return arr\n\n    def bitonic_merge(arr, reverse):\n        n = len(arr)\n        if n <= 1:\n            return arr\n        arr = compare(arr, reverse)\n        left = bitonic_merge(arr[:n // 2], reverse)\n        right = bitonic_merge(arr[n // 2:], reverse)\n        return left + right\n    n = len(arr)\n    if n <= 1:\n        return arr\n    if not (n and (not n & n - 1)):\n        raise ValueError('the size of input should be power of two')\n    left = bitonic_sort(arr[:n // 2], True)\n    right = bitonic_sort(arr[n // 2:], False)\n    arr = bitonic_merge(left + right, reverse)\n    return arr",
  "def compare(arr, reverse):\n    n = len(arr) // 2\n    for i in range(n):\n        if reverse != (arr[i] > arr[i + n]):\n            (arr[i], arr[i + n]) = (arr[i + n], arr[i])\n    return arr",
  "def bitonic_merge(arr, reverse):\n    n = len(arr)\n    if n <= 1:\n        return arr\n    arr = compare(arr, reverse)\n    left = bitonic_merge(arr[:n // 2], reverse)\n    right = bitonic_merge(arr[n // 2:], reverse)\n    return left + right",
  "def find_words(board, words):\n\n    def backtrack(board, i, j, trie, pre, used, result):\n        if '#' in trie:\n            result.add(pre)\n        if i < 0 or i >= len(board) or j < 0 or (j >= len(board[0])):\n            return\n        if not used[i][j] and board[i][j] in trie:\n            used[i][j] = True\n            backtrack(board, i + 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n            backtrack(board, i, j + 1, trie[board[i][j]], pre + board[i][j], used, result)\n            backtrack(board, i - 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n            backtrack(board, i, j - 1, trie[board[i][j]], pre + board[i][j], used, result)\n            used[i][j] = False\n    trie = {}\n    for word in words:\n        curr_trie = trie\n        for char in word:\n            if char not in curr_trie:\n                curr_trie[char] = {}\n            curr_trie = curr_trie[char]\n        curr_trie['#'] = '#'\n    result = set()\n    used = [[False] * len(board[0]) for _ in range(len(board))]\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            backtrack(board, i, j, trie, '', used, result)\n    return list(result)",
  "def backtrack(board, i, j, trie, pre, used, result):\n    if '#' in trie:\n        result.add(pre)\n    if i < 0 or i >= len(board) or j < 0 or (j >= len(board[0])):\n        return\n    if not used[i][j] and board[i][j] in trie:\n        used[i][j] = True\n        backtrack(board, i + 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n        backtrack(board, i, j + 1, trie[board[i][j]], pre + board[i][j], used, result)\n        backtrack(board, i - 1, j, trie[board[i][j]], pre + board[i][j], used, result)\n        backtrack(board, i, j - 1, trie[board[i][j]], pre + board[i][j], used, result)\n        used[i][j] = False",
  "def permute(elements):\n    if len(elements) <= 1:\n        return [elements]\n    else:\n        tmp = []\n        for perm in permute(elements[1:]):\n            for i in range(len(elements)):\n                tmp.append(perm[:i] + elements[0:1] + perm[i:])\n        return tmp",
  "def permute_iter(elements):\n    if len(elements) <= 1:\n        yield elements\n    else:\n        for perm in permute_iter(elements[1:]):\n            for i in range(len(elements)):\n                yield (perm[:i] + elements[0:1] + perm[i:])",
  "def permute_recursive(nums):\n\n    def dfs(res, nums, path):\n        if not nums:\n            res.append(path)\n        for i in range(len(nums)):\n            print(nums[:i] + nums[i + 1:])\n            dfs(res, nums[:i] + nums[i + 1:], path + [nums[i]])\n    res = []\n    dfs(res, nums, [])\n    return res",
  "def dfs(res, nums, path):\n    if not nums:\n        res.append(path)\n    for i in range(len(nums)):\n        print(nums[:i] + nums[i + 1:])\n        dfs(res, nums[:i] + nums[i + 1:], path + [nums[i]])",
  "def subsets_unique(nums):\n\n    def backtrack(res, nums, stack, pos):\n        if pos == len(nums):\n            res.add(tuple(stack))\n        else:\n            stack.append(nums[pos])\n            backtrack(res, nums, stack, pos + 1)\n            stack.pop()\n            backtrack(res, nums, stack, pos + 1)\n    res = set()\n    backtrack(res, nums, [], 0)\n    return list(res)",
  "def backtrack(res, nums, stack, pos):\n    if pos == len(nums):\n        res.add(tuple(stack))\n    else:\n        stack.append(nums[pos])\n        backtrack(res, nums, stack, pos + 1)\n        stack.pop()\n        backtrack(res, nums, stack, pos + 1)",
  "def array_sum_combinations(A, B, C, target):\n\n    def over(constructed_sofar):\n        sum = 0\n        (to_stop, reached_target) = (False, False)\n        for elem in constructed_sofar:\n            sum += elem\n        if sum >= target or len(constructed_sofar) >= 3:\n            to_stop = True\n            if sum == target and 3 == len(constructed_sofar):\n                reached_target = True\n        return (to_stop, reached_target)\n\n    def construct_candidates(constructed_sofar):\n        array = A\n        if 1 == len(constructed_sofar):\n            array = B\n        elif 2 == len(constructed_sofar):\n            array = C\n        return array\n\n    def backtrack(constructed_sofar=[], res=[]):\n        (to_stop, reached_target) = over(constructed_sofar)\n        if to_stop:\n            if reached_target:\n                res.append(constructed_sofar)\n            return\n        candidates = construct_candidates(constructed_sofar)\n        for candidate in candidates:\n            constructed_sofar.append(candidate)\n            backtrack(constructed_sofar[:], res)\n            constructed_sofar.pop()\n    res = []\n    backtrack([], res)\n    return res",
  "def unique_array_sum_combinations(A, B, C, target):\n\n    def check_sum(n, *nums):\n        if sum((x for x in nums)) == n:\n            return (True, nums)\n        else:\n            return (False, nums)\n    pro = itertools.product(A, B, C)\n    func = partial(check_sum, target)\n    sums = list(itertools.starmap(func, pro))\n    res = set()\n    for s in sums:\n        if s[0] is True and s[1] not in res:\n            res.add(s[1])\n    return list(res)",
  "def over(constructed_sofar):\n    sum = 0\n    (to_stop, reached_target) = (False, False)\n    for elem in constructed_sofar:\n        sum += elem\n    if sum >= target or len(constructed_sofar) >= 3:\n        to_stop = True\n        if sum == target and 3 == len(constructed_sofar):\n            reached_target = True\n    return (to_stop, reached_target)",
  "def construct_candidates(constructed_sofar):\n    array = A\n    if 1 == len(constructed_sofar):\n        array = B\n    elif 2 == len(constructed_sofar):\n        array = C\n    return array",
  "def backtrack(constructed_sofar=[], res=[]):\n    (to_stop, reached_target) = over(constructed_sofar)\n    if to_stop:\n        if reached_target:\n            res.append(constructed_sofar)\n        return\n    candidates = construct_candidates(constructed_sofar)\n    for candidate in candidates:\n        constructed_sofar.append(candidate)\n        backtrack(constructed_sofar[:], res)\n        constructed_sofar.pop()",
  "def check_sum(n, *nums):\n    if sum((x for x in nums)) == n:\n        return (True, nums)\n    else:\n        return (False, nums)",
  "def anagram(s1, s2):\n    c1 = [0] * 26\n    c2 = [0] * 26\n    for c in s1:\n        pos = ord(c) - ord('a')\n        c1[pos] = c1[pos] + 1\n    for c in s2:\n        pos = ord(c) - ord('a')\n        c2[pos] = c2[pos] + 1\n    return c1 == c2",
  "def permute_unique(nums):\n    perms = [[]]\n    for n in nums:\n        new_perms = []\n        for l in perms:\n            for i in range(len(l) + 1):\n                new_perms.append(l[:i] + [n] + l[i:])\n                if i < len(l) and l[i] == n:\n                    break\n        perms = new_perms\n    return perms",
  "def letter_combinations(digits):\n    if digits == '':\n        return []\n    kmaps = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n    ans = ['']\n    for num in digits:\n        tmp = []\n        for an in ans:\n            for char in kmaps[num]:\n                tmp.append(an + char)\n        ans = tmp\n    return ans",
  "def get_factors(n):\n    (todo, combis) = ([(n, 2, [])], [])\n    while todo:\n        (n, i, combi) = todo.pop()\n        while i * i <= n:\n            if n % i == 0:\n                combis.append(combi + [i, n // i])\n                todo.append((n // i, i, combi + [i]))\n            i += 1\n    return combis",
  "def recursive_get_factors(n):\n\n    def factor(n, i, combi, combis):\n        while i * i <= n:\n            if n % i == 0:\n                (combis.append(combi + [i, n // i]),)\n                factor(n // i, i, combi + [i], combis)\n            i += 1\n        return combis\n    return factor(n, 2, [], [])",
  "def factor(n, i, combi, combis):\n    while i * i <= n:\n        if n % i == 0:\n            (combis.append(combi + [i, n // i]),)\n            factor(n // i, i, combi + [i], combis)\n        i += 1\n    return combis",
  "def add_operators(num, target):\n\n    def dfs(res, path, num, target, pos, prev, multed):\n        if pos == len(num):\n            if target == prev:\n                res.append(path)\n            return\n        for i in range(pos, len(num)):\n            if i != pos and num[pos] == '0':\n                break\n            cur = int(num[pos:i + 1])\n            if pos == 0:\n                dfs(res, path + str(cur), num, target, i + 1, cur, cur)\n            else:\n                dfs(res, path + '+' + str(cur), num, target, i + 1, prev + cur, cur)\n                dfs(res, path + '-' + str(cur), num, target, i + 1, prev - cur, -cur)\n                dfs(res, path + '*' + str(cur), num, target, i + 1, prev - multed + multed * cur, multed * cur)\n    res = []\n    if not num:\n        return res\n    dfs(res, '', num, target, 0, 0, 0)\n    return res",
  "def dfs(res, path, num, target, pos, prev, multed):\n    if pos == len(num):\n        if target == prev:\n            res.append(path)\n        return\n    for i in range(pos, len(num)):\n        if i != pos and num[pos] == '0':\n            break\n        cur = int(num[pos:i + 1])\n        if pos == 0:\n            dfs(res, path + str(cur), num, target, i + 1, cur, cur)\n        else:\n            dfs(res, path + '+' + str(cur), num, target, i + 1, prev + cur, cur)\n            dfs(res, path + '-' + str(cur), num, target, i + 1, prev - cur, -cur)\n            dfs(res, path + '*' + str(cur), num, target, i + 1, prev - multed + multed * cur, multed * cur)",
  "def subsets(nums):\n\n    def backtrack(res, nums, stack, pos):\n        if pos == len(nums):\n            res.append(list(stack))\n        else:\n            stack.append(nums[pos])\n            backtrack(res, nums, stack, pos + 1)\n            stack.pop()\n            backtrack(res, nums, stack, pos + 1)\n    res = []\n    backtrack(res, nums, [], 0)\n    return res",
  "def subsets_v2(nums):\n    res = [[]]\n    for num in sorted(nums):\n        res += [item + [num] for item in res]\n    return res",
  "def backtrack(res, nums, stack, pos):\n    if pos == len(nums):\n        res.append(list(stack))\n    else:\n        stack.append(nums[pos])\n        backtrack(res, nums, stack, pos + 1)\n        stack.pop()\n        backtrack(res, nums, stack, pos + 1)",
  "def generate_parenthesis_v1(n):\n\n    def add_pair(res, s, left, right):\n        if left == 0 and right == 0:\n            res.append(s)\n            return\n        if right > 0:\n            add_pair(res, s + ')', left, right - 1)\n        if left > 0:\n            add_pair(res, s + '(', left - 1, right + 1)\n    res = []\n    add_pair(res, '', n, 0)\n    return res",
  "def generate_parenthesis_v2(n):\n\n    def add_pair(res, s, left, right):\n        if left == 0 and right == 0:\n            res.append(s)\n        if left > 0:\n            add_pair(res, s + '(', left - 1, right)\n        if right > 0 and left < right:\n            add_pair(res, s + ')', left, right - 1)\n    res = []\n    add_pair(res, '', n, n)\n    return res",
  "def add_pair(res, s, left, right):\n    if left == 0 and right == 0:\n        res.append(s)\n        return\n    if right > 0:\n        add_pair(res, s + ')', left, right - 1)\n    if left > 0:\n        add_pair(res, s + '(', left - 1, right + 1)",
  "def add_pair(res, s, left, right):\n    if left == 0 and right == 0:\n        res.append(s)\n    if left > 0:\n        add_pair(res, s + '(', left - 1, right)\n    if right > 0 and left < right:\n        add_pair(res, s + ')', left, right - 1)",
  "def generate_abbreviations(word):\n\n    def backtrack(result, word, pos, count, cur):\n        if pos == len(word):\n            if count > 0:\n                cur += str(count)\n            result.append(cur)\n            return\n        if count > 0:\n            backtrack(result, word, pos + 1, 0, cur + str(count) + word[pos])\n        else:\n            backtrack(result, word, pos + 1, 0, cur + word[pos])\n        backtrack(result, word, pos + 1, count + 1, cur)\n    result = []\n    backtrack(result, word, 0, 0, '')\n    return result",
  "def backtrack(result, word, pos, count, cur):\n    if pos == len(word):\n        if count > 0:\n            cur += str(count)\n        result.append(cur)\n        return\n    if count > 0:\n        backtrack(result, word, pos + 1, 0, cur + str(count) + word[pos])\n    else:\n        backtrack(result, word, pos + 1, 0, cur + word[pos])\n    backtrack(result, word, pos + 1, count + 1, cur)",
  "def pattern_match(pattern, string):\n\n    def backtrack(pattern, string, dic):\n        if len(pattern) == 0 and len(string) > 0:\n            return False\n        if len(pattern) == len(string) == 0:\n            return True\n        for end in range(1, len(string) - len(pattern) + 2):\n            if pattern[0] not in dic and string[:end] not in dic.values():\n                dic[pattern[0]] = string[:end]\n                if backtrack(pattern[1:], string[end:], dic):\n                    return True\n                del dic[pattern[0]]\n            elif pattern[0] in dic and dic[pattern[0]] == string[:end]:\n                if backtrack(pattern[1:], string[end:], dic):\n                    return True\n        return False\n    return backtrack(pattern, string, {})",
  "def backtrack(pattern, string, dic):\n    if len(pattern) == 0 and len(string) > 0:\n        return False\n    if len(pattern) == len(string) == 0:\n        return True\n    for end in range(1, len(string) - len(pattern) + 2):\n        if pattern[0] not in dic and string[:end] not in dic.values():\n            dic[pattern[0]] = string[:end]\n            if backtrack(pattern[1:], string[end:], dic):\n                return True\n            del dic[pattern[0]]\n        elif pattern[0] in dic and dic[pattern[0]] == string[:end]:\n            if backtrack(pattern[1:], string[end:], dic):\n                return True\n    return False",
  "def palindromic_substrings(s):\n    if not s:\n        return [[]]\n    results = []\n    for i in range(len(s), 0, -1):\n        sub = s[:i]\n        if sub == sub[::-1]:\n            for rest in palindromic_substrings(s[i:]):\n                results.append([sub] + rest)\n    return results",
  "def palindromic_substrings_iter(s):\n    if not s:\n        yield []\n        return\n    for i in range(len(s), 0, -1):\n        sub = s[:i]\n        if sub == sub[::-1]:\n            for rest in palindromic_substrings_iter(s[i:]):\n                yield ([sub] + rest)",
  "def combination_sum(candidates, target):\n\n    def dfs(nums, target, index, path, res):\n        if target < 0:\n            return\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(index, len(nums)):\n            dfs(nums, target - nums[i], i, path + [nums[i]], res)\n    res = []\n    candidates.sort()\n    dfs(candidates, target, 0, [], res)\n    return res",
  "def dfs(nums, target, index, path, res):\n    if target < 0:\n        return\n    if target == 0:\n        res.append(path)\n        return\n    for i in range(index, len(nums)):\n        dfs(nums, target - nums[i], i, path + [nums[i]], res)",
  "def num_islands(positions):\n    ans = []\n    islands = Union()\n    for position in map(tuple, positions):\n        islands.add(position)\n        for delta in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n            adjacent = (position[0] + delta[0], position[1] + delta[1])\n            if adjacent in islands.parents:\n                islands.unite(position, adjacent)\n        ans += [islands.count]\n    return ans",
  "def __init__(self):\n    self.parents = {}\n    self.size = {}\n    self.count = 0",
  "def add(self, element):\n    self.parents[element] = element\n    self.size[element] = 1\n    self.count += 1",
  "def root(self, element):\n    while element != self.parents[element]:\n        self.parents[element] = self.parents[self.parents[element]]\n        element = self.parents[element]\n    return element",
  "def unite(self, element1, element2):\n    (root1, root2) = (self.root(element1), self.root(element2))\n    if root1 == root2:\n        return\n    if self.size[root1] > self.size[root2]:\n        (root1, root2) = (root2, root1)\n    self.parents[root1] = root2\n    self.size[root2] += self.size[root1]\n    self.count -= 1",
  "def rotate_right(head, k):\n    if not head or not head.next:\n        return head\n    current = head\n    length = 1\n    while current.next:\n        current = current.next\n        length += 1\n    current.next = head\n    k = k % length\n    for i in range(length - k):\n        current = current.next\n    head = current.next\n    current.next = None\n    return head",
  "def print_linked_list(head):\n    string = ''\n    while head.next:\n        string += str(head.val) + ' -> '\n        head = head.next\n    string += str(head.val)\n    print(string)",
  "def partition(head, x):\n    left = None\n    right = None\n    prev = None\n    current = head\n    while current:\n        if int(current.val) >= x:\n            if not right:\n                right = current\n        elif not left:\n            left = current\n        else:\n            prev.next = current.next\n            left.next = current\n            left = current\n            left.next = right\n        if prev and prev.next is None:\n            break\n        prev = current\n        current = current.next",
  "def test():\n    a = Node('3')\n    b = Node('5')\n    c = Node('8')\n    d = Node('5')\n    e = Node('10')\n    f = Node('2')\n    g = Node('1')\n    a.next = b\n    b.next = c\n    c.next = d\n    d.next = e\n    e.next = f\n    f.next = g\n    print_linked_list(a)\n    partition(a, 5)\n    print_linked_list(a)",
  "def __init__(self, val=None):\n    self.val = int(val)\n    self.next = None",
  "def reverse_list(head):\n    if not head or not head.next:\n        return head\n    prev = None\n    while head:\n        current = head\n        head = head.next\n        current.next = prev\n        prev = current\n    return prev",
  "def reverse_list_recursive(head):\n    if head is None or head.next is None:\n        return head\n    p = head.next\n    head.next = None\n    revrest = reverse_list_recursive(p)\n    p.next = head\n    return revrest",
  "def merge_two_list(l1, l2):\n    ret = cur = Node(0)\n    while l1 and l2:\n        if l1.val < l2.val:\n            cur.next = l1\n            l1 = l1.next\n        else:\n            cur.next = l2\n            l2 = l2.next\n        cur = cur.next\n    cur.next = l1 or l2\n    return ret.next",
  "def merge_two_list_recur(l1, l2):\n    if not l1 or not l2:\n        return l1 or l2\n    if l1.val < l2.val:\n        l1.next = merge_two_list_recur(l1.next, l2)\n        return l1\n    else:\n        l2.next = merge_two_list_recur(l1, l2.next)\n        return l2",
  "def __init__(self, x):\n    self.val = x\n    self.next = None",
  "def delete_node(node):\n    if node is None or node.next is None:\n        raise ValueError\n    node.val = node.next.val\n    node.next = node.next.next",
  "def __init__(self, x):\n    self.val = x\n    self.next = None",
  "def test_delete_node(self):\n    head = Node(1)\n    curr = head\n    for i in range(2, 6):\n        curr.next = Node(i)\n        curr = curr.next\n    node3 = head.next.next\n    delete_node(node3)\n    curr = head\n    self.assertEqual(1, curr.val)\n    curr = curr.next\n    self.assertEqual(2, curr.val)\n    curr = curr.next\n    self.assertEqual(4, curr.val)\n    curr = curr.next\n    self.assertEqual(5, curr.val)\n    tail = curr\n    self.assertIsNone(tail.next)\n    self.assertRaises(ValueError, delete_node, tail)\n    self.assertRaises(ValueError, delete_node, tail.next)",
  "def is_palindrome(head):\n    if not head:\n        return True\n    (fast, slow) = (head.next, head)\n    while fast and fast.next:\n        fast = fast.next.next\n        slow = slow.next\n    second = slow.next\n    slow.next = None\n    node = None\n    while second:\n        nxt = second.next\n        second.next = node\n        node = second\n        second = nxt\n    while node:\n        if node.val != head.val:\n            return False\n        node = node.next\n        head = head.next\n    return True",
  "def is_palindrome_stack(head):\n    if not head or not head.next:\n        return True\n    slow = fast = cur = head\n    while fast and fast.next:\n        (fast, slow) = (fast.next.next, slow.next)\n    stack = [slow.val]\n    while slow.next:\n        slow = slow.next\n        stack.append(slow.val)\n    while stack:\n        if stack.pop() != cur.val:\n            return False\n        cur = cur.next\n    return True",
  "def is_palindrome_dict(head):\n    if not head or not head.next:\n        return True\n    d = {}\n    pos = 0\n    while head:\n        if head.val in d.keys():\n            d[head.val].append(pos)\n        else:\n            d[head.val] = [pos]\n        head = head.next\n        pos += 1\n    checksum = pos - 1\n    middle = 0\n    for v in d.values():\n        if len(v) % 2 != 0:\n            middle += 1\n        else:\n            step = 0\n            for i in range(0, len(v)):\n                if v[i] + v[len(v) - 1 - step] != checksum:\n                    return False\n                step += 1\n        if middle > 1:\n            return False\n    return True",
  "def __init__(self, value):\n    self.value = value\n    self.next = None\n    self.prev = None",
  "def __init__(self, value):\n    self.value = value\n    self.next = None",
  "def remove_range(head, start, end):\n    assert start <= end\n    if start == 0:\n        for i in range(0, end + 1):\n            if head != None:\n                head = head.next\n    else:\n        current = head\n        for i in range(0, start - 1):\n            current = current.next\n        for i in range(0, end - start + 1):\n            if current != None and current.next != None:\n                current.next = current.next.next\n    return head",
  "def add_two_numbers(left: Node, right: Node) -> Node:\n    head = Node(0)\n    current = head\n    sum = 0\n    while left or right:\n        print('adding: ', left.val, right.val)\n        sum //= 10\n        if left:\n            sum += left.val\n            left = left.next\n        if right:\n            sum += right.val\n            right = right.next\n        current.next = Node(sum % 10)\n        current = current.next\n    if sum // 10 == 1:\n        current.next = Node(1)\n    return head.next",
  "def convert_to_list(number: int) -> Node:\n    if number >= 0:\n        head = Node(0)\n        current = head\n        remainder = number % 10\n        quotient = number // 10\n        while quotient != 0:\n            current.next = Node(remainder)\n            current = current.next\n            remainder = quotient % 10\n            quotient //= 10\n        current.next = Node(remainder)\n        return head.next\n    else:\n        print('number must be positive!')",
  "def convert_to_str(l: Node) -> str:\n    result = ''\n    while l:\n        result += str(l.val)\n        l = l.next\n    return result",
  "def __init__(self, x):\n    self.val = x\n    self.next = None",
  "def test_convert_to_str(self):\n    number1 = Node(2)\n    number1.next = Node(4)\n    number1.next.next = Node(3)\n    self.assertEqual('243', convert_to_str(number1))",
  "def test_add_two_numbers(self):\n    number1 = Node(2)\n    number1.next = Node(4)\n    number1.next.next = Node(3)\n    number2 = Node(5)\n    number2.next = Node(6)\n    number2.next.next = Node(4)\n    result = convert_to_str(add_two_numbers(number1, number2))\n    self.assertEqual('708', result)\n    number3 = Node(1)\n    number3.next = Node(1)\n    number3.next.next = Node(9)\n    number4 = Node(1)\n    number4.next = Node(0)\n    number4.next.next = Node(1)\n    result = convert_to_str(add_two_numbers(number3, number4))\n    self.assertEqual('2101', result)\n    number5 = Node(1)\n    number6 = Node(0)\n    result = convert_to_str(add_two_numbers(number5, number6))\n    self.assertEqual('1', result)\n    number7 = Node(9)\n    number7.next = Node(1)\n    number7.next.next = Node(1)\n    number8 = Node(1)\n    number8.next = Node(0)\n    number8.next.next = Node(1)\n    result = convert_to_str(add_two_numbers(number7, number8))\n    self.assertEqual('022', result)",
  "def test_convert_to_list(self):\n    result = convert_to_str(convert_to_list(112))\n    self.assertEqual('211', result)",
  "def is_cyclic(head):\n    if not head:\n        return False\n    runner = head\n    walker = head\n    while runner.next and runner.next.next:\n        runner = runner.next.next\n        walker = walker.next\n        if runner == walker:\n            return True\n    return False",
  "def __init__(self, x):\n    self.val = x\n    self.next = None",
  "def copy_random_pointer_v1(head):\n    dic = dict()\n    m = n = head\n    while m:\n        dic[m] = RandomListNode(m.label)\n        m = m.next\n    while n:\n        dic[n].next = dic.get(n.next)\n        dic[n].random = dic.get(n.random)\n        n = n.next\n    return dic.get(head)",
  "def copy_random_pointer_v2(head):\n    copy = defaultdict(lambda : RandomListNode(0))\n    copy[None] = None\n    node = head\n    while node:\n        copy[node].label = node.label\n        copy[node].next = copy[node.next]\n        copy[node].random = copy[node.random]\n        node = node.next\n    return copy[head]",
  "def __init__(self, label):\n    self.label = label\n    self.next = None\n    self.random = None",
  "def kth_to_last_eval(head, k):\n    if not isinstance(k, int) or not head.val:\n        return False\n    nexts = '.'.join(['next' for n in range(1, k + 1)])\n    seeker = str('.'.join(['head', nexts]))\n    while head:\n        if eval(seeker) is None:\n            return head\n        else:\n            head = head.next\n    return False",
  "def kth_to_last_dict(head, k):\n    if not (head and k > -1):\n        return False\n    d = dict()\n    count = 0\n    while head:\n        d[count] = head\n        head = head.next\n        count += 1\n    return len(d) - k in d and d[len(d) - k]",
  "def kth_to_last(head, k):\n    if not (head or k > -1):\n        return False\n    p1 = head\n    p2 = head\n    for i in range(1, k + 1):\n        if p1 is None:\n            raise IndexError\n        p1 = p1.next\n    while p1:\n        p1 = p1.next\n        p2 = p2.next\n    return p2",
  "def print_linked_list(head):\n    string = ''\n    while head.next:\n        string += head.val + ' -> '\n        head = head.next\n    string += head.val\n    print(string)",
  "def test():\n    a1 = Node('A')\n    a2 = Node('A')\n    b = Node('B')\n    c1 = Node('C')\n    d = Node('D')\n    c2 = Node('C')\n    f = Node('F')\n    g = Node('G')\n    a1.next = a2\n    a2.next = b\n    b.next = c1\n    c1.next = d\n    d.next = c2\n    c2.next = f\n    f.next = g\n    print_linked_list(a1)\n    kth = kth_to_last_eval(a1, 4)\n    try:\n        assert kth.val == 'D'\n    except AssertionError as e:\n        e.args += ('Expecting D, got %s' % kth.val,)\n        raise\n    kth = kth_to_last_dict(a1, 4)\n    try:\n        assert kth.val == 'D'\n    except AssertionError as e:\n        e.args += ('Expecting D, got %s' % kth.val,)\n        raise\n    kth = kth_to_last(a1, 4)\n    try:\n        assert kth.val == 'D'\n    except AssertionError as e:\n        e.args += ('Expecting D, got %s' % kth.val,)\n        raise\n    print('all passed.')",
  "def __init__(self, val=None):\n    self.val = val\n    self.next = None",
  "def intersection(h1, h2):\n    count = 0\n    flag = None\n    h1_orig = h1\n    h2_orig = h2\n    while h1 or h2:\n        count += 1\n        if not flag and (h1.next is None or h2.next is None):\n            flag = (count, h1.next, h2.next)\n        if h1:\n            h1 = h1.next\n        if h2:\n            h2 = h2.next\n    long_len = count\n    short_len = flag[0]\n    if flag[1] is None:\n        shorter = h1_orig\n        longer = h2_orig\n    elif flag[2] is None:\n        shorter = h2_orig\n        longer = h1_orig\n    while longer and shorter:\n        while long_len > short_len:\n            longer = longer.next\n            long_len -= 1\n        if longer == shorter:\n            return longer\n        else:\n            longer = longer.next\n            shorter = shorter.next\n    return None",
  "def __init__(self, val=None):\n    self.val = val\n    self.next = None",
  "def test_intersection(self):\n    a1 = Node(1)\n    b1 = Node(3)\n    c1 = Node(5)\n    d = Node(7)\n    a2 = Node(2)\n    b2 = Node(4)\n    c2 = Node(6)\n    e = Node(9)\n    f = Node(11)\n    a1.next = b1\n    b1.next = c1\n    c1.next = d\n    a2.next = b2\n    b2.next = c2\n    c2.next = d\n    d.next = e\n    e.next = f\n    self.assertEqual(7, intersection(a1, a2).val)",
  "def first_cyclic_node(head):\n    runner = walker = head\n    while runner and runner.next:\n        runner = runner.next.next\n        walker = walker.next\n        if runner is walker:\n            break\n    if runner is None or runner.next is None:\n        return None\n    walker = head\n    while runner is not walker:\n        (runner, walker) = (runner.next, walker.next)\n    return runner",
  "def __init__(self, x):\n    self.val = x\n    self.next = None",
  "def test_first_cyclic_node(self):\n    head = Node('A')\n    head.next = Node('B')\n    curr = head.next\n    cyclic_node = Node('C')\n    curr.next = cyclic_node\n    curr = curr.next\n    curr.next = Node('D')\n    curr = curr.next\n    curr.next = Node('E')\n    curr = curr.next\n    curr.next = cyclic_node\n    self.assertEqual('C', first_cyclic_node(head).val)",
  "def remove_dups(head):\n    hashset = set()\n    prev = Node()\n    while head:\n        if head.val in hashset:\n            prev.next = head.next\n        else:\n            hashset.add(head.val)\n            prev = head\n        head = head.next",
  "def remove_dups_wothout_set(head):\n    current = head\n    while current:\n        runner = current\n        while runner.next:\n            if runner.next.val == current.val:\n                runner.next = runner.next.next\n            else:\n                runner = runner.next\n        current = current.next",
  "def print_linked_list(head):\n    string = ''\n    while head.next:\n        string += head.val + ' -> '\n        head = head.next\n    string += head.val\n    print(string)",
  "def __init__(self, val=None):\n    self.val = val\n    self.next = None",
  "def swap_pairs(head):\n    if not head:\n        return head\n    start = Node(0)\n    start.next = head\n    current = start\n    while current.next and current.next.next:\n        first = current.next\n        second = current.next.next\n        first.next = second.next\n        current.next = second\n        current.next.next = first\n        current = current.next.next\n    return start.next",
  "def __init__(self, x):\n    self.val = x\n    self.next = None",
  "def is_sorted(head):\n    if not head:\n        return True\n    current = head\n    while current.next:\n        if current.val > current.next.val:\n            return False\n        current = current.next\n    return True",
  "def dfs(source, visited, adjacency_list):\n    visited[source] = True\n    for child in adjacency_list[source]:\n        if not visited[child]:\n            dfs(child, visited, adjacency_list)",
  "def count_components(adjacency_list, size):\n    count = 0\n    visited = [False] * (size + 1)\n    for i in range(1, size + 1):\n        if not visited[i]:\n            dfs(i, visited, adjacency_list)\n            count += 1\n    return count",
  "def main():\n    (node_count, edge_count) = map(int, input('Enter the Number of Nodes and Edges \\n').split(' '))\n    adjacency = [[] for _ in range(node_count + 1)]\n    for _ in range(edge_count):\n        print(\"Enter the edge's Nodes in form of `source target`\\n\")\n        (source, target) = map(int, input().split(' '))\n        adjacency[source].append(target)\n        adjacency[target].append(source)\n    print('Total number of Connected Components are : ', count_components(adjacency, node_count))",
  "def __init__(self, vertex_count):\n    self.vertex_count = vertex_count\n    self.graph = [[0 for _ in range(vertex_count)] for _ in range(vertex_count)]",
  "def min_distance(self, dist, min_dist_set):\n    min_dist = float('inf')\n    for target in range(self.vertex_count):\n        if min_dist_set[target]:\n            continue\n        if dist[target] < min_dist:\n            min_dist = dist[target]\n            min_index = target\n    return min_index",
  "def dijkstra(self, src):\n    dist = [float('inf')] * self.vertex_count\n    dist[src] = 0\n    min_dist_set = [False] * self.vertex_count\n    for _ in range(self.vertex_count):\n        source = self.min_distance(dist, min_dist_set)\n        min_dist_set[source] = True\n        for target in range(self.vertex_count):\n            if self.graph[source][target] <= 0 or min_dist_set[target]:\n                continue\n            if dist[target] > dist[source] + self.graph[source][target]:\n                dist[target] = dist[source] + self.graph[source][target]\n    return dist",
  "def __init__(self, vertex_count):\n    self.vertex_count = vertex_count\n    self.graph = defaultdict(list)\n    self.has_path = False",
  "def add_edge(self, source, target):\n    self.graph[source].append(target)",
  "def dfs(self, source, target):\n    visited = [False] * self.vertex_count\n    self.dfsutil(visited, source, target)",
  "def dfsutil(self, visited, source, target):\n    visited[source] = True\n    for i in self.graph[source]:\n        if target in self.graph[source]:\n            self.has_path = True\n            return\n        if not visited[i]:\n            self.dfsutil(visited, source, i)",
  "def is_reachable(self, source, target):\n    self.has_path = False\n    self.dfs(source, target)\n    return self.has_path",
  "def __choose_state(state_map):\n    choice = random.random()\n    probability_reached = 0\n    for (state, probability) in state_map.items():\n        probability_reached += probability\n        if probability_reached > choice:\n            return state\n    return None",
  "def next_state(chain, current_state):\n    next_state_map = chain.get(current_state)\n    return __choose_state(next_state_map)",
  "def iterating_markov_chain(chain, state):\n    while True:\n        state = next_state(chain, state)\n        yield state",
  "def dfs_traverse(graph, start):\n    (visited, stack) = (set(), [start])\n    while stack:\n        node = stack.pop()\n        if node not in visited:\n            visited.add(node)\n            for next_node in graph[node]:\n                if next_node not in visited:\n                    stack.append(next_node)\n    return visited",
  "def bfs_traverse(graph, start):\n    (visited, queue) = (set(), [start])\n    while queue:\n        node = queue.pop(0)\n        if node not in visited:\n            visited.add(node)\n            for next_node in graph[node]:\n                if next_node not in visited:\n                    queue.append(next_node)\n    return visited",
  "def dfs_traverse_recursive(graph, start, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    for next_node in graph[start]:\n        if next_node not in visited:\n            dfs_traverse_recursive(graph, next_node, visited)\n    return visited",
  "def find_path(graph, start, end, path=[]):\n    path = path + [start]\n    if start == end:\n        return path\n    if not start in graph:\n        return None\n    for node in graph[start]:\n        if node not in path:\n            newpath = find_path(graph, node, end, path)\n            return newpath\n    return None",
  "def find_all_path(graph, start, end, path=[]):\n    path = path + [start]\n    if start == end:\n        return [path]\n    if not start in graph:\n        return []\n    paths = []\n    for node in graph[start]:\n        if node not in path:\n            newpaths = find_all_path(graph, node, end, path)\n            for newpath in newpaths:\n                paths.append(newpath)\n    return paths",
  "def find_shortest_path(graph, start, end, path=[]):\n    path = path + [start]\n    if start == end:\n        return path\n    if start not in graph:\n        return None\n    shortest = None\n    for node in graph[start]:\n        if node not in path:\n            newpath = find_shortest_path(graph, node, end, path)\n            if newpath:\n                if not shortest or len(newpath) < len(shortest):\n                    shortest = newpath\n    return shortest",
  "def prims_minimum_spanning(graph_used):\n    vis = []\n    heap = [[0, 1]]\n    prim = set()\n    mincost = 0\n    while len(heap) > 0:\n        (cost, node) = heapq.heappop(heap)\n        if node in vis:\n            continue\n        mincost += cost\n        prim.add(node)\n        vis.append(node)\n        for (distance, adjacent) in graph_used[node]:\n            if adjacent not in vis:\n                heapq.heappush(heap, [distance, adjacent])\n    return mincost",
  "def __init__(self, vertices):\n    self.vertex_count = vertices\n    self.graph = {}\n    self.closure = [[0 for j in range(vertices)] for i in range(vertices)]",
  "def add_edge(self, source, target):\n    if source in self.graph:\n        self.graph[source].append(target)\n    else:\n        self.graph[source] = [target]",
  "def dfs_util(self, source, target):\n    self.closure[source][target] = 1\n    for adjacent in self.graph[target]:\n        if self.closure[source][adjacent] == 0:\n            self.dfs_util(source, adjacent)",
  "def transitive_closure(self):\n    for i in range(self.vertex_count):\n        self.dfs_util(i, i)\n    return self.closure",
  "def clone_graph1(node):\n    if not node:\n        return None\n    node_copy = node.shallow_copy()\n    dic = {node: node_copy}\n    queue = collections.deque([node])\n    while queue:\n        node = queue.popleft()\n        for neighbor in node.neighbors:\n            if neighbor not in dic:\n                neighbor_copy = neighbor.shallow_copy()\n                dic[neighbor] = neighbor_copy\n                dic[node].add_neighbor(neighbor_copy)\n                queue.append(neighbor)\n            else:\n                dic[node].add_neighbor(dic[neighbor])\n    return node_copy",
  "def clone_graph2(node):\n    if not node:\n        return None\n    node_copy = node.shallow_copy()\n    dic = {node: node_copy}\n    stack = [node]\n    while stack:\n        node = stack.pop()\n        for neighbor in node.neighbors:\n            if neighbor not in dic:\n                neighbor_copy = neighbor.shallow_copy()\n                dic[neighbor] = neighbor_copy\n                dic[node].add_neighbor(neighbor_copy)\n                stack.append(neighbor)\n            else:\n                dic[node].add_neighbor(dic[neighbor])\n    return node_copy",
  "def clone_graph(node):\n    if not node:\n        return None\n    node_copy = node.shallow_copy()\n    dic = {node: node_copy}\n    dfs(node, dic)\n    return node_copy",
  "def dfs(node, dic):\n    for neighbor in node.neighbors:\n        if neighbor not in dic:\n            neighbor_copy = neighbor.shallow_copy()\n            dic[neighbor] = neighbor_copy\n            dic[node].add_neighbor(neighbor_copy)\n            dfs(neighbor, dic)\n        else:\n            dic[node].add_neighbor(dic[neighbor])",
  "def __init__(self, label):\n    self.label = label\n    self.neighbors = []",
  "def shallow_copy(self):\n    return UndirectedGraphNode(self.label)",
  "def add_neighbor(self, node):\n    self.neighbors.append(node)",
  "def __init__(self, name):\n    self.name = name",
  "@staticmethod\ndef get_name(obj):\n    if isinstance(obj, Node):\n        return obj.name\n    if isinstance(obj, str):\n        return obj\n    return ''",
  "def __eq__(self, obj):\n    return self.name == self.get_name(obj)",
  "def __repr__(self):\n    return self.name",
  "def __hash__(self):\n    return hash(self.name)",
  "def __ne__(self, obj):\n    return self.name != self.get_name(obj)",
  "def __lt__(self, obj):\n    return self.name < self.get_name(obj)",
  "def __le__(self, obj):\n    return self.name <= self.get_name(obj)",
  "def __gt__(self, obj):\n    return self.name > self.get_name(obj)",
  "def __ge__(self, obj):\n    return self.name >= self.get_name(obj)",
  "def __bool__(self):\n    return self.name",
  "def __init__(self, node_from, node_to):\n    self.source = node_from\n    self.target = node_to",
  "def __eq__(self, obj):\n    if isinstance(obj, DirectedEdge):\n        return obj.source == self.source and obj.target == self.target\n    return False",
  "def __repr__(self):\n    return f'({self.source} -> {self.target})'",
  "def __init__(self, load_dict={}):\n    self.nodes = []\n    self.edges = []\n    self.adjacency_list = {}\n    if load_dict and isinstance(load_dict, dict):\n        for vertex in load_dict:\n            node_from = self.add_node(vertex)\n            self.adjacency_list[node_from] = []\n            for neighbor in load_dict[vertex]:\n                node_to = self.add_node(neighbor)\n                self.adjacency_list[node_from].append(node_to)\n                self.add_edge(vertex, neighbor)",
  "def add_node(self, node_name):\n    try:\n        return self.nodes[self.nodes.index(node_name)]\n    except ValueError:\n        node = Node(node_name)\n        self.nodes.append(node)\n        return node",
  "def add_edge(self, node_name_from, node_name_to):\n    try:\n        node_from = self.nodes[self.nodes.index(node_name_from)]\n        node_to = self.nodes[self.nodes.index(node_name_to)]\n        self.edges.append(DirectedEdge(node_from, node_to))\n    except ValueError:\n        pass",
  "def kruskal(vertex_count, edges, forest):\n    edges.sort(key=lambda edge: edge.weight)\n    mst = []\n    for edge in edges:\n        set_u = forest.find_set(edge.u)\n        set_v = forest.find_set(edge.v)\n        if set_u != set_v:\n            forest.merge_set(set_u, set_v)\n            mst.append(edge)\n            if len(mst) == vertex_count - 1:\n                break\n    return sum([edge.weight for edge in mst])",
  "def main():\n    for size in sys.stdin:\n        (vertex_count, edge_count) = map(int, size.split())\n        forest = DisjointSet(edge_count)\n        edges = [None] * edge_count\n        for i in range(edge_count):\n            (source, target, weight) = map(int, input().split())\n            source -= 1\n            target -= 1\n            edges[i] = Edge(source, target, weight)\n        print('MST weights sum:', kruskal(vertex_count, edges, forest))",
  "def __init__(self, source, target, weight):\n    self.source = source\n    self.target = target\n    self.weight = weight",
  "def __init__(self, size):\n    self.parent = [None] * size\n    self.size = [1] * size\n    for i in range(size):\n        self.parent[i] = i",
  "def merge_set(self, node1, node2):\n    node1 = self.find_set(node1)\n    node2 = self.find_set(node2)\n    if self.size[node1] < self.size[node2]:\n        self.parent[node1] = node2\n        self.size[node2] += self.size[node1]\n    else:\n        self.parent[node2] = node1\n        self.size[node1] += self.size[node2]",
  "def find_set(self, node):\n    if self.parent[node] != node:\n        self.parent[node] = self.find_set(self.parent[node])\n    return self.parent[node]",
  "def bellman_ford(graph, source):\n    weight = {}\n    pre_node = {}\n    initialize_single_source(graph, source, weight, pre_node)\n    for _ in range(1, len(graph)):\n        for node in graph:\n            for adjacent in graph[node]:\n                if weight[adjacent] > weight[node] + graph[node][adjacent]:\n                    weight[adjacent] = weight[node] + graph[node][adjacent]\n                    pre_node[adjacent] = node\n    for node in graph:\n        for adjacent in graph[node]:\n            if weight[adjacent] > weight[node] + graph[node][adjacent]:\n                return False\n    return True",
  "def initialize_single_source(graph, source, weight, pre_node):\n    for node in graph:\n        weight[node] = float('inf')\n        pre_node[node] = None\n    weight[source] = 0",
  "def __init__(self, dict_graph):\n    self.graph = DirectedGraph(dict_graph)\n    self.index = 0\n    self.stack = []\n    for vertex in self.graph.nodes:\n        vertex.index = None\n    self.sccs = []\n    for vertex in self.graph.nodes:\n        if vertex.index is None:\n            self.strongconnect(vertex, self.sccs)",
  "def strongconnect(self, vertex, sccs):\n    vertex.index = self.index\n    vertex.lowlink = self.index\n    self.index += 1\n    self.stack.append(vertex)\n    vertex.on_stack = True\n    for adjacent in self.graph.adjacency_list[vertex]:\n        if adjacent.index is None:\n            self.strongconnect(adjacent, sccs)\n            vertex.lowlink = min(vertex.lowlink, adjacent.lowlink)\n        elif adjacent.on_stack:\n            vertex.lowlink = min(vertex.lowlink, adjacent.index)\n    if vertex.lowlink == vertex.index:\n        scc = []\n        while True:\n            adjacent = self.stack.pop()\n            adjacent.on_stack = False\n            scc.append(adjacent)\n            if adjacent == vertex:\n                break\n        scc.sort()\n        sccs.append(scc)",
  "def find_all_cliques(edges):\n\n    def expand_clique(candidates, nays):\n        nonlocal compsub\n        if not candidates and (not nays):\n            nonlocal solutions\n            solutions.append(compsub.copy())\n        else:\n            for selected in candidates.copy():\n                candidates.remove(selected)\n                candidates_temp = get_connected(selected, candidates)\n                nays_temp = get_connected(selected, nays)\n                compsub.append(selected)\n                expand_clique(candidates_temp, nays_temp)\n                nays.add(compsub.pop())\n\n    def get_connected(vertex, old_set):\n        new_set = set()\n        for neighbor in edges[str(vertex)]:\n            if neighbor in old_set:\n                new_set.add(neighbor)\n        return new_set\n    compsub = []\n    solutions = []\n    possibles = set(edges.keys())\n    expand_clique(possibles, set())\n    return solutions",
  "def expand_clique(candidates, nays):\n    nonlocal compsub\n    if not candidates and (not nays):\n        nonlocal solutions\n        solutions.append(compsub.copy())\n    else:\n        for selected in candidates.copy():\n            candidates.remove(selected)\n            candidates_temp = get_connected(selected, candidates)\n            nays_temp = get_connected(selected, nays)\n            compsub.append(selected)\n            expand_clique(candidates_temp, nays_temp)\n            nays.add(compsub.pop())",
  "def get_connected(vertex, old_set):\n    new_set = set()\n    for neighbor in edges[str(vertex)]:\n        if neighbor in old_set:\n            new_set.add(neighbor)\n    return new_set",
  "def all_pairs_shortest_path(adjacency_matrix):\n    new_array = copy.deepcopy(adjacency_matrix)\n    size = len(new_array)\n    for k in range(size):\n        for i in range(size):\n            for j in range(size):\n                if new_array[i][j] > new_array[i][k] + new_array[k][j]:\n                    new_array[i][j] = new_array[i][k] + new_array[k][j]\n    return new_array",
  "def maximum_flow_dfs(adjacency_matrix):\n    new_array = copy.deepcopy(adjacency_matrix)\n    total = 0\n    while True:\n        min = math.inf\n        visited = [0] * len(new_array)\n        path = [0] * len(new_array)\n        stack = []\n        visited[0] = 1\n        stack.append(0)\n        while len(stack) > 0:\n            src = stack.pop()\n            for k in range(len(new_array)):\n                if new_array[src][k] > 0 and visited[k] == 0:\n                    visited[k] = 1\n                    stack.append(k)\n                    path[k] = src\n        if visited[len(new_array) - 1] == 0:\n            break\n        tmp = len(new_array) - 1\n        while tmp != 0:\n            if min > new_array[path[tmp]][tmp]:\n                min = new_array[path[tmp]][tmp]\n            tmp = path[tmp]\n        tmp = len(new_array) - 1\n        while tmp != 0:\n            new_array[path[tmp]][tmp] = new_array[path[tmp]][tmp] - min\n            tmp = path[tmp]\n        total = total + min\n    return total",
  "def is_in_cycle(graph, traversal_states, vertex):\n    if traversal_states[vertex] == TraversalState.GRAY:\n        return True\n    traversal_states[vertex] = TraversalState.GRAY\n    for neighbor in graph[vertex]:\n        if is_in_cycle(graph, traversal_states, neighbor):\n            return True\n    traversal_states[vertex] = TraversalState.BLACK\n    return False",
  "def contains_cycle(graph):\n    traversal_states = {vertex: TraversalState.WHITE for vertex in graph}\n    for (vertex, state) in traversal_states.items():\n        if state == TraversalState.WHITE and is_in_cycle(graph, traversal_states, vertex):\n            return True\n    return False",
  "def dfs_transposed(vertex, graph, order, visited):\n    visited[vertex] = True\n    for adjacent in graph[vertex]:\n        if not visited[adjacent]:\n            dfs_transposed(adjacent, graph, order, visited)\n    order.append(vertex)",
  "def dfs(vertex, current_comp, vertex_scc, graph, visited):\n    visited[vertex] = True\n    vertex_scc[vertex] = current_comp\n    for adjacent in graph[vertex]:\n        if not visited[adjacent]:\n            dfs(adjacent, current_comp, vertex_scc, graph, visited)",
  "def add_edge(graph, vertex_from, vertex_to):\n    if vertex_from not in graph:\n        graph[vertex_from] = []\n    graph[vertex_from].append(vertex_to)",
  "def scc(graph):\n    order = []\n    visited = {vertex: False for vertex in graph}\n    graph_transposed = {vertex: [] for vertex in graph}\n    for (source, neighbours) in graph.iteritems():\n        for target in neighbours:\n            add_edge(graph_transposed, target, source)\n    for vertex in graph:\n        if not visited[vertex]:\n            dfs_transposed(vertex, graph_transposed, order, visited)\n    visited = {vertex: False for vertex in graph}\n    vertex_scc = {}\n    current_comp = 0\n    for vertex in reversed(order):\n        if not visited[vertex]:\n            dfs(vertex, current_comp, vertex_scc, graph, visited)\n            current_comp += 1\n    return vertex_scc",
  "def build_graph(formula):\n    graph = {}\n    for clause in formula:\n        for (lit, _) in clause:\n            for neg in [False, True]:\n                graph[lit, neg] = []\n    for ((a_lit, a_neg), (b_lit, b_neg)) in formula:\n        add_edge(graph, (a_lit, a_neg), (b_lit, not b_neg))\n        add_edge(graph, (b_lit, b_neg), (a_lit, not a_neg))\n    return graph",
  "def solve_sat(formula):\n    graph = build_graph(formula)\n    vertex_scc = scc(graph)\n    for (var, _) in graph:\n        if vertex_scc[var, False] == vertex_scc[var, True]:\n            return None\n    comp_repr = {}\n    for vertex in graph:\n        if not vertex_scc[vertex] in comp_repr:\n            comp_repr[vertex_scc[vertex]] = vertex\n    comp_value = {}\n    components = sorted(vertex_scc.values())\n    for comp in components:\n        if comp not in comp_value:\n            comp_value[comp] = False\n            (lit, neg) = comp_repr[comp]\n            comp_value[vertex_scc[lit, not neg]] = True\n    value = {var: comp_value[vertex_scc[var, False]] for (var, _) in graph}\n    return value",
  "def main():\n    formula = [(('x', False), ('y', False)), (('y', True), ('y', True)), (('a', False), ('b', False)), (('a', True), ('c', True)), (('c', False), ('b', True))]\n    result = solve_sat(formula)\n    for (variable, assign) in result.items():\n        print(f'{variable}:{assign}')",
  "def maximum_flow_bfs(adjacency_matrix):\n    new_array = copy.deepcopy(adjacency_matrix)\n    total = 0\n    while True:\n        min_flow = math.inf\n        visited = [0] * len(new_array)\n        path = [0] * len(new_array)\n        bfs = queue.Queue()\n        visited[0] = 1\n        bfs.put(0)\n        while bfs.qsize() > 0:\n            src = bfs.get()\n            for k in range(len(new_array)):\n                if new_array[src][k] > 0 and visited[k] == 0:\n                    visited[k] = 1\n                    bfs.put(k)\n                    path[k] = src\n        if visited[len(new_array) - 1] == 0:\n            break\n        tmp = len(new_array) - 1\n        while tmp != 0:\n            if min_flow > new_array[path[tmp]][tmp]:\n                min_flow = new_array[path[tmp]][tmp]\n            tmp = path[tmp]\n        tmp = len(new_array) - 1\n        while tmp != 0:\n            new_array[path[tmp]][tmp] = new_array[path[tmp]][tmp] - min_flow\n            tmp = path[tmp]\n        total = total + min_flow\n    return total",
  "def check_bipartite(adj_list):\n    vertices = len(adj_list)\n    set_type = [-1 for v in range(vertices)]\n    set_type[0] = 0\n    queue = [0]\n    while queue:\n        current = queue.pop(0)\n        if adj_list[current][current]:\n            return False\n        for adjacent in range(vertices):\n            if adj_list[current][adjacent]:\n                if set_type[adjacent] == set_type[current]:\n                    return False\n                if set_type[adjacent] == -1:\n                    set_type[adjacent] = 1 - set_type[current]\n                    queue.append(adjacent)\n    return True",
  "def __init__(self, vertex_count):\n    self.vertex_count = vertex_count\n    self.graph = defaultdict(list)",
  "def add_edge(self, source, target):\n    self.graph[source].append(target)",
  "def dfs(self):\n    visited = [False] * self.vertex_count\n    self.dfs_util(0, visited)\n    if visited == [True] * self.vertex_count:\n        return True\n    return False",
  "def dfs_util(self, source, visited):\n    visited[source] = True\n    for adjacent in self.graph[source]:\n        if not visited[adjacent]:\n            self.dfs_util(adjacent, visited)",
  "def reverse_graph(self):\n    reverse_graph = Graph(self.vertex_count)\n    for (source, adjacent) in self.graph.items():\n        for target in adjacent:\n            reverse_graph.add_edge(target, source)\n    return reverse_graph",
  "def is_strongly_connected(self):\n    if self.dfs():\n        reversed_graph = self.reverse_graph()\n        if reversed_graph.dfs():\n            return True\n    return False",
  "def dfs(capacity, flow, visit, vertices, idx, sink, current_flow=1 << 63):\n    if idx == sink:\n        return current_flow\n    visit[idx] = True\n    for nxt in range(vertices):\n        if not visit[nxt] and flow[idx][nxt] < capacity[idx][nxt]:\n            available_flow = min(current_flow, capacity[idx][nxt] - flow[idx][nxt])\n            tmp = dfs(capacity, flow, visit, vertices, nxt, sink, available_flow)\n            if tmp:\n                flow[idx][nxt] += tmp\n                flow[nxt][idx] -= tmp\n                return tmp\n    return 0",
  "def ford_fulkerson(capacity, source, sink):\n    vertices = len(capacity)\n    ret = 0\n    flow = [[0] * vertices for _ in range(vertices)]\n    while True:\n        visit = [False for _ in range(vertices)]\n        tmp = dfs(capacity, flow, visit, vertices, source, sink)\n        if tmp:\n            ret += tmp\n        else:\n            break\n    return ret",
  "def edmonds_karp(capacity, source, sink):\n    vertices = len(capacity)\n    ret = 0\n    flow = [[0] * vertices for _ in range(vertices)]\n    while True:\n        tmp = 0\n        queue = Queue()\n        visit = [False for _ in range(vertices)]\n        par = [-1 for _ in range(vertices)]\n        visit[source] = True\n        queue.put((source, 1 << 63))\n        while queue.qsize():\n            front = queue.get()\n            (idx, current_flow) = front\n            if idx == sink:\n                tmp = current_flow\n                break\n            for nxt in range(vertices):\n                if not visit[nxt] and flow[idx][nxt] < capacity[idx][nxt]:\n                    visit[nxt] = True\n                    par[nxt] = idx\n                    queue.put((nxt, min(current_flow, capacity[idx][nxt] - flow[idx][nxt])))\n        if par[sink] == -1:\n            break\n        ret += tmp\n        parent = par[sink]\n        idx = sink\n        while parent != -1:\n            flow[parent][idx] += tmp\n            flow[idx][parent] -= tmp\n            idx = parent\n            parent = par[parent]\n    return ret",
  "def dinic_bfs(capacity, flow, level, source, sink):\n    vertices = len(capacity)\n    queue = Queue()\n    queue.put(source)\n    level[source] = 0\n    while queue.qsize():\n        front = queue.get()\n        for nxt in range(vertices):\n            if level[nxt] == -1 and flow[front][nxt] < capacity[front][nxt]:\n                level[nxt] = level[front] + 1\n                queue.put(nxt)\n    return level[sink] != -1",
  "def dinic_dfs(capacity, flow, level, idx, sink, work, current_flow=1 << 63):\n    if idx == sink:\n        return current_flow\n    vertices = len(capacity)\n    while work[idx] < vertices:\n        nxt = work[idx]\n        if level[nxt] == level[idx] + 1 and flow[idx][nxt] < capacity[idx][nxt]:\n            available_flow = min(current_flow, capacity[idx][nxt] - flow[idx][nxt])\n            tmp = dinic_dfs(capacity, flow, level, nxt, sink, work, available_flow)\n            if tmp > 0:\n                flow[idx][nxt] += tmp\n                flow[nxt][idx] -= tmp\n                return tmp\n        work[idx] += 1\n    return 0",
  "def dinic(capacity, source, sink):\n    vertices = len(capacity)\n    flow = [[0] * vertices for i in range(vertices)]\n    ret = 0\n    while True:\n        level = [-1 for i in range(vertices)]\n        work = [0 for i in range(vertices)]\n        if not dinic_bfs(capacity, flow, level, source, sink):\n            break\n        while True:\n            tmp = dinic_dfs(capacity, flow, level, source, sink, work)\n            if tmp > 0:\n                ret += tmp\n            else:\n                break\n    return ret",
  "def get_histogram(input_list: list) -> dict:\n    histogram = {}\n    for i in input_list:\n        histogram[i] = histogram.get(i, 0) + 1\n    return histogram",
  "def one_sparse(array):\n    sum_signs = 0\n    bitsum = [0] * 32\n    sum_values = 0\n    for (val, sign) in array:\n        if sign == '+':\n            sum_signs += 1\n            sum_values += val\n        else:\n            sum_signs -= 1\n            sum_values -= val\n        _get_bit_sum(bitsum, val, sign)\n    if sum_signs > 0 and _check_every_number_in_bitsum(bitsum, sum_signs):\n        return int(sum_values / sum_signs)\n    else:\n        return None",
  "def _check_every_number_in_bitsum(bitsum, sum_signs):\n    for val in bitsum:\n        if val != 0 and val != sum_signs:\n            return False\n    return True",
  "def _get_bit_sum(bitsum, val, sign):\n    i = 0\n    if sign == '+':\n        while val:\n            bitsum[i] += val & 1\n            i += 1\n            val >>= 1\n    else:\n        while val:\n            bitsum[i] -= val & 1\n            i += 1\n            val >>= 1",
  "def misras_gries(array, k=2):\n    keys = {}\n    for i in array:\n        val = str(i)\n        if val in keys:\n            keys[val] = keys[val] + 1\n        elif len(keys) < k - 1:\n            keys[val] = 1\n        else:\n            for key in list(keys):\n                keys[key] = keys[key] - 1\n                if keys[key] == 0:\n                    del keys[key]\n    suspects = keys.keys()\n    frequencies = {}\n    for suspect in suspects:\n        freq = _count_frequency(array, int(suspect))\n        if freq >= len(array) / k:\n            frequencies[suspect] = freq\n    return frequencies if len(frequencies) > 0 else None",
  "def _count_frequency(array, element):\n    return array.count(element)",
  "def search_rotate(array, val):\n    (low, high) = (0, len(array) - 1)\n    while low <= high:\n        mid = (low + high) // 2\n        if val == array[mid]:\n            return mid\n        if array[low] <= array[mid]:\n            if array[low] <= val <= array[mid]:\n                high = mid - 1\n            else:\n                low = mid + 1\n        elif array[mid] <= val <= array[high]:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1",
  "def search_rotate_recur(array, low, high, val):\n    if low >= high:\n        return -1\n    mid = (low + high) // 2\n    if val == array[mid]:\n        return mid\n    if array[low] <= array[mid]:\n        if array[low] <= val <= array[mid]:\n            return search_rotate_recur(array, low, mid - 1, val)\n        return search_rotate_recur(array, mid + 1, high, val)\n    if array[mid] <= val <= array[high]:\n        return search_rotate_recur(array, mid + 1, high, val)\n    return search_rotate_recur(array, low, mid - 1, val)",
  "def binary_search(array, query):\n    (low, high) = (0, len(array) - 1)\n    while low <= high:\n        mid = (high + low) // 2\n        val = array[mid]\n        if val == query:\n            return mid\n        if val < query:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return None",
  "def binary_search_recur(array, low, high, val):\n    if low > high:\n        return -1\n    mid = (low + high) // 2\n    if val < array[mid]:\n        return binary_search_recur(array, low, mid - 1, val)\n    if val > array[mid]:\n        return binary_search_recur(array, mid + 1, high, val)\n    return mid",
  "def search_range(nums, target):\n    low = 0\n    high = len(nums) - 1\n    while low <= high:\n        mid = low + (high - low) // 2\n        if target < nums[mid]:\n            high = mid - 1\n        elif target > nums[mid]:\n            low = mid + 1\n        else:\n            break\n    for j in range(len(nums) - 1, -1, -1):\n        if nums[j] == target:\n            return [mid, j]\n    return [-1, -1]",
  "def first_occurrence(array, query):\n    (low, high) = (0, len(array) - 1)\n    while low <= high:\n        mid = (low + high) // 2\n        if low == high:\n            break\n        if array[mid] < query:\n            low = mid + 1\n        else:\n            high = mid\n    if array[low] == query:\n        return low",
  "def ternary_search(left, right, key, arr):\n    while right >= left:\n        mid1 = left + (right - left) // 3\n        mid2 = right - (right - left) // 3\n        if key == arr[mid1]:\n            return mid1\n        if key == mid2:\n            return mid2\n        if key < arr[mid1]:\n            right = mid1 - 1\n        elif key > arr[mid2]:\n            left = mid2 + 1\n        else:\n            left = mid1 + 1\n            right = mid2 - 1\n    return -1",
  "def next_greatest_letter(letters, target):\n    index = bisect.bisect(letters, target)\n    return letters[index % len(letters)]",
  "def next_greatest_letter_v1(letters, target):\n    if letters[0] > target:\n        return letters[0]\n    if letters[len(letters) - 1] <= target:\n        return letters[0]\n    (left, right) = (0, len(letters) - 1)\n    while left <= right:\n        mid = left + (right - left) // 2\n        if letters[mid] > target:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return letters[left]",
  "def next_greatest_letter_v2(letters, target):\n    for index in letters:\n        if index > target:\n            return index\n    return letters[0]",
  "def search_insert(array, val):\n    low = 0\n    high = len(array) - 1\n    while low <= high:\n        mid = low + (high - low) // 2\n        if val > array[mid]:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return low",
  "def linear_search(array, query):\n    for (i, value) in enumerate(array):\n        if value == query:\n            return i\n    return -1",
  "def find_min_rotate(array):\n    low = 0\n    high = len(array) - 1\n    while low < high:\n        mid = (low + high) // 2\n        if array[mid] > array[high]:\n            low = mid + 1\n        else:\n            high = mid\n    return array[low]",
  "def find_min_rotate_recur(array, low, high):\n    mid = (low + high) // 2\n    if mid == low:\n        return array[low]\n    if array[mid] > array[high]:\n        return find_min_rotate_recur(array, mid + 1, high)\n    return find_min_rotate_recur(array, low, mid)",
  "def interpolation_search(array: List[int], search_key: int) -> int:\n    high = len(array) - 1\n    low = 0\n    while low <= high and array[low] <= search_key <= array[high]:\n        pos = low + int((search_key - array[low]) * (high - low) / (array[high] - array[low]))\n        if array[pos] == search_key:\n            return pos\n        if array[pos] < search_key:\n            low = pos + 1\n        else:\n            high = pos - 1\n    return -1",
  "def two_sum(numbers, target):\n    for (i, number) in enumerate(numbers):\n        second_val = target - number\n        (low, high) = (i + 1, len(numbers) - 1)\n        while low <= high:\n            mid = low + (high - low) // 2\n            if second_val == numbers[mid]:\n                return [i + 1, mid + 1]\n            if second_val > numbers[mid]:\n                low = mid + 1\n            else:\n                high = mid - 1\n    return None",
  "def two_sum1(numbers, target):\n    dic = {}\n    for (i, num) in enumerate(numbers):\n        if target - num in dic:\n            return [dic[target - num] + 1, i + 1]\n        dic[num] = i\n    return None",
  "def two_sum2(numbers, target):\n    left = 0\n    right = len(numbers) - 1\n    while left < right:\n        current_sum = numbers[left] + numbers[right]\n        if current_sum == target:\n            return [left + 1, right + 1]\n        if current_sum > target:\n            right = right - 1\n        else:\n            left = left + 1",
  "def last_occurrence(array, query):\n    (low, high) = (0, len(array) - 1)\n    while low <= high:\n        mid = (high + low) // 2\n        if array[mid] == query and mid == len(array) - 1 or (array[mid] == query and array[mid + 1] > query):\n            return mid\n        if array[mid] <= query:\n            low = mid + 1\n        else:\n            high = mid - 1",
  "def jump_search(arr, target):\n    length = len(arr)\n    block_size = int(math.sqrt(length))\n    block_prev = 0\n    block = block_size\n    if arr[length - 1] < target:\n        return -1\n    while block <= length and arr[block - 1] < target:\n        block_prev = block\n        block += block_size\n    while arr[block_prev] < target:\n        block_prev += 1\n        if block_prev == min(block, length):\n            return -1\n    if arr[block_prev] == target:\n        return block_prev\n    return -1",
  "def full_path(file):\n    return os.path.abspath(os.path.expanduser(file))",
  "def split(path):\n    parts = []\n    split_part = path.rpartition('/')\n    parts.append(split_part[0])\n    parts.append(split_part[2])\n    return parts",
  "def join_with_slash(base, suffix):\n    base = base.rstrip('/')\n    suffix = suffix.lstrip('/').rstrip()\n    full_path = '{}/{}'.format(base, suffix)\n    return full_path",
  "def simplify_path_v1(path):\n    return os.path.abspath(path)",
  "def simplify_path_v2(path):\n    (stack, tokens) = ([], path.split('/'))\n    for token in tokens:\n        if token == '..' and stack:\n            stack.pop()\n        elif token != '..' and token != '.' and token:\n            stack.append(token)\n    return '/' + '/'.join(stack)",
  "def __init__(self, key=None, value=None, next=None):\n    self.key = key\n    self.value = value\n    self.next = next",
  "def __init__(self, size=11):\n    self.size = size\n    self._len = 0\n    self._table = [self._empty] * size",
  "def put(self, key, value):\n    hash_ = self.hash(key)\n    node_ = self._table[hash_]\n    if node_ is self._empty:\n        self._table[hash_] = Node(key, value)\n    else:\n        while node_.next is not None:\n            if node_.key == key:\n                node_.value = value\n                return\n            node_ = node_.next\n        node_.next = Node(key, value)\n    self._len += 1",
  "def get(self, key):\n    hash_ = self.hash(key)\n    node_ = self._table[hash_]\n    while node_ is not self._empty:\n        if node_.key == key:\n            return node_.value\n        node_ = node_.next\n    return None",
  "def del_(self, key):\n    hash_ = self.hash(key)\n    node_ = self._table[hash_]\n    pre_node = None\n    while node_ is not None:\n        if node_.key == key:\n            if pre_node is None:\n                self._table[hash_] = node_.next\n            else:\n                pre_node.next = node_.next\n            self._len -= 1\n        pre_node = node_\n        node_ = node_.next",
  "def hash(self, key):\n    return hash(key) % self.size",
  "def __len__(self):\n    return self._len",
  "def __getitem__(self, key):\n    return self.get(key)",
  "def __delitem__(self, key):\n    return self.del_(key)",
  "def __setitem__(self, key, value):\n    self.put(key, value)",
  "def is_isomorphic(s, t):\n    if len(s) != len(t):\n        return False\n    dict = {}\n    set_value = set()\n    for i in range(len(s)):\n        if s[i] not in dict:\n            if t[i] in set_value:\n                return False\n            dict[s[i]] = t[i]\n            set_value.add(t[i])\n        elif dict[s[i]] != t[i]:\n            return False\n    return True",
  "def max_common_sub_string(s1, s2):\n    s2dic = {s2[i]: i for i in range(len(s2))}\n    maxr = 0\n    subs = ''\n    i = 0\n    while i < len(s1):\n        if s1[i] in s2dic:\n            j = s2dic[s1[i]]\n            k = i\n            while j < len(s2) and k < len(s1) and (s1[k] == s2[j]):\n                k += 1\n                j += 1\n            if k - i > maxr:\n                maxr = k - i\n                subs = s1[i:k]\n            i = k\n        else:\n            i += 1\n    return subs",
  "def word_pattern(pattern, str):\n    dict = {}\n    set_value = set()\n    list_str = str.split()\n    if len(list_str) != len(pattern):\n        return False\n    for i in range(len(pattern)):\n        if pattern[i] not in dict:\n            if list_str[i] in set_value:\n                return False\n            dict[pattern[i]] = list_str[i]\n            set_value.add(list_str[i])\n        elif dict[pattern[i]] != list_str[i]:\n            return False\n    return True",
  "def is_anagram(s, t):\n    maps = {}\n    mapt = {}\n    for i in s:\n        maps[i] = maps.get(i, 0) + 1\n    for i in t:\n        mapt[i] = mapt.get(i, 0) + 1\n    return maps == mapt",
  "def longest_palindromic_subsequence(s):\n    k = len(s)\n    olist = [0] * k\n    nList = [0] * k\n    logestSubStr = ''\n    logestLen = 0\n    for j in range(0, k):\n        for i in range(0, j + 1):\n            if j - i <= 1:\n                if s[i] == s[j]:\n                    nList[i] = 1\n                    len_t = j - i + 1\n                    if logestLen < len_t:\n                        logestSubStr = s[i:j + 1]\n                        logestLen = len_t\n            elif s[i] == s[j] and olist[i + 1]:\n                nList[i] = 1\n                len_t = j - i + 1\n                if logestLen < len_t:\n                    logestSubStr = s[i:j + 1]\n                    logestLen = len_t\n        olist = nList\n        nList = [0] * k\n    return logestLen",
  "def __init__(self):\n    self.nums = []\n    self.idxs = {}",
  "def insert(self, val):\n    if val not in self.idxs:\n        self.nums.append(val)\n        self.idxs[val] = len(self.nums) - 1\n        return True\n    return False",
  "def remove(self, val):\n    if val in self.idxs:\n        (idx, last) = (self.idxs[val], self.nums[-1])\n        (self.nums[idx], self.idxs[last]) = (last, idx)\n        self.nums.pop()\n        self.idxs.pop(val, 0)\n        return True\n    return False",
  "def get_random(self):\n    idx = random.randint(0, len(self.nums) - 1)\n    return self.nums[idx]",
  "def __init__(self, size=11):\n    self.size = size\n    self._len = 0\n    self._keys = [self._empty] * size\n    self._values = [self._empty] * size",
  "def put(self, key, value):\n    initial_hash = hash_ = self.hash(key)\n    while True:\n        if self._keys[hash_] is self._empty or self._keys[hash_] is self._deleted:\n            self._keys[hash_] = key\n            self._values[hash_] = value\n            self._len += 1\n            return\n        elif self._keys[hash_] == key:\n            self._keys[hash_] = key\n            self._values[hash_] = value\n            return\n        hash_ = self._rehash(hash_)\n        if initial_hash == hash_:\n            raise ValueError('Table is full')",
  "def get(self, key):\n    initial_hash = hash_ = self.hash(key)\n    while True:\n        if self._keys[hash_] is self._empty:\n            return None\n        elif self._keys[hash_] == key:\n            return self._values[hash_]\n        hash_ = self._rehash(hash_)\n        if initial_hash == hash_:\n            return None",
  "def del_(self, key):\n    initial_hash = hash_ = self.hash(key)\n    while True:\n        if self._keys[hash_] is self._empty:\n            return None\n        elif self._keys[hash_] == key:\n            self._keys[hash_] = self._deleted\n            self._values[hash_] = self._deleted\n            self._len -= 1\n            return\n        hash_ = self._rehash(hash_)\n        if initial_hash == hash_:\n            return None",
  "def hash(self, key):\n    return key % self.size",
  "def _rehash(self, old_hash):\n    return (old_hash + 1) % self.size",
  "def __getitem__(self, key):\n    return self.get(key)",
  "def __delitem__(self, key):\n    return self.del_(key)",
  "def __setitem__(self, key, value):\n    self.put(key, value)",
  "def __len__(self):\n    return self._len",
  "def __init__(self):\n    super().__init__(self.MIN_SIZE)",
  "def put(self, key, value):\n    rv = super().put(key, value)\n    if len(self) >= self.size * 2 / 3:\n        self.__resize()",
  "def __resize(self):\n    (keys, values) = (self._keys, self._values)\n    self.size *= 2\n    self._len = 0\n    self._keys = [self._empty] * self.size\n    self._values = [self._empty] * self.size\n    for (key, value) in zip(keys, values):\n        if key is not self._empty and key is not self._deleted:\n            self.put(key, value)",
  "def is_valid_sudoku(self, board):\n    seen = []\n    for (i, row) in enumerate(board):\n        for (j, c) in enumerate(row):\n            if c != '.':\n                seen += [(c, j), (i, c), (i / 3, j / 3, c)]\n    return len(seen) == len(set(seen))",
  "def __init__(self):",
  "@abstractmethod\ndef perc_up(self, i):",
  "@abstractmethod\ndef insert(self, val):",
  "@abstractmethod\ndef perc_down(self, i):",
  "@abstractmethod\ndef min_child(self, i):",
  "@abstractmethod\ndef remove_min(self):",
  "def __init__(self):\n    self.current_size = 0\n    self.heap = [0]",
  "def perc_up(self, i):\n    while i // 2 > 0:\n        if self.heap[i] < self.heap[i // 2]:\n            (self.heap[i], self.heap[i // 2]) = (self.heap[i // 2], self.heap[i])\n        i = i // 2",
  "def insert(self, val):\n    self.heap.append(val)\n    self.current_size = self.current_size + 1\n    self.perc_up(self.current_size)\n    '\\n        Method min_child returns the index of smaller of 2 children of parent at index i\\n        '",
  "def min_child(self, i):\n    if 2 * i + 1 > self.current_size:\n        return 2 * i\n    if self.heap[2 * i] > self.heap[2 * i + 1]:\n        return 2 * i + 1\n    return 2 * i",
  "def perc_down(self, i):\n    while 2 * i < self.current_size:\n        min_child = self.min_child(i)\n        if self.heap[min_child] < self.heap[i]:\n            (self.heap[min_child], self.heap[i]) = (self.heap[i], self.heap[min_child])\n        i = min_child",
  "def remove_min(self):\n    ret = self.heap[1]\n    self.heap[1] = self.heap[self.current_size]\n    self.current_size = self.current_size - 1\n    self.heap.pop()\n    self.perc_down(1)\n    return ret",
  "def k_closest(points, k, origin=(0, 0)):\n    heap = [(-distance(p, origin), p) for p in points[:k]]\n    heapify(heap)\n    '\\n    For every point p in points[k:],\\n    check if p is smaller than the root of the max heap;\\n    if it is, add p to heap and remove root. Reheapify.\\n    '\n    for point in points[k:]:\n        dist = distance(point, origin)\n        heappushpop(heap, (-dist, point))\n        'Same as:\\n            if d < -heap[0][0]:\\n                heappush(heap, (-d,p))\\n                heappop(heap)\\n\\n        Note: heappushpop is more efficient than separate push and pop calls.\\n        Each heappushpop call takes O(logk) time.\\n        '\n    return [point for (nd, point) in heap]",
  "def distance(point, origin=(0, 0)):\n    return (point[0] - origin[0]) ** 2 + (point[1] - origin[1]) ** 2",
  "def max_sliding_window(nums, k):\n    if not nums:\n        return nums\n    queue = collections.deque()\n    res = []\n    for num in nums:\n        if len(queue) < k:\n            queue.append(num)\n        else:\n            res.append(max(queue))\n            queue.popleft()\n            queue.append(num)\n    res.append(max(queue))\n    return res",
  "def merge_k_lists(lists):\n    dummy = node = ListNode(0)\n    list_h = [(n.val, n) for n in lists if n]\n    heapify(list_h)\n    while list_h:\n        (_, n_val) = list_h[0]\n        if n_val.next is None:\n            heappop(list_h)\n        else:\n            heapreplace(list_h, (n_val.next.val, n_val.next))\n        node.next = n_val\n        node = node.next\n    return dummy.next",
  "def merge_k_lists(lists):\n    dummy = ListNode(None)\n    curr = dummy\n    q = PriorityQueue()\n    for node in lists:\n        if node:\n            q.put((node.val, node))\n    while not q.empty():\n        curr.next = q.get()[1]\n        curr = curr.next\n        if curr.next:\n            q.put((curr.next.val, curr.next))\n    return dummy.next",
  "def __init__(self, val):\n    self.val = val\n    self.next = None",
  "def get_skyline(lrh):\n    (skyline, live) = ([], [])\n    (i, n) = (0, len(lrh))\n    while i < n or live:\n        if not live or (i < n and lrh[i][0] <= -live[0][1]):\n            x = lrh[i][0]\n            while i < n and lrh[i][0] == x:\n                heapq.heappush(live, (-lrh[i][2], -lrh[i][1]))\n                i += 1\n        else:\n            x = -live[0][1]\n            while live and -live[0][1] <= x:\n                heapq.heappop(live)\n        height = len(live) and -live[0][0]\n        if not skyline or height != skyline[-1][1]:\n            skyline += ([x, height],)\n    return skyline",
  "def distance(x, y):\n    assert len(x) == len(y), 'The vector must have same length'\n    result = ()\n    sum = 0\n    for i in range(len(x)):\n        result += (x[i] - y[i],)\n    for component in result:\n        sum += component ** 2\n    return math.sqrt(sum)",
  "def nearest_neighbor(x, tSet):\n    assert isinstance(x, tuple) and isinstance(tSet, dict)\n    current_key = ()\n    min_d = float('inf')\n    for key in tSet:\n        d = distance(x, key)\n        if d < min_d:\n            min_d = d\n            current_key = key\n    return tSet[current_key]",
  "def count_islands(grid):\n    row = len(grid)\n    col = len(grid[0])\n    num_islands = 0\n    visited = [[0] * col for i in range(row)]\n    directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n    queue = []\n    for i in range(row):\n        for (j, num) in enumerate(grid[i]):\n            if num == 1 and visited[i][j] != 1:\n                visited[i][j] = 1\n                queue.append((i, j))\n                while queue:\n                    (x, y) = queue.pop(0)\n                    for k in range(len(directions)):\n                        nx_x = x + directions[k][0]\n                        nx_y = y + directions[k][1]\n                        if nx_x >= 0 and nx_y >= 0 and (nx_x < row) and (nx_y < col):\n                            if visited[nx_x][nx_y] != 1 and grid[nx_x][nx_y] == 1:\n                                queue.append((nx_x, nx_y))\n                                visited[nx_x][nx_y] = 1\n                num_islands += 1\n    return num_islands",
  "def shortest_distance(grid):\n    if not grid or not grid[0]:\n        return -1\n    matrix = [[[0, 0] for i in range(len(grid[0]))] for j in range(len(grid))]\n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                bfs(grid, matrix, i, j, count)\n                count += 1\n    res = float('inf')\n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            if matrix[i][j][1] == count:\n                res = min(res, matrix[i][j][0])\n    return res if res != float('inf') else -1",
  "def bfs(grid, matrix, i, j, count):\n    q = [(i, j, 0)]\n    while q:\n        (i, j, step) = q.pop(0)\n        for (k, l) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n            if 0 <= k < len(grid) and 0 <= l < len(grid[0]) and (matrix[k][l][1] == count) and (grid[k][l] == 0):\n                matrix[k][l][0] += step + 1\n                matrix[k][l][1] = count + 1\n                q.append((k, l, step + 1))",
  "def ladder_length(begin_word, end_word, word_list):\n    if len(begin_word) != len(end_word):\n        return -1\n    if begin_word == end_word:\n        return 0\n    if sum((c1 != c2 for (c1, c2) in zip(begin_word, end_word))) == 1:\n        return 1\n    begin_set = set()\n    end_set = set()\n    begin_set.add(begin_word)\n    end_set.add(end_word)\n    result = 2\n    while begin_set and end_set:\n        if len(begin_set) > len(end_set):\n            (begin_set, end_set) = (end_set, begin_set)\n        next_begin_set = set()\n        for word in begin_set:\n            for ladder_word in word_range(word):\n                if ladder_word in end_set:\n                    return result\n                if ladder_word in word_list:\n                    next_begin_set.add(ladder_word)\n                    word_list.remove(ladder_word)\n        begin_set = next_begin_set\n        result += 1\n    return -1",
  "def word_range(word):\n    for ind in range(len(word)):\n        temp = word[ind]\n        for c in [chr(x) for x in range(ord('a'), ord('z') + 1)]:\n            if c != temp:\n                yield (word[:ind] + c + word[ind + 1:])",
  "def maze_search(maze):\n    (BLOCKED, ALLOWED) = (0, 1)\n    (UNVISITED, VISITED) = (0, 1)\n    (initial_x, initial_y) = (0, 0)\n    if maze[initial_x][initial_y] == BLOCKED:\n        return -1\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    (height, width) = (len(maze), len(maze[0]))\n    (target_x, target_y) = (height - 1, width - 1)\n    queue = deque([(initial_x, initial_y, 0)])\n    is_visited = [[UNVISITED for w in range(width)] for h in range(height)]\n    is_visited[initial_x][initial_y] = VISITED\n    while queue:\n        (x, y, steps) = queue.popleft()\n        if x == target_x and y == target_y:\n            return steps\n        for (dx, dy) in directions:\n            new_x = x + dx\n            new_y = y + dy\n            if not (0 <= new_x < height and 0 <= new_y < width):\n                continue\n            if maze[new_x][new_y] == ALLOWED and is_visited[new_x][new_y] == UNVISITED:\n                queue.append((new_x, new_y, steps + 1))\n                is_visited[new_x][new_y] = VISITED\n    return -1",
  "def longest_non_repeat_v1(string):\n    if string is None:\n        return 0\n    dict = {}\n    max_length = 0\n    j = 0\n    for i in range(len(string)):\n        if string[i] in dict:\n            j = max(dict[string[i]], j)\n        dict[string[i]] = i + 1\n        max_length = max(max_length, i - j + 1)\n    return max_length",
  "def longest_non_repeat_v2(string):\n    if string is None:\n        return 0\n    (start, max_len) = (0, 0)\n    used_char = {}\n    for (index, char) in enumerate(string):\n        if char in used_char and start <= used_char[char]:\n            start = used_char[char] + 1\n        else:\n            max_len = max(max_len, index - start + 1)\n        used_char[char] = index\n    return max_len",
  "def get_longest_non_repeat_v1(string):\n    if string is None:\n        return (0, '')\n    sub_string = ''\n    dict = {}\n    max_length = 0\n    j = 0\n    for i in range(len(string)):\n        if string[i] in dict:\n            j = max(dict[string[i]], j)\n        dict[string[i]] = i + 1\n        if i - j + 1 > max_length:\n            max_length = i - j + 1\n            sub_string = string[j:i + 1]\n    return (max_length, sub_string)",
  "def get_longest_non_repeat_v2(string):\n    if string is None:\n        return (0, '')\n    sub_string = ''\n    (start, max_len) = (0, 0)\n    used_char = {}\n    for (index, char) in enumerate(string):\n        if char in used_char and start <= used_char[char]:\n            start = used_char[char] + 1\n        elif index - start + 1 > max_len:\n            max_len = index - start + 1\n            sub_string = string[start:index + 1]\n        used_char[char] = index\n    return (max_len, sub_string)",
  "def flatten(input_arr, output_arr=None):\n    if output_arr is None:\n        output_arr = []\n    for ele in input_arr:\n        if not isinstance(ele, str) and isinstance(ele, Iterable):\n            flatten(ele, output_arr)\n        else:\n            output_arr.append(ele)\n    return output_arr",
  "def flatten_iter(iterable):\n    for element in iterable:\n        if not isinstance(element, str) and isinstance(element, Iterable):\n            yield from flatten_iter(element)\n        else:\n            yield element",
  "def max_ones_index(arr):\n    n = len(arr)\n    max_count = 0\n    max_index = 0\n    prev_zero = -1\n    prev_prev_zero = -1\n    for curr in range(n):\n        if arr[curr] == 0:\n            if curr - prev_prev_zero > max_count:\n                max_count = curr - prev_prev_zero\n                max_index = prev_zero\n            prev_prev_zero = prev_zero\n            prev_zero = curr\n    if n - prev_prev_zero > max_count:\n        max_index = prev_zero\n    return max_index",
  "def plus_one_v1(digits):\n    digits[-1] = digits[-1] + 1\n    res = []\n    ten = 0\n    i = len(digits) - 1\n    while i >= 0 or ten == 1:\n        summ = 0\n        if i >= 0:\n            summ += digits[i]\n        if ten:\n            summ += 1\n        res.append(summ % 10)\n        ten = summ // 10\n        i -= 1\n    return res[::-1]",
  "def plus_one_v2(digits):\n    n = len(digits)\n    for i in range(n - 1, -1, -1):\n        if digits[i] < 9:\n            digits[i] += 1\n            return digits\n        digits[i] = 0\n    digits.insert(0, 1)\n    return digits",
  "def plus_one_v3(num_arr):\n    for idx in reversed(list(enumerate(num_arr))):\n        num_arr[idx[0]] = (num_arr[idx[0]] + 1) % 10\n        if num_arr[idx[0]]:\n            return num_arr\n    return [1] + num_arr",
  "def n_sum(n, nums, target, **kv):\n\n    def sum_closure_default(a, b):\n        return a + b\n\n    def compare_closure_default(num, target):\n        if num < target:\n            return -1\n        elif num > target:\n            return 1\n        else:\n            return 0\n\n    def same_closure_default(a, b):\n        return a == b\n\n    def n_sum(n, nums, target):\n        if n == 2:\n            results = two_sum(nums, target)\n        else:\n            results = []\n            prev_num = None\n            for (index, num) in enumerate(nums):\n                if prev_num is not None and same_closure(prev_num, num):\n                    continue\n                prev_num = num\n                n_minus1_results = n_sum(n - 1, nums[index + 1:], target - num)\n                n_minus1_results = append_elem_to_each_list(num, n_minus1_results)\n                results += n_minus1_results\n        return union(results)\n\n    def two_sum(nums, target):\n        nums.sort()\n        lt = 0\n        rt = len(nums) - 1\n        results = []\n        while lt < rt:\n            sum_ = sum_closure(nums[lt], nums[rt])\n            flag = compare_closure(sum_, target)\n            if flag == -1:\n                lt += 1\n            elif flag == 1:\n                rt -= 1\n            else:\n                results.append(sorted([nums[lt], nums[rt]]))\n                lt += 1\n                rt -= 1\n                while lt < len(nums) and same_closure(nums[lt - 1], nums[lt]):\n                    lt += 1\n                while 0 <= rt and same_closure(nums[rt], nums[rt + 1]):\n                    rt -= 1\n        return results\n\n    def append_elem_to_each_list(elem, container):\n        results = []\n        for elems in container:\n            elems.append(elem)\n            results.append(sorted(elems))\n        return results\n\n    def union(duplicate_results):\n        results = []\n        if len(duplicate_results) != 0:\n            duplicate_results.sort()\n            results.append(duplicate_results[0])\n            for result in duplicate_results[1:]:\n                if results[-1] != result:\n                    results.append(result)\n        return results\n    sum_closure = kv.get('sum_closure', sum_closure_default)\n    same_closure = kv.get('same_closure', same_closure_default)\n    compare_closure = kv.get('compare_closure', compare_closure_default)\n    nums.sort()\n    return n_sum(n, nums, target)",
  "def sum_closure_default(a, b):\n    return a + b",
  "def compare_closure_default(num, target):\n    if num < target:\n        return -1\n    elif num > target:\n        return 1\n    else:\n        return 0",
  "def same_closure_default(a, b):\n    return a == b",
  "def n_sum(n, nums, target):\n    if n == 2:\n        results = two_sum(nums, target)\n    else:\n        results = []\n        prev_num = None\n        for (index, num) in enumerate(nums):\n            if prev_num is not None and same_closure(prev_num, num):\n                continue\n            prev_num = num\n            n_minus1_results = n_sum(n - 1, nums[index + 1:], target - num)\n            n_minus1_results = append_elem_to_each_list(num, n_minus1_results)\n            results += n_minus1_results\n    return union(results)",
  "def two_sum(nums, target):\n    nums.sort()\n    lt = 0\n    rt = len(nums) - 1\n    results = []\n    while lt < rt:\n        sum_ = sum_closure(nums[lt], nums[rt])\n        flag = compare_closure(sum_, target)\n        if flag == -1:\n            lt += 1\n        elif flag == 1:\n            rt -= 1\n        else:\n            results.append(sorted([nums[lt], nums[rt]]))\n            lt += 1\n            rt -= 1\n            while lt < len(nums) and same_closure(nums[lt - 1], nums[lt]):\n                lt += 1\n            while 0 <= rt and same_closure(nums[rt], nums[rt + 1]):\n                rt -= 1\n    return results",
  "def append_elem_to_each_list(elem, container):\n    results = []\n    for elems in container:\n        elems.append(elem)\n        results.append(sorted(elems))\n    return results",
  "def union(duplicate_results):\n    results = []\n    if len(duplicate_results) != 0:\n        duplicate_results.sort()\n        results.append(duplicate_results[0])\n        for result in duplicate_results[1:]:\n            if results[-1] != result:\n                results.append(result)\n    return results",
  "def missing_ranges(arr, lo, hi):\n    res = []\n    start = lo\n    for n in arr:\n        if n == start:\n            start += 1\n        elif n > start:\n            res.append((start, n - 1))\n            start = n + 1\n    if start <= hi:\n        res.append((start, hi))\n    return res",
  "def limit(arr, min_lim=None, max_lim=None):\n    if len(arr) == 0:\n        return arr\n    if min_lim is None:\n        min_lim = min(arr)\n    if max_lim is None:\n        max_lim = max(arr)\n    return list(filter(lambda x: min_lim <= x <= max_lim, arr))",
  "def summarize_ranges(array):\n    res = []\n    if len(array) == 1:\n        return [str(array[0])]\n    i = 0\n    while i < len(array):\n        num = array[i]\n        while i + 1 < len(array) and array[i + 1] - array[i] == 1:\n            i += 1\n        if array[i] != num:\n            res.append((num, array[i]))\n        else:\n            res.append((num, num))\n        i += 1\n    return res",
  "def move_zeros(array):\n    result = []\n    zeros = 0\n    for i in array:\n        if i == 0 and type(i) != bool:\n            zeros += 1\n        else:\n            result.append(i)\n    result.extend([0] * zeros)\n    return result",
  "def three_sum(array):\n    res = set()\n    array.sort()\n    for i in range(len(array) - 2):\n        if i > 0 and array[i] == array[i - 1]:\n            continue\n        (l, r) = (i + 1, len(array) - 1)\n        while l < r:\n            s = array[i] + array[l] + array[r]\n            if s > 0:\n                r -= 1\n            elif s < 0:\n                l += 1\n            else:\n                res.add((array[i], array[l], array[r]))\n                while l < r and array[l] == array[l + 1]:\n                    l += 1\n                while l < r and array[r] == array[r - 1]:\n                    r -= 1\n                l += 1\n                r -= 1\n    return res",
  "def trimmean(arr, per):\n    ratio = per / 200\n    cal_sum = 0\n    arr.sort()\n    neg_val = int(len(arr) * ratio)\n    arr = arr[neg_val:len(arr) - neg_val]\n    for i in arr:\n        cal_sum += i\n    return cal_sum / len(arr)",
  "def top_1(arr):\n    values = {}\n    result = []\n    f_val = 0\n    for i in arr:\n        if i in values:\n            values[i] += 1\n        else:\n            values[i] = 1\n    f_val = max(values.values())\n    for i in values.keys():\n        if values[i] == f_val:\n            result.append(i)\n        else:\n            continue\n    return result",
  "def delete_nth_naive(array, n):\n    ans = []\n    for num in array:\n        if ans.count(num) < n:\n            ans.append(num)\n    return ans",
  "def delete_nth(array, n):\n    result = []\n    counts = collections.defaultdict(int)\n    for i in array:\n        if counts[i] < n:\n            result.append(i)\n            counts[i] += 1\n    return result",
  "def rotate_v1(array, k):\n    array = array[:]\n    n = len(array)\n    for i in range(k):\n        temp = array[n - 1]\n        for j in range(n - 1, 0, -1):\n            array[j] = array[j - 1]\n        array[0] = temp\n    return array",
  "def rotate_v2(array, k):\n    array = array[:]\n\n    def reverse(arr, a, b):\n        while a < b:\n            (arr[a], arr[b]) = (arr[b], arr[a])\n            a += 1\n            b -= 1\n    n = len(array)\n    k = k % n\n    reverse(array, 0, n - k - 1)\n    reverse(array, n - k, n - 1)\n    reverse(array, 0, n - 1)\n    return array",
  "def rotate_v3(array, k):\n    if array is None:\n        return None\n    length = len(array)\n    k = k % length\n    return array[length - k:] + array[:length - k]",
  "def reverse(arr, a, b):\n    while a < b:\n        (arr[a], arr[b]) = (arr[b], arr[a])\n        a += 1\n        b -= 1",
  "def josephus(int_list, skip):\n    skip = skip - 1\n    idx = 0\n    len_list = len(int_list)\n    while len_list > 0:\n        idx = (skip + idx) % len_list\n        yield int_list.pop(idx)\n        len_list -= 1",
  "def two_sum(array, target):\n    dic = {}\n    for (i, num) in enumerate(array):\n        if num in dic:\n            return (dic[num], i)\n        else:\n            dic[target - num] = i\n    return None",
  "def merge_intervals(intervals):\n    if intervals is None:\n        return None\n    intervals.sort(key=lambda i: i[0])\n    out = [intervals.pop(0)]\n    for i in intervals:\n        if out[-1][-1] >= i[0]:\n            out[-1][-1] = max(out[-1][-1], i[-1])\n        else:\n            out.append(i)\n    return out",
  "def __init__(self, start=0, end=0):\n    self.start = start\n    self.end = end",
  "def __repr__(self):\n    return 'Interval ({}, {})'.format(self.start, self.end)",
  "def __iter__(self):\n    return iter(range(self.start, self.end))",
  "def __getitem__(self, index):\n    if index < 0:\n        return self.end + index\n    return self.start + index",
  "def __len__(self):\n    return self.end - self.start",
  "def __contains__(self, item):\n    if self.start >= item >= self.end:\n        return True\n    return False",
  "def __eq__(self, other):\n    if self.start == other.start and self.end == other.end:\n        return True\n    return False",
  "def as_list(self):\n    return list(self)",
  "@staticmethod\ndef merge(intervals):\n    out = []\n    for i in sorted(intervals, key=lambda i: i.start):\n        if out and i.start <= out[-1].end:\n            out[-1].end = max(out[-1].end, i.end)\n        else:\n            out += (i,)\n    return out",
  "@staticmethod\ndef print_intervals(intervals):\n    res = []\n    for i in intervals:\n        res.append(repr(i))\n    print(''.join(res))",
  "def garage(initial, final):\n    initial = initial[:]\n    seq = []\n    steps = 0\n    while initial != final:\n        zero = initial.index(0)\n        if zero != final.index(0):\n            car_to_move = final[zero]\n            pos = initial.index(car_to_move)\n            (initial[zero], initial[pos]) = (initial[pos], initial[zero])\n        else:\n            for i in range(len(initial)):\n                if initial[i] != final[i]:\n                    (initial[zero], initial[i]) = (initial[i], initial[zero])\n                    break\n        seq.append(initial[:])\n        steps += 1\n    return (steps, seq)",
  "def binary(x, l=1):\n    fmt = '{0:0%db}' % l\n    return fmt.format(x)",
  "def unary(x):\n    return (x - 1) * '1' + '0'",
  "def elias_generic(lencoding, x):\n    if x == 0:\n        return '0'\n    first_part = 1 + int(log2(x))\n    a = x - 2 ** int(log2(x))\n    k = int(log2(x))\n    return lencoding(first_part) + binary(a, k)",
  "def elias_gamma(x):\n    return elias_generic(unary, x)",
  "def elias_delta(x):\n    return elias_generic(elias_gamma, x)",
  "def __init__(self, frequency=0, sign=None, left=None, right=None):\n    self.frequency = frequency\n    self.sign = sign\n    self.left = left\n    self.right = right",
  "def __lt__(self, other):\n    return self.frequency < other.frequency",
  "def __gt__(self, other):\n    return self.frequency > other.frequency",
  "def __eq__(self, other):\n    return self.frequency == other.frequency",
  "def __str__(self):\n    return '<ch: {0}: {1}>'.format(self.sign, self.frequency)",
  "def __repr__(self):\n    return '<ch: {0}: {1}>'.format(self.sign, self.frequency)",
  "def __init__(self, file):\n    self.file = file\n    self.buffer = []\n    self.is_last_byte = False",
  "def get_number_of_additional_bits_in_the_last_byte(self) -> int:\n    bin_num = self.get_bit() + self.get_bit() + self.get_bit()\n    return int(bin_num, 2)",
  "def load_tree(self) -> Node:\n    node_stack = deque()\n    queue_leaves = deque()\n    root = Node()\n    current_node = root\n    is_end_of_tree = False\n    while not is_end_of_tree:\n        current_bit = self.get_bit()\n        if current_bit == '0':\n            current_node.left = Node()\n            current_node.right = Node()\n            node_stack.append(current_node.right)\n            current_node = current_node.left\n        else:\n            queue_leaves.append(current_node)\n            if node_stack:\n                current_node = node_stack.pop()\n            else:\n                is_end_of_tree = True\n    self._fill_tree(queue_leaves)\n    return root",
  "def _fill_tree(self, leaves_queue):\n    leaves_queue.reverse()\n    while leaves_queue:\n        node = leaves_queue.pop()\n        s = int(self.get_byte(), 2)\n        node.sign = s",
  "def _load_byte(self, buff_limit=8) -> bool:\n    if len(self.buffer) <= buff_limit:\n        byte = self.file.read(1)\n        if not byte:\n            return False\n        i = int.from_bytes(byte, 'big')\n        self.buffer.extend(list('{0:08b}'.format(i)))\n    return True",
  "def get_bit(self, buff_limit=8):\n    if self._load_byte(buff_limit):\n        bit = self.buffer.pop(0)\n        return bit\n    else:\n        return -1",
  "def get_byte(self):\n    if self._load_byte():\n        byte_list = self.buffer[:8]\n        self.buffer = self.buffer[8:]\n        return ''.join(byte_list)\n    else:\n        return -1",
  "def __init__(self, file):\n    self.file = file\n    self.buffer = ''\n    self.saved_bits = 0",
  "def write_char(self, char):\n    self.write_int(ord(char))",
  "def write_int(self, num):\n    bin_int = '{0:08b}'.format(num)\n    self.write_bits(bin_int)",
  "def write_bits(self, bits):\n    self.saved_bits += len(bits)\n    self.buffer += bits\n    while len(self.buffer) >= 8:\n        i = int(self.buffer[:8], 2)\n        self.file.write(bytes([i]))\n        self.buffer = self.buffer[8:]",
  "def save_tree(self, tree):\n    signs = []\n    tree_code = ''\n\n    def get_code_tree(T):\n        nonlocal tree_code\n        if T.sign is not None:\n            signs.append(T.sign)\n        if T.left:\n            tree_code += '0'\n            get_code_tree(T.left)\n        if T.right:\n            tree_code += '1'\n            get_code_tree(T.right)\n    get_code_tree(tree)\n    self.write_bits(tree_code + '1')\n    for int_sign in signs:\n        self.write_int(int_sign)",
  "def _save_information_about_additional_bits(self, additional_bits: int):\n    self.file.seek(0)\n    first_byte_raw = self.file.read(1)\n    self.file.seek(0)\n    first_byte = '{0:08b}'.format(int.from_bytes(first_byte_raw, 'big'))\n    first_byte = first_byte[3:]\n    first_byte = '{0:03b}'.format(additional_bits) + first_byte\n    self.write_bits(first_byte)",
  "def close(self):\n    additional_bits = 8 - len(self.buffer)\n    if additional_bits != 8:\n        self.write_bits('0' * additional_bits)\n        self._save_information_about_additional_bits(additional_bits)",
  "def __init__(self, tree):\n    self.root = tree\n    self.current_node = tree\n    self.found = None",
  "def find(self, bit):\n    if bit == '0':\n        self.current_node = self.current_node.left\n    elif bit == '1':\n        self.current_node = self.current_node.right\n    else:\n        self._reset()\n        return True\n    if self.current_node.sign is not None:\n        self._reset(self.current_node.sign)\n        return True\n    else:\n        return False",
  "def _reset(self, found=''):\n    self.found = found\n    self.current_node = self.root",
  "def __init__(self):\n    pass",
  "@staticmethod\ndef decode_file(file_in_name, file_out_name):\n    with open(file_in_name, 'rb') as file_in, open(file_out_name, 'wb') as file_out:\n        reader = HuffmanReader(file_in)\n        additional_bits = reader.get_number_of_additional_bits_in_the_last_byte()\n        tree = reader.load_tree()\n        HuffmanCoding._decode_and_write_signs_to_file(file_out, reader, tree, additional_bits)\n    print('File decoded.')",
  "@staticmethod\ndef _decode_and_write_signs_to_file(file, reader: HuffmanReader, tree: Node, additional_bits: int):\n    tree_finder = TreeFinder(tree)\n    is_end_of_file = False\n    while not is_end_of_file:\n        bit = reader.get_bit()\n        if bit != -1:\n            while not tree_finder.find(bit):\n                bit = reader.get_bit(0)\n            file.write(bytes([tree_finder.found]))\n        else:\n            is_end_of_file = True\n            last_byte = reader.buffer\n            last_byte = last_byte[:-additional_bits]\n            for bit in last_byte:\n                if tree_finder.find(bit):\n                    file.write(bytes([tree_finder.found]))",
  "@staticmethod\ndef encode_file(file_in_name, file_out_name):\n    with open(file_in_name, 'rb') as file_in, open(file_out_name, mode='wb+') as file_out:\n        signs_frequency = HuffmanCoding._get_char_frequency(file_in)\n        file_in.seek(0)\n        tree = HuffmanCoding._create_tree(signs_frequency)\n        codes = HuffmanCoding._generate_codes(tree)\n        writer = HuffmanWriter(file_out)\n        writer.write_bits('000')\n        writer.save_tree(tree)\n        HuffmanCoding._encode_and_write_signs_to_file(file_in, writer, codes)\n        writer.close()\n    print('File encoded.')",
  "@staticmethod\ndef _encode_and_write_signs_to_file(file, writer: HuffmanWriter, codes: dict):\n    sign = file.read(1)\n    while sign:\n        int_char = int.from_bytes(sign, 'big')\n        writer.write_bits(codes[int_char])\n        sign = file.read(1)",
  "@staticmethod\ndef _get_char_frequency(file) -> dict:\n    is_end_of_file = False\n    signs_frequency = defaultdict(lambda : 0)\n    while not is_end_of_file:\n        prev_pos = file.tell()\n        sign = file.read(1)\n        curr_pos = file.tell()\n        if prev_pos == curr_pos:\n            is_end_of_file = True\n        else:\n            signs_frequency[int.from_bytes(sign, 'big')] += 1\n    return signs_frequency",
  "@staticmethod\ndef _generate_codes(tree: Node) -> dict:\n    codes = dict()\n    HuffmanCoding._go_through_tree_and_create_codes(tree, '', codes)\n    return codes",
  "@staticmethod\ndef _create_tree(signs_frequency: dict) -> Node:\n    nodes = [Node(frequency=frequency, sign=char_int) for (char_int, frequency) in signs_frequency.items()]\n    heapq.heapify(nodes)\n    while len(nodes) > 1:\n        left = heapq.heappop(nodes)\n        right = heapq.heappop(nodes)\n        new_node = Node(frequency=left.frequency + right.frequency, left=left, right=right)\n        heapq.heappush(nodes, new_node)\n    return nodes[0]",
  "@staticmethod\ndef _go_through_tree_and_create_codes(tree: Node, code: str, dict_codes: dict):\n    if tree.sign is not None:\n        dict_codes[tree.sign] = code\n    if tree.left:\n        HuffmanCoding._go_through_tree_and_create_codes(tree.left, code + '0', dict_codes)\n    if tree.right:\n        HuffmanCoding._go_through_tree_and_create_codes(tree.right, code + '1', dict_codes)",
  "def get_code_tree(T):\n    nonlocal tree_code\n    if T.sign is not None:\n        signs.append(T.sign)\n    if T.left:\n        tree_code += '0'\n        get_code_tree(T.left)\n    if T.right:\n        tree_code += '1'\n        get_code_tree(T.right)",
  "def encode_rle(input):\n    if not input:\n        return ''\n    encoded_str = ''\n    prev_ch = ''\n    count = 1\n    for ch in input:\n        if ch != prev_ch:\n            if prev_ch:\n                encoded_str += str(count) + prev_ch\n            count = 1\n            prev_ch = ch\n        else:\n            count += 1\n    else:\n        return encoded_str + (str(count) + prev_ch)",
  "def decode_rle(input):\n    decode_str = ''\n    count = ''\n    for ch in input:\n        if not ch.isdigit():\n            decode_str += ch * int(count)\n            count = ''\n        else:\n            count += ch\n    return decode_str",
  "def max_contiguous_subsequence_sum(arr) -> int:\n    arr_size = len(arr)\n    if arr_size == 0:\n        return 0\n    max_till_now = arr[0]\n    curr_sub_sum = 0\n    for i in range(0, arr_size):\n        if curr_sub_sum + arr[i] < arr[i]:\n            curr_sub_sum = arr[i]\n        else:\n            curr_sub_sum += arr[i]\n        max_till_now = max(max_till_now, curr_sub_sum)\n    return max_till_now",
  "def get_primes(n):\n    if n <= 0:\n        raise ValueError(\"'n' must be a positive integer.\")\n    sieve_size = n // 2 - 1 if n % 2 == 0 else n // 2\n    sieve = [True for _ in range(sieve_size)]\n    primes = []\n    if n >= 2:\n        primes.append(2)\n    for i in range(sieve_size):\n        if sieve[i]:\n            value_at_i = i * 2 + 3\n            primes.append(value_at_i)\n            for j in range(i, sieve_size, value_at_i):\n                sieve[j] = False\n    return primes",
  "def prime_check(num):\n    if num <= 1:\n        return False\n    if num == 2 or num == 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    j = 5\n    while j * j <= num:\n        if num % j == 0 or num % (j + 2) == 0:\n            return False\n        j += 6\n    return True",
  "def find_order(a, n):\n    if (a == 1) & (n == 1):\n        return 1\n    if math.gcd(a, n) != 1:\n        print('a and n should be relative prime!')\n        return -1\n    for i in range(1, n):\n        if pow(a, i) % n == 1:\n            return i\n    return -1",
  "def euler_totient(n):\n    result = n\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            while n % i == 0:\n                n //= i\n            result -= result // i\n    if n > 1:\n        result -= result // n\n    return result",
  "def find_primitive_root(n):\n    if n == 1:\n        return [0]\n    phi = euler_totient(n)\n    p_root_list = []\n    for i in range(1, n):\n        if math.gcd(i, n) != 1:\n            continue\n        order = find_order(i, n)\n        if order == phi:\n            p_root_list.append(i)\n    return p_root_list",
  "def alice_private_key(p):\n    return randint(1, p - 1)",
  "def alice_public_key(a_pr_k, a, p):\n    return pow(a, a_pr_k) % p",
  "def bob_private_key(p):\n    return randint(1, p - 1)",
  "def bob_public_key(b_pr_k, a, p):\n    return pow(a, b_pr_k) % p",
  "def alice_shared_key(b_pu_k, a_pr_k, p):\n    return pow(b_pu_k, a_pr_k) % p",
  "def bob_shared_key(a_pu_k, b_pr_k, p):\n    return pow(a_pu_k, b_pr_k) % p",
  "def diffie_hellman_key_exchange(a, p, option=None):\n    if option is not None:\n        option = 1\n    if prime_check(p) is False:\n        print(f'{p} is not a prime number')\n        return False\n    try:\n        p_root_list = find_primitive_root(p)\n        p_root_list.index(a)\n    except ValueError:\n        print(f'{a} is not a primitive root of {p}')\n        return False\n    a_pr_k = alice_private_key(p)\n    a_pu_k = alice_public_key(a_pr_k, a, p)\n    b_pr_k = bob_private_key(p)\n    b_pu_k = bob_public_key(b_pr_k, a, p)\n    if option == 1:\n        print(f\"Alice's private key: {a_pr_k}\")\n        print(f\"Alice's public key: {a_pu_k}\")\n        print(f\"Bob's private key: {b_pr_k}\")\n        print(f\"Bob's public key: {b_pu_k}\")\n    a_sh_k = alice_shared_key(b_pu_k, a_pr_k, p)\n    b_sh_k = bob_shared_key(a_pu_k, b_pr_k, p)\n    print(f'Shared key calculated by Alice = {a_sh_k}')\n    print(f'Shared key calculated by Bob = {b_sh_k}')\n    return a_sh_k == b_sh_k",
  "def find_next_square(sq):\n    root = sq ** 0.5\n    if root.is_integer():\n        return (root + 1) ** 2\n    return -1",
  "def find_next_square2(sq):\n    root = sq ** 0.5\n    return -1 if root % 1 else (root + 1) ** 2",
  "def decimal_to_binary_util(val):\n    bits = [128, 64, 32, 16, 8, 4, 2, 1]\n    val = int(val)\n    binary_rep = ''\n    for bit in bits:\n        if val >= bit:\n            binary_rep += str(1)\n            val -= bit\n        else:\n            binary_rep += str(0)\n    return binary_rep",
  "def decimal_to_binary_ip(ip):\n    values = ip.split('.')\n    binary_list = []\n    for val in values:\n        binary_list.append(decimal_to_binary_util(val))\n    return '.'.join(binary_list)",
  "def next_bigger(num):\n    digits = [int(i) for i in str(num)]\n    idx = len(digits) - 1\n    while idx >= 1 and digits[idx - 1] >= digits[idx]:\n        idx -= 1\n    if idx == 0:\n        return -1\n    pivot = digits[idx - 1]\n    swap_idx = len(digits) - 1\n    while pivot >= digits[swap_idx]:\n        swap_idx -= 1\n    (digits[swap_idx], digits[idx - 1]) = (digits[idx - 1], digits[swap_idx])\n    digits[idx:] = digits[:idx - 1:-1]\n    return int(''.join((str(x) for x in digits)))",
  "def test_next_bigger(self):\n    self.assertEqual(next_bigger(38276), 38627)\n    self.assertEqual(next_bigger(12345), 12354)\n    self.assertEqual(next_bigger(1528452), 1528524)\n    self.assertEqual(next_bigger(138654), 143568)\n    self.assertEqual(next_bigger(54321), -1)\n    self.assertEqual(next_bigger(999), -1)\n    self.assertEqual(next_bigger(5), -1)",
  "def is_strobogrammatic(num):\n    comb = '00 11 88 69 96'\n    i = 0\n    j = len(num) - 1\n    while i <= j:\n        if comb.find(num[i] + num[j]) == -1:\n            return False\n        i += 1\n        j -= 1\n    return True",
  "def is_strobogrammatic2(num: str):\n    return num == num[::-1].replace('6', '#').replace('9', '6').replace('#', '9')",
  "def gcd(a, b):\n    a_int = isinstance(a, int)\n    b_int = isinstance(b, int)\n    a = abs(a)\n    b = abs(b)\n    if not (a_int or b_int):\n        raise ValueError('Input arguments are not integers')\n    if a == 0 or b == 0:\n        raise ValueError('One or more input arguments equals zero')\n    while b != 0:\n        (a, b) = (b, a % b)\n    return a",
  "def lcm(a, b):\n    return abs(a) * abs(b) / gcd(a, b)",
  "def trailing_zero(x):\n    count = 0\n    while x and (not x & 1):\n        count += 1\n        x >>= 1\n    return count",
  "def gcd_bit(a, b):\n    tza = trailing_zero(a)\n    tzb = trailing_zero(b)\n    a >>= tza\n    b >>= tzb\n    while b:\n        if a < b:\n            (a, b) = (b, a)\n        a -= b\n        a >>= trailing_zero(a)\n    return a << min(tza, tzb)",
  "def generate_key(k, seed=None):\n\n    def modinv(a, m):\n        b = 1\n        while not a * b % m == 1:\n            b += 1\n        return b\n\n    def gen_prime(k, seed=None):\n\n        def is_prime(num):\n            if num == 2:\n                return True\n            for i in range(2, int(num ** 0.5) + 1):\n                if num % i == 0:\n                    return False\n            return True\n        random.seed(seed)\n        while True:\n            key = random.randrange(int(2 ** (k - 1)), int(2 ** k))\n            if is_prime(key):\n                return key\n    p_size = k / 2\n    q_size = k - p_size\n    e = gen_prime(k, seed)\n    while True:\n        p = gen_prime(p_size, seed)\n        if p % e != 1:\n            break\n    while True:\n        q = gen_prime(q_size, seed)\n        if q % e != 1:\n            break\n    n = p * q\n    l = (p - 1) * (q - 1)\n    d = modinv(e, l)\n    return (int(n), int(e), int(d))",
  "def encrypt(data, e, n):\n    return pow(int(data), int(e), int(n))",
  "def decrypt(data, d, n):\n    return pow(int(data), int(d), int(n))",
  "def modinv(a, m):\n    b = 1\n    while not a * b % m == 1:\n        b += 1\n    return b",
  "def gen_prime(k, seed=None):\n\n    def is_prime(num):\n        if num == 2:\n            return True\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    random.seed(seed)\n    while True:\n        key = random.randrange(int(2 ** (k - 1)), int(2 ** k))\n        if is_prime(key):\n            return key",
  "def is_prime(num):\n    if num == 2:\n        return True\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True",
  "def is_prime(n, k):\n\n    def pow2_factor(num):\n        power = 0\n        while num % 2 == 0:\n            num /= 2\n            power += 1\n        return (power, num)\n\n    def valid_witness(a):\n        x = pow(int(a), int(d), int(n))\n        if x == 1 or x == n - 1:\n            return False\n        for _ in range(r - 1):\n            x = pow(int(x), int(2), int(n))\n            if x == 1:\n                return True\n            if x == n - 1:\n                return False\n        return True\n    if n < 5:\n        return n == 2 or n == 3\n    (r, d) = pow2_factor(n - 1)\n    for _ in range(k):\n        if valid_witness(random.randrange(2, n - 2)):\n            return False\n    return True",
  "def pow2_factor(num):\n    power = 0\n    while num % 2 == 0:\n        num /= 2\n        power += 1\n    return (power, num)",
  "def valid_witness(a):\n    x = pow(int(a), int(d), int(n))\n    if x == 1 or x == n - 1:\n        return False\n    for _ in range(r - 1):\n        x = pow(int(x), int(2), int(n))\n        if x == 1:\n            return True\n        if x == n - 1:\n            return False\n    return True",
  "def num_perfect_squares(number):\n    if int(math.sqrt(number)) ** 2 == number:\n        return 1\n    while number > 0 and number % 4 == 0:\n        number /= 4\n    if number % 8 == 7:\n        return 4\n    for i in range(1, int(math.sqrt(number)) + 1):\n        if int(math.sqrt(number - i ** 2)) ** 2 == number - i ** 2:\n            return 2\n    return 3",
  "def find_order(a, n):\n    if (a == 1) & (n == 1):\n        return 1\n    if math.gcd(a, n) != 1:\n        print('a and n should be relative prime!')\n        return -1\n    for i in range(1, n):\n        if pow(a, i) % n == 1:\n            return i\n    return -1",
  "def euler_totient(n):\n    result = n\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            while n % i == 0:\n                n //= i\n            result -= result // i\n    if n > 1:\n        result -= result // n\n    return result",
  "def find_primitive_root(n):\n    if n == 1:\n        return [0]\n    phi = euler_totient(n)\n    p_root_list = []\n    ' It will return every primitive roots of n. '\n    for i in range(1, n):\n        if math.gcd(i, n) == 1:\n            order = find_order(i, n)\n            if order == phi:\n                p_root_list.append(i)\n    return p_root_list",
  "def num_digits(n):\n    n = abs(n)\n    if n == 0:\n        return 1\n    return int(math.log10(n)) + 1",
  "def combination(n, r):\n    if n == r or r == 0:\n        return 1\n    return combination(n - 1, r - 1) + combination(n - 1, r)",
  "def combination_memo(n, r):\n    memo = {}\n\n    def recur(n, r):\n        if n == r or r == 0:\n            return 1\n        if (n, r) not in memo:\n            memo[n, r] = recur(n - 1, r - 1) + recur(n - 1, r)\n        return memo[n, r]\n    return recur(n, r)",
  "def recur(n, r):\n    if n == r or r == 0:\n        return 1\n    if (n, r) not in memo:\n        memo[n, r] = recur(n - 1, r - 1) + recur(n - 1, r)\n    return memo[n, r]",
  "def _l2_distance(vec):\n    norm = 0.0\n    for element in vec:\n        norm += element * element\n    norm = math.sqrt(norm)\n    return norm",
  "def cosine_similarity(vec1, vec2):\n    if len(vec1) != len(vec2):\n        raise ValueError('The two vectors must be the same length. Got shape ' + str(len(vec1)) + ' and ' + str(len(vec2)))\n    norm_a = _l2_distance(vec1)\n    norm_b = _l2_distance(vec2)\n    similarity = 0.0\n    for (vec1_element, vec2_element) in zip(vec1, vec2):\n        similarity += vec1_element * vec2_element\n    similarity /= norm_a * norm_b\n    return similarity",
  "def euler_totient(n):\n    result = n\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            while n % i == 0:\n                n //= i\n            result -= result // i\n    if n > 1:\n        result -= result // n\n    return result",
  "def recursive_binomial_coefficient(n, k):\n    if k > n:\n        raise ValueError('Invalid Inputs, ensure that n >= k')\n    if k == 0 or n == k:\n        return 1\n    if k > n / 2:\n        return recursive_binomial_coefficient(n, n - k)\n    return int(n / k * recursive_binomial_coefficient(n - 1, k - 1))",
  "def int_to_base(num, base):\n    is_negative = False\n    if num == 0:\n        return '0'\n    if num < 0:\n        is_negative = True\n        num *= -1\n    digit = string.digits + string.ascii_uppercase\n    res = ''\n    while num > 0:\n        res += digit[num % base]\n        num //= base\n    if is_negative:\n        return '-' + res[::-1]\n    return res[::-1]",
  "def base_to_int(str_to_convert, base):\n    digit = {}\n    for (ind, char) in enumerate(string.digits + string.ascii_uppercase):\n        digit[char] = ind\n    multiplier = 1\n    res = 0\n    for char in str_to_convert[::-1]:\n        res += digit[char] * multiplier\n        multiplier *= base\n    return res",
  "def solve_chinese_remainder(nums: List[int], rems: List[int]):\n    if not len(nums) == len(rems):\n        raise Exception('nums and rems should have equal length')\n    if not len(nums) > 0:\n        raise Exception('Lists nums and rems need to contain at least one element')\n    for num in nums:\n        if not num > 1:\n            raise Exception('All numbers in nums needs to be > 1')\n    if not _check_coprime(nums):\n        raise Exception('All pairs of numbers in nums are not coprime')\n    k = len(nums)\n    x = 1\n    while True:\n        i = 0\n        while i < k:\n            if x % nums[i] != rems[i]:\n                break\n            i += 1\n        if i == k:\n            return x\n        x += 1",
  "def _check_coprime(list_to_check: List[int]):\n    for (ind, num) in enumerate(list_to_check):\n        for num2 in list_to_check[ind + 1:]:\n            if gcd(num, num2) != 1:\n                return False\n    return True",
  "def cycle_product(m1: Monomial, m2: Monomial) -> Monomial:\n    assert isinstance(m1, Monomial) and isinstance(m2, Monomial)\n    A = m1.variables\n    B = m2.variables\n    result_variables = dict()\n    for i in A:\n        for j in B:\n            k = lcm(i, j)\n            g = i * j // k\n            if k in result_variables:\n                result_variables[k] += A[i] * B[j] * g\n            else:\n                result_variables[k] = A[i] * B[j] * g\n    return Monomial(result_variables, Fraction(m1.coeff * m2.coeff, 1))",
  "def cycle_product_for_two_polynomials(p1: Polynomial, p2: Polynomial, q: Union[float, int, Fraction]) -> Union[float, int, Fraction]:\n    ans = Fraction(0, 1)\n    for m1 in p1.monomials:\n        for m2 in p2.monomials:\n            ans += cycle_product(m1, m2).substitute(q)\n    return ans",
  "def cycle_index_sym_helper(n: int, memo: Dict[int, Polynomial]) -> Polynomial:\n    if n in memo:\n        return memo[n]\n    ans = Polynomial([Monomial({}, Fraction(0, 1))])\n    for t in range(1, n + 1):\n        ans = ans.__add__(Polynomial([Monomial({t: 1}, Fraction(1, 1))]) * cycle_index_sym_helper(n - t, memo))\n    ans *= Fraction(1, n)\n    memo[n] = ans\n    return memo[n]",
  "def get_cycle_index_sym(n: int) -> Polynomial:\n    if n < 0:\n        raise ValueError('n should be a non-negative integer.')\n    memo = {0: Polynomial([Monomial({}, Fraction(1, 1))]), 1: Polynomial([Monomial({1: 1}, Fraction(1, 1))]), 2: Polynomial([Monomial({1: 2}, Fraction(1, 2)), Monomial({2: 1}, Fraction(1, 2))]), 3: Polynomial([Monomial({1: 3}, Fraction(1, 6)), Monomial({1: 1, 2: 1}, Fraction(1, 2)), Monomial({3: 1}, Fraction(1, 3))]), 4: Polynomial([Monomial({1: 4}, Fraction(1, 24)), Monomial({2: 1, 1: 2}, Fraction(1, 4)), Monomial({3: 1, 1: 1}, Fraction(1, 3)), Monomial({2: 2}, Fraction(1, 8)), Monomial({4: 1}, Fraction(1, 4))])}\n    result = cycle_index_sym_helper(n, memo)\n    return result",
  "def magic_number(n):\n    total_sum = 0\n    while n > 0 or total_sum > 9:\n        if n == 0:\n            n = total_sum\n            total_sum = 0\n        total_sum += n % 10\n        n //= 10\n    return total_sum == 1",
  "def factorial(n, mod=None):\n    if not (isinstance(n, int) and n >= 0):\n        raise ValueError(\"'n' must be a non-negative integer.\")\n    if mod is not None and (not (isinstance(mod, int) and mod > 0)):\n        raise ValueError(\"'mod' must be a positive integer\")\n    result = 1\n    if n == 0:\n        return 1\n    for i in range(2, n + 1):\n        result *= i\n        if mod:\n            result %= mod\n    return result",
  "def factorial_recur(n, mod=None):\n    if not (isinstance(n, int) and n >= 0):\n        raise ValueError(\"'n' must be a non-negative integer.\")\n    if mod is not None and (not (isinstance(mod, int) and mod > 0)):\n        raise ValueError(\"'mod' must be a positive integer\")\n    if n == 0:\n        return 1\n    result = n * factorial(n - 1, mod)\n    if mod:\n        result %= mod\n    return result",
  "def gen_strobogrammatic(n):\n    return helper(n, n)",
  "def helper(n, length):\n    if n == 0:\n        return ['']\n    if n == 1:\n        return ['1', '0', '8']\n    middles = helper(n - 2, length)\n    result = []\n    for middle in middles:\n        if n != length:\n            result.append('0' + middle + '0')\n        result.append('8' + middle + '8')\n        result.append('1' + middle + '1')\n        result.append('9' + middle + '6')\n        result.append('6' + middle + '9')\n    return result",
  "def strobogrammatic_in_range(low, high):\n    res = []\n    count = 0\n    low_len = len(low)\n    high_len = len(high)\n    for i in range(low_len, high_len + 1):\n        res.extend(helper2(i, i))\n    for perm in res:\n        if len(perm) == low_len and int(perm) < int(low):\n            continue\n        if len(perm) == high_len and int(perm) > int(high):\n            continue\n        count += 1\n    return count",
  "def helper2(n, length):\n    if n == 0:\n        return ['']\n    if n == 1:\n        return ['0', '8', '1']\n    mids = helper(n - 2, length)\n    res = []\n    for mid in mids:\n        if n != length:\n            res.append('0' + mid + '0')\n        res.append('1' + mid + '1')\n        res.append('6' + mid + '9')\n        res.append('9' + mid + '6')\n        res.append('8' + mid + '8')\n    return res",
  "def extended_gcd(num1, num2):\n    (old_s, s) = (1, 0)\n    (old_t, t) = (0, 1)\n    (old_r, r) = (num1, num2)\n    while r != 0:\n        quotient = old_r / r\n        (old_r, r) = (r, old_r - quotient * r)\n        (old_s, s) = (s, old_s - quotient * s)\n        (old_t, t) = (t, old_t - quotient * t)\n    return (old_s, old_t, old_r)",
  "def pythagoras(opposite, adjacent, hypotenuse):\n    try:\n        if opposite == str('?'):\n            return 'Opposite = ' + str((hypotenuse ** 2 - adjacent ** 2) ** 0.5)\n        if adjacent == str('?'):\n            return 'Adjacent = ' + str((hypotenuse ** 2 - opposite ** 2) ** 0.5)\n        if hypotenuse == str('?'):\n            return 'Hypotenuse = ' + str((opposite ** 2 + adjacent ** 2) ** 0.5)\n        return 'You already know the answer!'\n    except:\n        raise ValueError('invalid argument(s) were given.')",
  "def find_factorial(n):\n    fact = 1\n    while n != 0:\n        fact *= n\n        n -= 1\n    return fact",
  "def krishnamurthy_number(n):\n    if n == 0:\n        return False\n    sum_of_digits = 0\n    temp = n\n    while temp != 0:\n        sum_of_digits += find_factorial(temp % 10)\n        temp //= 10\n    return sum_of_digits == n",
  "def prime_check(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    j = 5\n    while j * j <= n:\n        if n % j == 0 or n % (j + 2) == 0:\n            return False\n        j += 6\n    return True",
  "def extended_gcd(a: int, b: int) -> [int, int, int]:\n    (old_s, s) = (1, 0)\n    (old_t, t) = (0, 1)\n    (old_r, r) = (a, b)\n    while r != 0:\n        quotient = old_r // r\n        (old_r, r) = (r, old_r - quotient * r)\n        (old_s, s) = (s, old_s - quotient * s)\n        (old_t, t) = (t, old_t - quotient * t)\n    return (old_s, old_t, old_r)",
  "def modular_inverse(a: int, m: int) -> int:\n    (s, _, g) = extended_gcd(a, m)\n    if g != 1:\n        raise ValueError('a and m must be coprime')\n    return s % m",
  "def hailstone(n):\n    sequence = [n]\n    while n > 1:\n        if n % 2 != 0:\n            n = 3 * n + 1\n        else:\n            n = int(n / 2)\n        sequence.append(n)\n    return sequence",
  "def find_order(a, n):\n    if (a == 1) & (n == 1):\n        return 1\n    if math.gcd(a, n) != 1:\n        print('a and n should be relative prime!')\n        return -1\n    for i in range(1, n):\n        if pow(a, i) % n == 1:\n            return i\n    return -1",
  "def find_nth_digit(n):\n    length = 1\n    count = 9\n    start = 1\n    while n > length * count:\n        n -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n    start += (n - 1) / length\n    s = str(start)\n    return int(s[(n - 1) % length])",
  "def __init__(self, variables: Dict[int, int], coeff: Union[int, float, Fraction, None]=None) -> None:\n    self.variables = dict()\n    if coeff is None:\n        if len(variables) == 0:\n            coeff = Fraction(0, 1)\n        else:\n            coeff = Fraction(1, 1)\n    elif coeff == 0:\n        self.coeff = Fraction(0, 1)\n        return\n    if len(variables) == 0:\n        self.coeff = Monomial._rationalize_if_possible(coeff)\n        return\n    for i in variables:\n        if variables[i] != 0:\n            self.variables[i] = variables[i]\n    self.coeff = Monomial._rationalize_if_possible(coeff)",
  "@staticmethod\ndef _rationalize_if_possible(num):\n    if isinstance(num, Rational):\n        res = Fraction(num, 1)\n        return Fraction(res.numerator, res.denominator)\n    else:\n        return num",
  "def equal_upto_scalar(self, other) -> bool:\n    if not isinstance(other, Monomial):\n        raise ValueError('Can only compare monomials.')\n    return other.variables == self.variables",
  "def __add__(self, other: Union[int, float, Fraction]):\n    if isinstance(other, int) or isinstance(other, float) or isinstance(other, Fraction):\n        return self.__add__(Monomial({}, Monomial._rationalize_if_possible(other)))\n    if not isinstance(other, Monomial):\n        raise ValueError('Can only add monomials, ints, floats, or Fractions.')\n    if self.variables == other.variables:\n        mono = {i: self.variables[i] for i in self.variables}\n        return Monomial(mono, Monomial._rationalize_if_possible(self.coeff + other.coeff)).clean()\n    raise ValueError(f\"Cannot add {str(other)} to {self.__str__()} because they don't have same variables.\")",
  "def __eq__(self, other) -> bool:\n    return self.equal_upto_scalar(other) and self.coeff == other.coeff",
  "def __mul__(self, other: Union[int, float, Fraction]):\n    if isinstance(other, float) or isinstance(other, int) or isinstance(other, Fraction):\n        mono = {i: self.variables[i] for i in self.variables}\n        return Monomial(mono, Monomial._rationalize_if_possible(self.coeff * other)).clean()\n    if not isinstance(other, Monomial):\n        raise ValueError('Can only multiply monomials, ints, floats, or Fractions.')\n    else:\n        mono = {i: self.variables[i] for i in self.variables}\n        for i in other.variables:\n            if i in mono:\n                mono[i] += other.variables[i]\n            else:\n                mono[i] = other.variables[i]\n        temp = dict()\n        for k in mono:\n            if mono[k] != 0:\n                temp[k] = mono[k]\n        return Monomial(temp, Monomial._rationalize_if_possible(self.coeff * other.coeff)).clean()",
  "def inverse(self):\n    mono = {i: self.variables[i] for i in self.variables if self.variables[i] != 0}\n    for i in mono:\n        mono[i] *= -1\n    if self.coeff == 0:\n        raise ValueError('Coefficient must not be 0.')\n    return Monomial(mono, Monomial._rationalize_if_possible(1 / self.coeff)).clean()",
  "def __truediv__(self, other: Union[int, float, Fraction]):\n    if isinstance(other, int) or isinstance(other, float) or isinstance(other, Fraction):\n        mono = {i: self.variables[i] for i in self.variables}\n        if other == 0:\n            raise ValueError('Cannot divide by 0.')\n        return Monomial(mono, Monomial._rationalize_if_possible(self.coeff / other)).clean()\n    o = other.inverse()\n    return self.__mul__(o)",
  "def __floordiv__(self, other: Union[int, float, Fraction]):\n    return self.__truediv__(other)",
  "def clone(self):\n    temp_variables = {i: self.variables[i] for i in self.variables}\n    return Monomial(temp_variables, Monomial._rationalize_if_possible(self.coeff)).clean()",
  "def clean(self):\n    temp_variables = {i: self.variables[i] for i in self.variables if self.variables[i] != 0}\n    return Monomial(temp_variables, Monomial._rationalize_if_possible(self.coeff))",
  "def __sub__(self, other: Union[int, float, Fraction]):\n    if isinstance(other, int) or isinstance(other, float) or isinstance(other, Fraction):\n        mono = {i: self.variables[i] for i in self.variables if self.variables[i] != 0}\n        if len(mono) != 0:\n            raise ValueError('Can only subtract like monomials.')\n        other_term = Monomial(mono, Monomial._rationalize_if_possible(other))\n        return self.__sub__(other_term)\n    if not isinstance(other, Monomial):\n        raise ValueError('Can only subtract monomials')\n    return self.__add__(other.__mul__(Fraction(-1, 1)))",
  "def __hash__(self) -> int:\n    arr = []\n    for i in sorted(self.variables):\n        if self.variables[i] > 0:\n            for _ in range(self.variables[i]):\n                arr.append(i)\n    return hash(tuple(arr))",
  "def all_variables(self) -> Set:\n    return set(sorted(self.variables.keys()))",
  "def substitute(self, substitutions: Union[int, float, Fraction, Dict[int, Union[int, float, Fraction]]]) -> Fraction:\n    if isinstance(substitutions, int) or isinstance(substitutions, float) or isinstance(substitutions, Fraction):\n        substitutions = {v: Monomial._rationalize_if_possible(substitutions) for v in self.all_variables()}\n    elif not self.all_variables().issubset(set(substitutions.keys())):\n        raise ValueError(\"Some variables didn't receive their values.\")\n    if self.coeff == 0:\n        return Fraction(0, 1)\n    ans = Monomial._rationalize_if_possible(self.coeff)\n    for k in self.variables:\n        ans *= Monomial._rationalize_if_possible(substitutions[k] ** self.variables[k])\n    return Monomial._rationalize_if_possible(ans)",
  "def __str__(self) -> str:\n    if len(self.variables) == 0:\n        return str(self.coeff)\n    result = str(self.coeff)\n    result += '('\n    for i in self.variables:\n        temp = 'a_{}'.format(str(i))\n        if self.variables[i] > 1:\n            temp = '(' + temp + ')**{}'.format(self.variables[i])\n        elif self.variables[i] < 0:\n            temp = '(' + temp + ')**(-{})'.format(-self.variables[i])\n        elif self.variables[i] == 0:\n            continue\n        else:\n            temp = '(' + temp + ')'\n        result += temp\n    return result + ')'",
  "def __init__(self, monomials: Iterable[Union[int, float, Fraction, Monomial]]) -> None:\n    self.monomials = set()\n    for m in monomials:\n        if any(map(lambda x: isinstance(m, x), [int, float, Fraction])):\n            self.monomials |= {Monomial({}, m)}\n        elif isinstance(m, Monomial):\n            self.monomials |= {m}\n        else:\n            raise ValueError('Iterable should have monomials, int, float, or Fraction.')\n    self.monomials -= {Monomial({}, 0)}",
  "@staticmethod\ndef _rationalize_if_possible(num):\n    if isinstance(num, Rational):\n        res = Fraction(num, 1)\n        return Fraction(res.numerator, res.denominator)\n    else:\n        return num",
  "def __add__(self, other: Union[int, float, Fraction, Monomial]):\n    if isinstance(other, int) or isinstance(other, float) or isinstance(other, Fraction):\n        return self.__add__(Monomial({}, Polynomial._rationalize_if_possible(other)))\n    elif isinstance(other, Monomial):\n        monos = {m.clone() for m in self.monomials}\n        for _own_monos in monos:\n            if _own_monos.equal_upto_scalar(other):\n                scalar = _own_monos.coeff\n                monos -= {_own_monos}\n                temp_variables = {i: other.variables[i] for i in other.variables}\n                monos |= {Monomial(temp_variables, Polynomial._rationalize_if_possible(scalar + other.coeff))}\n                return Polynomial([z for z in monos])\n        monos |= {other.clone()}\n        return Polynomial([z for z in monos])\n    elif isinstance(other, Polynomial):\n        temp = list((z for z in {m.clone() for m in self.all_monomials()}))\n        p = Polynomial(temp)\n        for o in other.all_monomials():\n            p = p.__add__(o.clone())\n        return p\n    else:\n        raise ValueError('Can only add int, float, Fraction, Monomials, or Polynomials to Polynomials.')",
  "def __sub__(self, other: Union[int, float, Fraction, Monomial]):\n    if isinstance(other, int) or isinstance(other, float) or isinstance(other, Fraction):\n        return self.__sub__(Monomial({}, Polynomial._rationalize_if_possible(other)))\n    elif isinstance(other, Monomial):\n        monos = {m.clone() for m in self.all_monomials()}\n        for _own_monos in monos:\n            if _own_monos.equal_upto_scalar(other):\n                scalar = _own_monos.coeff\n                monos -= {_own_monos}\n                temp_variables = {i: other.variables[i] for i in other.variables}\n                monos |= {Monomial(temp_variables, Polynomial._rationalize_if_possible(scalar - other.coeff))}\n                return Polynomial([z for z in monos])\n        to_insert = other.clone()\n        to_insert.coeff *= -1\n        monos |= {to_insert}\n        return Polynomial([z for z in monos])\n    elif isinstance(other, Polynomial):\n        p = Polynomial(list((z for z in {m.clone() for m in self.all_monomials()})))\n        for o in other.all_monomials():\n            p = p.__sub__(o.clone())\n        return p\n    else:\n        raise ValueError('Can only subtract int, float, Fraction, Monomials, or Polynomials from Polynomials.')\n        return",
  "def __mul__(self, other: Union[int, float, Fraction, Monomial]):\n    if isinstance(other, int) or isinstance(other, float) or isinstance(other, Fraction):\n        result = Polynomial([])\n        monos = {m.clone() for m in self.all_monomials()}\n        for m in monos:\n            result = result.__add__(m.clone() * other)\n        return result\n    elif isinstance(other, Monomial):\n        result = Polynomial([])\n        monos = {m.clone() for m in self.all_monomials()}\n        for m in monos:\n            result = result.__add__(m.clone() * other)\n        return result\n    elif isinstance(other, Polynomial):\n        temp_self = {m.clone() for m in self.all_monomials()}\n        temp_other = {m.clone() for m in other.all_monomials()}\n        result = Polynomial([])\n        for i in temp_self:\n            for j in temp_other:\n                result = result.__add__(i * j)\n        return result\n    else:\n        raise ValueError('Can only multiple int, float, Fraction, Monomials, or Polynomials with Polynomials.')",
  "def __floordiv__(self, other: Union[int, float, Fraction, Monomial]):\n    return self.__truediv__(other)",
  "def __truediv__(self, other: Union[int, float, Fraction, Monomial]):\n    if isinstance(other, int) or isinstance(other, float) or isinstance(other, Fraction):\n        return self.__truediv__(Monomial({}, other))\n    elif isinstance(other, Monomial):\n        poly_temp = reduce(lambda acc, val: acc + val, map(lambda x: x / other, [z for z in self.all_monomials()]), Polynomial([Monomial({}, 0)]))\n        return poly_temp\n    elif isinstance(other, Polynomial):\n        if Monomial({}, 0) in other.all_monomials():\n            if len(other.all_monomials()) == 2:\n                temp_set = {x for x in other.all_monomials() if x != Monomial({}, 0)}\n                only = temp_set.pop()\n                return self.__truediv__(only)\n        elif len(other.all_monomials()) == 1:\n            temp_set = {x for x in other.all_monomials()}\n            only = temp_set.pop()\n            return self.__truediv__(only)\n    raise ValueError('Can only divide a polynomial by an int, float, Fraction, or a Monomial.')\n    return",
  "def clone(self):\n    return Polynomial(list({m.clone() for m in self.all_monomials()}))",
  "def variables(self) -> Set:\n    res = set()\n    for i in self.all_monomials():\n        res |= {j for j in i.variables}\n    res = list(res)\n    return set(res)",
  "def all_monomials(self) -> Iterable[Monomial]:\n    return {m for m in self.monomials if m != Monomial({}, 0)}",
  "def __eq__(self, other) -> bool:\n    if isinstance(other, int) or isinstance(other, float) or isinstance(other, Fraction):\n        other_poly = Polynomial([Monomial({}, other)])\n        return self.__eq__(other_poly)\n    elif isinstance(other, Monomial):\n        return self.__eq__(Polynomial([other]))\n    elif isinstance(other, Polynomial):\n        return self.all_monomials() == other.all_monomials()\n    else:\n        raise ValueError('Can only compare a polynomial with an int, float, Fraction, Monomial, or another Polynomial.')",
  "def subs(self, substitutions: Union[int, float, Fraction, Dict[int, Union[int, float, Fraction]]]) -> Union[int, float, Fraction]:\n    if isinstance(substitutions, int) or isinstance(substitutions, float) or isinstance(substitutions, Fraction):\n        substitutions = {i: Polynomial._rationalize_if_possible(substitutions) for i in set(self.variables())}\n        return self.subs(substitutions)\n    elif not isinstance(substitutions, dict):\n        raise ValueError('The substitutions should be a dictionary.')\n    if not self.variables().issubset(set(substitutions.keys())):\n        raise ValueError(\"Some variables didn't receive their values.\")\n    ans = 0\n    for m in self.all_monomials():\n        ans += Polynomial._rationalize_if_possible(m.substitute(substitutions))\n    return Polynomial._rationalize_if_possible(ans)",
  "def __str__(self) -> str:\n    return ' + '.join((str(m) for m in self.all_monomials() if m.coeff != Fraction(0, 1)))",
  "def modular_exponential(base, exponent, mod):\n    if exponent < 0:\n        raise ValueError('Exponent must be positive.')\n    base %= mod\n    result = 1\n    while exponent > 0:\n        if exponent & 1:\n            result = result * base % mod\n        exponent = exponent >> 1\n        base = base * base % mod\n    return result",
  "def power(a: int, n: int, mod: int=None):\n    ans = 1\n    while n:\n        if n & 1:\n            ans = ans * a\n        a = a * a\n        if mod:\n            ans %= mod\n            a %= mod\n        n >>= 1\n    return ans",
  "def power_recur(a: int, n: int, mod: int=None):\n    if n == 0:\n        ans = 1\n    elif n == 1:\n        ans = a\n    else:\n        ans = power_recur(a, n // 2, mod)\n        ans = ans * ans\n        if n % 2:\n            ans = ans * a\n    if mod:\n        ans %= mod\n    return ans",
  "def square_root(n, epsilon=0.001):\n    guess = n / 2\n    while abs(guess * guess - n) > epsilon:\n        guess = (guess + n / guess) / 2\n    return guess",
  "def sum_dig_pow(low, high):\n    result = []\n    for number in range(low, high + 1):\n        exponent = 1\n        summation = 0\n        number_as_string = str(number)\n        tokens = list(map(int, number_as_string))\n        for k in tokens:\n            summation = summation + k ** exponent\n            exponent += 1\n        if summation == number:\n            result.append(number)\n    return result",
  "def cut_rod(price):\n    n = len(price)\n    val = [0] * (n + 1)\n    for i in range(1, n + 1):\n        max_val = INT_MIN\n        for j in range(i):\n            max_val = max(max_val, price[j] + val[i - j - 1])\n        val[i] = max_val\n    return val[n]",
  "def house_robber(houses):\n    (last, now) = (0, 0)\n    for house in houses:\n        (last, now) = (now, max(last + house, now))\n    return now",
  "def binary_search(job, start_index):\n    left = 0\n    right = start_index - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if job[mid].finish <= job[start_index].start:\n            if job[mid + 1].finish <= job[start_index].start:\n                left = mid + 1\n            else:\n                return mid\n        else:\n            right = mid - 1\n    return -1",
  "def schedule(job):\n    job = sorted(job, key=lambda j: j.finish)\n    length = len(job)\n    table = [0 for _ in range(length)]\n    table[0] = job[0].profit\n    for i in range(1, length):\n        incl_prof = job[i].profit\n        pos = binary_search(job, i)\n        if pos != -1:\n            incl_prof += table[pos]\n        table[i] = max(incl_prof, table[i - 1])\n    return table[length - 1]",
  "def __init__(self, start, finish, profit):\n    self.start = start\n    self.finish = finish\n    self.profit = profit",
  "def longest_common_subsequence(s_1, s_2):\n    m = len(s_1)\n    n = len(s_2)\n    mat = [[0] * (n + 1) for i in range(m + 1)]\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0 or j == 0:\n                mat[i][j] = 0\n            elif s_1[i - 1] == s_2[j - 1]:\n                mat[i][j] = mat[i - 1][j - 1] + 1\n            else:\n                mat[i][j] = max(mat[i - 1][j], mat[i][j - 1])\n    return mat[m][n]",
  "def max_profit_naive(prices):\n    max_so_far = 0\n    for i in range(0, len(prices) - 1):\n        for j in range(i + 1, len(prices)):\n            max_so_far = max(max_so_far, prices[j] - prices[i])\n    return max_so_far",
  "def max_profit_optimized(prices):\n    (cur_max, max_so_far) = (0, 0)\n    for i in range(1, len(prices)):\n        cur_max = max(0, cur_max + prices[i] - prices[i - 1])\n        max_so_far = max(max_so_far, cur_max)\n    return max_so_far",
  "def is_match(str_a, str_b):\n    (len_a, len_b) = (len(str_a) + 1, len(str_b) + 1)\n    matches = [[False] * len_b for _ in range(len_a)]\n    matches[0][0] = True\n    for (i, element) in enumerate(str_b[1:], 2):\n        matches[0][i] = matches[0][i - 2] and element == '*'\n    for (i, char_a) in enumerate(str_a, 1):\n        for (j, char_b) in enumerate(str_b, 1):\n            if char_b != '*':\n                matches[i][j] = matches[i - 1][j - 1] and char_b in (char_a, '.')\n            else:\n                matches[i][j] |= matches[i][j - 2]\n                if char_a == str_b[j - 2] or str_b[j - 2] == '.':\n                    matches[i][j] |= matches[i - 1][j]\n    return matches[-1][-1]",
  "def get_maximum_value(items, capacity):\n    dp = [0] * (capacity + 1)\n    for item in items:\n        for cur_weight in reversed(range(item.weight, capacity + 1)):\n            dp[cur_weight] = max(dp[cur_weight], item.value + dp[cur_weight - item.weight])\n    return dp[capacity]",
  "def __init__(self, value, weight):\n    self.value = value\n    self.weight = weight",
  "def max_subarray(array):\n    max_so_far = max_now = array[0]\n    for i in range(1, len(array)):\n        max_now = max(array[i], max_now + array[i])\n        max_so_far = max(max_so_far, max_now)\n    return max_so_far",
  "def matrix_chain_order(array):\n    n = len(array)\n    matrix = [[0 for x in range(n)] for x in range(n)]\n    sol = [[0 for x in range(n)] for x in range(n)]\n    for chain_length in range(2, n):\n        for a in range(1, n - chain_length + 1):\n            b = a + chain_length - 1\n            matrix[a][b] = INF\n            for c in range(a, b):\n                cost = matrix[a][c] + matrix[c + 1][b] + array[a - 1] * array[c] * array[b]\n                if cost < matrix[a][b]:\n                    matrix[a][b] = cost\n                    sol[a][b] = c\n    return (matrix, sol)",
  "def print_optimal_solution(optimal_solution, i, j):\n    if i == j:\n        print('A' + str(i), end=' ')\n    else:\n        print('(', end=' ')\n        print_optimal_solution(optimal_solution, i, optimal_solution[i][j])\n        print_optimal_solution(optimal_solution, optimal_solution[i][j] + 1, j)\n        print(')', end=' ')",
  "def main():\n    array = [30, 35, 15, 5, 10, 20, 25]\n    length = len(array)\n    (matrix, optimal_solution) = matrix_chain_order(array)\n    print('No. of Operation required: ' + str(matrix[1][length - 1]))\n    print_optimal_solution(optimal_solution, 1, length - 1)",
  "def fib_recursive(n):\n    assert n >= 0, 'n must be a positive integer'\n    if n <= 1:\n        return n\n    return fib_recursive(n - 1) + fib_recursive(n - 2)",
  "def fib_list(n):\n    assert n >= 0, 'n must be a positive integer'\n    list_results = [0, 1]\n    for i in range(2, n + 1):\n        list_results.append(list_results[i - 1] + list_results[i - 2])\n    return list_results[n]",
  "def fib_iter(n):\n    assert n >= 0, 'n must be positive integer'\n    fib_1 = 0\n    fib_2 = 1\n    res = 0\n    if n <= 1:\n        return n\n    for _ in range(n - 1):\n        res = fib_1 + fib_2\n        fib_1 = fib_2\n        fib_2 = res\n    return res",
  "def count(coins, value):\n    dp_array = [1] + [0] * value\n    for coin in coins:\n        for i in range(coin, value + 1):\n            dp_array[i] += dp_array[i - coin]\n    return dp_array[value]",
  "def longest_increasing_subsequence(sequence):\n    length = len(sequence)\n    counts = [1 for _ in range(length)]\n    for i in range(1, length):\n        for j in range(0, i):\n            if sequence[i] > sequence[j]:\n                counts[i] = max(counts[i], counts[j] + 1)\n                print(counts)\n    return max(counts)",
  "def longest_increasing_subsequence_optimized(sequence):\n    max_seq = max(sequence)\n    tree = [0] * (max_seq << 2)\n\n    def update(pos, left, right, target, vertex):\n        if left == right:\n            tree[pos] = vertex\n            return\n        mid = left + right >> 1\n        if target <= mid:\n            update(pos << 1, left, mid, target, vertex)\n        else:\n            update(pos << 1 | 1, mid + 1, right, target, vertex)\n        tree[pos] = max_seq(tree[pos << 1], tree[pos << 1 | 1])\n\n    def get_max(pos, left, right, start, end):\n        if left > end or right < start:\n            return 0\n        if left >= start and right <= end:\n            return tree[pos]\n        mid = left + right >> 1\n        return max_seq(get_max(pos << 1, left, mid, start, end), get_max(pos << 1 | 1, mid + 1, right, start, end))\n    ans = 0\n    for element in sequence:\n        cur = get_max(1, 0, max_seq, 0, element - 1) + 1\n        ans = max_seq(ans, cur)\n        update(1, 0, max_seq, element, cur)\n    return ans",
  "def longest_increasing_subsequence_optimized2(sequence):\n    length = len(sequence)\n    tree = [0] * (length << 2)\n    sorted_seq = sorted(((x, -i) for (i, x) in enumerate(sequence)))\n\n    def update(pos, left, right, target, vertex):\n        if left == right:\n            tree[pos] = vertex\n            return\n        mid = left + right >> 1\n        if target <= mid:\n            vertex(pos << 1, left, mid, target, vertex)\n        else:\n            vertex(pos << 1 | 1, mid + 1, right, target, vertex)\n        tree[pos] = max(tree[pos << 1], tree[pos << 1 | 1])\n\n    def get_max(pos, left, right, start, end):\n        if left > end or right < start:\n            return 0\n        if left >= start and right <= end:\n            return tree[pos]\n        mid = left + right >> 1\n        return max(get_max(pos << 1, left, mid, start, end), get_max(pos << 1 | 1, mid + 1, right, start, end))\n    ans = 0\n    for tup in sorted_seq:\n        i = -tup[1]\n        cur = get_max(1, 0, length - 1, 0, i - 1) + 1\n        ans = max(ans, cur)\n        update(1, 0, length - 1, i, cur)\n    return ans",
  "def update(pos, left, right, target, vertex):\n    if left == right:\n        tree[pos] = vertex\n        return\n    mid = left + right >> 1\n    if target <= mid:\n        update(pos << 1, left, mid, target, vertex)\n    else:\n        update(pos << 1 | 1, mid + 1, right, target, vertex)\n    tree[pos] = max_seq(tree[pos << 1], tree[pos << 1 | 1])",
  "def get_max(pos, left, right, start, end):\n    if left > end or right < start:\n        return 0\n    if left >= start and right <= end:\n        return tree[pos]\n    mid = left + right >> 1\n    return max_seq(get_max(pos << 1, left, mid, start, end), get_max(pos << 1 | 1, mid + 1, right, start, end))",
  "def update(pos, left, right, target, vertex):\n    if left == right:\n        tree[pos] = vertex\n        return\n    mid = left + right >> 1\n    if target <= mid:\n        vertex(pos << 1, left, mid, target, vertex)\n    else:\n        vertex(pos << 1 | 1, mid + 1, right, target, vertex)\n    tree[pos] = max(tree[pos << 1], tree[pos << 1 | 1])",
  "def get_max(pos, left, right, start, end):\n    if left > end or right < start:\n        return 0\n    if left >= start and right <= end:\n        return tree[pos]\n    mid = left + right >> 1\n    return max(get_max(pos << 1, left, mid, start, end), get_max(pos << 1 | 1, mid + 1, right, start, end))",
  "def num_decodings(enc_mes):\n    if not enc_mes or enc_mes[0] == '0':\n        return 0\n    (last_char, last_two_chars) = (1, 1)\n    for i in range(1, len(enc_mes)):\n        last = last_char if enc_mes[i] != '0' else 0\n        last_two = last_two_chars if int(enc_mes[i - 1:i + 1]) < 27 and enc_mes[i - 1] != '0' else 0\n        last_two_chars = last_char\n        last_char = last + last_two\n    return last_char",
  "def num_decodings2(enc_mes):\n    if not enc_mes or enc_mes.startswith('0'):\n        return 0\n    stack = [1, 1]\n    for i in range(1, len(enc_mes)):\n        if enc_mes[i] == '0':\n            if enc_mes[i - 1] == '0' or enc_mes[i - 1] > '2':\n                return 0\n            stack.append(stack[-2])\n        elif 9 < int(enc_mes[i - 1:i + 1]) < 27:\n            stack.append(stack[-2] + stack[-1])\n        else:\n            stack.append(stack[-1])\n    return stack[-1]",
  "def int_divide(decompose):\n    arr = [[0 for i in range(decompose + 1)] for j in range(decompose + 1)]\n    arr[1][1] = 1\n    for i in range(1, decompose + 1):\n        for j in range(1, decompose + 1):\n            if i < j:\n                arr[i][j] = arr[i][i]\n            elif i == j:\n                arr[i][j] = 1 + arr[i][j - 1]\n            else:\n                arr[i][j] = arr[i][j - 1] + arr[i - j][j]\n    return arr[decompose][decompose]",
  "def edit_distance(word_a, word_b):\n    (length_a, length_b) = (len(word_a) + 1, len(word_b) + 1)\n    edit = [[0 for _ in range(length_b)] for _ in range(length_a)]\n    for i in range(1, length_a):\n        edit[i][0] = i\n    for j in range(1, length_b):\n        edit[0][j] = j\n    for i in range(1, length_a):\n        for j in range(1, length_b):\n            cost = 0 if word_a[i - 1] == word_b[j - 1] else 1\n            edit[i][j] = min(edit[i - 1][j] + 1, edit[i][j - 1] + 1, edit[i - 1][j - 1] + cost)\n    return edit[-1][-1]",
  "def max_product(nums):\n    lmin = lmax = gmax = nums[0]\n    for num in nums:\n        t_1 = num * lmax\n        t_2 = num * lmin\n        lmax = max(max(t_1, t_2), num)\n        lmin = min(min(t_1, t_2), num)\n        gmax = max(gmax, lmax)",
  "def subarray_with_max_product(arr):\n    length = len(arr)\n    product_so_far = max_product_end = 1\n    max_start_i = 0\n    so_far_start_i = so_far_end_i = 0\n    all_negative_flag = True\n    for i in range(length):\n        max_product_end *= arr[i]\n        if arr[i] > 0:\n            all_negative_flag = False\n        if max_product_end <= 0:\n            max_product_end = arr[i]\n            max_start_i = i\n        if product_so_far <= max_product_end:\n            product_so_far = max_product_end\n            so_far_end_i = i\n            so_far_start_i = max_start_i\n    if all_negative_flag:\n        print(f'max_product_so_far: {reduce(lambda x, y: x * y, arr)}, {arr}')\n    else:\n        print(f'max_product_so_far: {product_so_far},{arr[so_far_start_i:so_far_end_i + 1]}')",
  "def find_k_factor(length, k_factor):\n    mat = [[[0 for i in range(4)] for j in range((length - 1) // 3 + 2)] for k in range(length + 1)]\n    if 3 * k_factor + 1 > length:\n        return 0\n    mat[1][0][0] = 1\n    mat[1][0][1] = 0\n    mat[1][0][2] = 0\n    mat[1][0][3] = 25\n    for i in range(2, length + 1):\n        for j in range((length - 1) // 3 + 2):\n            if j == 0:\n                mat[i][j][0] = mat[i - 1][j][0] + mat[i - 1][j][1] + mat[i - 1][j][3]\n                mat[i][j][1] = mat[i - 1][j][0]\n                mat[i][j][2] = mat[i - 1][j][1]\n                mat[i][j][3] = mat[i - 1][j][0] * 24 + mat[i - 1][j][1] * 24 + mat[i - 1][j][2] * 25 + mat[i - 1][j][3] * 25\n            elif 3 * j + 1 < i:\n                mat[i][j][0] = mat[i - 1][j][0] + mat[i - 1][j][1] + mat[i - 1][j][3] + mat[i - 1][j - 1][2]\n                mat[i][j][1] = mat[i - 1][j][0]\n                mat[i][j][2] = mat[i - 1][j][1]\n                mat[i][j][3] = mat[i - 1][j][0] * 24 + mat[i - 1][j][1] * 24 + mat[i - 1][j][2] * 25 + mat[i - 1][j][3] * 25\n            elif 3 * j + 1 == i:\n                mat[i][j][0] = 1\n                mat[i][j][1] = 0\n                mat[i][j][2] = 0\n                mat[i][j][3] = 0\n            else:\n                mat[i][j][0] = 0\n                mat[i][j][1] = 0\n                mat[i][j][2] = 0\n                mat[i][j][3] = 0\n    return sum(mat[length][k_factor])",
  "def climb_stairs(steps):\n    arr = [1, 1]\n    for _ in range(1, steps):\n        arr.append(arr[-1] + arr[-2])\n    return arr[-1]",
  "def climb_stairs_optimized(steps):\n    a_steps = b_steps = 1\n    for _ in range(steps):\n        (a_steps, b_steps) = (b_steps, a_steps + b_steps)\n    return a_steps",
  "def word_break(word, word_dict):\n    dp_array = [False] * (len(word) + 1)\n    dp_array[0] = True\n    for i in range(1, len(word) + 1):\n        for j in range(0, i):\n            if dp_array[j] and word[j:i] in word_dict:\n                dp_array[i] = True\n                break\n    return dp_array[-1]",
  "def hosoya(height, width):\n    if width == 0 and height in (0, 1):\n        return 1\n    if width == 1 and height in (1, 2):\n        return 1\n    if height > width:\n        return hosoya(height - 1, width) + hosoya(height - 2, width)\n    if width == height:\n        return hosoya(height - 1, width - 1) + hosoya(height - 2, width - 2)\n    return 0",
  "def print_hosoya(height):\n    for i in range(height):\n        for j in range(i + 1):\n            print(hosoya(i, j), end=' ')\n        print('\\n', end='')",
  "def hosoya_testing(height):\n    res = []\n    for i in range(height):\n        for j in range(i + 1):\n            res.append(hosoya(i, j))\n    return res",
  "def min_cost(cost):\n    length = len(cost)\n    dist = [INF] * length\n    dist[0] = 0\n    for i in range(length):\n        for j in range(i + 1, length):\n            dist[j] = min(dist[j], dist[i] + cost[i][j])\n    return dist[length - 1]",
  "def helper_topdown(nums, target):\n    if DP[target] != -1:\n        return DP[target]\n    res = 0\n    for num in nums:\n        if target >= num:\n            res += helper_topdown(nums, target - num)\n    DP[target] = res\n    return res",
  "def combination_sum_topdown(nums, target):\n    global DP\n    DP = [-1] * (target + 1)\n    DP[0] = 1\n    return helper_topdown(nums, target)",
  "def combination_sum_bottom_up(nums, target):\n    combs = [0] * (target + 1)\n    combs[0] = 1\n    for i in range(0, len(combs)):\n        for num in nums:\n            if i - num >= 0:\n                combs[i] += combs[i - num]\n    return combs[target]",
  "def planting_trees(trees, length, width):\n    trees = [0] + trees\n    n_pairs = int(len(trees) / 2)\n    space_between_pairs = length / (n_pairs - 1)\n    target_locations = [location * space_between_pairs for location in range(n_pairs)]\n    cmatrix = [[0 for _ in range(n_pairs + 1)] for _ in range(n_pairs + 1)]\n    for r_i in range(1, n_pairs + 1):\n        cmatrix[r_i][0] = cmatrix[r_i - 1][0] + sqrt(width + abs(trees[r_i] - target_locations[r_i - 1]) ** 2)\n    for l_i in range(1, n_pairs + 1):\n        cmatrix[0][l_i] = cmatrix[0][l_i - 1] + abs(trees[l_i] - target_locations[l_i - 1])\n    for r_i in range(1, n_pairs + 1):\n        for l_i in range(1, n_pairs + 1):\n            cmatrix[r_i][l_i] = min(cmatrix[r_i - 1][l_i] + sqrt(width + (trees[l_i + r_i] - target_locations[r_i - 1]) ** 2), cmatrix[r_i][l_i - 1] + abs(trees[l_i + r_i] - target_locations[l_i - 1]))\n    return cmatrix[n_pairs][n_pairs]",
  "def egg_drop(n, k):\n    egg_floor = [[0 for _ in range(k + 1)] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        egg_floor[i][1] = 1\n        egg_floor[i][0] = 0\n    for j in range(1, k + 1):\n        egg_floor[1][j] = j\n    for i in range(2, n + 1):\n        for j in range(2, k + 1):\n            egg_floor[i][j] = INT_MAX\n            for x in range(1, j + 1):\n                res = 1 + max(egg_floor[i - 1][x - 1], egg_floor[i][j - x])\n                if res < egg_floor[i][j]:\n                    egg_floor[i][j] = res\n    return egg_floor[n][k]",
  "def __init__(self):\n    self._size = 0",
  "def __len__(self):\n    return self._size",
  "def is_empty(self):\n    return self._size == 0",
  "@abstractmethod\ndef enqueue(self, value):\n    pass",
  "@abstractmethod\ndef dequeue(self):\n    pass",
  "@abstractmethod\ndef peek(self):\n    pass",
  "@abstractmethod\ndef __iter__(self):\n    pass",
  "def __init__(self, capacity=10):\n    super().__init__()\n    self._array = [None] * capacity\n    self._front = 0\n    self._rear = 0",
  "def __iter__(self):\n    probe = self._front\n    while True:\n        if probe == self._rear:\n            return\n        yield self._array[probe]\n        probe += 1",
  "def enqueue(self, value):\n    if self._rear == len(self._array):\n        self._expand()\n    self._array[self._rear] = value\n    self._rear += 1\n    self._size += 1",
  "def dequeue(self):\n    if self.is_empty():\n        raise IndexError('Queue is empty')\n    value = self._array[self._front]\n    self._array[self._front] = None\n    self._front += 1\n    self._size -= 1\n    return value",
  "def peek(self):\n    if self.is_empty():\n        raise IndexError('Queue is empty')\n    return self._array[self._front]",
  "def _expand(self):\n    self._array += [None] * len(self._array)",
  "def __init__(self, value):\n    self.value = value\n    self.next = None",
  "def __init__(self):\n    super().__init__()\n    self._front = None\n    self._rear = None",
  "def __iter__(self):\n    probe = self._front\n    while True:\n        if probe is None:\n            return\n        yield probe.value\n        probe = probe.next",
  "def enqueue(self, value):\n    node = QueueNode(value)\n    if self._front is None:\n        self._front = node\n        self._rear = node\n    else:\n        self._rear.next = node\n        self._rear = node\n    self._size += 1",
  "def dequeue(self):\n    if self.is_empty():\n        raise IndexError('Queue is empty')\n    value = self._front.value\n    if self._front is self._rear:\n        self._front = None\n        self._rear = None\n    else:\n        self._front = self._front.next\n    self._size -= 1\n    return value",
  "def peek(self):\n    if self.is_empty():\n        raise IndexError('Queue is empty')\n    return self._front.value",
  "def reconstruct_queue(people):\n    queue = []\n    people.sort(key=lambda x: (-x[0], x[1]))\n    for (h, k) in people:\n        queue.insert(k, [h, k])\n    return queue",
  "def max_sliding_window(arr, k):\n    qi = collections.deque()\n    result = []\n    for (i, n) in enumerate(arr):\n        while qi and arr[qi[-1]] < n:\n            qi.pop()\n        qi.append(i)\n        if qi[0] == i - k:\n            qi.popleft()\n        if i >= k - 1:\n            result.append(arr[qi[0]])\n    return result",
  "def __init__(self, size):\n    self.queue = deque(maxlen=size)",
  "def next(self, val):\n    self.queue.append(val)\n    return sum(self.queue) / len(self.queue)",
  "def __init__(self, v1, v2):\n    self.queue = [_ for _ in (v1, v2) if _]\n    print(self.queue)",
  "def next(self):\n    v = self.queue.pop(0)\n    ret = v.pop(0)\n    if v:\n        self.queue.append(v)\n    return ret",
  "def has_next(self):\n    if self.queue:\n        return True\n    return False",
  "def __init__(self, data, priority):\n    self.data = data\n    self.priority = priority",
  "def __repr__(self):\n    return '{}: {}'.format(self.data, self.priority)",
  "def __init__(self, items=None, priorities=None):\n    self.priority_queue_list = []\n    if items is None:\n        return\n    if priorities is None:\n        priorities = itertools.repeat(None)\n    for (item, priority) in zip(items, priorities):\n        self.push(item, priority=priority)",
  "def __repr__(self):\n    return 'PriorityQueue({!r})'.format(self.priority_queue_list)",
  "def size(self):\n    return len(self.priority_queue_list)",
  "def push(self, item, priority=None):\n    priority = item if priority is None else priority\n    node = PriorityQueueNode(item, priority)\n    for (index, current) in enumerate(self.priority_queue_list):\n        if current.priority < node.priority:\n            self.priority_queue_list.insert(index, node)\n            return\n    self.priority_queue_list.append(node)",
  "def pop(self):\n    return self.priority_queue_list.pop().data",
  "def remove_min(stack):\n    storage_stack = []\n    if len(stack) == 0:\n        return stack\n    min = stack.pop()\n    stack.append(min)\n    for i in range(len(stack)):\n        val = stack.pop()\n        if val <= min:\n            min = val\n        storage_stack.append(val)\n    for i in range(len(storage_stack)):\n        val = storage_stack.pop()\n        if val != min:\n            stack.append(val)\n    return stack",
  "def first_switch_pairs(stack):\n    storage_stack = []\n    for i in range(len(stack)):\n        storage_stack.append(stack.pop())\n    for i in range(len(storage_stack)):\n        if len(storage_stack) == 0:\n            break\n        first = storage_stack.pop()\n        if len(storage_stack) == 0:\n            stack.append(first)\n            break\n        second = storage_stack.pop()\n        stack.append(second)\n        stack.append(first)\n    return stack",
  "def second_switch_pairs(stack):\n    q = collections.deque()\n    for i in range(len(stack)):\n        q.append(stack.pop())\n    for i in range(len(q)):\n        stack.append(q.pop())\n    for i in range(len(stack)):\n        q.append(stack.pop())\n    for i in range(len(q)):\n        if len(q) == 0:\n            break\n        first = q.pop()\n        if len(q) == 0:\n            stack.append(first)\n            break\n        second = q.pop()\n        stack.append(second)\n        stack.append(first)\n    return stack",
  "def is_valid(s: str) -> bool:\n    stack = []\n    dic = {')': '(', '}': '{', ']': '['}\n    for char in s:\n        if char in dic.values():\n            stack.append(char)\n        elif char in dic:\n            if not stack or dic[char] != stack.pop():\n                return False\n    return not stack",
  "def first_is_consecutive(stack):\n    storage_stack = []\n    for i in range(len(stack)):\n        first_value = stack.pop()\n        if len(stack) == 0:\n            return True\n        second_value = stack.pop()\n        if first_value - second_value != 1:\n            return False\n        stack.append(second_value)\n        storage_stack.append(first_value)\n    for i in range(len(storage_stack)):\n        stack.append(storage_stack.pop())\n    return True",
  "def second_is_consecutive(stack):\n    q = collections.deque()\n    for i in range(len(stack)):\n        first_value = stack.pop()\n        if len(stack) == 0:\n            return True\n        second_value = stack.pop()\n        if first_value - second_value != 1:\n            return False\n        stack.append(second_value)\n        q.append(first_value)\n    for i in range(len(q)):\n        stack.append(q.pop())\n    for i in range(len(stack)):\n        q.append(stack.pop())\n    for i in range(len(q)):\n        stack.append(q.pop())\n    return True",
  "def __init__(self):\n    self.items = []",
  "def is_empty(self):\n    return self.items == []",
  "def push_t(self, item):\n    self.items.append(item)",
  "def push(self, item):\n    temp_stack = OrderedStack()\n    if self.is_empty() or item > self.peek():\n        self.push_t(item)\n    else:\n        while item < self.peek() and (not self.is_empty()):\n            temp_stack.push_t(self.pop())\n        self.push_t(item)\n        while not temp_stack.is_empty():\n            self.push_t(temp_stack.pop())",
  "def pop(self):\n    if self.is_empty():\n        raise IndexError('Stack is empty')\n    return self.items.pop()",
  "def peek(self):\n    return self.items[len(self.items) - 1]",
  "def size(self):\n    return len(self.items)",
  "def __init__(self):\n    self._top = -1",
  "def __len__(self):\n    return self._top + 1",
  "def __str__(self):\n    result = ' '.join(map(str, self))\n    return 'Top-> ' + result",
  "def is_empty(self):\n    return self._top == -1",
  "@abstractmethod\ndef __iter__(self):\n    pass",
  "@abstractmethod\ndef push(self, value):\n    pass",
  "@abstractmethod\ndef pop(self):\n    pass",
  "@abstractmethod\ndef peek(self):\n    pass",
  "def __init__(self, size=10):\n    super().__init__()\n    self._array = [None] * size",
  "def __iter__(self):\n    probe = self._top\n    while True:\n        if probe == -1:\n            return\n        yield self._array[probe]\n        probe -= 1",
  "def push(self, value):\n    self._top += 1\n    if self._top == len(self._array):\n        self._expand()\n    self._array[self._top] = value",
  "def pop(self):\n    if self.is_empty():\n        raise IndexError('Stack is empty')\n    value = self._array[self._top]\n    self._top -= 1\n    return value",
  "def peek(self):\n    if self.is_empty():\n        raise IndexError('Stack is empty')\n    return self._array[self._top]",
  "def _expand(self):\n    self._array += [None] * len(self._array)",
  "def __init__(self, value):\n    self.value = value\n    self.next = None",
  "def __init__(self):\n    super().__init__()\n    self.head = None",
  "def __iter__(self):\n    probe = self.head\n    while True:\n        if probe is None:\n            return\n        yield probe.value\n        probe = probe.next",
  "def push(self, value):\n    node = StackNode(value)\n    node.next = self.head\n    self.head = node\n    self._top += 1",
  "def pop(self):\n    if self.is_empty():\n        raise IndexError('Stack is empty')\n    value = self.head.value\n    self.head = self.head.next\n    self._top -= 1\n    return value",
  "def peek(self):\n    if self.is_empty():\n        raise IndexError('Stack is empty')\n    return self.head.value",
  "def first_stutter(stack):\n    storage_stack = []\n    for i in range(len(stack)):\n        storage_stack.append(stack.pop())\n    for i in range(len(storage_stack)):\n        val = storage_stack.pop()\n        stack.append(val)\n        stack.append(val)\n    return stack",
  "def second_stutter(stack):\n    q = collections.deque()\n    for i in range(len(stack)):\n        q.append(stack.pop())\n    for i in range(len(q)):\n        stack.append(q.pop())\n    for i in range(len(stack)):\n        q.append(stack.pop())\n    for i in range(len(q)):\n        val = q.pop()\n        stack.append(val)\n        stack.append(val)\n    return stack",
  "def simplify_path(path):\n    skip = {'..', '.', ''}\n    stack = []\n    paths = path.split('/')\n    for tok in paths:\n        if tok == '..':\n            if stack:\n                stack.pop()\n        elif tok not in skip:\n            stack.append(tok)\n    return '/' + '/'.join(stack)",
  "def length_longest_path(input):\n    (curr_len, max_len) = (0, 0)\n    stack = []\n    for s in input.split('\\n'):\n        print('---------')\n        print('<path>:', s)\n        depth = s.count('\\t')\n        print('depth: ', depth)\n        print('stack: ', stack)\n        print('curlen: ', curr_len)\n        while len(stack) > depth:\n            curr_len -= stack.pop()\n        stack.append(len(s.strip('\\t')) + 1)\n        curr_len += stack[-1]\n        print('stack: ', stack)\n        print('curlen: ', curr_len)\n        if '.' in s:\n            max_len = max(max_len, curr_len - 1)\n    return max_len",
  "def is_sorted(stack):\n    storage_stack = []\n    for i in range(len(stack)):\n        if len(stack) == 0:\n            break\n        first_val = stack.pop()\n        if len(stack) == 0:\n            break\n        second_val = stack.pop()\n        if first_val < second_val:\n            return False\n        storage_stack.append(first_val)\n        stack.append(second_val)\n    for i in range(len(storage_stack)):\n        stack.append(storage_stack.pop())\n    return True",
  "def powerset(iterable):\n    \"\"\"list(powerset([1,2,3])) --> [(), (1,), (2,), (3,), (1,2), (1,3), (2,3), (1,2,3)]\"\"\"\n    s = list(iterable)\n    return chain.from_iterable((combinations(s, r) for r in range(len(s) + 1)))",
  "def optimal_set_cover(universe, subsets, costs):\n    pset = powerset(subsets.keys())\n    best_set = None\n    best_cost = float('inf')\n    for subset in pset:\n        covered = set()\n        cost = 0\n        for s in subset:\n            covered.update(subsets[s])\n            cost += costs[s]\n        if len(covered) == len(universe) and cost < best_cost:\n            best_set = subset\n            best_cost = cost\n    return best_set",
  "def greedy_set_cover(universe, subsets, costs):\n    elements = set((e for s in subsets.keys() for e in subsets[s]))\n    if elements != universe:\n        return None\n    covered = set()\n    cover_sets = []\n    while covered != universe:\n        min_cost_elem_ratio = float('inf')\n        min_set = None\n        for (s, elements) in subsets.items():\n            new_elements = len(elements - covered)\n            if new_elements != 0:\n                cost_elem_ratio = costs[s] / new_elements\n                if cost_elem_ratio < min_cost_elem_ratio:\n                    min_cost_elem_ratio = cost_elem_ratio\n                    min_set = s\n        cover_sets.append(min_set)\n        covered |= subsets[min_set]\n    return cover_sets",
  "def __test():\n    rset = RandomizedSet()\n    ground_truth = set()\n    n = 64\n    for i in range(n):\n        rset.insert(i)\n        ground_truth.add(i)\n    for i in random.sample(range(n), n // 2):\n        rset.remove(i)\n        ground_truth.remove(i)\n    print(len(ground_truth), len(rset.elements), len(rset.index_map))\n    for i in ground_truth:\n        assert i == rset.elements[rset.index_map[i]]\n    for i in range(n):\n        print(rset.random_element(), end=' ')\n    print()",
  "def __init__(self):\n    self.elements = []\n    self.index_map = {}",
  "def insert(self, new_one):\n    if new_one in self.index_map:\n        return\n    self.index_map[new_one] = len(self.elements)\n    self.elements.append(new_one)",
  "def remove(self, old_one):\n    if not old_one in self.index_map:\n        return\n    index = self.index_map[old_one]\n    last = self.elements.pop()\n    self.index_map.pop(old_one)\n    if index == len(self.elements):\n        return\n    self.elements[index] = last\n    self.index_map[last] = index",
  "def random_element(self):\n    return random.choice(self.elements)",
  "def find_keyboard_row(words):\n    keyboard = [set('qwertyuiop'), set('asdfghjkl'), set('zxcvbnm')]\n    result = []\n    for word in words:\n        for key in keyboard:\n            if set(word.lower()).issubset(key):\n                result.append(word)\n    return result",
  "def search_in_a_sorted_matrix(mat, m, n, key):\n    (i, j) = (m - 1, 0)\n    while i >= 0 and j < n:\n        if key == mat[i][j]:\n            print('Key %s found at row- %s column- %s' % (key, i + 1, j + 1))\n            return\n        if key < mat[i][j]:\n            i -= 1\n        else:\n            j += 1\n    print('Key %s not found' % key)",
  "def main():\n    mat = [[2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20]]\n    key = 13\n    print(mat)\n    search_in_a_sorted_matrix(mat, len(mat), len(mat[0]), key)",
  "def count_paths(m, n):\n    if m < 1 or n < 1:\n        return -1\n    count = [[None for j in range(n)] for i in range(m)]\n    for i in range(n):\n        count[0][i] = 1\n    for j in range(m):\n        count[j][0] = 1\n    for i in range(1, m):\n        for j in range(1, n):\n            count[i][j] = count[i - 1][j] + count[i][j - 1]\n    print(count[m - 1][n - 1])",
  "def main():\n    (m, n) = map(int, input('Enter two positive integers: ').split())\n    count_paths(m, n)",
  "def sort_diagonally(mat: List[List[int]]) -> List[List[int]]:\n    if len(mat) == 1 or len(mat[0]) == 1:\n        return mat\n    for i in range(len(mat) + len(mat[0]) - 1):\n        if i + 1 < len(mat):\n            h = []\n            row = len(mat) - (i + 1)\n            col = 0\n            while row < len(mat):\n                heappush(h, mat[row][col])\n                row += 1\n                col += 1\n            row = len(mat) - (i + 1)\n            col = 0\n            while h:\n                ele = heappop(h)\n                mat[row][col] = ele\n                row += 1\n                col += 1\n        else:\n            h = []\n            row = 0\n            col = i - (len(mat) - 1)\n            while col < len(mat[0]) and row < len(mat):\n                heappush(h, mat[row][col])\n                row += 1\n                col += 1\n            row = 0\n            col = i - (len(mat) - 1)\n            while h:\n                ele = heappop(h)\n                mat[row][col] = ele\n                row += 1\n                col += 1\n    return mat",
  "def cholesky_decomposition(A):\n    n = len(A)\n    for ai in A:\n        if len(ai) != n:\n            return None\n    V = [[0.0] * n for _ in range(n)]\n    for j in range(n):\n        sum_diagonal_element = 0\n        for k in range(j):\n            sum_diagonal_element = sum_diagonal_element + math.pow(V[j][k], 2)\n        sum_diagonal_element = A[j][j] - sum_diagonal_element\n        if sum_diagonal_element <= 0:\n            return None\n        V[j][j] = math.pow(sum_diagonal_element, 0.5)\n        for i in range(j + 1, n):\n            sum_other_element = 0\n            for k in range(j):\n                sum_other_element += V[i][k] * V[j][k]\n            V[i][j] = (A[i][j] - sum_other_element) / V[j][j]\n    return V",
  "def multiply(multiplicand: list, multiplier: list) -> list:\n    (multiplicand_row, multiplicand_col) = (len(multiplicand), len(multiplicand[0]))\n    (multiplier_row, multiplier_col) = (len(multiplier), len(multiplier[0]))\n    if multiplicand_col != multiplier_row:\n        raise Exception('Multiplicand matrix not compatible with Multiplier matrix.')\n    result = [[0] * multiplier_col for i in range(multiplicand_row)]\n    for i in range(multiplicand_row):\n        for j in range(multiplier_col):\n            for k in range(len(multiplier)):\n                result[i][j] += multiplicand[i][k] * multiplier[k][j]\n    return result",
  "def multiply(self, a, b):\n    if a is None or b is None:\n        return None\n    (m, n, l) = (len(a), len(b[0]), len(b[0]))\n    if len(b) != n:\n        raise Exception(\"A's column number must be equal to B's row number.\")\n    c = [[0 for _ in range(l)] for _ in range(m)]\n    for (i, row) in enumerate(a):\n        for (k, eleA) in enumerate(row):\n            if eleA:\n                for (j, eleB) in enumerate(b[k]):\n                    if eleB:\n                        c[i][j] += eleA * eleB\n    return c",
  "def multiply(self, a, b):\n    if a is None or b is None:\n        return None\n    (m, n, l) = (len(a), len(a[0]), len(b[0]))\n    if len(b) != n:\n        raise Exception(\"A's column number must be equal to B's row number.\")\n    c = [[0 for _ in range(l)] for _ in range(m)]\n    table_b = {}\n    for (k, row) in enumerate(b):\n        table_b[k] = {}\n        for (j, eleB) in enumerate(row):\n            if eleB:\n                table_b[k][j] = eleB\n    for (i, row) in enumerate(a):\n        for (k, eleA) in enumerate(row):\n            if eleA:\n                for (j, eleB) in table_b[k].iteritems():\n                    c[i][j] += eleA * eleB\n    return c",
  "def multiply(self, a, b):\n    if a is None or b is None:\n        return None\n    (m, n) = (len(a), len(b[0]))\n    if len(b) != n:\n        raise Exception(\"A's column number must be equal to B's row number.\")\n    l = len(b[0])\n    (table_a, table_b) = ({}, {})\n    for (i, row) in enumerate(a):\n        for (j, ele) in enumerate(row):\n            if ele:\n                if i not in table_a:\n                    table_a[i] = {}\n                table_a[i][j] = ele\n    for (i, row) in enumerate(b):\n        for (j, ele) in enumerate(row):\n            if ele:\n                if i not in table_b:\n                    table_b[i] = {}\n                table_b[i][j] = ele\n    c = [[0 for j in range(l)] for i in range(m)]\n    for i in table_a:\n        for k in table_a[i]:\n            if k not in table_b:\n                continue\n            for j in table_b[k]:\n                c[i][j] += table_a[i][k] * table_b[k][j]\n    return c",
  "def multiply(matA: list, matB: list) -> list:\n    n = len(matA)\n    matC = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                matC[i][j] += matA[i][k] * matB[k][j]\n    return matC",
  "def identity(n: int) -> list:\n    I = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        I[i][i] = 1\n    return I",
  "def matrix_exponentiation(mat: list, n: int) -> list:\n    if n == 0:\n        return identity(len(mat))\n    elif n % 2 == 1:\n        return multiply(matrix_exponentiation(mat, n - 1), mat)\n    else:\n        tmp = matrix_exponentiation(mat, n // 2)\n        return multiply(tmp, tmp)",
  "def sum_sub_squares(matrix, k):\n    n = len(matrix)\n    result = [[0 for i in range(k)] for j in range(k)]\n    if k > n:\n        return\n    for i in range(n - k + 1):\n        l = 0\n        for j in range(n - k + 1):\n            sum = 0\n            for p in range(i, k + i):\n                for q in range(j, k + j):\n                    sum += matrix[p][q]\n            result[i][l] = sum\n            l += 1\n    return result",
  "def invert_matrix(m):\n    if not array_is_matrix(m):\n        print('Invalid matrix: array is not a matrix')\n        return [[-1]]\n    elif len(m) != len(m[0]):\n        print('Invalid matrix: matrix is not square')\n        return [[-2]]\n    elif len(m) < 2:\n        print('Invalid matrix: matrix is too small')\n        return [[-3]]\n    elif get_determinant(m) == 0:\n        print('Invalid matrix: matrix is square, but singular (determinant = 0)')\n        return [[-4]]\n    elif len(m) == 2:\n        multiplier = 1 / get_determinant(m)\n        inverted = [[multiplier] * len(m) for n in range(len(m))]\n        inverted[0][1] = inverted[0][1] * -1 * m[0][1]\n        inverted[1][0] = inverted[1][0] * -1 * m[1][0]\n        inverted[0][0] = multiplier * m[1][1]\n        inverted[1][1] = multiplier * m[0][0]\n        return inverted\n    else:\n        'some steps combined in helpers to reduce traversals'\n        m_of_minors = get_matrix_of_minors(m)\n        multiplier = fractions.Fraction(1, get_determinant(m))\n        inverted = transpose_and_multiply(m_of_minors, multiplier)\n        return inverted",
  "def get_determinant(m):\n    if len(m) == 2:\n        return m[0][0] * m[1][1] - m[0][1] * m[1][0]\n    else:\n        sign = 1\n        det = 0\n        for i in range(len(m)):\n            det += sign * m[0][i] * get_determinant(get_minor(m, 0, i))\n            sign *= -1\n        return det",
  "def get_matrix_of_minors(m):\n    matrix_of_minors = [[0 for i in range(len(m))] for j in range(len(m))]\n    for row in range(len(m)):\n        for col in range(len(m[0])):\n            if (row + col) % 2 == 0:\n                sign = 1\n            else:\n                sign = -1\n            matrix_of_minors[row][col] = sign * get_determinant(get_minor(m, row, col))\n    return matrix_of_minors",
  "def get_minor(m, row, col):\n    minors = []\n    for i in range(len(m)):\n        if i != row:\n            new_row = m[i][:col]\n            new_row.extend(m[i][col + 1:])\n            minors.append(new_row)\n    return minors",
  "def transpose_and_multiply(m, multiplier=1):\n    for row in range(len(m)):\n        for col in range(row + 1):\n            temp = m[row][col] * multiplier\n            m[row][col] = m[col][row] * multiplier\n            m[col][row] = temp\n    return m",
  "def array_is_matrix(m):\n    if len(m) == 0:\n        return False\n    first_col = len(m[0])\n    for row in m:\n        if len(row) != first_col:\n            return False\n    return True",
  "def rotate(mat):\n    if not mat:\n        return mat\n    mat.reverse()\n    for i in range(len(mat)):\n        for j in range(i):\n            (mat[i][j], mat[j][i]) = (mat[j][i], mat[i][j])\n    return mat",
  "def spiral_traversal(matrix):\n    res = []\n    if len(matrix) == 0:\n        return res\n    row_begin = 0\n    row_end = len(matrix) - 1\n    col_begin = 0\n    col_end = len(matrix[0]) - 1\n    while row_begin <= row_end and col_begin <= col_end:\n        for i in range(col_begin, col_end + 1):\n            res.append(matrix[row_begin][i])\n        row_begin += 1\n        for i in range(row_begin, row_end + 1):\n            res.append(matrix[i][col_end])\n        col_end -= 1\n        if row_begin <= row_end:\n            for i in range(col_end, col_begin - 1, -1):\n                res.append(matrix[row_end][i])\n        row_end -= 1\n        if col_begin <= col_end:\n            for i in range(row_end, row_begin - 1, -1):\n                res.append(matrix[i][col_begin])\n        col_begin += 1\n    return res",
  "def max_killed_enemies(grid):\n    if not grid:\n        return 0\n    (m, n) = (len(grid), len(grid[0]))\n    max_killed = 0\n    (row_e, col_e) = (0, [0] * n)\n    for i in range(m):\n        for j in range(n):\n            if j == 0 or grid[i][j - 1] == 'W':\n                row_e = row_kills(grid, i, j)\n            if i == 0 or grid[i - 1][j] == 'W':\n                col_e[j] = col_kills(grid, i, j)\n            if grid[i][j] == '0':\n                max_killed = max(max_killed, row_e + col_e[j])\n    return max_killed",
  "def row_kills(grid, i, j):\n    num = 0\n    len_row = len(grid[0])\n    while j < len_row and grid[i][j] != 'W':\n        if grid[i][j] == 'E':\n            num += 1\n        j += 1\n    return num",
  "def col_kills(grid, i, j):\n    num = 0\n    len_col = len(grid)\n    while i < len_col and grid[i][j] != 'W':\n        if grid[i][j] == 'E':\n            num += 1\n        i += 1\n    return num",
  "def test_3x4(self):\n    grid1 = [['0', 'E', '0', '0'], ['E', '0', 'W', 'E'], ['0', 'E', '0', '0']]\n    self.assertEqual(3, max_killed_enemies(grid1))",
  "def test_4x4(self):\n    grid1 = [['0', 'E', '0', 'E'], ['E', 'E', 'E', '0'], ['E', '0', 'W', 'E'], ['0', 'E', '0', '0']]\n    grid2 = [['0', '0', '0', 'E'], ['E', '0', '0', '0'], ['E', '0', 'W', 'E'], ['0', 'E', '0', '0']]\n    self.assertEqual(5, max_killed_enemies(grid1))\n    self.assertEqual(3, max_killed_enemies(grid2))",
  "def vector_to_index_value_list(vector):\n    return [(i, v) for (i, v) in enumerate(vector) if v != 0.0]",
  "def dot_product(iv_list1, iv_list2):\n    product = 0\n    p1 = len(iv_list1) - 1\n    p2 = len(iv_list2) - 1\n    while p1 >= 0 and p2 >= 0:\n        (i1, v1) = iv_list1[p1]\n        (i2, v2) = iv_list2[p2]\n        if i1 < i2:\n            p1 -= 1\n        elif i2 < i1:\n            p2 -= 1\n        else:\n            product += v1 * v2\n            p1 -= 1\n            p2 -= 1\n    return product",
  "def __test_simple():\n    print(dot_product(vector_to_index_value_list([1.0, 2.0, 3.0]), vector_to_index_value_list([0.0, 2.0, 2.0])))",
  "def __test_time():\n    vector_length = 1024\n    vector_count = 1024\n    nozero_counut = 10\n\n    def random_vector():\n        import random\n        vector = [0 for _ in range(vector_length)]\n        for i in random.sample(range(vector_length), nozero_counut):\n            vector[i] = random.random()\n        return vector\n    vectors = [random_vector() for _ in range(vector_count)]\n    iv_lists = [vector_to_index_value_list(vector) for vector in vectors]\n    import time\n    time_start = time.time()\n    for i in range(vector_count):\n        for j in range(i):\n            dot_product(iv_lists[i], iv_lists[j])\n    time_end = time.time()\n    print(time_end - time_start, 'seconds')",
  "def random_vector():\n    import random\n    vector = [0 for _ in range(vector_length)]\n    for i in random.sample(range(vector_length), nozero_counut):\n        vector[i] = random.random()\n    return vector",
  "def crout_matrix_decomposition(A):\n    n = len(A)\n    L = [[0.0] * n for i in range(n)]\n    U = [[0.0] * n for i in range(n)]\n    for j in range(n):\n        U[j][j] = 1.0\n        for i in range(j, n):\n            alpha = float(A[i][j])\n            for k in range(j):\n                alpha -= L[i][k] * U[k][j]\n            L[i][j] = float(alpha)\n        for i in range(j + 1, n):\n            tempU = float(A[j][i])\n            for k in range(j):\n                tempU -= float(L[j][k] * U[k][i])\n            if int(L[j][j]) == 0:\n                L[j][j] = float(0.1 ** 40)\n            U[j][i] = float(tempU / L[j][j])\n    return (L, U)",
  "def valid_solution_hashtable(board):\n    for i in range(len(board)):\n        dict_row = defaultdict(int)\n        dict_col = defaultdict(int)\n        for j in range(len(board[0])):\n            value_row = board[i][j]\n            value_col = board[j][i]\n            if not value_row or value_col == 0:\n                return False\n            if value_row in dict_row:\n                return False\n            else:\n                dict_row[value_row] += 1\n            if value_col in dict_col:\n                return False\n            else:\n                dict_col[value_col] += 1\n    for i in range(3):\n        for j in range(3):\n            grid_add = 0\n            for k in range(3):\n                for l in range(3):\n                    grid_add += board[i * 3 + k][j * 3 + l]\n            if grid_add != 45:\n                return False\n    return True",
  "def valid_solution(board):\n    correct = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    for row in board:\n        if sorted(row) != correct:\n            return False\n    for column in zip(*board):\n        if sorted(column) != correct:\n            return False\n    for i in range(3):\n        for j in range(3):\n            region = []\n            for line in board[i * 3:(i + 1) * 3]:\n                region += line[j * 3:(j + 1) * 3]\n            if sorted(region) != correct:\n                return False\n    return True",
  "def valid_solution_set(board):\n    valid = set(range(1, 10))\n    for row in board:\n        if set(row) != valid:\n            return False\n    for col in [[row[i] for row in board] for i in range(9)]:\n        if set(col) != valid:\n            return False\n    for x in range(3):\n        for y in range(3):\n            if set(sum([row[x * 3:(x + 1) * 3] for row in board[y * 3:(y + 1) * 3]], [])) != valid:\n                return False\n    return True",
  "def rotate_clockwise(matrix):\n    new = []\n    for row in reversed(matrix):\n        for (i, elem) in enumerate(row):\n            try:\n                new[i].append(elem)\n            except IndexError:\n                new.insert(i, [])\n                new[i].append(elem)\n    return new",
  "def rotate_counterclockwise(matrix):\n    new = []\n    for row in matrix:\n        for (i, elem) in enumerate(reversed(row)):\n            try:\n                new[i].append(elem)\n            except IndexError:\n                new.insert(i, [])\n                new[i].append(elem)\n    return new",
  "def top_left_invert(matrix):\n    new = []\n    for row in matrix:\n        for (i, elem) in enumerate(row):\n            try:\n                new[i].append(elem)\n            except IndexError:\n                new.insert(i, [])\n                new[i].append(elem)\n    return new",
  "def bottom_left_invert(matrix):\n    new = []\n    for row in reversed(matrix):\n        for (i, elem) in enumerate(reversed(row)):\n            try:\n                new[i].append(elem)\n            except IndexError:\n                new.insert(i, [])\n                new[i].append(elem)\n    return new",
  "def print_matrix(matrix, name):\n    print('{}:\\n['.format(name))\n    for row in matrix:\n        print('  {}'.format(row))\n    print(']\\n')"
]